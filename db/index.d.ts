
/**
 * Client
**/

import * as runtime from './runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model REProertyModel
 * 
 */
export type REProertyModel = {
  id: string
  created_at: Date
  updated_at: Date
  is_deleted: boolean
  deleted_at: Date | null
  name: string
  main_image_url: string
  re_agent_id: string
}

/**
 * Model REPropertyCategoryModel
 * 
 */
export type REPropertyCategoryModel = {
  id: string
  created_at: Date
  updated_at: Date
  is_deleted: boolean
  deleted_at: Date | null
  re_property_id: string
  sub_category_id: string
}

/**
 * Model REPropertySubCategoryModel
 * 
 */
export type REPropertySubCategoryModel = {
  id: string
  created_at: Date
  updated_at: Date
  is_deleted: boolean
  deleted_at: Date | null
  name: string
  middle_category_id: string
}

/**
 * Model REPropertyMiddleCategoryModel
 * 
 */
export type REPropertyMiddleCategoryModel = {
  id: string
  created_at: Date
  updated_at: Date
  is_deleted: boolean
  deleted_at: Date | null
  name: string
  super_category_id: string
}

/**
 * Model REPropertySuperCategoryModel
 * 
 */
export type REPropertySuperCategoryModel = {
  id: string
  created_at: Date
  updated_at: Date
  is_deleted: boolean
  deleted_at: Date | null
  name: string
}

/**
 * Model ReviewModel
 * 
 */
export type ReviewModel = {
  id: string
  created_at: Date
  updated_at: Date
  is_deleted: boolean
  deleted_at: Date | null
  reviewer_id: string
  reviewee_id: string
  content: string
}

/**
 * Model RateModel
 * 
 */
export type RateModel = {
  id: string
  created_at: Date
  updated_at: Date
  is_deleted: boolean
  deleted_at: Date | null
  score: number
  category_id: string
  review_id: string
}

/**
 * Model RateCategoryModel
 * 
 */
export type RateCategoryModel = {
  id: string
  created_at: Date
  updated_at: Date
  is_deleted: boolean
  deleted_at: Date | null
  name: string
  target_type: RateTargetType
}

/**
 * Model AgreementModel
 * 
 */
export type AgreementModel = {
  id: string
  created_at: Date
  updated_at: Date
  is_deleted: boolean
  deleted_at: Date | null
  title: string
  content: string
  is_required: boolean
  target_type: AgreementTargetType
}

/**
 * Model AgreementAcceptanceModel
 * 
 */
export type AgreementAcceptanceModel = {
  id: string
  created_at: Date
  updated_at: Date
  is_deleted: boolean
  deleted_at: Date | null
  user_id: string
  agreement_id: string
}

/**
 * Model ConsultationTimeModel
 * 
 */
export type ConsultationTimeModel = {
  id: string
  created_at: Date
  updated_at: Date
  is_deleted: boolean
  deleted_at: Date | null
  start_time: Date
  end_time: Date
}

/**
 * Model ServiceSubCategoryModel
 * 
 */
export type ServiceSubCategoryModel = {
  id: string
  created_at: Date
  updated_at: Date
  is_deleted: boolean
  deleted_at: Date | null
  name: string
  super_category_id: string
}

/**
 * Model ServiceSuperCategoryModel
 * 
 */
export type ServiceSuperCategoryModel = {
  id: string
  created_at: Date
  updated_at: Date
  is_deleted: boolean
  deleted_at: Date | null
  name: string
  type: ServiceType
}

/**
 * Model FocusCareRequestModel
 * 
 */
export type FocusCareRequestModel = {
  id: string
  created_at: Date
  updated_at: Date
  is_deleted: boolean
  deleted_at: Date | null
  care_start_date: Date
  care_end_date: Date
  detail: string
  status: FocusCareStatus
  requester_id: string
}

/**
 * Model FocusCareServiceCheckModel
 * 
 */
export type FocusCareServiceCheckModel = {
  id: string
  created_at: Date
  updated_at: Date
  is_deleted: boolean
  deleted_at: Date | null
  service_super_category_id: string
  request_id: string
}

/**
 * Model FocusCareConsultationTimeCheckModel
 * 
 */
export type FocusCareConsultationTimeCheckModel = {
  id: string
  created_at: Date
  updated_at: Date
  is_deleted: boolean
  deleted_at: Date | null
  consultation_time_id: string
  request_id: string
}

/**
 * Model UserModel
 * 
 */
export type UserModel = {
  id: string
  created_at: Date
  updated_at: Date
  is_deleted: boolean
  deleted_at: Date | null
  name: string
  email: string | null
}

/**
 * Model CustomerModel
 * 
 */
export type CustomerModel = {
  id: string
  birth: string | null
  gender: GenderType | null
  phone: string | null
  address_first: string | null
  address_second: string | null
  profile_image_url: string | null
}

/**
 * Model BusinessUserModel
 * 
 */
export type BusinessUserModel = {
  id: string
  is_verified: boolean
  introduction_title: string
  introduction_content: string
  phone: string
  address_first: string
  address_second: string | null
  profile_image_url: string
}

/**
 * Model SubExpertiseModel
 * 
 */
export type SubExpertiseModel = {
  id: string
  created_at: Date
  updated_at: Date
  is_deleted: boolean
  deleted_at: Date | null
  sub_category_id: string
  business_user_id: string
}

/**
 * Model REAgentModel
 * 
 */
export type REAgentModel = {
  id: string
  is_licensed: boolean
  re_num: string
  re_name: string
  re_phone: string
  re_licensed_agent_name: string
}

/**
 * Model HSProviderModel
 * 
 */
export type HSProviderModel = {
  id: string
  business_registration_num: string
}

/**
 * Model BusinessCertificationImageModel
 * 
 */
export type BusinessCertificationImageModel = {
  id: string
  created_at: Date
  updated_at: Date
  is_deleted: boolean
  deleted_at: Date | null
  business_user_id: string
  url: string
}

/**
 * Model HSIntroductionImageModel
 * 
 */
export type HSIntroductionImageModel = {
  id: string
  created_at: Date
  updated_at: Date
  is_deleted: boolean
  deleted_at: Date | null
  hs_provider_id: string
  url: string
}

/**
 * Model OauthAccountModel
 * 
 */
export type OauthAccountModel = {
  id: string
  created_at: Date
  updated_at: Date
  is_deleted: boolean
  deleted_at: Date | null
  oauth_type: OauthType
  oauth_sub: string
  business_user_id: string | null
  customer_id: string | null
  name: string | null
  email: string | null
  phone: string | null
  profile_image_url: string | null
  birth: string | null
  gender: GenderType | null
  address_first: string | null
  address_second: string | null
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const AgreementTargetType: {
  all: 'all',
  customer: 'customer',
  business: 'business',
  HS: 'HS',
  RE: 'RE'
};

export type AgreementTargetType = (typeof AgreementTargetType)[keyof typeof AgreementTargetType]


export const FocusCareStatus: {
  pending: 'pending',
  caring: 'caring',
  cared: 'cared',
  cancelled: 'cancelled'
};

export type FocusCareStatus = (typeof FocusCareStatus)[keyof typeof FocusCareStatus]


export const GenderType: {
  female: 'female',
  male: 'male',
  other: 'other'
};

export type GenderType = (typeof GenderType)[keyof typeof GenderType]


export const OauthType: {
  kakao: 'kakao',
  naver: 'naver'
};

export type OauthType = (typeof OauthType)[keyof typeof OauthType]


export const RateTargetType: {
  all: 'all',
  HS: 'HS',
  RE: 'RE'
};

export type RateTargetType = (typeof RateTargetType)[keyof typeof RateTargetType]


export const ServiceType: {
  HS: 'HS',
  RE: 'RE'
};

export type ServiceType = (typeof ServiceType)[keyof typeof ServiceType]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more REProertyModels
 * const rEProertyModels = await prisma.rEProertyModel.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more REProertyModels
   * const rEProertyModels = await prisma.rEProertyModel.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.rEProertyModel`: Exposes CRUD operations for the **REProertyModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more REProertyModels
    * const rEProertyModels = await prisma.rEProertyModel.findMany()
    * ```
    */
  get rEProertyModel(): Prisma.REProertyModelDelegate<GlobalReject>;

  /**
   * `prisma.rEPropertyCategoryModel`: Exposes CRUD operations for the **REPropertyCategoryModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more REPropertyCategoryModels
    * const rEPropertyCategoryModels = await prisma.rEPropertyCategoryModel.findMany()
    * ```
    */
  get rEPropertyCategoryModel(): Prisma.REPropertyCategoryModelDelegate<GlobalReject>;

  /**
   * `prisma.rEPropertySubCategoryModel`: Exposes CRUD operations for the **REPropertySubCategoryModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more REPropertySubCategoryModels
    * const rEPropertySubCategoryModels = await prisma.rEPropertySubCategoryModel.findMany()
    * ```
    */
  get rEPropertySubCategoryModel(): Prisma.REPropertySubCategoryModelDelegate<GlobalReject>;

  /**
   * `prisma.rEPropertyMiddleCategoryModel`: Exposes CRUD operations for the **REPropertyMiddleCategoryModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more REPropertyMiddleCategoryModels
    * const rEPropertyMiddleCategoryModels = await prisma.rEPropertyMiddleCategoryModel.findMany()
    * ```
    */
  get rEPropertyMiddleCategoryModel(): Prisma.REPropertyMiddleCategoryModelDelegate<GlobalReject>;

  /**
   * `prisma.rEPropertySuperCategoryModel`: Exposes CRUD operations for the **REPropertySuperCategoryModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more REPropertySuperCategoryModels
    * const rEPropertySuperCategoryModels = await prisma.rEPropertySuperCategoryModel.findMany()
    * ```
    */
  get rEPropertySuperCategoryModel(): Prisma.REPropertySuperCategoryModelDelegate<GlobalReject>;

  /**
   * `prisma.reviewModel`: Exposes CRUD operations for the **ReviewModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewModels
    * const reviewModels = await prisma.reviewModel.findMany()
    * ```
    */
  get reviewModel(): Prisma.ReviewModelDelegate<GlobalReject>;

  /**
   * `prisma.rateModel`: Exposes CRUD operations for the **RateModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RateModels
    * const rateModels = await prisma.rateModel.findMany()
    * ```
    */
  get rateModel(): Prisma.RateModelDelegate<GlobalReject>;

  /**
   * `prisma.rateCategoryModel`: Exposes CRUD operations for the **RateCategoryModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RateCategoryModels
    * const rateCategoryModels = await prisma.rateCategoryModel.findMany()
    * ```
    */
  get rateCategoryModel(): Prisma.RateCategoryModelDelegate<GlobalReject>;

  /**
   * `prisma.agreementModel`: Exposes CRUD operations for the **AgreementModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgreementModels
    * const agreementModels = await prisma.agreementModel.findMany()
    * ```
    */
  get agreementModel(): Prisma.AgreementModelDelegate<GlobalReject>;

  /**
   * `prisma.agreementAcceptanceModel`: Exposes CRUD operations for the **AgreementAcceptanceModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgreementAcceptanceModels
    * const agreementAcceptanceModels = await prisma.agreementAcceptanceModel.findMany()
    * ```
    */
  get agreementAcceptanceModel(): Prisma.AgreementAcceptanceModelDelegate<GlobalReject>;

  /**
   * `prisma.consultationTimeModel`: Exposes CRUD operations for the **ConsultationTimeModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConsultationTimeModels
    * const consultationTimeModels = await prisma.consultationTimeModel.findMany()
    * ```
    */
  get consultationTimeModel(): Prisma.ConsultationTimeModelDelegate<GlobalReject>;

  /**
   * `prisma.serviceSubCategoryModel`: Exposes CRUD operations for the **ServiceSubCategoryModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceSubCategoryModels
    * const serviceSubCategoryModels = await prisma.serviceSubCategoryModel.findMany()
    * ```
    */
  get serviceSubCategoryModel(): Prisma.ServiceSubCategoryModelDelegate<GlobalReject>;

  /**
   * `prisma.serviceSuperCategoryModel`: Exposes CRUD operations for the **ServiceSuperCategoryModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceSuperCategoryModels
    * const serviceSuperCategoryModels = await prisma.serviceSuperCategoryModel.findMany()
    * ```
    */
  get serviceSuperCategoryModel(): Prisma.ServiceSuperCategoryModelDelegate<GlobalReject>;

  /**
   * `prisma.focusCareRequestModel`: Exposes CRUD operations for the **FocusCareRequestModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FocusCareRequestModels
    * const focusCareRequestModels = await prisma.focusCareRequestModel.findMany()
    * ```
    */
  get focusCareRequestModel(): Prisma.FocusCareRequestModelDelegate<GlobalReject>;

  /**
   * `prisma.focusCareServiceCheckModel`: Exposes CRUD operations for the **FocusCareServiceCheckModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FocusCareServiceCheckModels
    * const focusCareServiceCheckModels = await prisma.focusCareServiceCheckModel.findMany()
    * ```
    */
  get focusCareServiceCheckModel(): Prisma.FocusCareServiceCheckModelDelegate<GlobalReject>;

  /**
   * `prisma.focusCareConsultationTimeCheckModel`: Exposes CRUD operations for the **FocusCareConsultationTimeCheckModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FocusCareConsultationTimeCheckModels
    * const focusCareConsultationTimeCheckModels = await prisma.focusCareConsultationTimeCheckModel.findMany()
    * ```
    */
  get focusCareConsultationTimeCheckModel(): Prisma.FocusCareConsultationTimeCheckModelDelegate<GlobalReject>;

  /**
   * `prisma.userModel`: Exposes CRUD operations for the **UserModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserModels
    * const userModels = await prisma.userModel.findMany()
    * ```
    */
  get userModel(): Prisma.UserModelDelegate<GlobalReject>;

  /**
   * `prisma.customerModel`: Exposes CRUD operations for the **CustomerModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerModels
    * const customerModels = await prisma.customerModel.findMany()
    * ```
    */
  get customerModel(): Prisma.CustomerModelDelegate<GlobalReject>;

  /**
   * `prisma.businessUserModel`: Exposes CRUD operations for the **BusinessUserModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessUserModels
    * const businessUserModels = await prisma.businessUserModel.findMany()
    * ```
    */
  get businessUserModel(): Prisma.BusinessUserModelDelegate<GlobalReject>;

  /**
   * `prisma.subExpertiseModel`: Exposes CRUD operations for the **SubExpertiseModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubExpertiseModels
    * const subExpertiseModels = await prisma.subExpertiseModel.findMany()
    * ```
    */
  get subExpertiseModel(): Prisma.SubExpertiseModelDelegate<GlobalReject>;

  /**
   * `prisma.rEAgentModel`: Exposes CRUD operations for the **REAgentModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more REAgentModels
    * const rEAgentModels = await prisma.rEAgentModel.findMany()
    * ```
    */
  get rEAgentModel(): Prisma.REAgentModelDelegate<GlobalReject>;

  /**
   * `prisma.hSProviderModel`: Exposes CRUD operations for the **HSProviderModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HSProviderModels
    * const hSProviderModels = await prisma.hSProviderModel.findMany()
    * ```
    */
  get hSProviderModel(): Prisma.HSProviderModelDelegate<GlobalReject>;

  /**
   * `prisma.businessCertificationImageModel`: Exposes CRUD operations for the **BusinessCertificationImageModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessCertificationImageModels
    * const businessCertificationImageModels = await prisma.businessCertificationImageModel.findMany()
    * ```
    */
  get businessCertificationImageModel(): Prisma.BusinessCertificationImageModelDelegate<GlobalReject>;

  /**
   * `prisma.hSIntroductionImageModel`: Exposes CRUD operations for the **HSIntroductionImageModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HSIntroductionImageModels
    * const hSIntroductionImageModels = await prisma.hSIntroductionImageModel.findMany()
    * ```
    */
  get hSIntroductionImageModel(): Prisma.HSIntroductionImageModelDelegate<GlobalReject>;

  /**
   * `prisma.oauthAccountModel`: Exposes CRUD operations for the **OauthAccountModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OauthAccountModels
    * const oauthAccountModels = await prisma.oauthAccountModel.findMany()
    * ```
    */
  get oauthAccountModel(): Prisma.OauthAccountModelDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.14.0
   * Query Engine version: d9a4c5988f480fa576d43970d5a23641aa77bc9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    REProertyModel: 'REProertyModel',
    REPropertyCategoryModel: 'REPropertyCategoryModel',
    REPropertySubCategoryModel: 'REPropertySubCategoryModel',
    REPropertyMiddleCategoryModel: 'REPropertyMiddleCategoryModel',
    REPropertySuperCategoryModel: 'REPropertySuperCategoryModel',
    ReviewModel: 'ReviewModel',
    RateModel: 'RateModel',
    RateCategoryModel: 'RateCategoryModel',
    AgreementModel: 'AgreementModel',
    AgreementAcceptanceModel: 'AgreementAcceptanceModel',
    ConsultationTimeModel: 'ConsultationTimeModel',
    ServiceSubCategoryModel: 'ServiceSubCategoryModel',
    ServiceSuperCategoryModel: 'ServiceSuperCategoryModel',
    FocusCareRequestModel: 'FocusCareRequestModel',
    FocusCareServiceCheckModel: 'FocusCareServiceCheckModel',
    FocusCareConsultationTimeCheckModel: 'FocusCareConsultationTimeCheckModel',
    UserModel: 'UserModel',
    CustomerModel: 'CustomerModel',
    BusinessUserModel: 'BusinessUserModel',
    SubExpertiseModel: 'SubExpertiseModel',
    REAgentModel: 'REAgentModel',
    HSProviderModel: 'HSProviderModel',
    BusinessCertificationImageModel: 'BusinessCertificationImageModel',
    HSIntroductionImageModel: 'HSIntroductionImageModel',
    OauthAccountModel: 'OauthAccountModel'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    database?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type REProertyModelCountOutputType
   */


  export type REProertyModelCountOutputType = {
    categories: number
  }

  export type REProertyModelCountOutputTypeSelect = {
    categories?: boolean
  }

  export type REProertyModelCountOutputTypeGetPayload<S extends boolean | null | undefined | REProertyModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? REProertyModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (REProertyModelCountOutputTypeArgs)
    ? REProertyModelCountOutputType 
    : S extends { select: any } & (REProertyModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof REProertyModelCountOutputType ? REProertyModelCountOutputType[P] : never
  } 
      : REProertyModelCountOutputType




  // Custom InputTypes

  /**
   * REProertyModelCountOutputType without action
   */
  export type REProertyModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the REProertyModelCountOutputType
     */
    select?: REProertyModelCountOutputTypeSelect | null
  }



  /**
   * Count Type REPropertySubCategoryModelCountOutputType
   */


  export type REPropertySubCategoryModelCountOutputType = {
    property_categories: number
  }

  export type REPropertySubCategoryModelCountOutputTypeSelect = {
    property_categories?: boolean
  }

  export type REPropertySubCategoryModelCountOutputTypeGetPayload<S extends boolean | null | undefined | REPropertySubCategoryModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? REPropertySubCategoryModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (REPropertySubCategoryModelCountOutputTypeArgs)
    ? REPropertySubCategoryModelCountOutputType 
    : S extends { select: any } & (REPropertySubCategoryModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof REPropertySubCategoryModelCountOutputType ? REPropertySubCategoryModelCountOutputType[P] : never
  } 
      : REPropertySubCategoryModelCountOutputType




  // Custom InputTypes

  /**
   * REPropertySubCategoryModelCountOutputType without action
   */
  export type REPropertySubCategoryModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the REPropertySubCategoryModelCountOutputType
     */
    select?: REPropertySubCategoryModelCountOutputTypeSelect | null
  }



  /**
   * Count Type REPropertyMiddleCategoryModelCountOutputType
   */


  export type REPropertyMiddleCategoryModelCountOutputType = {
    sub_categories: number
  }

  export type REPropertyMiddleCategoryModelCountOutputTypeSelect = {
    sub_categories?: boolean
  }

  export type REPropertyMiddleCategoryModelCountOutputTypeGetPayload<S extends boolean | null | undefined | REPropertyMiddleCategoryModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? REPropertyMiddleCategoryModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (REPropertyMiddleCategoryModelCountOutputTypeArgs)
    ? REPropertyMiddleCategoryModelCountOutputType 
    : S extends { select: any } & (REPropertyMiddleCategoryModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof REPropertyMiddleCategoryModelCountOutputType ? REPropertyMiddleCategoryModelCountOutputType[P] : never
  } 
      : REPropertyMiddleCategoryModelCountOutputType




  // Custom InputTypes

  /**
   * REPropertyMiddleCategoryModelCountOutputType without action
   */
  export type REPropertyMiddleCategoryModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the REPropertyMiddleCategoryModelCountOutputType
     */
    select?: REPropertyMiddleCategoryModelCountOutputTypeSelect | null
  }



  /**
   * Count Type REPropertySuperCategoryModelCountOutputType
   */


  export type REPropertySuperCategoryModelCountOutputType = {
    middle_categories: number
  }

  export type REPropertySuperCategoryModelCountOutputTypeSelect = {
    middle_categories?: boolean
  }

  export type REPropertySuperCategoryModelCountOutputTypeGetPayload<S extends boolean | null | undefined | REPropertySuperCategoryModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? REPropertySuperCategoryModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (REPropertySuperCategoryModelCountOutputTypeArgs)
    ? REPropertySuperCategoryModelCountOutputType 
    : S extends { select: any } & (REPropertySuperCategoryModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof REPropertySuperCategoryModelCountOutputType ? REPropertySuperCategoryModelCountOutputType[P] : never
  } 
      : REPropertySuperCategoryModelCountOutputType




  // Custom InputTypes

  /**
   * REPropertySuperCategoryModelCountOutputType without action
   */
  export type REPropertySuperCategoryModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the REPropertySuperCategoryModelCountOutputType
     */
    select?: REPropertySuperCategoryModelCountOutputTypeSelect | null
  }



  /**
   * Count Type ReviewModelCountOutputType
   */


  export type ReviewModelCountOutputType = {
    rates: number
  }

  export type ReviewModelCountOutputTypeSelect = {
    rates?: boolean
  }

  export type ReviewModelCountOutputTypeGetPayload<S extends boolean | null | undefined | ReviewModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ReviewModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ReviewModelCountOutputTypeArgs)
    ? ReviewModelCountOutputType 
    : S extends { select: any } & (ReviewModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ReviewModelCountOutputType ? ReviewModelCountOutputType[P] : never
  } 
      : ReviewModelCountOutputType




  // Custom InputTypes

  /**
   * ReviewModelCountOutputType without action
   */
  export type ReviewModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ReviewModelCountOutputType
     */
    select?: ReviewModelCountOutputTypeSelect | null
  }



  /**
   * Count Type RateCategoryModelCountOutputType
   */


  export type RateCategoryModelCountOutputType = {
    rates: number
  }

  export type RateCategoryModelCountOutputTypeSelect = {
    rates?: boolean
  }

  export type RateCategoryModelCountOutputTypeGetPayload<S extends boolean | null | undefined | RateCategoryModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RateCategoryModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RateCategoryModelCountOutputTypeArgs)
    ? RateCategoryModelCountOutputType 
    : S extends { select: any } & (RateCategoryModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RateCategoryModelCountOutputType ? RateCategoryModelCountOutputType[P] : never
  } 
      : RateCategoryModelCountOutputType




  // Custom InputTypes

  /**
   * RateCategoryModelCountOutputType without action
   */
  export type RateCategoryModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RateCategoryModelCountOutputType
     */
    select?: RateCategoryModelCountOutputTypeSelect | null
  }



  /**
   * Count Type AgreementModelCountOutputType
   */


  export type AgreementModelCountOutputType = {
    acceptances: number
  }

  export type AgreementModelCountOutputTypeSelect = {
    acceptances?: boolean
  }

  export type AgreementModelCountOutputTypeGetPayload<S extends boolean | null | undefined | AgreementModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AgreementModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (AgreementModelCountOutputTypeArgs)
    ? AgreementModelCountOutputType 
    : S extends { select: any } & (AgreementModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof AgreementModelCountOutputType ? AgreementModelCountOutputType[P] : never
  } 
      : AgreementModelCountOutputType




  // Custom InputTypes

  /**
   * AgreementModelCountOutputType without action
   */
  export type AgreementModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AgreementModelCountOutputType
     */
    select?: AgreementModelCountOutputTypeSelect | null
  }



  /**
   * Count Type ConsultationTimeModelCountOutputType
   */


  export type ConsultationTimeModelCountOutputType = {
    focus_care_checks: number
  }

  export type ConsultationTimeModelCountOutputTypeSelect = {
    focus_care_checks?: boolean
  }

  export type ConsultationTimeModelCountOutputTypeGetPayload<S extends boolean | null | undefined | ConsultationTimeModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ConsultationTimeModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ConsultationTimeModelCountOutputTypeArgs)
    ? ConsultationTimeModelCountOutputType 
    : S extends { select: any } & (ConsultationTimeModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ConsultationTimeModelCountOutputType ? ConsultationTimeModelCountOutputType[P] : never
  } 
      : ConsultationTimeModelCountOutputType




  // Custom InputTypes

  /**
   * ConsultationTimeModelCountOutputType without action
   */
  export type ConsultationTimeModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ConsultationTimeModelCountOutputType
     */
    select?: ConsultationTimeModelCountOutputTypeSelect | null
  }



  /**
   * Count Type ServiceSubCategoryModelCountOutputType
   */


  export type ServiceSubCategoryModelCountOutputType = {
    expertises: number
  }

  export type ServiceSubCategoryModelCountOutputTypeSelect = {
    expertises?: boolean
  }

  export type ServiceSubCategoryModelCountOutputTypeGetPayload<S extends boolean | null | undefined | ServiceSubCategoryModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ServiceSubCategoryModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ServiceSubCategoryModelCountOutputTypeArgs)
    ? ServiceSubCategoryModelCountOutputType 
    : S extends { select: any } & (ServiceSubCategoryModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ServiceSubCategoryModelCountOutputType ? ServiceSubCategoryModelCountOutputType[P] : never
  } 
      : ServiceSubCategoryModelCountOutputType




  // Custom InputTypes

  /**
   * ServiceSubCategoryModelCountOutputType without action
   */
  export type ServiceSubCategoryModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ServiceSubCategoryModelCountOutputType
     */
    select?: ServiceSubCategoryModelCountOutputTypeSelect | null
  }



  /**
   * Count Type ServiceSuperCategoryModelCountOutputType
   */


  export type ServiceSuperCategoryModelCountOutputType = {
    sub_categories: number
    focus_care_checks: number
  }

  export type ServiceSuperCategoryModelCountOutputTypeSelect = {
    sub_categories?: boolean
    focus_care_checks?: boolean
  }

  export type ServiceSuperCategoryModelCountOutputTypeGetPayload<S extends boolean | null | undefined | ServiceSuperCategoryModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ServiceSuperCategoryModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ServiceSuperCategoryModelCountOutputTypeArgs)
    ? ServiceSuperCategoryModelCountOutputType 
    : S extends { select: any } & (ServiceSuperCategoryModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ServiceSuperCategoryModelCountOutputType ? ServiceSuperCategoryModelCountOutputType[P] : never
  } 
      : ServiceSuperCategoryModelCountOutputType




  // Custom InputTypes

  /**
   * ServiceSuperCategoryModelCountOutputType without action
   */
  export type ServiceSuperCategoryModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ServiceSuperCategoryModelCountOutputType
     */
    select?: ServiceSuperCategoryModelCountOutputTypeSelect | null
  }



  /**
   * Count Type FocusCareRequestModelCountOutputType
   */


  export type FocusCareRequestModelCountOutputType = {
    consultation_times: number
    services: number
  }

  export type FocusCareRequestModelCountOutputTypeSelect = {
    consultation_times?: boolean
    services?: boolean
  }

  export type FocusCareRequestModelCountOutputTypeGetPayload<S extends boolean | null | undefined | FocusCareRequestModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FocusCareRequestModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FocusCareRequestModelCountOutputTypeArgs)
    ? FocusCareRequestModelCountOutputType 
    : S extends { select: any } & (FocusCareRequestModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FocusCareRequestModelCountOutputType ? FocusCareRequestModelCountOutputType[P] : never
  } 
      : FocusCareRequestModelCountOutputType




  // Custom InputTypes

  /**
   * FocusCareRequestModelCountOutputType without action
   */
  export type FocusCareRequestModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FocusCareRequestModelCountOutputType
     */
    select?: FocusCareRequestModelCountOutputTypeSelect | null
  }



  /**
   * Count Type UserModelCountOutputType
   */


  export type UserModelCountOutputType = {
    agreement_acceptances: number
  }

  export type UserModelCountOutputTypeSelect = {
    agreement_acceptances?: boolean
  }

  export type UserModelCountOutputTypeGetPayload<S extends boolean | null | undefined | UserModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserModelCountOutputTypeArgs)
    ? UserModelCountOutputType 
    : S extends { select: any } & (UserModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserModelCountOutputType ? UserModelCountOutputType[P] : never
  } 
      : UserModelCountOutputType




  // Custom InputTypes

  /**
   * UserModelCountOutputType without action
   */
  export type UserModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserModelCountOutputType
     */
    select?: UserModelCountOutputTypeSelect | null
  }



  /**
   * Count Type CustomerModelCountOutputType
   */


  export type CustomerModelCountOutputType = {
    oauth_accounts: number
    reviews: number
    focus_care_requests: number
  }

  export type CustomerModelCountOutputTypeSelect = {
    oauth_accounts?: boolean
    reviews?: boolean
    focus_care_requests?: boolean
  }

  export type CustomerModelCountOutputTypeGetPayload<S extends boolean | null | undefined | CustomerModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CustomerModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CustomerModelCountOutputTypeArgs)
    ? CustomerModelCountOutputType 
    : S extends { select: any } & (CustomerModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CustomerModelCountOutputType ? CustomerModelCountOutputType[P] : never
  } 
      : CustomerModelCountOutputType




  // Custom InputTypes

  /**
   * CustomerModelCountOutputType without action
   */
  export type CustomerModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CustomerModelCountOutputType
     */
    select?: CustomerModelCountOutputTypeSelect | null
  }



  /**
   * Count Type BusinessUserModelCountOutputType
   */


  export type BusinessUserModelCountOutputType = {
    certification_images: number
    sub_expertises: number
    oauth_accounts: number
    reviews: number
  }

  export type BusinessUserModelCountOutputTypeSelect = {
    certification_images?: boolean
    sub_expertises?: boolean
    oauth_accounts?: boolean
    reviews?: boolean
  }

  export type BusinessUserModelCountOutputTypeGetPayload<S extends boolean | null | undefined | BusinessUserModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BusinessUserModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BusinessUserModelCountOutputTypeArgs)
    ? BusinessUserModelCountOutputType 
    : S extends { select: any } & (BusinessUserModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BusinessUserModelCountOutputType ? BusinessUserModelCountOutputType[P] : never
  } 
      : BusinessUserModelCountOutputType




  // Custom InputTypes

  /**
   * BusinessUserModelCountOutputType without action
   */
  export type BusinessUserModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BusinessUserModelCountOutputType
     */
    select?: BusinessUserModelCountOutputTypeSelect | null
  }



  /**
   * Count Type REAgentModelCountOutputType
   */


  export type REAgentModelCountOutputType = {
    properties: number
  }

  export type REAgentModelCountOutputTypeSelect = {
    properties?: boolean
  }

  export type REAgentModelCountOutputTypeGetPayload<S extends boolean | null | undefined | REAgentModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? REAgentModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (REAgentModelCountOutputTypeArgs)
    ? REAgentModelCountOutputType 
    : S extends { select: any } & (REAgentModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof REAgentModelCountOutputType ? REAgentModelCountOutputType[P] : never
  } 
      : REAgentModelCountOutputType




  // Custom InputTypes

  /**
   * REAgentModelCountOutputType without action
   */
  export type REAgentModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the REAgentModelCountOutputType
     */
    select?: REAgentModelCountOutputTypeSelect | null
  }



  /**
   * Count Type HSProviderModelCountOutputType
   */


  export type HSProviderModelCountOutputType = {
    introduction_images: number
  }

  export type HSProviderModelCountOutputTypeSelect = {
    introduction_images?: boolean
  }

  export type HSProviderModelCountOutputTypeGetPayload<S extends boolean | null | undefined | HSProviderModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HSProviderModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (HSProviderModelCountOutputTypeArgs)
    ? HSProviderModelCountOutputType 
    : S extends { select: any } & (HSProviderModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof HSProviderModelCountOutputType ? HSProviderModelCountOutputType[P] : never
  } 
      : HSProviderModelCountOutputType




  // Custom InputTypes

  /**
   * HSProviderModelCountOutputType without action
   */
  export type HSProviderModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the HSProviderModelCountOutputType
     */
    select?: HSProviderModelCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model REProertyModel
   */


  export type AggregateREProertyModel = {
    _count: REProertyModelCountAggregateOutputType | null
    _min: REProertyModelMinAggregateOutputType | null
    _max: REProertyModelMaxAggregateOutputType | null
  }

  export type REProertyModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    main_image_url: string | null
    re_agent_id: string | null
  }

  export type REProertyModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    main_image_url: string | null
    re_agent_id: string | null
  }

  export type REProertyModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    name: number
    main_image_url: number
    re_agent_id: number
    _all: number
  }


  export type REProertyModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    main_image_url?: true
    re_agent_id?: true
  }

  export type REProertyModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    main_image_url?: true
    re_agent_id?: true
  }

  export type REProertyModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    main_image_url?: true
    re_agent_id?: true
    _all?: true
  }

  export type REProertyModelAggregateArgs = {
    /**
     * Filter which REProertyModel to aggregate.
     */
    where?: REProertyModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REProertyModels to fetch.
     */
    orderBy?: Enumerable<REProertyModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: REProertyModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REProertyModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REProertyModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned REProertyModels
    **/
    _count?: true | REProertyModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: REProertyModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: REProertyModelMaxAggregateInputType
  }

  export type GetREProertyModelAggregateType<T extends REProertyModelAggregateArgs> = {
        [P in keyof T & keyof AggregateREProertyModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateREProertyModel[P]>
      : GetScalarType<T[P], AggregateREProertyModel[P]>
  }




  export type REProertyModelGroupByArgs = {
    where?: REProertyModelWhereInput
    orderBy?: Enumerable<REProertyModelOrderByWithAggregationInput>
    by: REProertyModelScalarFieldEnum[]
    having?: REProertyModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: REProertyModelCountAggregateInputType | true
    _min?: REProertyModelMinAggregateInputType
    _max?: REProertyModelMaxAggregateInputType
  }


  export type REProertyModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    name: string
    main_image_url: string
    re_agent_id: string
    _count: REProertyModelCountAggregateOutputType | null
    _min: REProertyModelMinAggregateOutputType | null
    _max: REProertyModelMaxAggregateOutputType | null
  }

  type GetREProertyModelGroupByPayload<T extends REProertyModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<REProertyModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof REProertyModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], REProertyModelGroupByOutputType[P]>
            : GetScalarType<T[P], REProertyModelGroupByOutputType[P]>
        }
      >
    >


  export type REProertyModelSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    name?: boolean
    main_image_url?: boolean
    re_agent_id?: boolean
    re_agent?: boolean | REAgentModelArgs
    categories?: boolean | REProertyModel$categoriesArgs
    _count?: boolean | REProertyModelCountOutputTypeArgs
  }


  export type REProertyModelInclude = {
    re_agent?: boolean | REAgentModelArgs
    categories?: boolean | REProertyModel$categoriesArgs
    _count?: boolean | REProertyModelCountOutputTypeArgs
  }

  export type REProertyModelGetPayload<S extends boolean | null | undefined | REProertyModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? REProertyModel :
    S extends undefined ? never :
    S extends { include: any } & (REProertyModelArgs | REProertyModelFindManyArgs)
    ? REProertyModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 're_agent' ? REAgentModelGetPayload<S['include'][P]> :
        P extends 'categories' ? Array < REPropertyCategoryModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? REProertyModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (REProertyModelArgs | REProertyModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 're_agent' ? REAgentModelGetPayload<S['select'][P]> :
        P extends 'categories' ? Array < REPropertyCategoryModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? REProertyModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof REProertyModel ? REProertyModel[P] : never
  } 
      : REProertyModel


  type REProertyModelCountArgs = 
    Omit<REProertyModelFindManyArgs, 'select' | 'include'> & {
      select?: REProertyModelCountAggregateInputType | true
    }

  export interface REProertyModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one REProertyModel that matches the filter.
     * @param {REProertyModelFindUniqueArgs} args - Arguments to find a REProertyModel
     * @example
     * // Get one REProertyModel
     * const rEProertyModel = await prisma.rEProertyModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends REProertyModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, REProertyModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'REProertyModel'> extends True ? Prisma__REProertyModelClient<REProertyModelGetPayload<T>> : Prisma__REProertyModelClient<REProertyModelGetPayload<T> | null, null>

    /**
     * Find one REProertyModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {REProertyModelFindUniqueOrThrowArgs} args - Arguments to find a REProertyModel
     * @example
     * // Get one REProertyModel
     * const rEProertyModel = await prisma.rEProertyModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends REProertyModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, REProertyModelFindUniqueOrThrowArgs>
    ): Prisma__REProertyModelClient<REProertyModelGetPayload<T>>

    /**
     * Find the first REProertyModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REProertyModelFindFirstArgs} args - Arguments to find a REProertyModel
     * @example
     * // Get one REProertyModel
     * const rEProertyModel = await prisma.rEProertyModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends REProertyModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, REProertyModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'REProertyModel'> extends True ? Prisma__REProertyModelClient<REProertyModelGetPayload<T>> : Prisma__REProertyModelClient<REProertyModelGetPayload<T> | null, null>

    /**
     * Find the first REProertyModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REProertyModelFindFirstOrThrowArgs} args - Arguments to find a REProertyModel
     * @example
     * // Get one REProertyModel
     * const rEProertyModel = await prisma.rEProertyModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends REProertyModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, REProertyModelFindFirstOrThrowArgs>
    ): Prisma__REProertyModelClient<REProertyModelGetPayload<T>>

    /**
     * Find zero or more REProertyModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REProertyModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all REProertyModels
     * const rEProertyModels = await prisma.rEProertyModel.findMany()
     * 
     * // Get first 10 REProertyModels
     * const rEProertyModels = await prisma.rEProertyModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rEProertyModelWithIdOnly = await prisma.rEProertyModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends REProertyModelFindManyArgs>(
      args?: SelectSubset<T, REProertyModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<REProertyModelGetPayload<T>>>

    /**
     * Create a REProertyModel.
     * @param {REProertyModelCreateArgs} args - Arguments to create a REProertyModel.
     * @example
     * // Create one REProertyModel
     * const REProertyModel = await prisma.rEProertyModel.create({
     *   data: {
     *     // ... data to create a REProertyModel
     *   }
     * })
     * 
    **/
    create<T extends REProertyModelCreateArgs>(
      args: SelectSubset<T, REProertyModelCreateArgs>
    ): Prisma__REProertyModelClient<REProertyModelGetPayload<T>>

    /**
     * Create many REProertyModels.
     *     @param {REProertyModelCreateManyArgs} args - Arguments to create many REProertyModels.
     *     @example
     *     // Create many REProertyModels
     *     const rEProertyModel = await prisma.rEProertyModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends REProertyModelCreateManyArgs>(
      args?: SelectSubset<T, REProertyModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a REProertyModel.
     * @param {REProertyModelDeleteArgs} args - Arguments to delete one REProertyModel.
     * @example
     * // Delete one REProertyModel
     * const REProertyModel = await prisma.rEProertyModel.delete({
     *   where: {
     *     // ... filter to delete one REProertyModel
     *   }
     * })
     * 
    **/
    delete<T extends REProertyModelDeleteArgs>(
      args: SelectSubset<T, REProertyModelDeleteArgs>
    ): Prisma__REProertyModelClient<REProertyModelGetPayload<T>>

    /**
     * Update one REProertyModel.
     * @param {REProertyModelUpdateArgs} args - Arguments to update one REProertyModel.
     * @example
     * // Update one REProertyModel
     * const rEProertyModel = await prisma.rEProertyModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends REProertyModelUpdateArgs>(
      args: SelectSubset<T, REProertyModelUpdateArgs>
    ): Prisma__REProertyModelClient<REProertyModelGetPayload<T>>

    /**
     * Delete zero or more REProertyModels.
     * @param {REProertyModelDeleteManyArgs} args - Arguments to filter REProertyModels to delete.
     * @example
     * // Delete a few REProertyModels
     * const { count } = await prisma.rEProertyModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends REProertyModelDeleteManyArgs>(
      args?: SelectSubset<T, REProertyModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more REProertyModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REProertyModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many REProertyModels
     * const rEProertyModel = await prisma.rEProertyModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends REProertyModelUpdateManyArgs>(
      args: SelectSubset<T, REProertyModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one REProertyModel.
     * @param {REProertyModelUpsertArgs} args - Arguments to update or create a REProertyModel.
     * @example
     * // Update or create a REProertyModel
     * const rEProertyModel = await prisma.rEProertyModel.upsert({
     *   create: {
     *     // ... data to create a REProertyModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the REProertyModel we want to update
     *   }
     * })
    **/
    upsert<T extends REProertyModelUpsertArgs>(
      args: SelectSubset<T, REProertyModelUpsertArgs>
    ): Prisma__REProertyModelClient<REProertyModelGetPayload<T>>

    /**
     * Count the number of REProertyModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REProertyModelCountArgs} args - Arguments to filter REProertyModels to count.
     * @example
     * // Count the number of REProertyModels
     * const count = await prisma.rEProertyModel.count({
     *   where: {
     *     // ... the filter for the REProertyModels we want to count
     *   }
     * })
    **/
    count<T extends REProertyModelCountArgs>(
      args?: Subset<T, REProertyModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], REProertyModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a REProertyModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REProertyModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends REProertyModelAggregateArgs>(args: Subset<T, REProertyModelAggregateArgs>): Prisma.PrismaPromise<GetREProertyModelAggregateType<T>>

    /**
     * Group by REProertyModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REProertyModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends REProertyModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: REProertyModelGroupByArgs['orderBy'] }
        : { orderBy?: REProertyModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, REProertyModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetREProertyModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for REProertyModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__REProertyModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    re_agent<T extends REAgentModelArgs= {}>(args?: Subset<T, REAgentModelArgs>): Prisma__REAgentModelClient<REAgentModelGetPayload<T> | Null>;

    categories<T extends REProertyModel$categoriesArgs= {}>(args?: Subset<T, REProertyModel$categoriesArgs>): Prisma.PrismaPromise<Array<REPropertyCategoryModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * REProertyModel base type for findUnique actions
   */
  export type REProertyModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the REProertyModel
     */
    select?: REProertyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REProertyModelInclude | null
    /**
     * Filter, which REProertyModel to fetch.
     */
    where: REProertyModelWhereUniqueInput
  }

  /**
   * REProertyModel findUnique
   */
  export interface REProertyModelFindUniqueArgs extends REProertyModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * REProertyModel findUniqueOrThrow
   */
  export type REProertyModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the REProertyModel
     */
    select?: REProertyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REProertyModelInclude | null
    /**
     * Filter, which REProertyModel to fetch.
     */
    where: REProertyModelWhereUniqueInput
  }


  /**
   * REProertyModel base type for findFirst actions
   */
  export type REProertyModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the REProertyModel
     */
    select?: REProertyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REProertyModelInclude | null
    /**
     * Filter, which REProertyModel to fetch.
     */
    where?: REProertyModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REProertyModels to fetch.
     */
    orderBy?: Enumerable<REProertyModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REProertyModels.
     */
    cursor?: REProertyModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REProertyModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REProertyModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REProertyModels.
     */
    distinct?: Enumerable<REProertyModelScalarFieldEnum>
  }

  /**
   * REProertyModel findFirst
   */
  export interface REProertyModelFindFirstArgs extends REProertyModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * REProertyModel findFirstOrThrow
   */
  export type REProertyModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the REProertyModel
     */
    select?: REProertyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REProertyModelInclude | null
    /**
     * Filter, which REProertyModel to fetch.
     */
    where?: REProertyModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REProertyModels to fetch.
     */
    orderBy?: Enumerable<REProertyModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REProertyModels.
     */
    cursor?: REProertyModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REProertyModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REProertyModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REProertyModels.
     */
    distinct?: Enumerable<REProertyModelScalarFieldEnum>
  }


  /**
   * REProertyModel findMany
   */
  export type REProertyModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the REProertyModel
     */
    select?: REProertyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REProertyModelInclude | null
    /**
     * Filter, which REProertyModels to fetch.
     */
    where?: REProertyModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REProertyModels to fetch.
     */
    orderBy?: Enumerable<REProertyModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing REProertyModels.
     */
    cursor?: REProertyModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REProertyModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REProertyModels.
     */
    skip?: number
    distinct?: Enumerable<REProertyModelScalarFieldEnum>
  }


  /**
   * REProertyModel create
   */
  export type REProertyModelCreateArgs = {
    /**
     * Select specific fields to fetch from the REProertyModel
     */
    select?: REProertyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REProertyModelInclude | null
    /**
     * The data needed to create a REProertyModel.
     */
    data: XOR<REProertyModelCreateInput, REProertyModelUncheckedCreateInput>
  }


  /**
   * REProertyModel createMany
   */
  export type REProertyModelCreateManyArgs = {
    /**
     * The data used to create many REProertyModels.
     */
    data: Enumerable<REProertyModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * REProertyModel update
   */
  export type REProertyModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the REProertyModel
     */
    select?: REProertyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REProertyModelInclude | null
    /**
     * The data needed to update a REProertyModel.
     */
    data: XOR<REProertyModelUpdateInput, REProertyModelUncheckedUpdateInput>
    /**
     * Choose, which REProertyModel to update.
     */
    where: REProertyModelWhereUniqueInput
  }


  /**
   * REProertyModel updateMany
   */
  export type REProertyModelUpdateManyArgs = {
    /**
     * The data used to update REProertyModels.
     */
    data: XOR<REProertyModelUpdateManyMutationInput, REProertyModelUncheckedUpdateManyInput>
    /**
     * Filter which REProertyModels to update
     */
    where?: REProertyModelWhereInput
  }


  /**
   * REProertyModel upsert
   */
  export type REProertyModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the REProertyModel
     */
    select?: REProertyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REProertyModelInclude | null
    /**
     * The filter to search for the REProertyModel to update in case it exists.
     */
    where: REProertyModelWhereUniqueInput
    /**
     * In case the REProertyModel found by the `where` argument doesn't exist, create a new REProertyModel with this data.
     */
    create: XOR<REProertyModelCreateInput, REProertyModelUncheckedCreateInput>
    /**
     * In case the REProertyModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<REProertyModelUpdateInput, REProertyModelUncheckedUpdateInput>
  }


  /**
   * REProertyModel delete
   */
  export type REProertyModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the REProertyModel
     */
    select?: REProertyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REProertyModelInclude | null
    /**
     * Filter which REProertyModel to delete.
     */
    where: REProertyModelWhereUniqueInput
  }


  /**
   * REProertyModel deleteMany
   */
  export type REProertyModelDeleteManyArgs = {
    /**
     * Filter which REProertyModels to delete
     */
    where?: REProertyModelWhereInput
  }


  /**
   * REProertyModel.categories
   */
  export type REProertyModel$categoriesArgs = {
    /**
     * Select specific fields to fetch from the REPropertyCategoryModel
     */
    select?: REPropertyCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyCategoryModelInclude | null
    where?: REPropertyCategoryModelWhereInput
    orderBy?: Enumerable<REPropertyCategoryModelOrderByWithRelationInput>
    cursor?: REPropertyCategoryModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<REPropertyCategoryModelScalarFieldEnum>
  }


  /**
   * REProertyModel without action
   */
  export type REProertyModelArgs = {
    /**
     * Select specific fields to fetch from the REProertyModel
     */
    select?: REProertyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REProertyModelInclude | null
  }



  /**
   * Model REPropertyCategoryModel
   */


  export type AggregateREPropertyCategoryModel = {
    _count: REPropertyCategoryModelCountAggregateOutputType | null
    _min: REPropertyCategoryModelMinAggregateOutputType | null
    _max: REPropertyCategoryModelMaxAggregateOutputType | null
  }

  export type REPropertyCategoryModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    re_property_id: string | null
    sub_category_id: string | null
  }

  export type REPropertyCategoryModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    re_property_id: string | null
    sub_category_id: string | null
  }

  export type REPropertyCategoryModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    re_property_id: number
    sub_category_id: number
    _all: number
  }


  export type REPropertyCategoryModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    re_property_id?: true
    sub_category_id?: true
  }

  export type REPropertyCategoryModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    re_property_id?: true
    sub_category_id?: true
  }

  export type REPropertyCategoryModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    re_property_id?: true
    sub_category_id?: true
    _all?: true
  }

  export type REPropertyCategoryModelAggregateArgs = {
    /**
     * Filter which REPropertyCategoryModel to aggregate.
     */
    where?: REPropertyCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertyCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertyCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: REPropertyCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertyCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertyCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned REPropertyCategoryModels
    **/
    _count?: true | REPropertyCategoryModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: REPropertyCategoryModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: REPropertyCategoryModelMaxAggregateInputType
  }

  export type GetREPropertyCategoryModelAggregateType<T extends REPropertyCategoryModelAggregateArgs> = {
        [P in keyof T & keyof AggregateREPropertyCategoryModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateREPropertyCategoryModel[P]>
      : GetScalarType<T[P], AggregateREPropertyCategoryModel[P]>
  }




  export type REPropertyCategoryModelGroupByArgs = {
    where?: REPropertyCategoryModelWhereInput
    orderBy?: Enumerable<REPropertyCategoryModelOrderByWithAggregationInput>
    by: REPropertyCategoryModelScalarFieldEnum[]
    having?: REPropertyCategoryModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: REPropertyCategoryModelCountAggregateInputType | true
    _min?: REPropertyCategoryModelMinAggregateInputType
    _max?: REPropertyCategoryModelMaxAggregateInputType
  }


  export type REPropertyCategoryModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    re_property_id: string
    sub_category_id: string
    _count: REPropertyCategoryModelCountAggregateOutputType | null
    _min: REPropertyCategoryModelMinAggregateOutputType | null
    _max: REPropertyCategoryModelMaxAggregateOutputType | null
  }

  type GetREPropertyCategoryModelGroupByPayload<T extends REPropertyCategoryModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<REPropertyCategoryModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof REPropertyCategoryModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], REPropertyCategoryModelGroupByOutputType[P]>
            : GetScalarType<T[P], REPropertyCategoryModelGroupByOutputType[P]>
        }
      >
    >


  export type REPropertyCategoryModelSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    re_property_id?: boolean
    sub_category_id?: boolean
    re_property?: boolean | REProertyModelArgs
    sub_category?: boolean | REPropertySubCategoryModelArgs
  }


  export type REPropertyCategoryModelInclude = {
    re_property?: boolean | REProertyModelArgs
    sub_category?: boolean | REPropertySubCategoryModelArgs
  }

  export type REPropertyCategoryModelGetPayload<S extends boolean | null | undefined | REPropertyCategoryModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? REPropertyCategoryModel :
    S extends undefined ? never :
    S extends { include: any } & (REPropertyCategoryModelArgs | REPropertyCategoryModelFindManyArgs)
    ? REPropertyCategoryModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 're_property' ? REProertyModelGetPayload<S['include'][P]> :
        P extends 'sub_category' ? REPropertySubCategoryModelGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (REPropertyCategoryModelArgs | REPropertyCategoryModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 're_property' ? REProertyModelGetPayload<S['select'][P]> :
        P extends 'sub_category' ? REPropertySubCategoryModelGetPayload<S['select'][P]> :  P extends keyof REPropertyCategoryModel ? REPropertyCategoryModel[P] : never
  } 
      : REPropertyCategoryModel


  type REPropertyCategoryModelCountArgs = 
    Omit<REPropertyCategoryModelFindManyArgs, 'select' | 'include'> & {
      select?: REPropertyCategoryModelCountAggregateInputType | true
    }

  export interface REPropertyCategoryModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one REPropertyCategoryModel that matches the filter.
     * @param {REPropertyCategoryModelFindUniqueArgs} args - Arguments to find a REPropertyCategoryModel
     * @example
     * // Get one REPropertyCategoryModel
     * const rEPropertyCategoryModel = await prisma.rEPropertyCategoryModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends REPropertyCategoryModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, REPropertyCategoryModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'REPropertyCategoryModel'> extends True ? Prisma__REPropertyCategoryModelClient<REPropertyCategoryModelGetPayload<T>> : Prisma__REPropertyCategoryModelClient<REPropertyCategoryModelGetPayload<T> | null, null>

    /**
     * Find one REPropertyCategoryModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {REPropertyCategoryModelFindUniqueOrThrowArgs} args - Arguments to find a REPropertyCategoryModel
     * @example
     * // Get one REPropertyCategoryModel
     * const rEPropertyCategoryModel = await prisma.rEPropertyCategoryModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends REPropertyCategoryModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, REPropertyCategoryModelFindUniqueOrThrowArgs>
    ): Prisma__REPropertyCategoryModelClient<REPropertyCategoryModelGetPayload<T>>

    /**
     * Find the first REPropertyCategoryModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyCategoryModelFindFirstArgs} args - Arguments to find a REPropertyCategoryModel
     * @example
     * // Get one REPropertyCategoryModel
     * const rEPropertyCategoryModel = await prisma.rEPropertyCategoryModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends REPropertyCategoryModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, REPropertyCategoryModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'REPropertyCategoryModel'> extends True ? Prisma__REPropertyCategoryModelClient<REPropertyCategoryModelGetPayload<T>> : Prisma__REPropertyCategoryModelClient<REPropertyCategoryModelGetPayload<T> | null, null>

    /**
     * Find the first REPropertyCategoryModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyCategoryModelFindFirstOrThrowArgs} args - Arguments to find a REPropertyCategoryModel
     * @example
     * // Get one REPropertyCategoryModel
     * const rEPropertyCategoryModel = await prisma.rEPropertyCategoryModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends REPropertyCategoryModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, REPropertyCategoryModelFindFirstOrThrowArgs>
    ): Prisma__REPropertyCategoryModelClient<REPropertyCategoryModelGetPayload<T>>

    /**
     * Find zero or more REPropertyCategoryModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyCategoryModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all REPropertyCategoryModels
     * const rEPropertyCategoryModels = await prisma.rEPropertyCategoryModel.findMany()
     * 
     * // Get first 10 REPropertyCategoryModels
     * const rEPropertyCategoryModels = await prisma.rEPropertyCategoryModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rEPropertyCategoryModelWithIdOnly = await prisma.rEPropertyCategoryModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends REPropertyCategoryModelFindManyArgs>(
      args?: SelectSubset<T, REPropertyCategoryModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<REPropertyCategoryModelGetPayload<T>>>

    /**
     * Create a REPropertyCategoryModel.
     * @param {REPropertyCategoryModelCreateArgs} args - Arguments to create a REPropertyCategoryModel.
     * @example
     * // Create one REPropertyCategoryModel
     * const REPropertyCategoryModel = await prisma.rEPropertyCategoryModel.create({
     *   data: {
     *     // ... data to create a REPropertyCategoryModel
     *   }
     * })
     * 
    **/
    create<T extends REPropertyCategoryModelCreateArgs>(
      args: SelectSubset<T, REPropertyCategoryModelCreateArgs>
    ): Prisma__REPropertyCategoryModelClient<REPropertyCategoryModelGetPayload<T>>

    /**
     * Create many REPropertyCategoryModels.
     *     @param {REPropertyCategoryModelCreateManyArgs} args - Arguments to create many REPropertyCategoryModels.
     *     @example
     *     // Create many REPropertyCategoryModels
     *     const rEPropertyCategoryModel = await prisma.rEPropertyCategoryModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends REPropertyCategoryModelCreateManyArgs>(
      args?: SelectSubset<T, REPropertyCategoryModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a REPropertyCategoryModel.
     * @param {REPropertyCategoryModelDeleteArgs} args - Arguments to delete one REPropertyCategoryModel.
     * @example
     * // Delete one REPropertyCategoryModel
     * const REPropertyCategoryModel = await prisma.rEPropertyCategoryModel.delete({
     *   where: {
     *     // ... filter to delete one REPropertyCategoryModel
     *   }
     * })
     * 
    **/
    delete<T extends REPropertyCategoryModelDeleteArgs>(
      args: SelectSubset<T, REPropertyCategoryModelDeleteArgs>
    ): Prisma__REPropertyCategoryModelClient<REPropertyCategoryModelGetPayload<T>>

    /**
     * Update one REPropertyCategoryModel.
     * @param {REPropertyCategoryModelUpdateArgs} args - Arguments to update one REPropertyCategoryModel.
     * @example
     * // Update one REPropertyCategoryModel
     * const rEPropertyCategoryModel = await prisma.rEPropertyCategoryModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends REPropertyCategoryModelUpdateArgs>(
      args: SelectSubset<T, REPropertyCategoryModelUpdateArgs>
    ): Prisma__REPropertyCategoryModelClient<REPropertyCategoryModelGetPayload<T>>

    /**
     * Delete zero or more REPropertyCategoryModels.
     * @param {REPropertyCategoryModelDeleteManyArgs} args - Arguments to filter REPropertyCategoryModels to delete.
     * @example
     * // Delete a few REPropertyCategoryModels
     * const { count } = await prisma.rEPropertyCategoryModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends REPropertyCategoryModelDeleteManyArgs>(
      args?: SelectSubset<T, REPropertyCategoryModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more REPropertyCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyCategoryModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many REPropertyCategoryModels
     * const rEPropertyCategoryModel = await prisma.rEPropertyCategoryModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends REPropertyCategoryModelUpdateManyArgs>(
      args: SelectSubset<T, REPropertyCategoryModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one REPropertyCategoryModel.
     * @param {REPropertyCategoryModelUpsertArgs} args - Arguments to update or create a REPropertyCategoryModel.
     * @example
     * // Update or create a REPropertyCategoryModel
     * const rEPropertyCategoryModel = await prisma.rEPropertyCategoryModel.upsert({
     *   create: {
     *     // ... data to create a REPropertyCategoryModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the REPropertyCategoryModel we want to update
     *   }
     * })
    **/
    upsert<T extends REPropertyCategoryModelUpsertArgs>(
      args: SelectSubset<T, REPropertyCategoryModelUpsertArgs>
    ): Prisma__REPropertyCategoryModelClient<REPropertyCategoryModelGetPayload<T>>

    /**
     * Count the number of REPropertyCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyCategoryModelCountArgs} args - Arguments to filter REPropertyCategoryModels to count.
     * @example
     * // Count the number of REPropertyCategoryModels
     * const count = await prisma.rEPropertyCategoryModel.count({
     *   where: {
     *     // ... the filter for the REPropertyCategoryModels we want to count
     *   }
     * })
    **/
    count<T extends REPropertyCategoryModelCountArgs>(
      args?: Subset<T, REPropertyCategoryModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], REPropertyCategoryModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a REPropertyCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyCategoryModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends REPropertyCategoryModelAggregateArgs>(args: Subset<T, REPropertyCategoryModelAggregateArgs>): Prisma.PrismaPromise<GetREPropertyCategoryModelAggregateType<T>>

    /**
     * Group by REPropertyCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyCategoryModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends REPropertyCategoryModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: REPropertyCategoryModelGroupByArgs['orderBy'] }
        : { orderBy?: REPropertyCategoryModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, REPropertyCategoryModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetREPropertyCategoryModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for REPropertyCategoryModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__REPropertyCategoryModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    re_property<T extends REProertyModelArgs= {}>(args?: Subset<T, REProertyModelArgs>): Prisma__REProertyModelClient<REProertyModelGetPayload<T> | Null>;

    sub_category<T extends REPropertySubCategoryModelArgs= {}>(args?: Subset<T, REPropertySubCategoryModelArgs>): Prisma__REPropertySubCategoryModelClient<REPropertySubCategoryModelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * REPropertyCategoryModel base type for findUnique actions
   */
  export type REPropertyCategoryModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the REPropertyCategoryModel
     */
    select?: REPropertyCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyCategoryModelInclude | null
    /**
     * Filter, which REPropertyCategoryModel to fetch.
     */
    where: REPropertyCategoryModelWhereUniqueInput
  }

  /**
   * REPropertyCategoryModel findUnique
   */
  export interface REPropertyCategoryModelFindUniqueArgs extends REPropertyCategoryModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * REPropertyCategoryModel findUniqueOrThrow
   */
  export type REPropertyCategoryModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the REPropertyCategoryModel
     */
    select?: REPropertyCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyCategoryModelInclude | null
    /**
     * Filter, which REPropertyCategoryModel to fetch.
     */
    where: REPropertyCategoryModelWhereUniqueInput
  }


  /**
   * REPropertyCategoryModel base type for findFirst actions
   */
  export type REPropertyCategoryModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the REPropertyCategoryModel
     */
    select?: REPropertyCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyCategoryModelInclude | null
    /**
     * Filter, which REPropertyCategoryModel to fetch.
     */
    where?: REPropertyCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertyCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertyCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REPropertyCategoryModels.
     */
    cursor?: REPropertyCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertyCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertyCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REPropertyCategoryModels.
     */
    distinct?: Enumerable<REPropertyCategoryModelScalarFieldEnum>
  }

  /**
   * REPropertyCategoryModel findFirst
   */
  export interface REPropertyCategoryModelFindFirstArgs extends REPropertyCategoryModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * REPropertyCategoryModel findFirstOrThrow
   */
  export type REPropertyCategoryModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the REPropertyCategoryModel
     */
    select?: REPropertyCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyCategoryModelInclude | null
    /**
     * Filter, which REPropertyCategoryModel to fetch.
     */
    where?: REPropertyCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertyCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertyCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REPropertyCategoryModels.
     */
    cursor?: REPropertyCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertyCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertyCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REPropertyCategoryModels.
     */
    distinct?: Enumerable<REPropertyCategoryModelScalarFieldEnum>
  }


  /**
   * REPropertyCategoryModel findMany
   */
  export type REPropertyCategoryModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the REPropertyCategoryModel
     */
    select?: REPropertyCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyCategoryModelInclude | null
    /**
     * Filter, which REPropertyCategoryModels to fetch.
     */
    where?: REPropertyCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertyCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertyCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing REPropertyCategoryModels.
     */
    cursor?: REPropertyCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertyCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertyCategoryModels.
     */
    skip?: number
    distinct?: Enumerable<REPropertyCategoryModelScalarFieldEnum>
  }


  /**
   * REPropertyCategoryModel create
   */
  export type REPropertyCategoryModelCreateArgs = {
    /**
     * Select specific fields to fetch from the REPropertyCategoryModel
     */
    select?: REPropertyCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyCategoryModelInclude | null
    /**
     * The data needed to create a REPropertyCategoryModel.
     */
    data: XOR<REPropertyCategoryModelCreateInput, REPropertyCategoryModelUncheckedCreateInput>
  }


  /**
   * REPropertyCategoryModel createMany
   */
  export type REPropertyCategoryModelCreateManyArgs = {
    /**
     * The data used to create many REPropertyCategoryModels.
     */
    data: Enumerable<REPropertyCategoryModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * REPropertyCategoryModel update
   */
  export type REPropertyCategoryModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the REPropertyCategoryModel
     */
    select?: REPropertyCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyCategoryModelInclude | null
    /**
     * The data needed to update a REPropertyCategoryModel.
     */
    data: XOR<REPropertyCategoryModelUpdateInput, REPropertyCategoryModelUncheckedUpdateInput>
    /**
     * Choose, which REPropertyCategoryModel to update.
     */
    where: REPropertyCategoryModelWhereUniqueInput
  }


  /**
   * REPropertyCategoryModel updateMany
   */
  export type REPropertyCategoryModelUpdateManyArgs = {
    /**
     * The data used to update REPropertyCategoryModels.
     */
    data: XOR<REPropertyCategoryModelUpdateManyMutationInput, REPropertyCategoryModelUncheckedUpdateManyInput>
    /**
     * Filter which REPropertyCategoryModels to update
     */
    where?: REPropertyCategoryModelWhereInput
  }


  /**
   * REPropertyCategoryModel upsert
   */
  export type REPropertyCategoryModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the REPropertyCategoryModel
     */
    select?: REPropertyCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyCategoryModelInclude | null
    /**
     * The filter to search for the REPropertyCategoryModel to update in case it exists.
     */
    where: REPropertyCategoryModelWhereUniqueInput
    /**
     * In case the REPropertyCategoryModel found by the `where` argument doesn't exist, create a new REPropertyCategoryModel with this data.
     */
    create: XOR<REPropertyCategoryModelCreateInput, REPropertyCategoryModelUncheckedCreateInput>
    /**
     * In case the REPropertyCategoryModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<REPropertyCategoryModelUpdateInput, REPropertyCategoryModelUncheckedUpdateInput>
  }


  /**
   * REPropertyCategoryModel delete
   */
  export type REPropertyCategoryModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the REPropertyCategoryModel
     */
    select?: REPropertyCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyCategoryModelInclude | null
    /**
     * Filter which REPropertyCategoryModel to delete.
     */
    where: REPropertyCategoryModelWhereUniqueInput
  }


  /**
   * REPropertyCategoryModel deleteMany
   */
  export type REPropertyCategoryModelDeleteManyArgs = {
    /**
     * Filter which REPropertyCategoryModels to delete
     */
    where?: REPropertyCategoryModelWhereInput
  }


  /**
   * REPropertyCategoryModel without action
   */
  export type REPropertyCategoryModelArgs = {
    /**
     * Select specific fields to fetch from the REPropertyCategoryModel
     */
    select?: REPropertyCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyCategoryModelInclude | null
  }



  /**
   * Model REPropertySubCategoryModel
   */


  export type AggregateREPropertySubCategoryModel = {
    _count: REPropertySubCategoryModelCountAggregateOutputType | null
    _min: REPropertySubCategoryModelMinAggregateOutputType | null
    _max: REPropertySubCategoryModelMaxAggregateOutputType | null
  }

  export type REPropertySubCategoryModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    middle_category_id: string | null
  }

  export type REPropertySubCategoryModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    middle_category_id: string | null
  }

  export type REPropertySubCategoryModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    name: number
    middle_category_id: number
    _all: number
  }


  export type REPropertySubCategoryModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    middle_category_id?: true
  }

  export type REPropertySubCategoryModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    middle_category_id?: true
  }

  export type REPropertySubCategoryModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    middle_category_id?: true
    _all?: true
  }

  export type REPropertySubCategoryModelAggregateArgs = {
    /**
     * Filter which REPropertySubCategoryModel to aggregate.
     */
    where?: REPropertySubCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertySubCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertySubCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: REPropertySubCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertySubCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertySubCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned REPropertySubCategoryModels
    **/
    _count?: true | REPropertySubCategoryModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: REPropertySubCategoryModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: REPropertySubCategoryModelMaxAggregateInputType
  }

  export type GetREPropertySubCategoryModelAggregateType<T extends REPropertySubCategoryModelAggregateArgs> = {
        [P in keyof T & keyof AggregateREPropertySubCategoryModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateREPropertySubCategoryModel[P]>
      : GetScalarType<T[P], AggregateREPropertySubCategoryModel[P]>
  }




  export type REPropertySubCategoryModelGroupByArgs = {
    where?: REPropertySubCategoryModelWhereInput
    orderBy?: Enumerable<REPropertySubCategoryModelOrderByWithAggregationInput>
    by: REPropertySubCategoryModelScalarFieldEnum[]
    having?: REPropertySubCategoryModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: REPropertySubCategoryModelCountAggregateInputType | true
    _min?: REPropertySubCategoryModelMinAggregateInputType
    _max?: REPropertySubCategoryModelMaxAggregateInputType
  }


  export type REPropertySubCategoryModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    name: string
    middle_category_id: string
    _count: REPropertySubCategoryModelCountAggregateOutputType | null
    _min: REPropertySubCategoryModelMinAggregateOutputType | null
    _max: REPropertySubCategoryModelMaxAggregateOutputType | null
  }

  type GetREPropertySubCategoryModelGroupByPayload<T extends REPropertySubCategoryModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<REPropertySubCategoryModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof REPropertySubCategoryModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], REPropertySubCategoryModelGroupByOutputType[P]>
            : GetScalarType<T[P], REPropertySubCategoryModelGroupByOutputType[P]>
        }
      >
    >


  export type REPropertySubCategoryModelSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    name?: boolean
    middle_category_id?: boolean
    middle_category?: boolean | REPropertyMiddleCategoryModelArgs
    property_categories?: boolean | REPropertySubCategoryModel$property_categoriesArgs
    _count?: boolean | REPropertySubCategoryModelCountOutputTypeArgs
  }


  export type REPropertySubCategoryModelInclude = {
    middle_category?: boolean | REPropertyMiddleCategoryModelArgs
    property_categories?: boolean | REPropertySubCategoryModel$property_categoriesArgs
    _count?: boolean | REPropertySubCategoryModelCountOutputTypeArgs
  }

  export type REPropertySubCategoryModelGetPayload<S extends boolean | null | undefined | REPropertySubCategoryModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? REPropertySubCategoryModel :
    S extends undefined ? never :
    S extends { include: any } & (REPropertySubCategoryModelArgs | REPropertySubCategoryModelFindManyArgs)
    ? REPropertySubCategoryModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'middle_category' ? REPropertyMiddleCategoryModelGetPayload<S['include'][P]> :
        P extends 'property_categories' ? Array < REPropertyCategoryModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? REPropertySubCategoryModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (REPropertySubCategoryModelArgs | REPropertySubCategoryModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'middle_category' ? REPropertyMiddleCategoryModelGetPayload<S['select'][P]> :
        P extends 'property_categories' ? Array < REPropertyCategoryModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? REPropertySubCategoryModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof REPropertySubCategoryModel ? REPropertySubCategoryModel[P] : never
  } 
      : REPropertySubCategoryModel


  type REPropertySubCategoryModelCountArgs = 
    Omit<REPropertySubCategoryModelFindManyArgs, 'select' | 'include'> & {
      select?: REPropertySubCategoryModelCountAggregateInputType | true
    }

  export interface REPropertySubCategoryModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one REPropertySubCategoryModel that matches the filter.
     * @param {REPropertySubCategoryModelFindUniqueArgs} args - Arguments to find a REPropertySubCategoryModel
     * @example
     * // Get one REPropertySubCategoryModel
     * const rEPropertySubCategoryModel = await prisma.rEPropertySubCategoryModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends REPropertySubCategoryModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, REPropertySubCategoryModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'REPropertySubCategoryModel'> extends True ? Prisma__REPropertySubCategoryModelClient<REPropertySubCategoryModelGetPayload<T>> : Prisma__REPropertySubCategoryModelClient<REPropertySubCategoryModelGetPayload<T> | null, null>

    /**
     * Find one REPropertySubCategoryModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {REPropertySubCategoryModelFindUniqueOrThrowArgs} args - Arguments to find a REPropertySubCategoryModel
     * @example
     * // Get one REPropertySubCategoryModel
     * const rEPropertySubCategoryModel = await prisma.rEPropertySubCategoryModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends REPropertySubCategoryModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, REPropertySubCategoryModelFindUniqueOrThrowArgs>
    ): Prisma__REPropertySubCategoryModelClient<REPropertySubCategoryModelGetPayload<T>>

    /**
     * Find the first REPropertySubCategoryModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySubCategoryModelFindFirstArgs} args - Arguments to find a REPropertySubCategoryModel
     * @example
     * // Get one REPropertySubCategoryModel
     * const rEPropertySubCategoryModel = await prisma.rEPropertySubCategoryModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends REPropertySubCategoryModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, REPropertySubCategoryModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'REPropertySubCategoryModel'> extends True ? Prisma__REPropertySubCategoryModelClient<REPropertySubCategoryModelGetPayload<T>> : Prisma__REPropertySubCategoryModelClient<REPropertySubCategoryModelGetPayload<T> | null, null>

    /**
     * Find the first REPropertySubCategoryModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySubCategoryModelFindFirstOrThrowArgs} args - Arguments to find a REPropertySubCategoryModel
     * @example
     * // Get one REPropertySubCategoryModel
     * const rEPropertySubCategoryModel = await prisma.rEPropertySubCategoryModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends REPropertySubCategoryModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, REPropertySubCategoryModelFindFirstOrThrowArgs>
    ): Prisma__REPropertySubCategoryModelClient<REPropertySubCategoryModelGetPayload<T>>

    /**
     * Find zero or more REPropertySubCategoryModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySubCategoryModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all REPropertySubCategoryModels
     * const rEPropertySubCategoryModels = await prisma.rEPropertySubCategoryModel.findMany()
     * 
     * // Get first 10 REPropertySubCategoryModels
     * const rEPropertySubCategoryModels = await prisma.rEPropertySubCategoryModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rEPropertySubCategoryModelWithIdOnly = await prisma.rEPropertySubCategoryModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends REPropertySubCategoryModelFindManyArgs>(
      args?: SelectSubset<T, REPropertySubCategoryModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<REPropertySubCategoryModelGetPayload<T>>>

    /**
     * Create a REPropertySubCategoryModel.
     * @param {REPropertySubCategoryModelCreateArgs} args - Arguments to create a REPropertySubCategoryModel.
     * @example
     * // Create one REPropertySubCategoryModel
     * const REPropertySubCategoryModel = await prisma.rEPropertySubCategoryModel.create({
     *   data: {
     *     // ... data to create a REPropertySubCategoryModel
     *   }
     * })
     * 
    **/
    create<T extends REPropertySubCategoryModelCreateArgs>(
      args: SelectSubset<T, REPropertySubCategoryModelCreateArgs>
    ): Prisma__REPropertySubCategoryModelClient<REPropertySubCategoryModelGetPayload<T>>

    /**
     * Create many REPropertySubCategoryModels.
     *     @param {REPropertySubCategoryModelCreateManyArgs} args - Arguments to create many REPropertySubCategoryModels.
     *     @example
     *     // Create many REPropertySubCategoryModels
     *     const rEPropertySubCategoryModel = await prisma.rEPropertySubCategoryModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends REPropertySubCategoryModelCreateManyArgs>(
      args?: SelectSubset<T, REPropertySubCategoryModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a REPropertySubCategoryModel.
     * @param {REPropertySubCategoryModelDeleteArgs} args - Arguments to delete one REPropertySubCategoryModel.
     * @example
     * // Delete one REPropertySubCategoryModel
     * const REPropertySubCategoryModel = await prisma.rEPropertySubCategoryModel.delete({
     *   where: {
     *     // ... filter to delete one REPropertySubCategoryModel
     *   }
     * })
     * 
    **/
    delete<T extends REPropertySubCategoryModelDeleteArgs>(
      args: SelectSubset<T, REPropertySubCategoryModelDeleteArgs>
    ): Prisma__REPropertySubCategoryModelClient<REPropertySubCategoryModelGetPayload<T>>

    /**
     * Update one REPropertySubCategoryModel.
     * @param {REPropertySubCategoryModelUpdateArgs} args - Arguments to update one REPropertySubCategoryModel.
     * @example
     * // Update one REPropertySubCategoryModel
     * const rEPropertySubCategoryModel = await prisma.rEPropertySubCategoryModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends REPropertySubCategoryModelUpdateArgs>(
      args: SelectSubset<T, REPropertySubCategoryModelUpdateArgs>
    ): Prisma__REPropertySubCategoryModelClient<REPropertySubCategoryModelGetPayload<T>>

    /**
     * Delete zero or more REPropertySubCategoryModels.
     * @param {REPropertySubCategoryModelDeleteManyArgs} args - Arguments to filter REPropertySubCategoryModels to delete.
     * @example
     * // Delete a few REPropertySubCategoryModels
     * const { count } = await prisma.rEPropertySubCategoryModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends REPropertySubCategoryModelDeleteManyArgs>(
      args?: SelectSubset<T, REPropertySubCategoryModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more REPropertySubCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySubCategoryModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many REPropertySubCategoryModels
     * const rEPropertySubCategoryModel = await prisma.rEPropertySubCategoryModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends REPropertySubCategoryModelUpdateManyArgs>(
      args: SelectSubset<T, REPropertySubCategoryModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one REPropertySubCategoryModel.
     * @param {REPropertySubCategoryModelUpsertArgs} args - Arguments to update or create a REPropertySubCategoryModel.
     * @example
     * // Update or create a REPropertySubCategoryModel
     * const rEPropertySubCategoryModel = await prisma.rEPropertySubCategoryModel.upsert({
     *   create: {
     *     // ... data to create a REPropertySubCategoryModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the REPropertySubCategoryModel we want to update
     *   }
     * })
    **/
    upsert<T extends REPropertySubCategoryModelUpsertArgs>(
      args: SelectSubset<T, REPropertySubCategoryModelUpsertArgs>
    ): Prisma__REPropertySubCategoryModelClient<REPropertySubCategoryModelGetPayload<T>>

    /**
     * Count the number of REPropertySubCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySubCategoryModelCountArgs} args - Arguments to filter REPropertySubCategoryModels to count.
     * @example
     * // Count the number of REPropertySubCategoryModels
     * const count = await prisma.rEPropertySubCategoryModel.count({
     *   where: {
     *     // ... the filter for the REPropertySubCategoryModels we want to count
     *   }
     * })
    **/
    count<T extends REPropertySubCategoryModelCountArgs>(
      args?: Subset<T, REPropertySubCategoryModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], REPropertySubCategoryModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a REPropertySubCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySubCategoryModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends REPropertySubCategoryModelAggregateArgs>(args: Subset<T, REPropertySubCategoryModelAggregateArgs>): Prisma.PrismaPromise<GetREPropertySubCategoryModelAggregateType<T>>

    /**
     * Group by REPropertySubCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySubCategoryModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends REPropertySubCategoryModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: REPropertySubCategoryModelGroupByArgs['orderBy'] }
        : { orderBy?: REPropertySubCategoryModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, REPropertySubCategoryModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetREPropertySubCategoryModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for REPropertySubCategoryModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__REPropertySubCategoryModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    middle_category<T extends REPropertyMiddleCategoryModelArgs= {}>(args?: Subset<T, REPropertyMiddleCategoryModelArgs>): Prisma__REPropertyMiddleCategoryModelClient<REPropertyMiddleCategoryModelGetPayload<T> | Null>;

    property_categories<T extends REPropertySubCategoryModel$property_categoriesArgs= {}>(args?: Subset<T, REPropertySubCategoryModel$property_categoriesArgs>): Prisma.PrismaPromise<Array<REPropertyCategoryModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * REPropertySubCategoryModel base type for findUnique actions
   */
  export type REPropertySubCategoryModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the REPropertySubCategoryModel
     */
    select?: REPropertySubCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySubCategoryModelInclude | null
    /**
     * Filter, which REPropertySubCategoryModel to fetch.
     */
    where: REPropertySubCategoryModelWhereUniqueInput
  }

  /**
   * REPropertySubCategoryModel findUnique
   */
  export interface REPropertySubCategoryModelFindUniqueArgs extends REPropertySubCategoryModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * REPropertySubCategoryModel findUniqueOrThrow
   */
  export type REPropertySubCategoryModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the REPropertySubCategoryModel
     */
    select?: REPropertySubCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySubCategoryModelInclude | null
    /**
     * Filter, which REPropertySubCategoryModel to fetch.
     */
    where: REPropertySubCategoryModelWhereUniqueInput
  }


  /**
   * REPropertySubCategoryModel base type for findFirst actions
   */
  export type REPropertySubCategoryModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the REPropertySubCategoryModel
     */
    select?: REPropertySubCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySubCategoryModelInclude | null
    /**
     * Filter, which REPropertySubCategoryModel to fetch.
     */
    where?: REPropertySubCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertySubCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertySubCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REPropertySubCategoryModels.
     */
    cursor?: REPropertySubCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertySubCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertySubCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REPropertySubCategoryModels.
     */
    distinct?: Enumerable<REPropertySubCategoryModelScalarFieldEnum>
  }

  /**
   * REPropertySubCategoryModel findFirst
   */
  export interface REPropertySubCategoryModelFindFirstArgs extends REPropertySubCategoryModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * REPropertySubCategoryModel findFirstOrThrow
   */
  export type REPropertySubCategoryModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the REPropertySubCategoryModel
     */
    select?: REPropertySubCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySubCategoryModelInclude | null
    /**
     * Filter, which REPropertySubCategoryModel to fetch.
     */
    where?: REPropertySubCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertySubCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertySubCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REPropertySubCategoryModels.
     */
    cursor?: REPropertySubCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertySubCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertySubCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REPropertySubCategoryModels.
     */
    distinct?: Enumerable<REPropertySubCategoryModelScalarFieldEnum>
  }


  /**
   * REPropertySubCategoryModel findMany
   */
  export type REPropertySubCategoryModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the REPropertySubCategoryModel
     */
    select?: REPropertySubCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySubCategoryModelInclude | null
    /**
     * Filter, which REPropertySubCategoryModels to fetch.
     */
    where?: REPropertySubCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertySubCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertySubCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing REPropertySubCategoryModels.
     */
    cursor?: REPropertySubCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertySubCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertySubCategoryModels.
     */
    skip?: number
    distinct?: Enumerable<REPropertySubCategoryModelScalarFieldEnum>
  }


  /**
   * REPropertySubCategoryModel create
   */
  export type REPropertySubCategoryModelCreateArgs = {
    /**
     * Select specific fields to fetch from the REPropertySubCategoryModel
     */
    select?: REPropertySubCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySubCategoryModelInclude | null
    /**
     * The data needed to create a REPropertySubCategoryModel.
     */
    data: XOR<REPropertySubCategoryModelCreateInput, REPropertySubCategoryModelUncheckedCreateInput>
  }


  /**
   * REPropertySubCategoryModel createMany
   */
  export type REPropertySubCategoryModelCreateManyArgs = {
    /**
     * The data used to create many REPropertySubCategoryModels.
     */
    data: Enumerable<REPropertySubCategoryModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * REPropertySubCategoryModel update
   */
  export type REPropertySubCategoryModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the REPropertySubCategoryModel
     */
    select?: REPropertySubCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySubCategoryModelInclude | null
    /**
     * The data needed to update a REPropertySubCategoryModel.
     */
    data: XOR<REPropertySubCategoryModelUpdateInput, REPropertySubCategoryModelUncheckedUpdateInput>
    /**
     * Choose, which REPropertySubCategoryModel to update.
     */
    where: REPropertySubCategoryModelWhereUniqueInput
  }


  /**
   * REPropertySubCategoryModel updateMany
   */
  export type REPropertySubCategoryModelUpdateManyArgs = {
    /**
     * The data used to update REPropertySubCategoryModels.
     */
    data: XOR<REPropertySubCategoryModelUpdateManyMutationInput, REPropertySubCategoryModelUncheckedUpdateManyInput>
    /**
     * Filter which REPropertySubCategoryModels to update
     */
    where?: REPropertySubCategoryModelWhereInput
  }


  /**
   * REPropertySubCategoryModel upsert
   */
  export type REPropertySubCategoryModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the REPropertySubCategoryModel
     */
    select?: REPropertySubCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySubCategoryModelInclude | null
    /**
     * The filter to search for the REPropertySubCategoryModel to update in case it exists.
     */
    where: REPropertySubCategoryModelWhereUniqueInput
    /**
     * In case the REPropertySubCategoryModel found by the `where` argument doesn't exist, create a new REPropertySubCategoryModel with this data.
     */
    create: XOR<REPropertySubCategoryModelCreateInput, REPropertySubCategoryModelUncheckedCreateInput>
    /**
     * In case the REPropertySubCategoryModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<REPropertySubCategoryModelUpdateInput, REPropertySubCategoryModelUncheckedUpdateInput>
  }


  /**
   * REPropertySubCategoryModel delete
   */
  export type REPropertySubCategoryModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the REPropertySubCategoryModel
     */
    select?: REPropertySubCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySubCategoryModelInclude | null
    /**
     * Filter which REPropertySubCategoryModel to delete.
     */
    where: REPropertySubCategoryModelWhereUniqueInput
  }


  /**
   * REPropertySubCategoryModel deleteMany
   */
  export type REPropertySubCategoryModelDeleteManyArgs = {
    /**
     * Filter which REPropertySubCategoryModels to delete
     */
    where?: REPropertySubCategoryModelWhereInput
  }


  /**
   * REPropertySubCategoryModel.property_categories
   */
  export type REPropertySubCategoryModel$property_categoriesArgs = {
    /**
     * Select specific fields to fetch from the REPropertyCategoryModel
     */
    select?: REPropertyCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyCategoryModelInclude | null
    where?: REPropertyCategoryModelWhereInput
    orderBy?: Enumerable<REPropertyCategoryModelOrderByWithRelationInput>
    cursor?: REPropertyCategoryModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<REPropertyCategoryModelScalarFieldEnum>
  }


  /**
   * REPropertySubCategoryModel without action
   */
  export type REPropertySubCategoryModelArgs = {
    /**
     * Select specific fields to fetch from the REPropertySubCategoryModel
     */
    select?: REPropertySubCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySubCategoryModelInclude | null
  }



  /**
   * Model REPropertyMiddleCategoryModel
   */


  export type AggregateREPropertyMiddleCategoryModel = {
    _count: REPropertyMiddleCategoryModelCountAggregateOutputType | null
    _min: REPropertyMiddleCategoryModelMinAggregateOutputType | null
    _max: REPropertyMiddleCategoryModelMaxAggregateOutputType | null
  }

  export type REPropertyMiddleCategoryModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    super_category_id: string | null
  }

  export type REPropertyMiddleCategoryModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    super_category_id: string | null
  }

  export type REPropertyMiddleCategoryModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    name: number
    super_category_id: number
    _all: number
  }


  export type REPropertyMiddleCategoryModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    super_category_id?: true
  }

  export type REPropertyMiddleCategoryModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    super_category_id?: true
  }

  export type REPropertyMiddleCategoryModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    super_category_id?: true
    _all?: true
  }

  export type REPropertyMiddleCategoryModelAggregateArgs = {
    /**
     * Filter which REPropertyMiddleCategoryModel to aggregate.
     */
    where?: REPropertyMiddleCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertyMiddleCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertyMiddleCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: REPropertyMiddleCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertyMiddleCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertyMiddleCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned REPropertyMiddleCategoryModels
    **/
    _count?: true | REPropertyMiddleCategoryModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: REPropertyMiddleCategoryModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: REPropertyMiddleCategoryModelMaxAggregateInputType
  }

  export type GetREPropertyMiddleCategoryModelAggregateType<T extends REPropertyMiddleCategoryModelAggregateArgs> = {
        [P in keyof T & keyof AggregateREPropertyMiddleCategoryModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateREPropertyMiddleCategoryModel[P]>
      : GetScalarType<T[P], AggregateREPropertyMiddleCategoryModel[P]>
  }




  export type REPropertyMiddleCategoryModelGroupByArgs = {
    where?: REPropertyMiddleCategoryModelWhereInput
    orderBy?: Enumerable<REPropertyMiddleCategoryModelOrderByWithAggregationInput>
    by: REPropertyMiddleCategoryModelScalarFieldEnum[]
    having?: REPropertyMiddleCategoryModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: REPropertyMiddleCategoryModelCountAggregateInputType | true
    _min?: REPropertyMiddleCategoryModelMinAggregateInputType
    _max?: REPropertyMiddleCategoryModelMaxAggregateInputType
  }


  export type REPropertyMiddleCategoryModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    name: string
    super_category_id: string
    _count: REPropertyMiddleCategoryModelCountAggregateOutputType | null
    _min: REPropertyMiddleCategoryModelMinAggregateOutputType | null
    _max: REPropertyMiddleCategoryModelMaxAggregateOutputType | null
  }

  type GetREPropertyMiddleCategoryModelGroupByPayload<T extends REPropertyMiddleCategoryModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<REPropertyMiddleCategoryModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof REPropertyMiddleCategoryModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], REPropertyMiddleCategoryModelGroupByOutputType[P]>
            : GetScalarType<T[P], REPropertyMiddleCategoryModelGroupByOutputType[P]>
        }
      >
    >


  export type REPropertyMiddleCategoryModelSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    name?: boolean
    super_category_id?: boolean
    super_category?: boolean | REPropertySuperCategoryModelArgs
    sub_categories?: boolean | REPropertyMiddleCategoryModel$sub_categoriesArgs
    _count?: boolean | REPropertyMiddleCategoryModelCountOutputTypeArgs
  }


  export type REPropertyMiddleCategoryModelInclude = {
    super_category?: boolean | REPropertySuperCategoryModelArgs
    sub_categories?: boolean | REPropertyMiddleCategoryModel$sub_categoriesArgs
    _count?: boolean | REPropertyMiddleCategoryModelCountOutputTypeArgs
  }

  export type REPropertyMiddleCategoryModelGetPayload<S extends boolean | null | undefined | REPropertyMiddleCategoryModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? REPropertyMiddleCategoryModel :
    S extends undefined ? never :
    S extends { include: any } & (REPropertyMiddleCategoryModelArgs | REPropertyMiddleCategoryModelFindManyArgs)
    ? REPropertyMiddleCategoryModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'super_category' ? REPropertySuperCategoryModelGetPayload<S['include'][P]> :
        P extends 'sub_categories' ? Array < REPropertySubCategoryModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? REPropertyMiddleCategoryModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (REPropertyMiddleCategoryModelArgs | REPropertyMiddleCategoryModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'super_category' ? REPropertySuperCategoryModelGetPayload<S['select'][P]> :
        P extends 'sub_categories' ? Array < REPropertySubCategoryModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? REPropertyMiddleCategoryModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof REPropertyMiddleCategoryModel ? REPropertyMiddleCategoryModel[P] : never
  } 
      : REPropertyMiddleCategoryModel


  type REPropertyMiddleCategoryModelCountArgs = 
    Omit<REPropertyMiddleCategoryModelFindManyArgs, 'select' | 'include'> & {
      select?: REPropertyMiddleCategoryModelCountAggregateInputType | true
    }

  export interface REPropertyMiddleCategoryModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one REPropertyMiddleCategoryModel that matches the filter.
     * @param {REPropertyMiddleCategoryModelFindUniqueArgs} args - Arguments to find a REPropertyMiddleCategoryModel
     * @example
     * // Get one REPropertyMiddleCategoryModel
     * const rEPropertyMiddleCategoryModel = await prisma.rEPropertyMiddleCategoryModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends REPropertyMiddleCategoryModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, REPropertyMiddleCategoryModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'REPropertyMiddleCategoryModel'> extends True ? Prisma__REPropertyMiddleCategoryModelClient<REPropertyMiddleCategoryModelGetPayload<T>> : Prisma__REPropertyMiddleCategoryModelClient<REPropertyMiddleCategoryModelGetPayload<T> | null, null>

    /**
     * Find one REPropertyMiddleCategoryModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {REPropertyMiddleCategoryModelFindUniqueOrThrowArgs} args - Arguments to find a REPropertyMiddleCategoryModel
     * @example
     * // Get one REPropertyMiddleCategoryModel
     * const rEPropertyMiddleCategoryModel = await prisma.rEPropertyMiddleCategoryModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends REPropertyMiddleCategoryModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, REPropertyMiddleCategoryModelFindUniqueOrThrowArgs>
    ): Prisma__REPropertyMiddleCategoryModelClient<REPropertyMiddleCategoryModelGetPayload<T>>

    /**
     * Find the first REPropertyMiddleCategoryModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyMiddleCategoryModelFindFirstArgs} args - Arguments to find a REPropertyMiddleCategoryModel
     * @example
     * // Get one REPropertyMiddleCategoryModel
     * const rEPropertyMiddleCategoryModel = await prisma.rEPropertyMiddleCategoryModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends REPropertyMiddleCategoryModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, REPropertyMiddleCategoryModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'REPropertyMiddleCategoryModel'> extends True ? Prisma__REPropertyMiddleCategoryModelClient<REPropertyMiddleCategoryModelGetPayload<T>> : Prisma__REPropertyMiddleCategoryModelClient<REPropertyMiddleCategoryModelGetPayload<T> | null, null>

    /**
     * Find the first REPropertyMiddleCategoryModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyMiddleCategoryModelFindFirstOrThrowArgs} args - Arguments to find a REPropertyMiddleCategoryModel
     * @example
     * // Get one REPropertyMiddleCategoryModel
     * const rEPropertyMiddleCategoryModel = await prisma.rEPropertyMiddleCategoryModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends REPropertyMiddleCategoryModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, REPropertyMiddleCategoryModelFindFirstOrThrowArgs>
    ): Prisma__REPropertyMiddleCategoryModelClient<REPropertyMiddleCategoryModelGetPayload<T>>

    /**
     * Find zero or more REPropertyMiddleCategoryModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyMiddleCategoryModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all REPropertyMiddleCategoryModels
     * const rEPropertyMiddleCategoryModels = await prisma.rEPropertyMiddleCategoryModel.findMany()
     * 
     * // Get first 10 REPropertyMiddleCategoryModels
     * const rEPropertyMiddleCategoryModels = await prisma.rEPropertyMiddleCategoryModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rEPropertyMiddleCategoryModelWithIdOnly = await prisma.rEPropertyMiddleCategoryModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends REPropertyMiddleCategoryModelFindManyArgs>(
      args?: SelectSubset<T, REPropertyMiddleCategoryModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<REPropertyMiddleCategoryModelGetPayload<T>>>

    /**
     * Create a REPropertyMiddleCategoryModel.
     * @param {REPropertyMiddleCategoryModelCreateArgs} args - Arguments to create a REPropertyMiddleCategoryModel.
     * @example
     * // Create one REPropertyMiddleCategoryModel
     * const REPropertyMiddleCategoryModel = await prisma.rEPropertyMiddleCategoryModel.create({
     *   data: {
     *     // ... data to create a REPropertyMiddleCategoryModel
     *   }
     * })
     * 
    **/
    create<T extends REPropertyMiddleCategoryModelCreateArgs>(
      args: SelectSubset<T, REPropertyMiddleCategoryModelCreateArgs>
    ): Prisma__REPropertyMiddleCategoryModelClient<REPropertyMiddleCategoryModelGetPayload<T>>

    /**
     * Create many REPropertyMiddleCategoryModels.
     *     @param {REPropertyMiddleCategoryModelCreateManyArgs} args - Arguments to create many REPropertyMiddleCategoryModels.
     *     @example
     *     // Create many REPropertyMiddleCategoryModels
     *     const rEPropertyMiddleCategoryModel = await prisma.rEPropertyMiddleCategoryModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends REPropertyMiddleCategoryModelCreateManyArgs>(
      args?: SelectSubset<T, REPropertyMiddleCategoryModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a REPropertyMiddleCategoryModel.
     * @param {REPropertyMiddleCategoryModelDeleteArgs} args - Arguments to delete one REPropertyMiddleCategoryModel.
     * @example
     * // Delete one REPropertyMiddleCategoryModel
     * const REPropertyMiddleCategoryModel = await prisma.rEPropertyMiddleCategoryModel.delete({
     *   where: {
     *     // ... filter to delete one REPropertyMiddleCategoryModel
     *   }
     * })
     * 
    **/
    delete<T extends REPropertyMiddleCategoryModelDeleteArgs>(
      args: SelectSubset<T, REPropertyMiddleCategoryModelDeleteArgs>
    ): Prisma__REPropertyMiddleCategoryModelClient<REPropertyMiddleCategoryModelGetPayload<T>>

    /**
     * Update one REPropertyMiddleCategoryModel.
     * @param {REPropertyMiddleCategoryModelUpdateArgs} args - Arguments to update one REPropertyMiddleCategoryModel.
     * @example
     * // Update one REPropertyMiddleCategoryModel
     * const rEPropertyMiddleCategoryModel = await prisma.rEPropertyMiddleCategoryModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends REPropertyMiddleCategoryModelUpdateArgs>(
      args: SelectSubset<T, REPropertyMiddleCategoryModelUpdateArgs>
    ): Prisma__REPropertyMiddleCategoryModelClient<REPropertyMiddleCategoryModelGetPayload<T>>

    /**
     * Delete zero or more REPropertyMiddleCategoryModels.
     * @param {REPropertyMiddleCategoryModelDeleteManyArgs} args - Arguments to filter REPropertyMiddleCategoryModels to delete.
     * @example
     * // Delete a few REPropertyMiddleCategoryModels
     * const { count } = await prisma.rEPropertyMiddleCategoryModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends REPropertyMiddleCategoryModelDeleteManyArgs>(
      args?: SelectSubset<T, REPropertyMiddleCategoryModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more REPropertyMiddleCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyMiddleCategoryModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many REPropertyMiddleCategoryModels
     * const rEPropertyMiddleCategoryModel = await prisma.rEPropertyMiddleCategoryModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends REPropertyMiddleCategoryModelUpdateManyArgs>(
      args: SelectSubset<T, REPropertyMiddleCategoryModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one REPropertyMiddleCategoryModel.
     * @param {REPropertyMiddleCategoryModelUpsertArgs} args - Arguments to update or create a REPropertyMiddleCategoryModel.
     * @example
     * // Update or create a REPropertyMiddleCategoryModel
     * const rEPropertyMiddleCategoryModel = await prisma.rEPropertyMiddleCategoryModel.upsert({
     *   create: {
     *     // ... data to create a REPropertyMiddleCategoryModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the REPropertyMiddleCategoryModel we want to update
     *   }
     * })
    **/
    upsert<T extends REPropertyMiddleCategoryModelUpsertArgs>(
      args: SelectSubset<T, REPropertyMiddleCategoryModelUpsertArgs>
    ): Prisma__REPropertyMiddleCategoryModelClient<REPropertyMiddleCategoryModelGetPayload<T>>

    /**
     * Count the number of REPropertyMiddleCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyMiddleCategoryModelCountArgs} args - Arguments to filter REPropertyMiddleCategoryModels to count.
     * @example
     * // Count the number of REPropertyMiddleCategoryModels
     * const count = await prisma.rEPropertyMiddleCategoryModel.count({
     *   where: {
     *     // ... the filter for the REPropertyMiddleCategoryModels we want to count
     *   }
     * })
    **/
    count<T extends REPropertyMiddleCategoryModelCountArgs>(
      args?: Subset<T, REPropertyMiddleCategoryModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], REPropertyMiddleCategoryModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a REPropertyMiddleCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyMiddleCategoryModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends REPropertyMiddleCategoryModelAggregateArgs>(args: Subset<T, REPropertyMiddleCategoryModelAggregateArgs>): Prisma.PrismaPromise<GetREPropertyMiddleCategoryModelAggregateType<T>>

    /**
     * Group by REPropertyMiddleCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyMiddleCategoryModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends REPropertyMiddleCategoryModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: REPropertyMiddleCategoryModelGroupByArgs['orderBy'] }
        : { orderBy?: REPropertyMiddleCategoryModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, REPropertyMiddleCategoryModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetREPropertyMiddleCategoryModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for REPropertyMiddleCategoryModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__REPropertyMiddleCategoryModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    super_category<T extends REPropertySuperCategoryModelArgs= {}>(args?: Subset<T, REPropertySuperCategoryModelArgs>): Prisma__REPropertySuperCategoryModelClient<REPropertySuperCategoryModelGetPayload<T> | Null>;

    sub_categories<T extends REPropertyMiddleCategoryModel$sub_categoriesArgs= {}>(args?: Subset<T, REPropertyMiddleCategoryModel$sub_categoriesArgs>): Prisma.PrismaPromise<Array<REPropertySubCategoryModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * REPropertyMiddleCategoryModel base type for findUnique actions
   */
  export type REPropertyMiddleCategoryModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the REPropertyMiddleCategoryModel
     */
    select?: REPropertyMiddleCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyMiddleCategoryModelInclude | null
    /**
     * Filter, which REPropertyMiddleCategoryModel to fetch.
     */
    where: REPropertyMiddleCategoryModelWhereUniqueInput
  }

  /**
   * REPropertyMiddleCategoryModel findUnique
   */
  export interface REPropertyMiddleCategoryModelFindUniqueArgs extends REPropertyMiddleCategoryModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * REPropertyMiddleCategoryModel findUniqueOrThrow
   */
  export type REPropertyMiddleCategoryModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the REPropertyMiddleCategoryModel
     */
    select?: REPropertyMiddleCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyMiddleCategoryModelInclude | null
    /**
     * Filter, which REPropertyMiddleCategoryModel to fetch.
     */
    where: REPropertyMiddleCategoryModelWhereUniqueInput
  }


  /**
   * REPropertyMiddleCategoryModel base type for findFirst actions
   */
  export type REPropertyMiddleCategoryModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the REPropertyMiddleCategoryModel
     */
    select?: REPropertyMiddleCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyMiddleCategoryModelInclude | null
    /**
     * Filter, which REPropertyMiddleCategoryModel to fetch.
     */
    where?: REPropertyMiddleCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertyMiddleCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertyMiddleCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REPropertyMiddleCategoryModels.
     */
    cursor?: REPropertyMiddleCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertyMiddleCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertyMiddleCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REPropertyMiddleCategoryModels.
     */
    distinct?: Enumerable<REPropertyMiddleCategoryModelScalarFieldEnum>
  }

  /**
   * REPropertyMiddleCategoryModel findFirst
   */
  export interface REPropertyMiddleCategoryModelFindFirstArgs extends REPropertyMiddleCategoryModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * REPropertyMiddleCategoryModel findFirstOrThrow
   */
  export type REPropertyMiddleCategoryModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the REPropertyMiddleCategoryModel
     */
    select?: REPropertyMiddleCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyMiddleCategoryModelInclude | null
    /**
     * Filter, which REPropertyMiddleCategoryModel to fetch.
     */
    where?: REPropertyMiddleCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertyMiddleCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertyMiddleCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REPropertyMiddleCategoryModels.
     */
    cursor?: REPropertyMiddleCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertyMiddleCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertyMiddleCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REPropertyMiddleCategoryModels.
     */
    distinct?: Enumerable<REPropertyMiddleCategoryModelScalarFieldEnum>
  }


  /**
   * REPropertyMiddleCategoryModel findMany
   */
  export type REPropertyMiddleCategoryModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the REPropertyMiddleCategoryModel
     */
    select?: REPropertyMiddleCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyMiddleCategoryModelInclude | null
    /**
     * Filter, which REPropertyMiddleCategoryModels to fetch.
     */
    where?: REPropertyMiddleCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertyMiddleCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertyMiddleCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing REPropertyMiddleCategoryModels.
     */
    cursor?: REPropertyMiddleCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertyMiddleCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertyMiddleCategoryModels.
     */
    skip?: number
    distinct?: Enumerable<REPropertyMiddleCategoryModelScalarFieldEnum>
  }


  /**
   * REPropertyMiddleCategoryModel create
   */
  export type REPropertyMiddleCategoryModelCreateArgs = {
    /**
     * Select specific fields to fetch from the REPropertyMiddleCategoryModel
     */
    select?: REPropertyMiddleCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyMiddleCategoryModelInclude | null
    /**
     * The data needed to create a REPropertyMiddleCategoryModel.
     */
    data: XOR<REPropertyMiddleCategoryModelCreateInput, REPropertyMiddleCategoryModelUncheckedCreateInput>
  }


  /**
   * REPropertyMiddleCategoryModel createMany
   */
  export type REPropertyMiddleCategoryModelCreateManyArgs = {
    /**
     * The data used to create many REPropertyMiddleCategoryModels.
     */
    data: Enumerable<REPropertyMiddleCategoryModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * REPropertyMiddleCategoryModel update
   */
  export type REPropertyMiddleCategoryModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the REPropertyMiddleCategoryModel
     */
    select?: REPropertyMiddleCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyMiddleCategoryModelInclude | null
    /**
     * The data needed to update a REPropertyMiddleCategoryModel.
     */
    data: XOR<REPropertyMiddleCategoryModelUpdateInput, REPropertyMiddleCategoryModelUncheckedUpdateInput>
    /**
     * Choose, which REPropertyMiddleCategoryModel to update.
     */
    where: REPropertyMiddleCategoryModelWhereUniqueInput
  }


  /**
   * REPropertyMiddleCategoryModel updateMany
   */
  export type REPropertyMiddleCategoryModelUpdateManyArgs = {
    /**
     * The data used to update REPropertyMiddleCategoryModels.
     */
    data: XOR<REPropertyMiddleCategoryModelUpdateManyMutationInput, REPropertyMiddleCategoryModelUncheckedUpdateManyInput>
    /**
     * Filter which REPropertyMiddleCategoryModels to update
     */
    where?: REPropertyMiddleCategoryModelWhereInput
  }


  /**
   * REPropertyMiddleCategoryModel upsert
   */
  export type REPropertyMiddleCategoryModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the REPropertyMiddleCategoryModel
     */
    select?: REPropertyMiddleCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyMiddleCategoryModelInclude | null
    /**
     * The filter to search for the REPropertyMiddleCategoryModel to update in case it exists.
     */
    where: REPropertyMiddleCategoryModelWhereUniqueInput
    /**
     * In case the REPropertyMiddleCategoryModel found by the `where` argument doesn't exist, create a new REPropertyMiddleCategoryModel with this data.
     */
    create: XOR<REPropertyMiddleCategoryModelCreateInput, REPropertyMiddleCategoryModelUncheckedCreateInput>
    /**
     * In case the REPropertyMiddleCategoryModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<REPropertyMiddleCategoryModelUpdateInput, REPropertyMiddleCategoryModelUncheckedUpdateInput>
  }


  /**
   * REPropertyMiddleCategoryModel delete
   */
  export type REPropertyMiddleCategoryModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the REPropertyMiddleCategoryModel
     */
    select?: REPropertyMiddleCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyMiddleCategoryModelInclude | null
    /**
     * Filter which REPropertyMiddleCategoryModel to delete.
     */
    where: REPropertyMiddleCategoryModelWhereUniqueInput
  }


  /**
   * REPropertyMiddleCategoryModel deleteMany
   */
  export type REPropertyMiddleCategoryModelDeleteManyArgs = {
    /**
     * Filter which REPropertyMiddleCategoryModels to delete
     */
    where?: REPropertyMiddleCategoryModelWhereInput
  }


  /**
   * REPropertyMiddleCategoryModel.sub_categories
   */
  export type REPropertyMiddleCategoryModel$sub_categoriesArgs = {
    /**
     * Select specific fields to fetch from the REPropertySubCategoryModel
     */
    select?: REPropertySubCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySubCategoryModelInclude | null
    where?: REPropertySubCategoryModelWhereInput
    orderBy?: Enumerable<REPropertySubCategoryModelOrderByWithRelationInput>
    cursor?: REPropertySubCategoryModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<REPropertySubCategoryModelScalarFieldEnum>
  }


  /**
   * REPropertyMiddleCategoryModel without action
   */
  export type REPropertyMiddleCategoryModelArgs = {
    /**
     * Select specific fields to fetch from the REPropertyMiddleCategoryModel
     */
    select?: REPropertyMiddleCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyMiddleCategoryModelInclude | null
  }



  /**
   * Model REPropertySuperCategoryModel
   */


  export type AggregateREPropertySuperCategoryModel = {
    _count: REPropertySuperCategoryModelCountAggregateOutputType | null
    _min: REPropertySuperCategoryModelMinAggregateOutputType | null
    _max: REPropertySuperCategoryModelMaxAggregateOutputType | null
  }

  export type REPropertySuperCategoryModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
  }

  export type REPropertySuperCategoryModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
  }

  export type REPropertySuperCategoryModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    name: number
    _all: number
  }


  export type REPropertySuperCategoryModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
  }

  export type REPropertySuperCategoryModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
  }

  export type REPropertySuperCategoryModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    _all?: true
  }

  export type REPropertySuperCategoryModelAggregateArgs = {
    /**
     * Filter which REPropertySuperCategoryModel to aggregate.
     */
    where?: REPropertySuperCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertySuperCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertySuperCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: REPropertySuperCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertySuperCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertySuperCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned REPropertySuperCategoryModels
    **/
    _count?: true | REPropertySuperCategoryModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: REPropertySuperCategoryModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: REPropertySuperCategoryModelMaxAggregateInputType
  }

  export type GetREPropertySuperCategoryModelAggregateType<T extends REPropertySuperCategoryModelAggregateArgs> = {
        [P in keyof T & keyof AggregateREPropertySuperCategoryModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateREPropertySuperCategoryModel[P]>
      : GetScalarType<T[P], AggregateREPropertySuperCategoryModel[P]>
  }




  export type REPropertySuperCategoryModelGroupByArgs = {
    where?: REPropertySuperCategoryModelWhereInput
    orderBy?: Enumerable<REPropertySuperCategoryModelOrderByWithAggregationInput>
    by: REPropertySuperCategoryModelScalarFieldEnum[]
    having?: REPropertySuperCategoryModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: REPropertySuperCategoryModelCountAggregateInputType | true
    _min?: REPropertySuperCategoryModelMinAggregateInputType
    _max?: REPropertySuperCategoryModelMaxAggregateInputType
  }


  export type REPropertySuperCategoryModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    name: string
    _count: REPropertySuperCategoryModelCountAggregateOutputType | null
    _min: REPropertySuperCategoryModelMinAggregateOutputType | null
    _max: REPropertySuperCategoryModelMaxAggregateOutputType | null
  }

  type GetREPropertySuperCategoryModelGroupByPayload<T extends REPropertySuperCategoryModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<REPropertySuperCategoryModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof REPropertySuperCategoryModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], REPropertySuperCategoryModelGroupByOutputType[P]>
            : GetScalarType<T[P], REPropertySuperCategoryModelGroupByOutputType[P]>
        }
      >
    >


  export type REPropertySuperCategoryModelSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    name?: boolean
    middle_categories?: boolean | REPropertySuperCategoryModel$middle_categoriesArgs
    _count?: boolean | REPropertySuperCategoryModelCountOutputTypeArgs
  }


  export type REPropertySuperCategoryModelInclude = {
    middle_categories?: boolean | REPropertySuperCategoryModel$middle_categoriesArgs
    _count?: boolean | REPropertySuperCategoryModelCountOutputTypeArgs
  }

  export type REPropertySuperCategoryModelGetPayload<S extends boolean | null | undefined | REPropertySuperCategoryModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? REPropertySuperCategoryModel :
    S extends undefined ? never :
    S extends { include: any } & (REPropertySuperCategoryModelArgs | REPropertySuperCategoryModelFindManyArgs)
    ? REPropertySuperCategoryModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'middle_categories' ? Array < REPropertyMiddleCategoryModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? REPropertySuperCategoryModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (REPropertySuperCategoryModelArgs | REPropertySuperCategoryModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'middle_categories' ? Array < REPropertyMiddleCategoryModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? REPropertySuperCategoryModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof REPropertySuperCategoryModel ? REPropertySuperCategoryModel[P] : never
  } 
      : REPropertySuperCategoryModel


  type REPropertySuperCategoryModelCountArgs = 
    Omit<REPropertySuperCategoryModelFindManyArgs, 'select' | 'include'> & {
      select?: REPropertySuperCategoryModelCountAggregateInputType | true
    }

  export interface REPropertySuperCategoryModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one REPropertySuperCategoryModel that matches the filter.
     * @param {REPropertySuperCategoryModelFindUniqueArgs} args - Arguments to find a REPropertySuperCategoryModel
     * @example
     * // Get one REPropertySuperCategoryModel
     * const rEPropertySuperCategoryModel = await prisma.rEPropertySuperCategoryModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends REPropertySuperCategoryModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, REPropertySuperCategoryModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'REPropertySuperCategoryModel'> extends True ? Prisma__REPropertySuperCategoryModelClient<REPropertySuperCategoryModelGetPayload<T>> : Prisma__REPropertySuperCategoryModelClient<REPropertySuperCategoryModelGetPayload<T> | null, null>

    /**
     * Find one REPropertySuperCategoryModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {REPropertySuperCategoryModelFindUniqueOrThrowArgs} args - Arguments to find a REPropertySuperCategoryModel
     * @example
     * // Get one REPropertySuperCategoryModel
     * const rEPropertySuperCategoryModel = await prisma.rEPropertySuperCategoryModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends REPropertySuperCategoryModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, REPropertySuperCategoryModelFindUniqueOrThrowArgs>
    ): Prisma__REPropertySuperCategoryModelClient<REPropertySuperCategoryModelGetPayload<T>>

    /**
     * Find the first REPropertySuperCategoryModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySuperCategoryModelFindFirstArgs} args - Arguments to find a REPropertySuperCategoryModel
     * @example
     * // Get one REPropertySuperCategoryModel
     * const rEPropertySuperCategoryModel = await prisma.rEPropertySuperCategoryModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends REPropertySuperCategoryModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, REPropertySuperCategoryModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'REPropertySuperCategoryModel'> extends True ? Prisma__REPropertySuperCategoryModelClient<REPropertySuperCategoryModelGetPayload<T>> : Prisma__REPropertySuperCategoryModelClient<REPropertySuperCategoryModelGetPayload<T> | null, null>

    /**
     * Find the first REPropertySuperCategoryModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySuperCategoryModelFindFirstOrThrowArgs} args - Arguments to find a REPropertySuperCategoryModel
     * @example
     * // Get one REPropertySuperCategoryModel
     * const rEPropertySuperCategoryModel = await prisma.rEPropertySuperCategoryModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends REPropertySuperCategoryModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, REPropertySuperCategoryModelFindFirstOrThrowArgs>
    ): Prisma__REPropertySuperCategoryModelClient<REPropertySuperCategoryModelGetPayload<T>>

    /**
     * Find zero or more REPropertySuperCategoryModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySuperCategoryModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all REPropertySuperCategoryModels
     * const rEPropertySuperCategoryModels = await prisma.rEPropertySuperCategoryModel.findMany()
     * 
     * // Get first 10 REPropertySuperCategoryModels
     * const rEPropertySuperCategoryModels = await prisma.rEPropertySuperCategoryModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rEPropertySuperCategoryModelWithIdOnly = await prisma.rEPropertySuperCategoryModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends REPropertySuperCategoryModelFindManyArgs>(
      args?: SelectSubset<T, REPropertySuperCategoryModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<REPropertySuperCategoryModelGetPayload<T>>>

    /**
     * Create a REPropertySuperCategoryModel.
     * @param {REPropertySuperCategoryModelCreateArgs} args - Arguments to create a REPropertySuperCategoryModel.
     * @example
     * // Create one REPropertySuperCategoryModel
     * const REPropertySuperCategoryModel = await prisma.rEPropertySuperCategoryModel.create({
     *   data: {
     *     // ... data to create a REPropertySuperCategoryModel
     *   }
     * })
     * 
    **/
    create<T extends REPropertySuperCategoryModelCreateArgs>(
      args: SelectSubset<T, REPropertySuperCategoryModelCreateArgs>
    ): Prisma__REPropertySuperCategoryModelClient<REPropertySuperCategoryModelGetPayload<T>>

    /**
     * Create many REPropertySuperCategoryModels.
     *     @param {REPropertySuperCategoryModelCreateManyArgs} args - Arguments to create many REPropertySuperCategoryModels.
     *     @example
     *     // Create many REPropertySuperCategoryModels
     *     const rEPropertySuperCategoryModel = await prisma.rEPropertySuperCategoryModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends REPropertySuperCategoryModelCreateManyArgs>(
      args?: SelectSubset<T, REPropertySuperCategoryModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a REPropertySuperCategoryModel.
     * @param {REPropertySuperCategoryModelDeleteArgs} args - Arguments to delete one REPropertySuperCategoryModel.
     * @example
     * // Delete one REPropertySuperCategoryModel
     * const REPropertySuperCategoryModel = await prisma.rEPropertySuperCategoryModel.delete({
     *   where: {
     *     // ... filter to delete one REPropertySuperCategoryModel
     *   }
     * })
     * 
    **/
    delete<T extends REPropertySuperCategoryModelDeleteArgs>(
      args: SelectSubset<T, REPropertySuperCategoryModelDeleteArgs>
    ): Prisma__REPropertySuperCategoryModelClient<REPropertySuperCategoryModelGetPayload<T>>

    /**
     * Update one REPropertySuperCategoryModel.
     * @param {REPropertySuperCategoryModelUpdateArgs} args - Arguments to update one REPropertySuperCategoryModel.
     * @example
     * // Update one REPropertySuperCategoryModel
     * const rEPropertySuperCategoryModel = await prisma.rEPropertySuperCategoryModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends REPropertySuperCategoryModelUpdateArgs>(
      args: SelectSubset<T, REPropertySuperCategoryModelUpdateArgs>
    ): Prisma__REPropertySuperCategoryModelClient<REPropertySuperCategoryModelGetPayload<T>>

    /**
     * Delete zero or more REPropertySuperCategoryModels.
     * @param {REPropertySuperCategoryModelDeleteManyArgs} args - Arguments to filter REPropertySuperCategoryModels to delete.
     * @example
     * // Delete a few REPropertySuperCategoryModels
     * const { count } = await prisma.rEPropertySuperCategoryModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends REPropertySuperCategoryModelDeleteManyArgs>(
      args?: SelectSubset<T, REPropertySuperCategoryModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more REPropertySuperCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySuperCategoryModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many REPropertySuperCategoryModels
     * const rEPropertySuperCategoryModel = await prisma.rEPropertySuperCategoryModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends REPropertySuperCategoryModelUpdateManyArgs>(
      args: SelectSubset<T, REPropertySuperCategoryModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one REPropertySuperCategoryModel.
     * @param {REPropertySuperCategoryModelUpsertArgs} args - Arguments to update or create a REPropertySuperCategoryModel.
     * @example
     * // Update or create a REPropertySuperCategoryModel
     * const rEPropertySuperCategoryModel = await prisma.rEPropertySuperCategoryModel.upsert({
     *   create: {
     *     // ... data to create a REPropertySuperCategoryModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the REPropertySuperCategoryModel we want to update
     *   }
     * })
    **/
    upsert<T extends REPropertySuperCategoryModelUpsertArgs>(
      args: SelectSubset<T, REPropertySuperCategoryModelUpsertArgs>
    ): Prisma__REPropertySuperCategoryModelClient<REPropertySuperCategoryModelGetPayload<T>>

    /**
     * Count the number of REPropertySuperCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySuperCategoryModelCountArgs} args - Arguments to filter REPropertySuperCategoryModels to count.
     * @example
     * // Count the number of REPropertySuperCategoryModels
     * const count = await prisma.rEPropertySuperCategoryModel.count({
     *   where: {
     *     // ... the filter for the REPropertySuperCategoryModels we want to count
     *   }
     * })
    **/
    count<T extends REPropertySuperCategoryModelCountArgs>(
      args?: Subset<T, REPropertySuperCategoryModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], REPropertySuperCategoryModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a REPropertySuperCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySuperCategoryModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends REPropertySuperCategoryModelAggregateArgs>(args: Subset<T, REPropertySuperCategoryModelAggregateArgs>): Prisma.PrismaPromise<GetREPropertySuperCategoryModelAggregateType<T>>

    /**
     * Group by REPropertySuperCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySuperCategoryModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends REPropertySuperCategoryModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: REPropertySuperCategoryModelGroupByArgs['orderBy'] }
        : { orderBy?: REPropertySuperCategoryModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, REPropertySuperCategoryModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetREPropertySuperCategoryModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for REPropertySuperCategoryModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__REPropertySuperCategoryModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    middle_categories<T extends REPropertySuperCategoryModel$middle_categoriesArgs= {}>(args?: Subset<T, REPropertySuperCategoryModel$middle_categoriesArgs>): Prisma.PrismaPromise<Array<REPropertyMiddleCategoryModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * REPropertySuperCategoryModel base type for findUnique actions
   */
  export type REPropertySuperCategoryModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the REPropertySuperCategoryModel
     */
    select?: REPropertySuperCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySuperCategoryModelInclude | null
    /**
     * Filter, which REPropertySuperCategoryModel to fetch.
     */
    where: REPropertySuperCategoryModelWhereUniqueInput
  }

  /**
   * REPropertySuperCategoryModel findUnique
   */
  export interface REPropertySuperCategoryModelFindUniqueArgs extends REPropertySuperCategoryModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * REPropertySuperCategoryModel findUniqueOrThrow
   */
  export type REPropertySuperCategoryModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the REPropertySuperCategoryModel
     */
    select?: REPropertySuperCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySuperCategoryModelInclude | null
    /**
     * Filter, which REPropertySuperCategoryModel to fetch.
     */
    where: REPropertySuperCategoryModelWhereUniqueInput
  }


  /**
   * REPropertySuperCategoryModel base type for findFirst actions
   */
  export type REPropertySuperCategoryModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the REPropertySuperCategoryModel
     */
    select?: REPropertySuperCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySuperCategoryModelInclude | null
    /**
     * Filter, which REPropertySuperCategoryModel to fetch.
     */
    where?: REPropertySuperCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertySuperCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertySuperCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REPropertySuperCategoryModels.
     */
    cursor?: REPropertySuperCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertySuperCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertySuperCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REPropertySuperCategoryModels.
     */
    distinct?: Enumerable<REPropertySuperCategoryModelScalarFieldEnum>
  }

  /**
   * REPropertySuperCategoryModel findFirst
   */
  export interface REPropertySuperCategoryModelFindFirstArgs extends REPropertySuperCategoryModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * REPropertySuperCategoryModel findFirstOrThrow
   */
  export type REPropertySuperCategoryModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the REPropertySuperCategoryModel
     */
    select?: REPropertySuperCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySuperCategoryModelInclude | null
    /**
     * Filter, which REPropertySuperCategoryModel to fetch.
     */
    where?: REPropertySuperCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertySuperCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertySuperCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REPropertySuperCategoryModels.
     */
    cursor?: REPropertySuperCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertySuperCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertySuperCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REPropertySuperCategoryModels.
     */
    distinct?: Enumerable<REPropertySuperCategoryModelScalarFieldEnum>
  }


  /**
   * REPropertySuperCategoryModel findMany
   */
  export type REPropertySuperCategoryModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the REPropertySuperCategoryModel
     */
    select?: REPropertySuperCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySuperCategoryModelInclude | null
    /**
     * Filter, which REPropertySuperCategoryModels to fetch.
     */
    where?: REPropertySuperCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertySuperCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertySuperCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing REPropertySuperCategoryModels.
     */
    cursor?: REPropertySuperCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertySuperCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertySuperCategoryModels.
     */
    skip?: number
    distinct?: Enumerable<REPropertySuperCategoryModelScalarFieldEnum>
  }


  /**
   * REPropertySuperCategoryModel create
   */
  export type REPropertySuperCategoryModelCreateArgs = {
    /**
     * Select specific fields to fetch from the REPropertySuperCategoryModel
     */
    select?: REPropertySuperCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySuperCategoryModelInclude | null
    /**
     * The data needed to create a REPropertySuperCategoryModel.
     */
    data: XOR<REPropertySuperCategoryModelCreateInput, REPropertySuperCategoryModelUncheckedCreateInput>
  }


  /**
   * REPropertySuperCategoryModel createMany
   */
  export type REPropertySuperCategoryModelCreateManyArgs = {
    /**
     * The data used to create many REPropertySuperCategoryModels.
     */
    data: Enumerable<REPropertySuperCategoryModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * REPropertySuperCategoryModel update
   */
  export type REPropertySuperCategoryModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the REPropertySuperCategoryModel
     */
    select?: REPropertySuperCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySuperCategoryModelInclude | null
    /**
     * The data needed to update a REPropertySuperCategoryModel.
     */
    data: XOR<REPropertySuperCategoryModelUpdateInput, REPropertySuperCategoryModelUncheckedUpdateInput>
    /**
     * Choose, which REPropertySuperCategoryModel to update.
     */
    where: REPropertySuperCategoryModelWhereUniqueInput
  }


  /**
   * REPropertySuperCategoryModel updateMany
   */
  export type REPropertySuperCategoryModelUpdateManyArgs = {
    /**
     * The data used to update REPropertySuperCategoryModels.
     */
    data: XOR<REPropertySuperCategoryModelUpdateManyMutationInput, REPropertySuperCategoryModelUncheckedUpdateManyInput>
    /**
     * Filter which REPropertySuperCategoryModels to update
     */
    where?: REPropertySuperCategoryModelWhereInput
  }


  /**
   * REPropertySuperCategoryModel upsert
   */
  export type REPropertySuperCategoryModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the REPropertySuperCategoryModel
     */
    select?: REPropertySuperCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySuperCategoryModelInclude | null
    /**
     * The filter to search for the REPropertySuperCategoryModel to update in case it exists.
     */
    where: REPropertySuperCategoryModelWhereUniqueInput
    /**
     * In case the REPropertySuperCategoryModel found by the `where` argument doesn't exist, create a new REPropertySuperCategoryModel with this data.
     */
    create: XOR<REPropertySuperCategoryModelCreateInput, REPropertySuperCategoryModelUncheckedCreateInput>
    /**
     * In case the REPropertySuperCategoryModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<REPropertySuperCategoryModelUpdateInput, REPropertySuperCategoryModelUncheckedUpdateInput>
  }


  /**
   * REPropertySuperCategoryModel delete
   */
  export type REPropertySuperCategoryModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the REPropertySuperCategoryModel
     */
    select?: REPropertySuperCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySuperCategoryModelInclude | null
    /**
     * Filter which REPropertySuperCategoryModel to delete.
     */
    where: REPropertySuperCategoryModelWhereUniqueInput
  }


  /**
   * REPropertySuperCategoryModel deleteMany
   */
  export type REPropertySuperCategoryModelDeleteManyArgs = {
    /**
     * Filter which REPropertySuperCategoryModels to delete
     */
    where?: REPropertySuperCategoryModelWhereInput
  }


  /**
   * REPropertySuperCategoryModel.middle_categories
   */
  export type REPropertySuperCategoryModel$middle_categoriesArgs = {
    /**
     * Select specific fields to fetch from the REPropertyMiddleCategoryModel
     */
    select?: REPropertyMiddleCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyMiddleCategoryModelInclude | null
    where?: REPropertyMiddleCategoryModelWhereInput
    orderBy?: Enumerable<REPropertyMiddleCategoryModelOrderByWithRelationInput>
    cursor?: REPropertyMiddleCategoryModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<REPropertyMiddleCategoryModelScalarFieldEnum>
  }


  /**
   * REPropertySuperCategoryModel without action
   */
  export type REPropertySuperCategoryModelArgs = {
    /**
     * Select specific fields to fetch from the REPropertySuperCategoryModel
     */
    select?: REPropertySuperCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySuperCategoryModelInclude | null
  }



  /**
   * Model ReviewModel
   */


  export type AggregateReviewModel = {
    _count: ReviewModelCountAggregateOutputType | null
    _min: ReviewModelMinAggregateOutputType | null
    _max: ReviewModelMaxAggregateOutputType | null
  }

  export type ReviewModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    reviewer_id: string | null
    reviewee_id: string | null
    content: string | null
  }

  export type ReviewModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    reviewer_id: string | null
    reviewee_id: string | null
    content: string | null
  }

  export type ReviewModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    reviewer_id: number
    reviewee_id: number
    content: number
    _all: number
  }


  export type ReviewModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    reviewer_id?: true
    reviewee_id?: true
    content?: true
  }

  export type ReviewModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    reviewer_id?: true
    reviewee_id?: true
    content?: true
  }

  export type ReviewModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    reviewer_id?: true
    reviewee_id?: true
    content?: true
    _all?: true
  }

  export type ReviewModelAggregateArgs = {
    /**
     * Filter which ReviewModel to aggregate.
     */
    where?: ReviewModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewModels to fetch.
     */
    orderBy?: Enumerable<ReviewModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewModels
    **/
    _count?: true | ReviewModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewModelMaxAggregateInputType
  }

  export type GetReviewModelAggregateType<T extends ReviewModelAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewModel[P]>
      : GetScalarType<T[P], AggregateReviewModel[P]>
  }




  export type ReviewModelGroupByArgs = {
    where?: ReviewModelWhereInput
    orderBy?: Enumerable<ReviewModelOrderByWithAggregationInput>
    by: ReviewModelScalarFieldEnum[]
    having?: ReviewModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewModelCountAggregateInputType | true
    _min?: ReviewModelMinAggregateInputType
    _max?: ReviewModelMaxAggregateInputType
  }


  export type ReviewModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    reviewer_id: string
    reviewee_id: string
    content: string
    _count: ReviewModelCountAggregateOutputType | null
    _min: ReviewModelMinAggregateOutputType | null
    _max: ReviewModelMaxAggregateOutputType | null
  }

  type GetReviewModelGroupByPayload<T extends ReviewModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ReviewModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewModelGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewModelGroupByOutputType[P]>
        }
      >
    >


  export type ReviewModelSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    reviewer_id?: boolean
    reviewee_id?: boolean
    content?: boolean
    reviewer?: boolean | CustomerModelArgs
    reviewee?: boolean | BusinessUserModelArgs
    rates?: boolean | ReviewModel$ratesArgs
    _count?: boolean | ReviewModelCountOutputTypeArgs
  }


  export type ReviewModelInclude = {
    reviewer?: boolean | CustomerModelArgs
    reviewee?: boolean | BusinessUserModelArgs
    rates?: boolean | ReviewModel$ratesArgs
    _count?: boolean | ReviewModelCountOutputTypeArgs
  }

  export type ReviewModelGetPayload<S extends boolean | null | undefined | ReviewModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ReviewModel :
    S extends undefined ? never :
    S extends { include: any } & (ReviewModelArgs | ReviewModelFindManyArgs)
    ? ReviewModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'reviewer' ? CustomerModelGetPayload<S['include'][P]> :
        P extends 'reviewee' ? BusinessUserModelGetPayload<S['include'][P]> :
        P extends 'rates' ? Array < RateModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? ReviewModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ReviewModelArgs | ReviewModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'reviewer' ? CustomerModelGetPayload<S['select'][P]> :
        P extends 'reviewee' ? BusinessUserModelGetPayload<S['select'][P]> :
        P extends 'rates' ? Array < RateModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? ReviewModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ReviewModel ? ReviewModel[P] : never
  } 
      : ReviewModel


  type ReviewModelCountArgs = 
    Omit<ReviewModelFindManyArgs, 'select' | 'include'> & {
      select?: ReviewModelCountAggregateInputType | true
    }

  export interface ReviewModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ReviewModel that matches the filter.
     * @param {ReviewModelFindUniqueArgs} args - Arguments to find a ReviewModel
     * @example
     * // Get one ReviewModel
     * const reviewModel = await prisma.reviewModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReviewModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReviewModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ReviewModel'> extends True ? Prisma__ReviewModelClient<ReviewModelGetPayload<T>> : Prisma__ReviewModelClient<ReviewModelGetPayload<T> | null, null>

    /**
     * Find one ReviewModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReviewModelFindUniqueOrThrowArgs} args - Arguments to find a ReviewModel
     * @example
     * // Get one ReviewModel
     * const reviewModel = await prisma.reviewModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReviewModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ReviewModelFindUniqueOrThrowArgs>
    ): Prisma__ReviewModelClient<ReviewModelGetPayload<T>>

    /**
     * Find the first ReviewModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewModelFindFirstArgs} args - Arguments to find a ReviewModel
     * @example
     * // Get one ReviewModel
     * const reviewModel = await prisma.reviewModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReviewModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReviewModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ReviewModel'> extends True ? Prisma__ReviewModelClient<ReviewModelGetPayload<T>> : Prisma__ReviewModelClient<ReviewModelGetPayload<T> | null, null>

    /**
     * Find the first ReviewModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewModelFindFirstOrThrowArgs} args - Arguments to find a ReviewModel
     * @example
     * // Get one ReviewModel
     * const reviewModel = await prisma.reviewModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReviewModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReviewModelFindFirstOrThrowArgs>
    ): Prisma__ReviewModelClient<ReviewModelGetPayload<T>>

    /**
     * Find zero or more ReviewModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewModels
     * const reviewModels = await prisma.reviewModel.findMany()
     * 
     * // Get first 10 ReviewModels
     * const reviewModels = await prisma.reviewModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewModelWithIdOnly = await prisma.reviewModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReviewModelFindManyArgs>(
      args?: SelectSubset<T, ReviewModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<ReviewModelGetPayload<T>>>

    /**
     * Create a ReviewModel.
     * @param {ReviewModelCreateArgs} args - Arguments to create a ReviewModel.
     * @example
     * // Create one ReviewModel
     * const ReviewModel = await prisma.reviewModel.create({
     *   data: {
     *     // ... data to create a ReviewModel
     *   }
     * })
     * 
    **/
    create<T extends ReviewModelCreateArgs>(
      args: SelectSubset<T, ReviewModelCreateArgs>
    ): Prisma__ReviewModelClient<ReviewModelGetPayload<T>>

    /**
     * Create many ReviewModels.
     *     @param {ReviewModelCreateManyArgs} args - Arguments to create many ReviewModels.
     *     @example
     *     // Create many ReviewModels
     *     const reviewModel = await prisma.reviewModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReviewModelCreateManyArgs>(
      args?: SelectSubset<T, ReviewModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReviewModel.
     * @param {ReviewModelDeleteArgs} args - Arguments to delete one ReviewModel.
     * @example
     * // Delete one ReviewModel
     * const ReviewModel = await prisma.reviewModel.delete({
     *   where: {
     *     // ... filter to delete one ReviewModel
     *   }
     * })
     * 
    **/
    delete<T extends ReviewModelDeleteArgs>(
      args: SelectSubset<T, ReviewModelDeleteArgs>
    ): Prisma__ReviewModelClient<ReviewModelGetPayload<T>>

    /**
     * Update one ReviewModel.
     * @param {ReviewModelUpdateArgs} args - Arguments to update one ReviewModel.
     * @example
     * // Update one ReviewModel
     * const reviewModel = await prisma.reviewModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReviewModelUpdateArgs>(
      args: SelectSubset<T, ReviewModelUpdateArgs>
    ): Prisma__ReviewModelClient<ReviewModelGetPayload<T>>

    /**
     * Delete zero or more ReviewModels.
     * @param {ReviewModelDeleteManyArgs} args - Arguments to filter ReviewModels to delete.
     * @example
     * // Delete a few ReviewModels
     * const { count } = await prisma.reviewModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReviewModelDeleteManyArgs>(
      args?: SelectSubset<T, ReviewModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewModels
     * const reviewModel = await prisma.reviewModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReviewModelUpdateManyArgs>(
      args: SelectSubset<T, ReviewModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReviewModel.
     * @param {ReviewModelUpsertArgs} args - Arguments to update or create a ReviewModel.
     * @example
     * // Update or create a ReviewModel
     * const reviewModel = await prisma.reviewModel.upsert({
     *   create: {
     *     // ... data to create a ReviewModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewModel we want to update
     *   }
     * })
    **/
    upsert<T extends ReviewModelUpsertArgs>(
      args: SelectSubset<T, ReviewModelUpsertArgs>
    ): Prisma__ReviewModelClient<ReviewModelGetPayload<T>>

    /**
     * Count the number of ReviewModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewModelCountArgs} args - Arguments to filter ReviewModels to count.
     * @example
     * // Count the number of ReviewModels
     * const count = await prisma.reviewModel.count({
     *   where: {
     *     // ... the filter for the ReviewModels we want to count
     *   }
     * })
    **/
    count<T extends ReviewModelCountArgs>(
      args?: Subset<T, ReviewModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewModelAggregateArgs>(args: Subset<T, ReviewModelAggregateArgs>): Prisma.PrismaPromise<GetReviewModelAggregateType<T>>

    /**
     * Group by ReviewModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewModelGroupByArgs['orderBy'] }
        : { orderBy?: ReviewModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReviewModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    reviewer<T extends CustomerModelArgs= {}>(args?: Subset<T, CustomerModelArgs>): Prisma__CustomerModelClient<CustomerModelGetPayload<T> | Null>;

    reviewee<T extends BusinessUserModelArgs= {}>(args?: Subset<T, BusinessUserModelArgs>): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T> | Null>;

    rates<T extends ReviewModel$ratesArgs= {}>(args?: Subset<T, ReviewModel$ratesArgs>): Prisma.PrismaPromise<Array<RateModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ReviewModel base type for findUnique actions
   */
  export type ReviewModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ReviewModel
     */
    select?: ReviewModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewModelInclude | null
    /**
     * Filter, which ReviewModel to fetch.
     */
    where: ReviewModelWhereUniqueInput
  }

  /**
   * ReviewModel findUnique
   */
  export interface ReviewModelFindUniqueArgs extends ReviewModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ReviewModel findUniqueOrThrow
   */
  export type ReviewModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ReviewModel
     */
    select?: ReviewModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewModelInclude | null
    /**
     * Filter, which ReviewModel to fetch.
     */
    where: ReviewModelWhereUniqueInput
  }


  /**
   * ReviewModel base type for findFirst actions
   */
  export type ReviewModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ReviewModel
     */
    select?: ReviewModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewModelInclude | null
    /**
     * Filter, which ReviewModel to fetch.
     */
    where?: ReviewModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewModels to fetch.
     */
    orderBy?: Enumerable<ReviewModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewModels.
     */
    cursor?: ReviewModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewModels.
     */
    distinct?: Enumerable<ReviewModelScalarFieldEnum>
  }

  /**
   * ReviewModel findFirst
   */
  export interface ReviewModelFindFirstArgs extends ReviewModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ReviewModel findFirstOrThrow
   */
  export type ReviewModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ReviewModel
     */
    select?: ReviewModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewModelInclude | null
    /**
     * Filter, which ReviewModel to fetch.
     */
    where?: ReviewModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewModels to fetch.
     */
    orderBy?: Enumerable<ReviewModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewModels.
     */
    cursor?: ReviewModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewModels.
     */
    distinct?: Enumerable<ReviewModelScalarFieldEnum>
  }


  /**
   * ReviewModel findMany
   */
  export type ReviewModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the ReviewModel
     */
    select?: ReviewModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewModelInclude | null
    /**
     * Filter, which ReviewModels to fetch.
     */
    where?: ReviewModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewModels to fetch.
     */
    orderBy?: Enumerable<ReviewModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewModels.
     */
    cursor?: ReviewModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewModels.
     */
    skip?: number
    distinct?: Enumerable<ReviewModelScalarFieldEnum>
  }


  /**
   * ReviewModel create
   */
  export type ReviewModelCreateArgs = {
    /**
     * Select specific fields to fetch from the ReviewModel
     */
    select?: ReviewModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewModelInclude | null
    /**
     * The data needed to create a ReviewModel.
     */
    data: XOR<ReviewModelCreateInput, ReviewModelUncheckedCreateInput>
  }


  /**
   * ReviewModel createMany
   */
  export type ReviewModelCreateManyArgs = {
    /**
     * The data used to create many ReviewModels.
     */
    data: Enumerable<ReviewModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ReviewModel update
   */
  export type ReviewModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the ReviewModel
     */
    select?: ReviewModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewModelInclude | null
    /**
     * The data needed to update a ReviewModel.
     */
    data: XOR<ReviewModelUpdateInput, ReviewModelUncheckedUpdateInput>
    /**
     * Choose, which ReviewModel to update.
     */
    where: ReviewModelWhereUniqueInput
  }


  /**
   * ReviewModel updateMany
   */
  export type ReviewModelUpdateManyArgs = {
    /**
     * The data used to update ReviewModels.
     */
    data: XOR<ReviewModelUpdateManyMutationInput, ReviewModelUncheckedUpdateManyInput>
    /**
     * Filter which ReviewModels to update
     */
    where?: ReviewModelWhereInput
  }


  /**
   * ReviewModel upsert
   */
  export type ReviewModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the ReviewModel
     */
    select?: ReviewModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewModelInclude | null
    /**
     * The filter to search for the ReviewModel to update in case it exists.
     */
    where: ReviewModelWhereUniqueInput
    /**
     * In case the ReviewModel found by the `where` argument doesn't exist, create a new ReviewModel with this data.
     */
    create: XOR<ReviewModelCreateInput, ReviewModelUncheckedCreateInput>
    /**
     * In case the ReviewModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewModelUpdateInput, ReviewModelUncheckedUpdateInput>
  }


  /**
   * ReviewModel delete
   */
  export type ReviewModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the ReviewModel
     */
    select?: ReviewModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewModelInclude | null
    /**
     * Filter which ReviewModel to delete.
     */
    where: ReviewModelWhereUniqueInput
  }


  /**
   * ReviewModel deleteMany
   */
  export type ReviewModelDeleteManyArgs = {
    /**
     * Filter which ReviewModels to delete
     */
    where?: ReviewModelWhereInput
  }


  /**
   * ReviewModel.rates
   */
  export type ReviewModel$ratesArgs = {
    /**
     * Select specific fields to fetch from the RateModel
     */
    select?: RateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateModelInclude | null
    where?: RateModelWhereInput
    orderBy?: Enumerable<RateModelOrderByWithRelationInput>
    cursor?: RateModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RateModelScalarFieldEnum>
  }


  /**
   * ReviewModel without action
   */
  export type ReviewModelArgs = {
    /**
     * Select specific fields to fetch from the ReviewModel
     */
    select?: ReviewModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewModelInclude | null
  }



  /**
   * Model RateModel
   */


  export type AggregateRateModel = {
    _count: RateModelCountAggregateOutputType | null
    _avg: RateModelAvgAggregateOutputType | null
    _sum: RateModelSumAggregateOutputType | null
    _min: RateModelMinAggregateOutputType | null
    _max: RateModelMaxAggregateOutputType | null
  }

  export type RateModelAvgAggregateOutputType = {
    score: number | null
  }

  export type RateModelSumAggregateOutputType = {
    score: number | null
  }

  export type RateModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    score: number | null
    category_id: string | null
    review_id: string | null
  }

  export type RateModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    score: number | null
    category_id: string | null
    review_id: string | null
  }

  export type RateModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    score: number
    category_id: number
    review_id: number
    _all: number
  }


  export type RateModelAvgAggregateInputType = {
    score?: true
  }

  export type RateModelSumAggregateInputType = {
    score?: true
  }

  export type RateModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    score?: true
    category_id?: true
    review_id?: true
  }

  export type RateModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    score?: true
    category_id?: true
    review_id?: true
  }

  export type RateModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    score?: true
    category_id?: true
    review_id?: true
    _all?: true
  }

  export type RateModelAggregateArgs = {
    /**
     * Filter which RateModel to aggregate.
     */
    where?: RateModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateModels to fetch.
     */
    orderBy?: Enumerable<RateModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RateModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RateModels
    **/
    _count?: true | RateModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RateModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RateModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RateModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RateModelMaxAggregateInputType
  }

  export type GetRateModelAggregateType<T extends RateModelAggregateArgs> = {
        [P in keyof T & keyof AggregateRateModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRateModel[P]>
      : GetScalarType<T[P], AggregateRateModel[P]>
  }




  export type RateModelGroupByArgs = {
    where?: RateModelWhereInput
    orderBy?: Enumerable<RateModelOrderByWithAggregationInput>
    by: RateModelScalarFieldEnum[]
    having?: RateModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RateModelCountAggregateInputType | true
    _avg?: RateModelAvgAggregateInputType
    _sum?: RateModelSumAggregateInputType
    _min?: RateModelMinAggregateInputType
    _max?: RateModelMaxAggregateInputType
  }


  export type RateModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    score: number
    category_id: string
    review_id: string
    _count: RateModelCountAggregateOutputType | null
    _avg: RateModelAvgAggregateOutputType | null
    _sum: RateModelSumAggregateOutputType | null
    _min: RateModelMinAggregateOutputType | null
    _max: RateModelMaxAggregateOutputType | null
  }

  type GetRateModelGroupByPayload<T extends RateModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RateModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RateModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RateModelGroupByOutputType[P]>
            : GetScalarType<T[P], RateModelGroupByOutputType[P]>
        }
      >
    >


  export type RateModelSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    score?: boolean
    category_id?: boolean
    review_id?: boolean
    category?: boolean | RateCategoryModelArgs
    review?: boolean | ReviewModelArgs
  }


  export type RateModelInclude = {
    category?: boolean | RateCategoryModelArgs
    review?: boolean | ReviewModelArgs
  }

  export type RateModelGetPayload<S extends boolean | null | undefined | RateModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RateModel :
    S extends undefined ? never :
    S extends { include: any } & (RateModelArgs | RateModelFindManyArgs)
    ? RateModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'category' ? RateCategoryModelGetPayload<S['include'][P]> :
        P extends 'review' ? ReviewModelGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RateModelArgs | RateModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'category' ? RateCategoryModelGetPayload<S['select'][P]> :
        P extends 'review' ? ReviewModelGetPayload<S['select'][P]> :  P extends keyof RateModel ? RateModel[P] : never
  } 
      : RateModel


  type RateModelCountArgs = 
    Omit<RateModelFindManyArgs, 'select' | 'include'> & {
      select?: RateModelCountAggregateInputType | true
    }

  export interface RateModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one RateModel that matches the filter.
     * @param {RateModelFindUniqueArgs} args - Arguments to find a RateModel
     * @example
     * // Get one RateModel
     * const rateModel = await prisma.rateModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RateModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RateModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RateModel'> extends True ? Prisma__RateModelClient<RateModelGetPayload<T>> : Prisma__RateModelClient<RateModelGetPayload<T> | null, null>

    /**
     * Find one RateModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RateModelFindUniqueOrThrowArgs} args - Arguments to find a RateModel
     * @example
     * // Get one RateModel
     * const rateModel = await prisma.rateModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RateModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RateModelFindUniqueOrThrowArgs>
    ): Prisma__RateModelClient<RateModelGetPayload<T>>

    /**
     * Find the first RateModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateModelFindFirstArgs} args - Arguments to find a RateModel
     * @example
     * // Get one RateModel
     * const rateModel = await prisma.rateModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RateModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RateModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RateModel'> extends True ? Prisma__RateModelClient<RateModelGetPayload<T>> : Prisma__RateModelClient<RateModelGetPayload<T> | null, null>

    /**
     * Find the first RateModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateModelFindFirstOrThrowArgs} args - Arguments to find a RateModel
     * @example
     * // Get one RateModel
     * const rateModel = await prisma.rateModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RateModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RateModelFindFirstOrThrowArgs>
    ): Prisma__RateModelClient<RateModelGetPayload<T>>

    /**
     * Find zero or more RateModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RateModels
     * const rateModels = await prisma.rateModel.findMany()
     * 
     * // Get first 10 RateModels
     * const rateModels = await prisma.rateModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rateModelWithIdOnly = await prisma.rateModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RateModelFindManyArgs>(
      args?: SelectSubset<T, RateModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<RateModelGetPayload<T>>>

    /**
     * Create a RateModel.
     * @param {RateModelCreateArgs} args - Arguments to create a RateModel.
     * @example
     * // Create one RateModel
     * const RateModel = await prisma.rateModel.create({
     *   data: {
     *     // ... data to create a RateModel
     *   }
     * })
     * 
    **/
    create<T extends RateModelCreateArgs>(
      args: SelectSubset<T, RateModelCreateArgs>
    ): Prisma__RateModelClient<RateModelGetPayload<T>>

    /**
     * Create many RateModels.
     *     @param {RateModelCreateManyArgs} args - Arguments to create many RateModels.
     *     @example
     *     // Create many RateModels
     *     const rateModel = await prisma.rateModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RateModelCreateManyArgs>(
      args?: SelectSubset<T, RateModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RateModel.
     * @param {RateModelDeleteArgs} args - Arguments to delete one RateModel.
     * @example
     * // Delete one RateModel
     * const RateModel = await prisma.rateModel.delete({
     *   where: {
     *     // ... filter to delete one RateModel
     *   }
     * })
     * 
    **/
    delete<T extends RateModelDeleteArgs>(
      args: SelectSubset<T, RateModelDeleteArgs>
    ): Prisma__RateModelClient<RateModelGetPayload<T>>

    /**
     * Update one RateModel.
     * @param {RateModelUpdateArgs} args - Arguments to update one RateModel.
     * @example
     * // Update one RateModel
     * const rateModel = await prisma.rateModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RateModelUpdateArgs>(
      args: SelectSubset<T, RateModelUpdateArgs>
    ): Prisma__RateModelClient<RateModelGetPayload<T>>

    /**
     * Delete zero or more RateModels.
     * @param {RateModelDeleteManyArgs} args - Arguments to filter RateModels to delete.
     * @example
     * // Delete a few RateModels
     * const { count } = await prisma.rateModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RateModelDeleteManyArgs>(
      args?: SelectSubset<T, RateModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RateModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RateModels
     * const rateModel = await prisma.rateModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RateModelUpdateManyArgs>(
      args: SelectSubset<T, RateModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RateModel.
     * @param {RateModelUpsertArgs} args - Arguments to update or create a RateModel.
     * @example
     * // Update or create a RateModel
     * const rateModel = await prisma.rateModel.upsert({
     *   create: {
     *     // ... data to create a RateModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RateModel we want to update
     *   }
     * })
    **/
    upsert<T extends RateModelUpsertArgs>(
      args: SelectSubset<T, RateModelUpsertArgs>
    ): Prisma__RateModelClient<RateModelGetPayload<T>>

    /**
     * Count the number of RateModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateModelCountArgs} args - Arguments to filter RateModels to count.
     * @example
     * // Count the number of RateModels
     * const count = await prisma.rateModel.count({
     *   where: {
     *     // ... the filter for the RateModels we want to count
     *   }
     * })
    **/
    count<T extends RateModelCountArgs>(
      args?: Subset<T, RateModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RateModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RateModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RateModelAggregateArgs>(args: Subset<T, RateModelAggregateArgs>): Prisma.PrismaPromise<GetRateModelAggregateType<T>>

    /**
     * Group by RateModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RateModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RateModelGroupByArgs['orderBy'] }
        : { orderBy?: RateModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RateModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRateModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RateModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RateModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    category<T extends RateCategoryModelArgs= {}>(args?: Subset<T, RateCategoryModelArgs>): Prisma__RateCategoryModelClient<RateCategoryModelGetPayload<T> | Null>;

    review<T extends ReviewModelArgs= {}>(args?: Subset<T, ReviewModelArgs>): Prisma__ReviewModelClient<ReviewModelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RateModel base type for findUnique actions
   */
  export type RateModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RateModel
     */
    select?: RateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateModelInclude | null
    /**
     * Filter, which RateModel to fetch.
     */
    where: RateModelWhereUniqueInput
  }

  /**
   * RateModel findUnique
   */
  export interface RateModelFindUniqueArgs extends RateModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RateModel findUniqueOrThrow
   */
  export type RateModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RateModel
     */
    select?: RateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateModelInclude | null
    /**
     * Filter, which RateModel to fetch.
     */
    where: RateModelWhereUniqueInput
  }


  /**
   * RateModel base type for findFirst actions
   */
  export type RateModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RateModel
     */
    select?: RateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateModelInclude | null
    /**
     * Filter, which RateModel to fetch.
     */
    where?: RateModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateModels to fetch.
     */
    orderBy?: Enumerable<RateModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RateModels.
     */
    cursor?: RateModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RateModels.
     */
    distinct?: Enumerable<RateModelScalarFieldEnum>
  }

  /**
   * RateModel findFirst
   */
  export interface RateModelFindFirstArgs extends RateModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RateModel findFirstOrThrow
   */
  export type RateModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RateModel
     */
    select?: RateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateModelInclude | null
    /**
     * Filter, which RateModel to fetch.
     */
    where?: RateModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateModels to fetch.
     */
    orderBy?: Enumerable<RateModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RateModels.
     */
    cursor?: RateModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RateModels.
     */
    distinct?: Enumerable<RateModelScalarFieldEnum>
  }


  /**
   * RateModel findMany
   */
  export type RateModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the RateModel
     */
    select?: RateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateModelInclude | null
    /**
     * Filter, which RateModels to fetch.
     */
    where?: RateModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateModels to fetch.
     */
    orderBy?: Enumerable<RateModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RateModels.
     */
    cursor?: RateModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateModels.
     */
    skip?: number
    distinct?: Enumerable<RateModelScalarFieldEnum>
  }


  /**
   * RateModel create
   */
  export type RateModelCreateArgs = {
    /**
     * Select specific fields to fetch from the RateModel
     */
    select?: RateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateModelInclude | null
    /**
     * The data needed to create a RateModel.
     */
    data: XOR<RateModelCreateInput, RateModelUncheckedCreateInput>
  }


  /**
   * RateModel createMany
   */
  export type RateModelCreateManyArgs = {
    /**
     * The data used to create many RateModels.
     */
    data: Enumerable<RateModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RateModel update
   */
  export type RateModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the RateModel
     */
    select?: RateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateModelInclude | null
    /**
     * The data needed to update a RateModel.
     */
    data: XOR<RateModelUpdateInput, RateModelUncheckedUpdateInput>
    /**
     * Choose, which RateModel to update.
     */
    where: RateModelWhereUniqueInput
  }


  /**
   * RateModel updateMany
   */
  export type RateModelUpdateManyArgs = {
    /**
     * The data used to update RateModels.
     */
    data: XOR<RateModelUpdateManyMutationInput, RateModelUncheckedUpdateManyInput>
    /**
     * Filter which RateModels to update
     */
    where?: RateModelWhereInput
  }


  /**
   * RateModel upsert
   */
  export type RateModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the RateModel
     */
    select?: RateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateModelInclude | null
    /**
     * The filter to search for the RateModel to update in case it exists.
     */
    where: RateModelWhereUniqueInput
    /**
     * In case the RateModel found by the `where` argument doesn't exist, create a new RateModel with this data.
     */
    create: XOR<RateModelCreateInput, RateModelUncheckedCreateInput>
    /**
     * In case the RateModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RateModelUpdateInput, RateModelUncheckedUpdateInput>
  }


  /**
   * RateModel delete
   */
  export type RateModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the RateModel
     */
    select?: RateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateModelInclude | null
    /**
     * Filter which RateModel to delete.
     */
    where: RateModelWhereUniqueInput
  }


  /**
   * RateModel deleteMany
   */
  export type RateModelDeleteManyArgs = {
    /**
     * Filter which RateModels to delete
     */
    where?: RateModelWhereInput
  }


  /**
   * RateModel without action
   */
  export type RateModelArgs = {
    /**
     * Select specific fields to fetch from the RateModel
     */
    select?: RateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateModelInclude | null
  }



  /**
   * Model RateCategoryModel
   */


  export type AggregateRateCategoryModel = {
    _count: RateCategoryModelCountAggregateOutputType | null
    _min: RateCategoryModelMinAggregateOutputType | null
    _max: RateCategoryModelMaxAggregateOutputType | null
  }

  export type RateCategoryModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    target_type: RateTargetType | null
  }

  export type RateCategoryModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    target_type: RateTargetType | null
  }

  export type RateCategoryModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    name: number
    target_type: number
    _all: number
  }


  export type RateCategoryModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    target_type?: true
  }

  export type RateCategoryModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    target_type?: true
  }

  export type RateCategoryModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    target_type?: true
    _all?: true
  }

  export type RateCategoryModelAggregateArgs = {
    /**
     * Filter which RateCategoryModel to aggregate.
     */
    where?: RateCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateCategoryModels to fetch.
     */
    orderBy?: Enumerable<RateCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RateCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RateCategoryModels
    **/
    _count?: true | RateCategoryModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RateCategoryModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RateCategoryModelMaxAggregateInputType
  }

  export type GetRateCategoryModelAggregateType<T extends RateCategoryModelAggregateArgs> = {
        [P in keyof T & keyof AggregateRateCategoryModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRateCategoryModel[P]>
      : GetScalarType<T[P], AggregateRateCategoryModel[P]>
  }




  export type RateCategoryModelGroupByArgs = {
    where?: RateCategoryModelWhereInput
    orderBy?: Enumerable<RateCategoryModelOrderByWithAggregationInput>
    by: RateCategoryModelScalarFieldEnum[]
    having?: RateCategoryModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RateCategoryModelCountAggregateInputType | true
    _min?: RateCategoryModelMinAggregateInputType
    _max?: RateCategoryModelMaxAggregateInputType
  }


  export type RateCategoryModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    name: string
    target_type: RateTargetType
    _count: RateCategoryModelCountAggregateOutputType | null
    _min: RateCategoryModelMinAggregateOutputType | null
    _max: RateCategoryModelMaxAggregateOutputType | null
  }

  type GetRateCategoryModelGroupByPayload<T extends RateCategoryModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RateCategoryModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RateCategoryModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RateCategoryModelGroupByOutputType[P]>
            : GetScalarType<T[P], RateCategoryModelGroupByOutputType[P]>
        }
      >
    >


  export type RateCategoryModelSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    name?: boolean
    target_type?: boolean
    rates?: boolean | RateCategoryModel$ratesArgs
    _count?: boolean | RateCategoryModelCountOutputTypeArgs
  }


  export type RateCategoryModelInclude = {
    rates?: boolean | RateCategoryModel$ratesArgs
    _count?: boolean | RateCategoryModelCountOutputTypeArgs
  }

  export type RateCategoryModelGetPayload<S extends boolean | null | undefined | RateCategoryModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RateCategoryModel :
    S extends undefined ? never :
    S extends { include: any } & (RateCategoryModelArgs | RateCategoryModelFindManyArgs)
    ? RateCategoryModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'rates' ? Array < RateModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? RateCategoryModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RateCategoryModelArgs | RateCategoryModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'rates' ? Array < RateModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? RateCategoryModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof RateCategoryModel ? RateCategoryModel[P] : never
  } 
      : RateCategoryModel


  type RateCategoryModelCountArgs = 
    Omit<RateCategoryModelFindManyArgs, 'select' | 'include'> & {
      select?: RateCategoryModelCountAggregateInputType | true
    }

  export interface RateCategoryModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one RateCategoryModel that matches the filter.
     * @param {RateCategoryModelFindUniqueArgs} args - Arguments to find a RateCategoryModel
     * @example
     * // Get one RateCategoryModel
     * const rateCategoryModel = await prisma.rateCategoryModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RateCategoryModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RateCategoryModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RateCategoryModel'> extends True ? Prisma__RateCategoryModelClient<RateCategoryModelGetPayload<T>> : Prisma__RateCategoryModelClient<RateCategoryModelGetPayload<T> | null, null>

    /**
     * Find one RateCategoryModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RateCategoryModelFindUniqueOrThrowArgs} args - Arguments to find a RateCategoryModel
     * @example
     * // Get one RateCategoryModel
     * const rateCategoryModel = await prisma.rateCategoryModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RateCategoryModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RateCategoryModelFindUniqueOrThrowArgs>
    ): Prisma__RateCategoryModelClient<RateCategoryModelGetPayload<T>>

    /**
     * Find the first RateCategoryModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateCategoryModelFindFirstArgs} args - Arguments to find a RateCategoryModel
     * @example
     * // Get one RateCategoryModel
     * const rateCategoryModel = await prisma.rateCategoryModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RateCategoryModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RateCategoryModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RateCategoryModel'> extends True ? Prisma__RateCategoryModelClient<RateCategoryModelGetPayload<T>> : Prisma__RateCategoryModelClient<RateCategoryModelGetPayload<T> | null, null>

    /**
     * Find the first RateCategoryModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateCategoryModelFindFirstOrThrowArgs} args - Arguments to find a RateCategoryModel
     * @example
     * // Get one RateCategoryModel
     * const rateCategoryModel = await prisma.rateCategoryModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RateCategoryModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RateCategoryModelFindFirstOrThrowArgs>
    ): Prisma__RateCategoryModelClient<RateCategoryModelGetPayload<T>>

    /**
     * Find zero or more RateCategoryModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateCategoryModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RateCategoryModels
     * const rateCategoryModels = await prisma.rateCategoryModel.findMany()
     * 
     * // Get first 10 RateCategoryModels
     * const rateCategoryModels = await prisma.rateCategoryModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rateCategoryModelWithIdOnly = await prisma.rateCategoryModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RateCategoryModelFindManyArgs>(
      args?: SelectSubset<T, RateCategoryModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<RateCategoryModelGetPayload<T>>>

    /**
     * Create a RateCategoryModel.
     * @param {RateCategoryModelCreateArgs} args - Arguments to create a RateCategoryModel.
     * @example
     * // Create one RateCategoryModel
     * const RateCategoryModel = await prisma.rateCategoryModel.create({
     *   data: {
     *     // ... data to create a RateCategoryModel
     *   }
     * })
     * 
    **/
    create<T extends RateCategoryModelCreateArgs>(
      args: SelectSubset<T, RateCategoryModelCreateArgs>
    ): Prisma__RateCategoryModelClient<RateCategoryModelGetPayload<T>>

    /**
     * Create many RateCategoryModels.
     *     @param {RateCategoryModelCreateManyArgs} args - Arguments to create many RateCategoryModels.
     *     @example
     *     // Create many RateCategoryModels
     *     const rateCategoryModel = await prisma.rateCategoryModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RateCategoryModelCreateManyArgs>(
      args?: SelectSubset<T, RateCategoryModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RateCategoryModel.
     * @param {RateCategoryModelDeleteArgs} args - Arguments to delete one RateCategoryModel.
     * @example
     * // Delete one RateCategoryModel
     * const RateCategoryModel = await prisma.rateCategoryModel.delete({
     *   where: {
     *     // ... filter to delete one RateCategoryModel
     *   }
     * })
     * 
    **/
    delete<T extends RateCategoryModelDeleteArgs>(
      args: SelectSubset<T, RateCategoryModelDeleteArgs>
    ): Prisma__RateCategoryModelClient<RateCategoryModelGetPayload<T>>

    /**
     * Update one RateCategoryModel.
     * @param {RateCategoryModelUpdateArgs} args - Arguments to update one RateCategoryModel.
     * @example
     * // Update one RateCategoryModel
     * const rateCategoryModel = await prisma.rateCategoryModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RateCategoryModelUpdateArgs>(
      args: SelectSubset<T, RateCategoryModelUpdateArgs>
    ): Prisma__RateCategoryModelClient<RateCategoryModelGetPayload<T>>

    /**
     * Delete zero or more RateCategoryModels.
     * @param {RateCategoryModelDeleteManyArgs} args - Arguments to filter RateCategoryModels to delete.
     * @example
     * // Delete a few RateCategoryModels
     * const { count } = await prisma.rateCategoryModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RateCategoryModelDeleteManyArgs>(
      args?: SelectSubset<T, RateCategoryModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RateCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateCategoryModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RateCategoryModels
     * const rateCategoryModel = await prisma.rateCategoryModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RateCategoryModelUpdateManyArgs>(
      args: SelectSubset<T, RateCategoryModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RateCategoryModel.
     * @param {RateCategoryModelUpsertArgs} args - Arguments to update or create a RateCategoryModel.
     * @example
     * // Update or create a RateCategoryModel
     * const rateCategoryModel = await prisma.rateCategoryModel.upsert({
     *   create: {
     *     // ... data to create a RateCategoryModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RateCategoryModel we want to update
     *   }
     * })
    **/
    upsert<T extends RateCategoryModelUpsertArgs>(
      args: SelectSubset<T, RateCategoryModelUpsertArgs>
    ): Prisma__RateCategoryModelClient<RateCategoryModelGetPayload<T>>

    /**
     * Count the number of RateCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateCategoryModelCountArgs} args - Arguments to filter RateCategoryModels to count.
     * @example
     * // Count the number of RateCategoryModels
     * const count = await prisma.rateCategoryModel.count({
     *   where: {
     *     // ... the filter for the RateCategoryModels we want to count
     *   }
     * })
    **/
    count<T extends RateCategoryModelCountArgs>(
      args?: Subset<T, RateCategoryModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RateCategoryModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RateCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateCategoryModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RateCategoryModelAggregateArgs>(args: Subset<T, RateCategoryModelAggregateArgs>): Prisma.PrismaPromise<GetRateCategoryModelAggregateType<T>>

    /**
     * Group by RateCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateCategoryModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RateCategoryModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RateCategoryModelGroupByArgs['orderBy'] }
        : { orderBy?: RateCategoryModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RateCategoryModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRateCategoryModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RateCategoryModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RateCategoryModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    rates<T extends RateCategoryModel$ratesArgs= {}>(args?: Subset<T, RateCategoryModel$ratesArgs>): Prisma.PrismaPromise<Array<RateModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RateCategoryModel base type for findUnique actions
   */
  export type RateCategoryModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RateCategoryModel
     */
    select?: RateCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateCategoryModelInclude | null
    /**
     * Filter, which RateCategoryModel to fetch.
     */
    where: RateCategoryModelWhereUniqueInput
  }

  /**
   * RateCategoryModel findUnique
   */
  export interface RateCategoryModelFindUniqueArgs extends RateCategoryModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RateCategoryModel findUniqueOrThrow
   */
  export type RateCategoryModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RateCategoryModel
     */
    select?: RateCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateCategoryModelInclude | null
    /**
     * Filter, which RateCategoryModel to fetch.
     */
    where: RateCategoryModelWhereUniqueInput
  }


  /**
   * RateCategoryModel base type for findFirst actions
   */
  export type RateCategoryModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RateCategoryModel
     */
    select?: RateCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateCategoryModelInclude | null
    /**
     * Filter, which RateCategoryModel to fetch.
     */
    where?: RateCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateCategoryModels to fetch.
     */
    orderBy?: Enumerable<RateCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RateCategoryModels.
     */
    cursor?: RateCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RateCategoryModels.
     */
    distinct?: Enumerable<RateCategoryModelScalarFieldEnum>
  }

  /**
   * RateCategoryModel findFirst
   */
  export interface RateCategoryModelFindFirstArgs extends RateCategoryModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RateCategoryModel findFirstOrThrow
   */
  export type RateCategoryModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RateCategoryModel
     */
    select?: RateCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateCategoryModelInclude | null
    /**
     * Filter, which RateCategoryModel to fetch.
     */
    where?: RateCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateCategoryModels to fetch.
     */
    orderBy?: Enumerable<RateCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RateCategoryModels.
     */
    cursor?: RateCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RateCategoryModels.
     */
    distinct?: Enumerable<RateCategoryModelScalarFieldEnum>
  }


  /**
   * RateCategoryModel findMany
   */
  export type RateCategoryModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the RateCategoryModel
     */
    select?: RateCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateCategoryModelInclude | null
    /**
     * Filter, which RateCategoryModels to fetch.
     */
    where?: RateCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateCategoryModels to fetch.
     */
    orderBy?: Enumerable<RateCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RateCategoryModels.
     */
    cursor?: RateCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateCategoryModels.
     */
    skip?: number
    distinct?: Enumerable<RateCategoryModelScalarFieldEnum>
  }


  /**
   * RateCategoryModel create
   */
  export type RateCategoryModelCreateArgs = {
    /**
     * Select specific fields to fetch from the RateCategoryModel
     */
    select?: RateCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateCategoryModelInclude | null
    /**
     * The data needed to create a RateCategoryModel.
     */
    data: XOR<RateCategoryModelCreateInput, RateCategoryModelUncheckedCreateInput>
  }


  /**
   * RateCategoryModel createMany
   */
  export type RateCategoryModelCreateManyArgs = {
    /**
     * The data used to create many RateCategoryModels.
     */
    data: Enumerable<RateCategoryModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RateCategoryModel update
   */
  export type RateCategoryModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the RateCategoryModel
     */
    select?: RateCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateCategoryModelInclude | null
    /**
     * The data needed to update a RateCategoryModel.
     */
    data: XOR<RateCategoryModelUpdateInput, RateCategoryModelUncheckedUpdateInput>
    /**
     * Choose, which RateCategoryModel to update.
     */
    where: RateCategoryModelWhereUniqueInput
  }


  /**
   * RateCategoryModel updateMany
   */
  export type RateCategoryModelUpdateManyArgs = {
    /**
     * The data used to update RateCategoryModels.
     */
    data: XOR<RateCategoryModelUpdateManyMutationInput, RateCategoryModelUncheckedUpdateManyInput>
    /**
     * Filter which RateCategoryModels to update
     */
    where?: RateCategoryModelWhereInput
  }


  /**
   * RateCategoryModel upsert
   */
  export type RateCategoryModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the RateCategoryModel
     */
    select?: RateCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateCategoryModelInclude | null
    /**
     * The filter to search for the RateCategoryModel to update in case it exists.
     */
    where: RateCategoryModelWhereUniqueInput
    /**
     * In case the RateCategoryModel found by the `where` argument doesn't exist, create a new RateCategoryModel with this data.
     */
    create: XOR<RateCategoryModelCreateInput, RateCategoryModelUncheckedCreateInput>
    /**
     * In case the RateCategoryModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RateCategoryModelUpdateInput, RateCategoryModelUncheckedUpdateInput>
  }


  /**
   * RateCategoryModel delete
   */
  export type RateCategoryModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the RateCategoryModel
     */
    select?: RateCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateCategoryModelInclude | null
    /**
     * Filter which RateCategoryModel to delete.
     */
    where: RateCategoryModelWhereUniqueInput
  }


  /**
   * RateCategoryModel deleteMany
   */
  export type RateCategoryModelDeleteManyArgs = {
    /**
     * Filter which RateCategoryModels to delete
     */
    where?: RateCategoryModelWhereInput
  }


  /**
   * RateCategoryModel.rates
   */
  export type RateCategoryModel$ratesArgs = {
    /**
     * Select specific fields to fetch from the RateModel
     */
    select?: RateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateModelInclude | null
    where?: RateModelWhereInput
    orderBy?: Enumerable<RateModelOrderByWithRelationInput>
    cursor?: RateModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RateModelScalarFieldEnum>
  }


  /**
   * RateCategoryModel without action
   */
  export type RateCategoryModelArgs = {
    /**
     * Select specific fields to fetch from the RateCategoryModel
     */
    select?: RateCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RateCategoryModelInclude | null
  }



  /**
   * Model AgreementModel
   */


  export type AggregateAgreementModel = {
    _count: AgreementModelCountAggregateOutputType | null
    _min: AgreementModelMinAggregateOutputType | null
    _max: AgreementModelMaxAggregateOutputType | null
  }

  export type AgreementModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    title: string | null
    content: string | null
    is_required: boolean | null
    target_type: AgreementTargetType | null
  }

  export type AgreementModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    title: string | null
    content: string | null
    is_required: boolean | null
    target_type: AgreementTargetType | null
  }

  export type AgreementModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    title: number
    content: number
    is_required: number
    target_type: number
    _all: number
  }


  export type AgreementModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    title?: true
    content?: true
    is_required?: true
    target_type?: true
  }

  export type AgreementModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    title?: true
    content?: true
    is_required?: true
    target_type?: true
  }

  export type AgreementModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    title?: true
    content?: true
    is_required?: true
    target_type?: true
    _all?: true
  }

  export type AgreementModelAggregateArgs = {
    /**
     * Filter which AgreementModel to aggregate.
     */
    where?: AgreementModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementModels to fetch.
     */
    orderBy?: Enumerable<AgreementModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgreementModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgreementModels
    **/
    _count?: true | AgreementModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgreementModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgreementModelMaxAggregateInputType
  }

  export type GetAgreementModelAggregateType<T extends AgreementModelAggregateArgs> = {
        [P in keyof T & keyof AggregateAgreementModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgreementModel[P]>
      : GetScalarType<T[P], AggregateAgreementModel[P]>
  }




  export type AgreementModelGroupByArgs = {
    where?: AgreementModelWhereInput
    orderBy?: Enumerable<AgreementModelOrderByWithAggregationInput>
    by: AgreementModelScalarFieldEnum[]
    having?: AgreementModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgreementModelCountAggregateInputType | true
    _min?: AgreementModelMinAggregateInputType
    _max?: AgreementModelMaxAggregateInputType
  }


  export type AgreementModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    title: string
    content: string
    is_required: boolean
    target_type: AgreementTargetType
    _count: AgreementModelCountAggregateOutputType | null
    _min: AgreementModelMinAggregateOutputType | null
    _max: AgreementModelMaxAggregateOutputType | null
  }

  type GetAgreementModelGroupByPayload<T extends AgreementModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AgreementModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgreementModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgreementModelGroupByOutputType[P]>
            : GetScalarType<T[P], AgreementModelGroupByOutputType[P]>
        }
      >
    >


  export type AgreementModelSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    title?: boolean
    content?: boolean
    is_required?: boolean
    target_type?: boolean
    acceptances?: boolean | AgreementModel$acceptancesArgs
    _count?: boolean | AgreementModelCountOutputTypeArgs
  }


  export type AgreementModelInclude = {
    acceptances?: boolean | AgreementModel$acceptancesArgs
    _count?: boolean | AgreementModelCountOutputTypeArgs
  }

  export type AgreementModelGetPayload<S extends boolean | null | undefined | AgreementModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AgreementModel :
    S extends undefined ? never :
    S extends { include: any } & (AgreementModelArgs | AgreementModelFindManyArgs)
    ? AgreementModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'acceptances' ? Array < AgreementAcceptanceModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? AgreementModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AgreementModelArgs | AgreementModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'acceptances' ? Array < AgreementAcceptanceModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? AgreementModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof AgreementModel ? AgreementModel[P] : never
  } 
      : AgreementModel


  type AgreementModelCountArgs = 
    Omit<AgreementModelFindManyArgs, 'select' | 'include'> & {
      select?: AgreementModelCountAggregateInputType | true
    }

  export interface AgreementModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one AgreementModel that matches the filter.
     * @param {AgreementModelFindUniqueArgs} args - Arguments to find a AgreementModel
     * @example
     * // Get one AgreementModel
     * const agreementModel = await prisma.agreementModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AgreementModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AgreementModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AgreementModel'> extends True ? Prisma__AgreementModelClient<AgreementModelGetPayload<T>> : Prisma__AgreementModelClient<AgreementModelGetPayload<T> | null, null>

    /**
     * Find one AgreementModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AgreementModelFindUniqueOrThrowArgs} args - Arguments to find a AgreementModel
     * @example
     * // Get one AgreementModel
     * const agreementModel = await prisma.agreementModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AgreementModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AgreementModelFindUniqueOrThrowArgs>
    ): Prisma__AgreementModelClient<AgreementModelGetPayload<T>>

    /**
     * Find the first AgreementModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementModelFindFirstArgs} args - Arguments to find a AgreementModel
     * @example
     * // Get one AgreementModel
     * const agreementModel = await prisma.agreementModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AgreementModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AgreementModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AgreementModel'> extends True ? Prisma__AgreementModelClient<AgreementModelGetPayload<T>> : Prisma__AgreementModelClient<AgreementModelGetPayload<T> | null, null>

    /**
     * Find the first AgreementModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementModelFindFirstOrThrowArgs} args - Arguments to find a AgreementModel
     * @example
     * // Get one AgreementModel
     * const agreementModel = await prisma.agreementModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AgreementModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AgreementModelFindFirstOrThrowArgs>
    ): Prisma__AgreementModelClient<AgreementModelGetPayload<T>>

    /**
     * Find zero or more AgreementModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgreementModels
     * const agreementModels = await prisma.agreementModel.findMany()
     * 
     * // Get first 10 AgreementModels
     * const agreementModels = await prisma.agreementModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agreementModelWithIdOnly = await prisma.agreementModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AgreementModelFindManyArgs>(
      args?: SelectSubset<T, AgreementModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<AgreementModelGetPayload<T>>>

    /**
     * Create a AgreementModel.
     * @param {AgreementModelCreateArgs} args - Arguments to create a AgreementModel.
     * @example
     * // Create one AgreementModel
     * const AgreementModel = await prisma.agreementModel.create({
     *   data: {
     *     // ... data to create a AgreementModel
     *   }
     * })
     * 
    **/
    create<T extends AgreementModelCreateArgs>(
      args: SelectSubset<T, AgreementModelCreateArgs>
    ): Prisma__AgreementModelClient<AgreementModelGetPayload<T>>

    /**
     * Create many AgreementModels.
     *     @param {AgreementModelCreateManyArgs} args - Arguments to create many AgreementModels.
     *     @example
     *     // Create many AgreementModels
     *     const agreementModel = await prisma.agreementModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AgreementModelCreateManyArgs>(
      args?: SelectSubset<T, AgreementModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgreementModel.
     * @param {AgreementModelDeleteArgs} args - Arguments to delete one AgreementModel.
     * @example
     * // Delete one AgreementModel
     * const AgreementModel = await prisma.agreementModel.delete({
     *   where: {
     *     // ... filter to delete one AgreementModel
     *   }
     * })
     * 
    **/
    delete<T extends AgreementModelDeleteArgs>(
      args: SelectSubset<T, AgreementModelDeleteArgs>
    ): Prisma__AgreementModelClient<AgreementModelGetPayload<T>>

    /**
     * Update one AgreementModel.
     * @param {AgreementModelUpdateArgs} args - Arguments to update one AgreementModel.
     * @example
     * // Update one AgreementModel
     * const agreementModel = await prisma.agreementModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AgreementModelUpdateArgs>(
      args: SelectSubset<T, AgreementModelUpdateArgs>
    ): Prisma__AgreementModelClient<AgreementModelGetPayload<T>>

    /**
     * Delete zero or more AgreementModels.
     * @param {AgreementModelDeleteManyArgs} args - Arguments to filter AgreementModels to delete.
     * @example
     * // Delete a few AgreementModels
     * const { count } = await prisma.agreementModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AgreementModelDeleteManyArgs>(
      args?: SelectSubset<T, AgreementModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgreementModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgreementModels
     * const agreementModel = await prisma.agreementModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AgreementModelUpdateManyArgs>(
      args: SelectSubset<T, AgreementModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgreementModel.
     * @param {AgreementModelUpsertArgs} args - Arguments to update or create a AgreementModel.
     * @example
     * // Update or create a AgreementModel
     * const agreementModel = await prisma.agreementModel.upsert({
     *   create: {
     *     // ... data to create a AgreementModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgreementModel we want to update
     *   }
     * })
    **/
    upsert<T extends AgreementModelUpsertArgs>(
      args: SelectSubset<T, AgreementModelUpsertArgs>
    ): Prisma__AgreementModelClient<AgreementModelGetPayload<T>>

    /**
     * Count the number of AgreementModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementModelCountArgs} args - Arguments to filter AgreementModels to count.
     * @example
     * // Count the number of AgreementModels
     * const count = await prisma.agreementModel.count({
     *   where: {
     *     // ... the filter for the AgreementModels we want to count
     *   }
     * })
    **/
    count<T extends AgreementModelCountArgs>(
      args?: Subset<T, AgreementModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgreementModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgreementModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgreementModelAggregateArgs>(args: Subset<T, AgreementModelAggregateArgs>): Prisma.PrismaPromise<GetAgreementModelAggregateType<T>>

    /**
     * Group by AgreementModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgreementModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgreementModelGroupByArgs['orderBy'] }
        : { orderBy?: AgreementModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgreementModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgreementModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AgreementModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AgreementModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    acceptances<T extends AgreementModel$acceptancesArgs= {}>(args?: Subset<T, AgreementModel$acceptancesArgs>): Prisma.PrismaPromise<Array<AgreementAcceptanceModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AgreementModel base type for findUnique actions
   */
  export type AgreementModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AgreementModel
     */
    select?: AgreementModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementModelInclude | null
    /**
     * Filter, which AgreementModel to fetch.
     */
    where: AgreementModelWhereUniqueInput
  }

  /**
   * AgreementModel findUnique
   */
  export interface AgreementModelFindUniqueArgs extends AgreementModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AgreementModel findUniqueOrThrow
   */
  export type AgreementModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AgreementModel
     */
    select?: AgreementModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementModelInclude | null
    /**
     * Filter, which AgreementModel to fetch.
     */
    where: AgreementModelWhereUniqueInput
  }


  /**
   * AgreementModel base type for findFirst actions
   */
  export type AgreementModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AgreementModel
     */
    select?: AgreementModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementModelInclude | null
    /**
     * Filter, which AgreementModel to fetch.
     */
    where?: AgreementModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementModels to fetch.
     */
    orderBy?: Enumerable<AgreementModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgreementModels.
     */
    cursor?: AgreementModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgreementModels.
     */
    distinct?: Enumerable<AgreementModelScalarFieldEnum>
  }

  /**
   * AgreementModel findFirst
   */
  export interface AgreementModelFindFirstArgs extends AgreementModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AgreementModel findFirstOrThrow
   */
  export type AgreementModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AgreementModel
     */
    select?: AgreementModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementModelInclude | null
    /**
     * Filter, which AgreementModel to fetch.
     */
    where?: AgreementModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementModels to fetch.
     */
    orderBy?: Enumerable<AgreementModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgreementModels.
     */
    cursor?: AgreementModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgreementModels.
     */
    distinct?: Enumerable<AgreementModelScalarFieldEnum>
  }


  /**
   * AgreementModel findMany
   */
  export type AgreementModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the AgreementModel
     */
    select?: AgreementModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementModelInclude | null
    /**
     * Filter, which AgreementModels to fetch.
     */
    where?: AgreementModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementModels to fetch.
     */
    orderBy?: Enumerable<AgreementModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgreementModels.
     */
    cursor?: AgreementModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementModels.
     */
    skip?: number
    distinct?: Enumerable<AgreementModelScalarFieldEnum>
  }


  /**
   * AgreementModel create
   */
  export type AgreementModelCreateArgs = {
    /**
     * Select specific fields to fetch from the AgreementModel
     */
    select?: AgreementModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementModelInclude | null
    /**
     * The data needed to create a AgreementModel.
     */
    data: XOR<AgreementModelCreateInput, AgreementModelUncheckedCreateInput>
  }


  /**
   * AgreementModel createMany
   */
  export type AgreementModelCreateManyArgs = {
    /**
     * The data used to create many AgreementModels.
     */
    data: Enumerable<AgreementModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AgreementModel update
   */
  export type AgreementModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the AgreementModel
     */
    select?: AgreementModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementModelInclude | null
    /**
     * The data needed to update a AgreementModel.
     */
    data: XOR<AgreementModelUpdateInput, AgreementModelUncheckedUpdateInput>
    /**
     * Choose, which AgreementModel to update.
     */
    where: AgreementModelWhereUniqueInput
  }


  /**
   * AgreementModel updateMany
   */
  export type AgreementModelUpdateManyArgs = {
    /**
     * The data used to update AgreementModels.
     */
    data: XOR<AgreementModelUpdateManyMutationInput, AgreementModelUncheckedUpdateManyInput>
    /**
     * Filter which AgreementModels to update
     */
    where?: AgreementModelWhereInput
  }


  /**
   * AgreementModel upsert
   */
  export type AgreementModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the AgreementModel
     */
    select?: AgreementModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementModelInclude | null
    /**
     * The filter to search for the AgreementModel to update in case it exists.
     */
    where: AgreementModelWhereUniqueInput
    /**
     * In case the AgreementModel found by the `where` argument doesn't exist, create a new AgreementModel with this data.
     */
    create: XOR<AgreementModelCreateInput, AgreementModelUncheckedCreateInput>
    /**
     * In case the AgreementModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgreementModelUpdateInput, AgreementModelUncheckedUpdateInput>
  }


  /**
   * AgreementModel delete
   */
  export type AgreementModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the AgreementModel
     */
    select?: AgreementModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementModelInclude | null
    /**
     * Filter which AgreementModel to delete.
     */
    where: AgreementModelWhereUniqueInput
  }


  /**
   * AgreementModel deleteMany
   */
  export type AgreementModelDeleteManyArgs = {
    /**
     * Filter which AgreementModels to delete
     */
    where?: AgreementModelWhereInput
  }


  /**
   * AgreementModel.acceptances
   */
  export type AgreementModel$acceptancesArgs = {
    /**
     * Select specific fields to fetch from the AgreementAcceptanceModel
     */
    select?: AgreementAcceptanceModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementAcceptanceModelInclude | null
    where?: AgreementAcceptanceModelWhereInput
    orderBy?: Enumerable<AgreementAcceptanceModelOrderByWithRelationInput>
    cursor?: AgreementAcceptanceModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AgreementAcceptanceModelScalarFieldEnum>
  }


  /**
   * AgreementModel without action
   */
  export type AgreementModelArgs = {
    /**
     * Select specific fields to fetch from the AgreementModel
     */
    select?: AgreementModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementModelInclude | null
  }



  /**
   * Model AgreementAcceptanceModel
   */


  export type AggregateAgreementAcceptanceModel = {
    _count: AgreementAcceptanceModelCountAggregateOutputType | null
    _min: AgreementAcceptanceModelMinAggregateOutputType | null
    _max: AgreementAcceptanceModelMaxAggregateOutputType | null
  }

  export type AgreementAcceptanceModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    user_id: string | null
    agreement_id: string | null
  }

  export type AgreementAcceptanceModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    user_id: string | null
    agreement_id: string | null
  }

  export type AgreementAcceptanceModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    user_id: number
    agreement_id: number
    _all: number
  }


  export type AgreementAcceptanceModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    user_id?: true
    agreement_id?: true
  }

  export type AgreementAcceptanceModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    user_id?: true
    agreement_id?: true
  }

  export type AgreementAcceptanceModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    user_id?: true
    agreement_id?: true
    _all?: true
  }

  export type AgreementAcceptanceModelAggregateArgs = {
    /**
     * Filter which AgreementAcceptanceModel to aggregate.
     */
    where?: AgreementAcceptanceModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementAcceptanceModels to fetch.
     */
    orderBy?: Enumerable<AgreementAcceptanceModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgreementAcceptanceModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementAcceptanceModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementAcceptanceModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgreementAcceptanceModels
    **/
    _count?: true | AgreementAcceptanceModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgreementAcceptanceModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgreementAcceptanceModelMaxAggregateInputType
  }

  export type GetAgreementAcceptanceModelAggregateType<T extends AgreementAcceptanceModelAggregateArgs> = {
        [P in keyof T & keyof AggregateAgreementAcceptanceModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgreementAcceptanceModel[P]>
      : GetScalarType<T[P], AggregateAgreementAcceptanceModel[P]>
  }




  export type AgreementAcceptanceModelGroupByArgs = {
    where?: AgreementAcceptanceModelWhereInput
    orderBy?: Enumerable<AgreementAcceptanceModelOrderByWithAggregationInput>
    by: AgreementAcceptanceModelScalarFieldEnum[]
    having?: AgreementAcceptanceModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgreementAcceptanceModelCountAggregateInputType | true
    _min?: AgreementAcceptanceModelMinAggregateInputType
    _max?: AgreementAcceptanceModelMaxAggregateInputType
  }


  export type AgreementAcceptanceModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    user_id: string
    agreement_id: string
    _count: AgreementAcceptanceModelCountAggregateOutputType | null
    _min: AgreementAcceptanceModelMinAggregateOutputType | null
    _max: AgreementAcceptanceModelMaxAggregateOutputType | null
  }

  type GetAgreementAcceptanceModelGroupByPayload<T extends AgreementAcceptanceModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AgreementAcceptanceModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgreementAcceptanceModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgreementAcceptanceModelGroupByOutputType[P]>
            : GetScalarType<T[P], AgreementAcceptanceModelGroupByOutputType[P]>
        }
      >
    >


  export type AgreementAcceptanceModelSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    user_id?: boolean
    agreement_id?: boolean
    user?: boolean | UserModelArgs
    agreement?: boolean | AgreementModelArgs
  }


  export type AgreementAcceptanceModelInclude = {
    user?: boolean | UserModelArgs
    agreement?: boolean | AgreementModelArgs
  }

  export type AgreementAcceptanceModelGetPayload<S extends boolean | null | undefined | AgreementAcceptanceModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AgreementAcceptanceModel :
    S extends undefined ? never :
    S extends { include: any } & (AgreementAcceptanceModelArgs | AgreementAcceptanceModelFindManyArgs)
    ? AgreementAcceptanceModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserModelGetPayload<S['include'][P]> :
        P extends 'agreement' ? AgreementModelGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AgreementAcceptanceModelArgs | AgreementAcceptanceModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserModelGetPayload<S['select'][P]> :
        P extends 'agreement' ? AgreementModelGetPayload<S['select'][P]> :  P extends keyof AgreementAcceptanceModel ? AgreementAcceptanceModel[P] : never
  } 
      : AgreementAcceptanceModel


  type AgreementAcceptanceModelCountArgs = 
    Omit<AgreementAcceptanceModelFindManyArgs, 'select' | 'include'> & {
      select?: AgreementAcceptanceModelCountAggregateInputType | true
    }

  export interface AgreementAcceptanceModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one AgreementAcceptanceModel that matches the filter.
     * @param {AgreementAcceptanceModelFindUniqueArgs} args - Arguments to find a AgreementAcceptanceModel
     * @example
     * // Get one AgreementAcceptanceModel
     * const agreementAcceptanceModel = await prisma.agreementAcceptanceModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AgreementAcceptanceModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AgreementAcceptanceModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AgreementAcceptanceModel'> extends True ? Prisma__AgreementAcceptanceModelClient<AgreementAcceptanceModelGetPayload<T>> : Prisma__AgreementAcceptanceModelClient<AgreementAcceptanceModelGetPayload<T> | null, null>

    /**
     * Find one AgreementAcceptanceModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AgreementAcceptanceModelFindUniqueOrThrowArgs} args - Arguments to find a AgreementAcceptanceModel
     * @example
     * // Get one AgreementAcceptanceModel
     * const agreementAcceptanceModel = await prisma.agreementAcceptanceModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AgreementAcceptanceModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AgreementAcceptanceModelFindUniqueOrThrowArgs>
    ): Prisma__AgreementAcceptanceModelClient<AgreementAcceptanceModelGetPayload<T>>

    /**
     * Find the first AgreementAcceptanceModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementAcceptanceModelFindFirstArgs} args - Arguments to find a AgreementAcceptanceModel
     * @example
     * // Get one AgreementAcceptanceModel
     * const agreementAcceptanceModel = await prisma.agreementAcceptanceModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AgreementAcceptanceModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AgreementAcceptanceModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AgreementAcceptanceModel'> extends True ? Prisma__AgreementAcceptanceModelClient<AgreementAcceptanceModelGetPayload<T>> : Prisma__AgreementAcceptanceModelClient<AgreementAcceptanceModelGetPayload<T> | null, null>

    /**
     * Find the first AgreementAcceptanceModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementAcceptanceModelFindFirstOrThrowArgs} args - Arguments to find a AgreementAcceptanceModel
     * @example
     * // Get one AgreementAcceptanceModel
     * const agreementAcceptanceModel = await prisma.agreementAcceptanceModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AgreementAcceptanceModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AgreementAcceptanceModelFindFirstOrThrowArgs>
    ): Prisma__AgreementAcceptanceModelClient<AgreementAcceptanceModelGetPayload<T>>

    /**
     * Find zero or more AgreementAcceptanceModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementAcceptanceModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgreementAcceptanceModels
     * const agreementAcceptanceModels = await prisma.agreementAcceptanceModel.findMany()
     * 
     * // Get first 10 AgreementAcceptanceModels
     * const agreementAcceptanceModels = await prisma.agreementAcceptanceModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agreementAcceptanceModelWithIdOnly = await prisma.agreementAcceptanceModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AgreementAcceptanceModelFindManyArgs>(
      args?: SelectSubset<T, AgreementAcceptanceModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<AgreementAcceptanceModelGetPayload<T>>>

    /**
     * Create a AgreementAcceptanceModel.
     * @param {AgreementAcceptanceModelCreateArgs} args - Arguments to create a AgreementAcceptanceModel.
     * @example
     * // Create one AgreementAcceptanceModel
     * const AgreementAcceptanceModel = await prisma.agreementAcceptanceModel.create({
     *   data: {
     *     // ... data to create a AgreementAcceptanceModel
     *   }
     * })
     * 
    **/
    create<T extends AgreementAcceptanceModelCreateArgs>(
      args: SelectSubset<T, AgreementAcceptanceModelCreateArgs>
    ): Prisma__AgreementAcceptanceModelClient<AgreementAcceptanceModelGetPayload<T>>

    /**
     * Create many AgreementAcceptanceModels.
     *     @param {AgreementAcceptanceModelCreateManyArgs} args - Arguments to create many AgreementAcceptanceModels.
     *     @example
     *     // Create many AgreementAcceptanceModels
     *     const agreementAcceptanceModel = await prisma.agreementAcceptanceModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AgreementAcceptanceModelCreateManyArgs>(
      args?: SelectSubset<T, AgreementAcceptanceModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgreementAcceptanceModel.
     * @param {AgreementAcceptanceModelDeleteArgs} args - Arguments to delete one AgreementAcceptanceModel.
     * @example
     * // Delete one AgreementAcceptanceModel
     * const AgreementAcceptanceModel = await prisma.agreementAcceptanceModel.delete({
     *   where: {
     *     // ... filter to delete one AgreementAcceptanceModel
     *   }
     * })
     * 
    **/
    delete<T extends AgreementAcceptanceModelDeleteArgs>(
      args: SelectSubset<T, AgreementAcceptanceModelDeleteArgs>
    ): Prisma__AgreementAcceptanceModelClient<AgreementAcceptanceModelGetPayload<T>>

    /**
     * Update one AgreementAcceptanceModel.
     * @param {AgreementAcceptanceModelUpdateArgs} args - Arguments to update one AgreementAcceptanceModel.
     * @example
     * // Update one AgreementAcceptanceModel
     * const agreementAcceptanceModel = await prisma.agreementAcceptanceModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AgreementAcceptanceModelUpdateArgs>(
      args: SelectSubset<T, AgreementAcceptanceModelUpdateArgs>
    ): Prisma__AgreementAcceptanceModelClient<AgreementAcceptanceModelGetPayload<T>>

    /**
     * Delete zero or more AgreementAcceptanceModels.
     * @param {AgreementAcceptanceModelDeleteManyArgs} args - Arguments to filter AgreementAcceptanceModels to delete.
     * @example
     * // Delete a few AgreementAcceptanceModels
     * const { count } = await prisma.agreementAcceptanceModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AgreementAcceptanceModelDeleteManyArgs>(
      args?: SelectSubset<T, AgreementAcceptanceModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgreementAcceptanceModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementAcceptanceModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgreementAcceptanceModels
     * const agreementAcceptanceModel = await prisma.agreementAcceptanceModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AgreementAcceptanceModelUpdateManyArgs>(
      args: SelectSubset<T, AgreementAcceptanceModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgreementAcceptanceModel.
     * @param {AgreementAcceptanceModelUpsertArgs} args - Arguments to update or create a AgreementAcceptanceModel.
     * @example
     * // Update or create a AgreementAcceptanceModel
     * const agreementAcceptanceModel = await prisma.agreementAcceptanceModel.upsert({
     *   create: {
     *     // ... data to create a AgreementAcceptanceModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgreementAcceptanceModel we want to update
     *   }
     * })
    **/
    upsert<T extends AgreementAcceptanceModelUpsertArgs>(
      args: SelectSubset<T, AgreementAcceptanceModelUpsertArgs>
    ): Prisma__AgreementAcceptanceModelClient<AgreementAcceptanceModelGetPayload<T>>

    /**
     * Count the number of AgreementAcceptanceModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementAcceptanceModelCountArgs} args - Arguments to filter AgreementAcceptanceModels to count.
     * @example
     * // Count the number of AgreementAcceptanceModels
     * const count = await prisma.agreementAcceptanceModel.count({
     *   where: {
     *     // ... the filter for the AgreementAcceptanceModels we want to count
     *   }
     * })
    **/
    count<T extends AgreementAcceptanceModelCountArgs>(
      args?: Subset<T, AgreementAcceptanceModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgreementAcceptanceModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgreementAcceptanceModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementAcceptanceModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgreementAcceptanceModelAggregateArgs>(args: Subset<T, AgreementAcceptanceModelAggregateArgs>): Prisma.PrismaPromise<GetAgreementAcceptanceModelAggregateType<T>>

    /**
     * Group by AgreementAcceptanceModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementAcceptanceModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgreementAcceptanceModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgreementAcceptanceModelGroupByArgs['orderBy'] }
        : { orderBy?: AgreementAcceptanceModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgreementAcceptanceModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgreementAcceptanceModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AgreementAcceptanceModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AgreementAcceptanceModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserModelArgs= {}>(args?: Subset<T, UserModelArgs>): Prisma__UserModelClient<UserModelGetPayload<T> | Null>;

    agreement<T extends AgreementModelArgs= {}>(args?: Subset<T, AgreementModelArgs>): Prisma__AgreementModelClient<AgreementModelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AgreementAcceptanceModel base type for findUnique actions
   */
  export type AgreementAcceptanceModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AgreementAcceptanceModel
     */
    select?: AgreementAcceptanceModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementAcceptanceModelInclude | null
    /**
     * Filter, which AgreementAcceptanceModel to fetch.
     */
    where: AgreementAcceptanceModelWhereUniqueInput
  }

  /**
   * AgreementAcceptanceModel findUnique
   */
  export interface AgreementAcceptanceModelFindUniqueArgs extends AgreementAcceptanceModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AgreementAcceptanceModel findUniqueOrThrow
   */
  export type AgreementAcceptanceModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AgreementAcceptanceModel
     */
    select?: AgreementAcceptanceModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementAcceptanceModelInclude | null
    /**
     * Filter, which AgreementAcceptanceModel to fetch.
     */
    where: AgreementAcceptanceModelWhereUniqueInput
  }


  /**
   * AgreementAcceptanceModel base type for findFirst actions
   */
  export type AgreementAcceptanceModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AgreementAcceptanceModel
     */
    select?: AgreementAcceptanceModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementAcceptanceModelInclude | null
    /**
     * Filter, which AgreementAcceptanceModel to fetch.
     */
    where?: AgreementAcceptanceModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementAcceptanceModels to fetch.
     */
    orderBy?: Enumerable<AgreementAcceptanceModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgreementAcceptanceModels.
     */
    cursor?: AgreementAcceptanceModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementAcceptanceModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementAcceptanceModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgreementAcceptanceModels.
     */
    distinct?: Enumerable<AgreementAcceptanceModelScalarFieldEnum>
  }

  /**
   * AgreementAcceptanceModel findFirst
   */
  export interface AgreementAcceptanceModelFindFirstArgs extends AgreementAcceptanceModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AgreementAcceptanceModel findFirstOrThrow
   */
  export type AgreementAcceptanceModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AgreementAcceptanceModel
     */
    select?: AgreementAcceptanceModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementAcceptanceModelInclude | null
    /**
     * Filter, which AgreementAcceptanceModel to fetch.
     */
    where?: AgreementAcceptanceModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementAcceptanceModels to fetch.
     */
    orderBy?: Enumerable<AgreementAcceptanceModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgreementAcceptanceModels.
     */
    cursor?: AgreementAcceptanceModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementAcceptanceModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementAcceptanceModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgreementAcceptanceModels.
     */
    distinct?: Enumerable<AgreementAcceptanceModelScalarFieldEnum>
  }


  /**
   * AgreementAcceptanceModel findMany
   */
  export type AgreementAcceptanceModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the AgreementAcceptanceModel
     */
    select?: AgreementAcceptanceModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementAcceptanceModelInclude | null
    /**
     * Filter, which AgreementAcceptanceModels to fetch.
     */
    where?: AgreementAcceptanceModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementAcceptanceModels to fetch.
     */
    orderBy?: Enumerable<AgreementAcceptanceModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgreementAcceptanceModels.
     */
    cursor?: AgreementAcceptanceModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementAcceptanceModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementAcceptanceModels.
     */
    skip?: number
    distinct?: Enumerable<AgreementAcceptanceModelScalarFieldEnum>
  }


  /**
   * AgreementAcceptanceModel create
   */
  export type AgreementAcceptanceModelCreateArgs = {
    /**
     * Select specific fields to fetch from the AgreementAcceptanceModel
     */
    select?: AgreementAcceptanceModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementAcceptanceModelInclude | null
    /**
     * The data needed to create a AgreementAcceptanceModel.
     */
    data: XOR<AgreementAcceptanceModelCreateInput, AgreementAcceptanceModelUncheckedCreateInput>
  }


  /**
   * AgreementAcceptanceModel createMany
   */
  export type AgreementAcceptanceModelCreateManyArgs = {
    /**
     * The data used to create many AgreementAcceptanceModels.
     */
    data: Enumerable<AgreementAcceptanceModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AgreementAcceptanceModel update
   */
  export type AgreementAcceptanceModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the AgreementAcceptanceModel
     */
    select?: AgreementAcceptanceModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementAcceptanceModelInclude | null
    /**
     * The data needed to update a AgreementAcceptanceModel.
     */
    data: XOR<AgreementAcceptanceModelUpdateInput, AgreementAcceptanceModelUncheckedUpdateInput>
    /**
     * Choose, which AgreementAcceptanceModel to update.
     */
    where: AgreementAcceptanceModelWhereUniqueInput
  }


  /**
   * AgreementAcceptanceModel updateMany
   */
  export type AgreementAcceptanceModelUpdateManyArgs = {
    /**
     * The data used to update AgreementAcceptanceModels.
     */
    data: XOR<AgreementAcceptanceModelUpdateManyMutationInput, AgreementAcceptanceModelUncheckedUpdateManyInput>
    /**
     * Filter which AgreementAcceptanceModels to update
     */
    where?: AgreementAcceptanceModelWhereInput
  }


  /**
   * AgreementAcceptanceModel upsert
   */
  export type AgreementAcceptanceModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the AgreementAcceptanceModel
     */
    select?: AgreementAcceptanceModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementAcceptanceModelInclude | null
    /**
     * The filter to search for the AgreementAcceptanceModel to update in case it exists.
     */
    where: AgreementAcceptanceModelWhereUniqueInput
    /**
     * In case the AgreementAcceptanceModel found by the `where` argument doesn't exist, create a new AgreementAcceptanceModel with this data.
     */
    create: XOR<AgreementAcceptanceModelCreateInput, AgreementAcceptanceModelUncheckedCreateInput>
    /**
     * In case the AgreementAcceptanceModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgreementAcceptanceModelUpdateInput, AgreementAcceptanceModelUncheckedUpdateInput>
  }


  /**
   * AgreementAcceptanceModel delete
   */
  export type AgreementAcceptanceModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the AgreementAcceptanceModel
     */
    select?: AgreementAcceptanceModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementAcceptanceModelInclude | null
    /**
     * Filter which AgreementAcceptanceModel to delete.
     */
    where: AgreementAcceptanceModelWhereUniqueInput
  }


  /**
   * AgreementAcceptanceModel deleteMany
   */
  export type AgreementAcceptanceModelDeleteManyArgs = {
    /**
     * Filter which AgreementAcceptanceModels to delete
     */
    where?: AgreementAcceptanceModelWhereInput
  }


  /**
   * AgreementAcceptanceModel without action
   */
  export type AgreementAcceptanceModelArgs = {
    /**
     * Select specific fields to fetch from the AgreementAcceptanceModel
     */
    select?: AgreementAcceptanceModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementAcceptanceModelInclude | null
  }



  /**
   * Model ConsultationTimeModel
   */


  export type AggregateConsultationTimeModel = {
    _count: ConsultationTimeModelCountAggregateOutputType | null
    _min: ConsultationTimeModelMinAggregateOutputType | null
    _max: ConsultationTimeModelMaxAggregateOutputType | null
  }

  export type ConsultationTimeModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    start_time: Date | null
    end_time: Date | null
  }

  export type ConsultationTimeModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    start_time: Date | null
    end_time: Date | null
  }

  export type ConsultationTimeModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    start_time: number
    end_time: number
    _all: number
  }


  export type ConsultationTimeModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    start_time?: true
    end_time?: true
  }

  export type ConsultationTimeModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    start_time?: true
    end_time?: true
  }

  export type ConsultationTimeModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    start_time?: true
    end_time?: true
    _all?: true
  }

  export type ConsultationTimeModelAggregateArgs = {
    /**
     * Filter which ConsultationTimeModel to aggregate.
     */
    where?: ConsultationTimeModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationTimeModels to fetch.
     */
    orderBy?: Enumerable<ConsultationTimeModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConsultationTimeModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationTimeModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationTimeModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConsultationTimeModels
    **/
    _count?: true | ConsultationTimeModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsultationTimeModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsultationTimeModelMaxAggregateInputType
  }

  export type GetConsultationTimeModelAggregateType<T extends ConsultationTimeModelAggregateArgs> = {
        [P in keyof T & keyof AggregateConsultationTimeModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsultationTimeModel[P]>
      : GetScalarType<T[P], AggregateConsultationTimeModel[P]>
  }




  export type ConsultationTimeModelGroupByArgs = {
    where?: ConsultationTimeModelWhereInput
    orderBy?: Enumerable<ConsultationTimeModelOrderByWithAggregationInput>
    by: ConsultationTimeModelScalarFieldEnum[]
    having?: ConsultationTimeModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsultationTimeModelCountAggregateInputType | true
    _min?: ConsultationTimeModelMinAggregateInputType
    _max?: ConsultationTimeModelMaxAggregateInputType
  }


  export type ConsultationTimeModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    start_time: Date
    end_time: Date
    _count: ConsultationTimeModelCountAggregateOutputType | null
    _min: ConsultationTimeModelMinAggregateOutputType | null
    _max: ConsultationTimeModelMaxAggregateOutputType | null
  }

  type GetConsultationTimeModelGroupByPayload<T extends ConsultationTimeModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ConsultationTimeModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsultationTimeModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsultationTimeModelGroupByOutputType[P]>
            : GetScalarType<T[P], ConsultationTimeModelGroupByOutputType[P]>
        }
      >
    >


  export type ConsultationTimeModelSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    start_time?: boolean
    end_time?: boolean
    focus_care_checks?: boolean | ConsultationTimeModel$focus_care_checksArgs
    _count?: boolean | ConsultationTimeModelCountOutputTypeArgs
  }


  export type ConsultationTimeModelInclude = {
    focus_care_checks?: boolean | ConsultationTimeModel$focus_care_checksArgs
    _count?: boolean | ConsultationTimeModelCountOutputTypeArgs
  }

  export type ConsultationTimeModelGetPayload<S extends boolean | null | undefined | ConsultationTimeModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ConsultationTimeModel :
    S extends undefined ? never :
    S extends { include: any } & (ConsultationTimeModelArgs | ConsultationTimeModelFindManyArgs)
    ? ConsultationTimeModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'focus_care_checks' ? Array < FocusCareConsultationTimeCheckModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? ConsultationTimeModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ConsultationTimeModelArgs | ConsultationTimeModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'focus_care_checks' ? Array < FocusCareConsultationTimeCheckModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? ConsultationTimeModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ConsultationTimeModel ? ConsultationTimeModel[P] : never
  } 
      : ConsultationTimeModel


  type ConsultationTimeModelCountArgs = 
    Omit<ConsultationTimeModelFindManyArgs, 'select' | 'include'> & {
      select?: ConsultationTimeModelCountAggregateInputType | true
    }

  export interface ConsultationTimeModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ConsultationTimeModel that matches the filter.
     * @param {ConsultationTimeModelFindUniqueArgs} args - Arguments to find a ConsultationTimeModel
     * @example
     * // Get one ConsultationTimeModel
     * const consultationTimeModel = await prisma.consultationTimeModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConsultationTimeModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ConsultationTimeModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ConsultationTimeModel'> extends True ? Prisma__ConsultationTimeModelClient<ConsultationTimeModelGetPayload<T>> : Prisma__ConsultationTimeModelClient<ConsultationTimeModelGetPayload<T> | null, null>

    /**
     * Find one ConsultationTimeModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConsultationTimeModelFindUniqueOrThrowArgs} args - Arguments to find a ConsultationTimeModel
     * @example
     * // Get one ConsultationTimeModel
     * const consultationTimeModel = await prisma.consultationTimeModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConsultationTimeModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ConsultationTimeModelFindUniqueOrThrowArgs>
    ): Prisma__ConsultationTimeModelClient<ConsultationTimeModelGetPayload<T>>

    /**
     * Find the first ConsultationTimeModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationTimeModelFindFirstArgs} args - Arguments to find a ConsultationTimeModel
     * @example
     * // Get one ConsultationTimeModel
     * const consultationTimeModel = await prisma.consultationTimeModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConsultationTimeModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ConsultationTimeModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ConsultationTimeModel'> extends True ? Prisma__ConsultationTimeModelClient<ConsultationTimeModelGetPayload<T>> : Prisma__ConsultationTimeModelClient<ConsultationTimeModelGetPayload<T> | null, null>

    /**
     * Find the first ConsultationTimeModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationTimeModelFindFirstOrThrowArgs} args - Arguments to find a ConsultationTimeModel
     * @example
     * // Get one ConsultationTimeModel
     * const consultationTimeModel = await prisma.consultationTimeModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConsultationTimeModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ConsultationTimeModelFindFirstOrThrowArgs>
    ): Prisma__ConsultationTimeModelClient<ConsultationTimeModelGetPayload<T>>

    /**
     * Find zero or more ConsultationTimeModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationTimeModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConsultationTimeModels
     * const consultationTimeModels = await prisma.consultationTimeModel.findMany()
     * 
     * // Get first 10 ConsultationTimeModels
     * const consultationTimeModels = await prisma.consultationTimeModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consultationTimeModelWithIdOnly = await prisma.consultationTimeModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConsultationTimeModelFindManyArgs>(
      args?: SelectSubset<T, ConsultationTimeModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<ConsultationTimeModelGetPayload<T>>>

    /**
     * Create a ConsultationTimeModel.
     * @param {ConsultationTimeModelCreateArgs} args - Arguments to create a ConsultationTimeModel.
     * @example
     * // Create one ConsultationTimeModel
     * const ConsultationTimeModel = await prisma.consultationTimeModel.create({
     *   data: {
     *     // ... data to create a ConsultationTimeModel
     *   }
     * })
     * 
    **/
    create<T extends ConsultationTimeModelCreateArgs>(
      args: SelectSubset<T, ConsultationTimeModelCreateArgs>
    ): Prisma__ConsultationTimeModelClient<ConsultationTimeModelGetPayload<T>>

    /**
     * Create many ConsultationTimeModels.
     *     @param {ConsultationTimeModelCreateManyArgs} args - Arguments to create many ConsultationTimeModels.
     *     @example
     *     // Create many ConsultationTimeModels
     *     const consultationTimeModel = await prisma.consultationTimeModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConsultationTimeModelCreateManyArgs>(
      args?: SelectSubset<T, ConsultationTimeModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConsultationTimeModel.
     * @param {ConsultationTimeModelDeleteArgs} args - Arguments to delete one ConsultationTimeModel.
     * @example
     * // Delete one ConsultationTimeModel
     * const ConsultationTimeModel = await prisma.consultationTimeModel.delete({
     *   where: {
     *     // ... filter to delete one ConsultationTimeModel
     *   }
     * })
     * 
    **/
    delete<T extends ConsultationTimeModelDeleteArgs>(
      args: SelectSubset<T, ConsultationTimeModelDeleteArgs>
    ): Prisma__ConsultationTimeModelClient<ConsultationTimeModelGetPayload<T>>

    /**
     * Update one ConsultationTimeModel.
     * @param {ConsultationTimeModelUpdateArgs} args - Arguments to update one ConsultationTimeModel.
     * @example
     * // Update one ConsultationTimeModel
     * const consultationTimeModel = await prisma.consultationTimeModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConsultationTimeModelUpdateArgs>(
      args: SelectSubset<T, ConsultationTimeModelUpdateArgs>
    ): Prisma__ConsultationTimeModelClient<ConsultationTimeModelGetPayload<T>>

    /**
     * Delete zero or more ConsultationTimeModels.
     * @param {ConsultationTimeModelDeleteManyArgs} args - Arguments to filter ConsultationTimeModels to delete.
     * @example
     * // Delete a few ConsultationTimeModels
     * const { count } = await prisma.consultationTimeModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConsultationTimeModelDeleteManyArgs>(
      args?: SelectSubset<T, ConsultationTimeModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConsultationTimeModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationTimeModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConsultationTimeModels
     * const consultationTimeModel = await prisma.consultationTimeModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConsultationTimeModelUpdateManyArgs>(
      args: SelectSubset<T, ConsultationTimeModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConsultationTimeModel.
     * @param {ConsultationTimeModelUpsertArgs} args - Arguments to update or create a ConsultationTimeModel.
     * @example
     * // Update or create a ConsultationTimeModel
     * const consultationTimeModel = await prisma.consultationTimeModel.upsert({
     *   create: {
     *     // ... data to create a ConsultationTimeModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConsultationTimeModel we want to update
     *   }
     * })
    **/
    upsert<T extends ConsultationTimeModelUpsertArgs>(
      args: SelectSubset<T, ConsultationTimeModelUpsertArgs>
    ): Prisma__ConsultationTimeModelClient<ConsultationTimeModelGetPayload<T>>

    /**
     * Count the number of ConsultationTimeModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationTimeModelCountArgs} args - Arguments to filter ConsultationTimeModels to count.
     * @example
     * // Count the number of ConsultationTimeModels
     * const count = await prisma.consultationTimeModel.count({
     *   where: {
     *     // ... the filter for the ConsultationTimeModels we want to count
     *   }
     * })
    **/
    count<T extends ConsultationTimeModelCountArgs>(
      args?: Subset<T, ConsultationTimeModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsultationTimeModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConsultationTimeModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationTimeModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsultationTimeModelAggregateArgs>(args: Subset<T, ConsultationTimeModelAggregateArgs>): Prisma.PrismaPromise<GetConsultationTimeModelAggregateType<T>>

    /**
     * Group by ConsultationTimeModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationTimeModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsultationTimeModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsultationTimeModelGroupByArgs['orderBy'] }
        : { orderBy?: ConsultationTimeModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsultationTimeModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsultationTimeModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ConsultationTimeModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ConsultationTimeModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    focus_care_checks<T extends ConsultationTimeModel$focus_care_checksArgs= {}>(args?: Subset<T, ConsultationTimeModel$focus_care_checksArgs>): Prisma.PrismaPromise<Array<FocusCareConsultationTimeCheckModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ConsultationTimeModel base type for findUnique actions
   */
  export type ConsultationTimeModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ConsultationTimeModel
     */
    select?: ConsultationTimeModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationTimeModelInclude | null
    /**
     * Filter, which ConsultationTimeModel to fetch.
     */
    where: ConsultationTimeModelWhereUniqueInput
  }

  /**
   * ConsultationTimeModel findUnique
   */
  export interface ConsultationTimeModelFindUniqueArgs extends ConsultationTimeModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ConsultationTimeModel findUniqueOrThrow
   */
  export type ConsultationTimeModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ConsultationTimeModel
     */
    select?: ConsultationTimeModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationTimeModelInclude | null
    /**
     * Filter, which ConsultationTimeModel to fetch.
     */
    where: ConsultationTimeModelWhereUniqueInput
  }


  /**
   * ConsultationTimeModel base type for findFirst actions
   */
  export type ConsultationTimeModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ConsultationTimeModel
     */
    select?: ConsultationTimeModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationTimeModelInclude | null
    /**
     * Filter, which ConsultationTimeModel to fetch.
     */
    where?: ConsultationTimeModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationTimeModels to fetch.
     */
    orderBy?: Enumerable<ConsultationTimeModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsultationTimeModels.
     */
    cursor?: ConsultationTimeModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationTimeModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationTimeModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsultationTimeModels.
     */
    distinct?: Enumerable<ConsultationTimeModelScalarFieldEnum>
  }

  /**
   * ConsultationTimeModel findFirst
   */
  export interface ConsultationTimeModelFindFirstArgs extends ConsultationTimeModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ConsultationTimeModel findFirstOrThrow
   */
  export type ConsultationTimeModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ConsultationTimeModel
     */
    select?: ConsultationTimeModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationTimeModelInclude | null
    /**
     * Filter, which ConsultationTimeModel to fetch.
     */
    where?: ConsultationTimeModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationTimeModels to fetch.
     */
    orderBy?: Enumerable<ConsultationTimeModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsultationTimeModels.
     */
    cursor?: ConsultationTimeModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationTimeModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationTimeModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsultationTimeModels.
     */
    distinct?: Enumerable<ConsultationTimeModelScalarFieldEnum>
  }


  /**
   * ConsultationTimeModel findMany
   */
  export type ConsultationTimeModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the ConsultationTimeModel
     */
    select?: ConsultationTimeModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationTimeModelInclude | null
    /**
     * Filter, which ConsultationTimeModels to fetch.
     */
    where?: ConsultationTimeModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationTimeModels to fetch.
     */
    orderBy?: Enumerable<ConsultationTimeModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConsultationTimeModels.
     */
    cursor?: ConsultationTimeModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationTimeModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationTimeModels.
     */
    skip?: number
    distinct?: Enumerable<ConsultationTimeModelScalarFieldEnum>
  }


  /**
   * ConsultationTimeModel create
   */
  export type ConsultationTimeModelCreateArgs = {
    /**
     * Select specific fields to fetch from the ConsultationTimeModel
     */
    select?: ConsultationTimeModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationTimeModelInclude | null
    /**
     * The data needed to create a ConsultationTimeModel.
     */
    data: XOR<ConsultationTimeModelCreateInput, ConsultationTimeModelUncheckedCreateInput>
  }


  /**
   * ConsultationTimeModel createMany
   */
  export type ConsultationTimeModelCreateManyArgs = {
    /**
     * The data used to create many ConsultationTimeModels.
     */
    data: Enumerable<ConsultationTimeModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ConsultationTimeModel update
   */
  export type ConsultationTimeModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the ConsultationTimeModel
     */
    select?: ConsultationTimeModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationTimeModelInclude | null
    /**
     * The data needed to update a ConsultationTimeModel.
     */
    data: XOR<ConsultationTimeModelUpdateInput, ConsultationTimeModelUncheckedUpdateInput>
    /**
     * Choose, which ConsultationTimeModel to update.
     */
    where: ConsultationTimeModelWhereUniqueInput
  }


  /**
   * ConsultationTimeModel updateMany
   */
  export type ConsultationTimeModelUpdateManyArgs = {
    /**
     * The data used to update ConsultationTimeModels.
     */
    data: XOR<ConsultationTimeModelUpdateManyMutationInput, ConsultationTimeModelUncheckedUpdateManyInput>
    /**
     * Filter which ConsultationTimeModels to update
     */
    where?: ConsultationTimeModelWhereInput
  }


  /**
   * ConsultationTimeModel upsert
   */
  export type ConsultationTimeModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the ConsultationTimeModel
     */
    select?: ConsultationTimeModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationTimeModelInclude | null
    /**
     * The filter to search for the ConsultationTimeModel to update in case it exists.
     */
    where: ConsultationTimeModelWhereUniqueInput
    /**
     * In case the ConsultationTimeModel found by the `where` argument doesn't exist, create a new ConsultationTimeModel with this data.
     */
    create: XOR<ConsultationTimeModelCreateInput, ConsultationTimeModelUncheckedCreateInput>
    /**
     * In case the ConsultationTimeModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsultationTimeModelUpdateInput, ConsultationTimeModelUncheckedUpdateInput>
  }


  /**
   * ConsultationTimeModel delete
   */
  export type ConsultationTimeModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the ConsultationTimeModel
     */
    select?: ConsultationTimeModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationTimeModelInclude | null
    /**
     * Filter which ConsultationTimeModel to delete.
     */
    where: ConsultationTimeModelWhereUniqueInput
  }


  /**
   * ConsultationTimeModel deleteMany
   */
  export type ConsultationTimeModelDeleteManyArgs = {
    /**
     * Filter which ConsultationTimeModels to delete
     */
    where?: ConsultationTimeModelWhereInput
  }


  /**
   * ConsultationTimeModel.focus_care_checks
   */
  export type ConsultationTimeModel$focus_care_checksArgs = {
    /**
     * Select specific fields to fetch from the FocusCareConsultationTimeCheckModel
     */
    select?: FocusCareConsultationTimeCheckModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareConsultationTimeCheckModelInclude | null
    where?: FocusCareConsultationTimeCheckModelWhereInput
    orderBy?: Enumerable<FocusCareConsultationTimeCheckModelOrderByWithRelationInput>
    cursor?: FocusCareConsultationTimeCheckModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FocusCareConsultationTimeCheckModelScalarFieldEnum>
  }


  /**
   * ConsultationTimeModel without action
   */
  export type ConsultationTimeModelArgs = {
    /**
     * Select specific fields to fetch from the ConsultationTimeModel
     */
    select?: ConsultationTimeModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConsultationTimeModelInclude | null
  }



  /**
   * Model ServiceSubCategoryModel
   */


  export type AggregateServiceSubCategoryModel = {
    _count: ServiceSubCategoryModelCountAggregateOutputType | null
    _min: ServiceSubCategoryModelMinAggregateOutputType | null
    _max: ServiceSubCategoryModelMaxAggregateOutputType | null
  }

  export type ServiceSubCategoryModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    super_category_id: string | null
  }

  export type ServiceSubCategoryModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    super_category_id: string | null
  }

  export type ServiceSubCategoryModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    name: number
    super_category_id: number
    _all: number
  }


  export type ServiceSubCategoryModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    super_category_id?: true
  }

  export type ServiceSubCategoryModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    super_category_id?: true
  }

  export type ServiceSubCategoryModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    super_category_id?: true
    _all?: true
  }

  export type ServiceSubCategoryModelAggregateArgs = {
    /**
     * Filter which ServiceSubCategoryModel to aggregate.
     */
    where?: ServiceSubCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSubCategoryModels to fetch.
     */
    orderBy?: Enumerable<ServiceSubCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceSubCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSubCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSubCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceSubCategoryModels
    **/
    _count?: true | ServiceSubCategoryModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceSubCategoryModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceSubCategoryModelMaxAggregateInputType
  }

  export type GetServiceSubCategoryModelAggregateType<T extends ServiceSubCategoryModelAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceSubCategoryModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceSubCategoryModel[P]>
      : GetScalarType<T[P], AggregateServiceSubCategoryModel[P]>
  }




  export type ServiceSubCategoryModelGroupByArgs = {
    where?: ServiceSubCategoryModelWhereInput
    orderBy?: Enumerable<ServiceSubCategoryModelOrderByWithAggregationInput>
    by: ServiceSubCategoryModelScalarFieldEnum[]
    having?: ServiceSubCategoryModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceSubCategoryModelCountAggregateInputType | true
    _min?: ServiceSubCategoryModelMinAggregateInputType
    _max?: ServiceSubCategoryModelMaxAggregateInputType
  }


  export type ServiceSubCategoryModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    name: string
    super_category_id: string
    _count: ServiceSubCategoryModelCountAggregateOutputType | null
    _min: ServiceSubCategoryModelMinAggregateOutputType | null
    _max: ServiceSubCategoryModelMaxAggregateOutputType | null
  }

  type GetServiceSubCategoryModelGroupByPayload<T extends ServiceSubCategoryModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServiceSubCategoryModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceSubCategoryModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceSubCategoryModelGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceSubCategoryModelGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSubCategoryModelSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    name?: boolean
    super_category_id?: boolean
    super_category?: boolean | ServiceSuperCategoryModelArgs
    expertises?: boolean | ServiceSubCategoryModel$expertisesArgs
    _count?: boolean | ServiceSubCategoryModelCountOutputTypeArgs
  }


  export type ServiceSubCategoryModelInclude = {
    super_category?: boolean | ServiceSuperCategoryModelArgs
    expertises?: boolean | ServiceSubCategoryModel$expertisesArgs
    _count?: boolean | ServiceSubCategoryModelCountOutputTypeArgs
  }

  export type ServiceSubCategoryModelGetPayload<S extends boolean | null | undefined | ServiceSubCategoryModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ServiceSubCategoryModel :
    S extends undefined ? never :
    S extends { include: any } & (ServiceSubCategoryModelArgs | ServiceSubCategoryModelFindManyArgs)
    ? ServiceSubCategoryModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'super_category' ? ServiceSuperCategoryModelGetPayload<S['include'][P]> :
        P extends 'expertises' ? Array < SubExpertiseModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? ServiceSubCategoryModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ServiceSubCategoryModelArgs | ServiceSubCategoryModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'super_category' ? ServiceSuperCategoryModelGetPayload<S['select'][P]> :
        P extends 'expertises' ? Array < SubExpertiseModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? ServiceSubCategoryModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ServiceSubCategoryModel ? ServiceSubCategoryModel[P] : never
  } 
      : ServiceSubCategoryModel


  type ServiceSubCategoryModelCountArgs = 
    Omit<ServiceSubCategoryModelFindManyArgs, 'select' | 'include'> & {
      select?: ServiceSubCategoryModelCountAggregateInputType | true
    }

  export interface ServiceSubCategoryModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ServiceSubCategoryModel that matches the filter.
     * @param {ServiceSubCategoryModelFindUniqueArgs} args - Arguments to find a ServiceSubCategoryModel
     * @example
     * // Get one ServiceSubCategoryModel
     * const serviceSubCategoryModel = await prisma.serviceSubCategoryModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceSubCategoryModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServiceSubCategoryModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ServiceSubCategoryModel'> extends True ? Prisma__ServiceSubCategoryModelClient<ServiceSubCategoryModelGetPayload<T>> : Prisma__ServiceSubCategoryModelClient<ServiceSubCategoryModelGetPayload<T> | null, null>

    /**
     * Find one ServiceSubCategoryModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServiceSubCategoryModelFindUniqueOrThrowArgs} args - Arguments to find a ServiceSubCategoryModel
     * @example
     * // Get one ServiceSubCategoryModel
     * const serviceSubCategoryModel = await prisma.serviceSubCategoryModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceSubCategoryModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ServiceSubCategoryModelFindUniqueOrThrowArgs>
    ): Prisma__ServiceSubCategoryModelClient<ServiceSubCategoryModelGetPayload<T>>

    /**
     * Find the first ServiceSubCategoryModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubCategoryModelFindFirstArgs} args - Arguments to find a ServiceSubCategoryModel
     * @example
     * // Get one ServiceSubCategoryModel
     * const serviceSubCategoryModel = await prisma.serviceSubCategoryModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceSubCategoryModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServiceSubCategoryModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ServiceSubCategoryModel'> extends True ? Prisma__ServiceSubCategoryModelClient<ServiceSubCategoryModelGetPayload<T>> : Prisma__ServiceSubCategoryModelClient<ServiceSubCategoryModelGetPayload<T> | null, null>

    /**
     * Find the first ServiceSubCategoryModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubCategoryModelFindFirstOrThrowArgs} args - Arguments to find a ServiceSubCategoryModel
     * @example
     * // Get one ServiceSubCategoryModel
     * const serviceSubCategoryModel = await prisma.serviceSubCategoryModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceSubCategoryModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ServiceSubCategoryModelFindFirstOrThrowArgs>
    ): Prisma__ServiceSubCategoryModelClient<ServiceSubCategoryModelGetPayload<T>>

    /**
     * Find zero or more ServiceSubCategoryModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubCategoryModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceSubCategoryModels
     * const serviceSubCategoryModels = await prisma.serviceSubCategoryModel.findMany()
     * 
     * // Get first 10 ServiceSubCategoryModels
     * const serviceSubCategoryModels = await prisma.serviceSubCategoryModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceSubCategoryModelWithIdOnly = await prisma.serviceSubCategoryModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceSubCategoryModelFindManyArgs>(
      args?: SelectSubset<T, ServiceSubCategoryModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<ServiceSubCategoryModelGetPayload<T>>>

    /**
     * Create a ServiceSubCategoryModel.
     * @param {ServiceSubCategoryModelCreateArgs} args - Arguments to create a ServiceSubCategoryModel.
     * @example
     * // Create one ServiceSubCategoryModel
     * const ServiceSubCategoryModel = await prisma.serviceSubCategoryModel.create({
     *   data: {
     *     // ... data to create a ServiceSubCategoryModel
     *   }
     * })
     * 
    **/
    create<T extends ServiceSubCategoryModelCreateArgs>(
      args: SelectSubset<T, ServiceSubCategoryModelCreateArgs>
    ): Prisma__ServiceSubCategoryModelClient<ServiceSubCategoryModelGetPayload<T>>

    /**
     * Create many ServiceSubCategoryModels.
     *     @param {ServiceSubCategoryModelCreateManyArgs} args - Arguments to create many ServiceSubCategoryModels.
     *     @example
     *     // Create many ServiceSubCategoryModels
     *     const serviceSubCategoryModel = await prisma.serviceSubCategoryModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceSubCategoryModelCreateManyArgs>(
      args?: SelectSubset<T, ServiceSubCategoryModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceSubCategoryModel.
     * @param {ServiceSubCategoryModelDeleteArgs} args - Arguments to delete one ServiceSubCategoryModel.
     * @example
     * // Delete one ServiceSubCategoryModel
     * const ServiceSubCategoryModel = await prisma.serviceSubCategoryModel.delete({
     *   where: {
     *     // ... filter to delete one ServiceSubCategoryModel
     *   }
     * })
     * 
    **/
    delete<T extends ServiceSubCategoryModelDeleteArgs>(
      args: SelectSubset<T, ServiceSubCategoryModelDeleteArgs>
    ): Prisma__ServiceSubCategoryModelClient<ServiceSubCategoryModelGetPayload<T>>

    /**
     * Update one ServiceSubCategoryModel.
     * @param {ServiceSubCategoryModelUpdateArgs} args - Arguments to update one ServiceSubCategoryModel.
     * @example
     * // Update one ServiceSubCategoryModel
     * const serviceSubCategoryModel = await prisma.serviceSubCategoryModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceSubCategoryModelUpdateArgs>(
      args: SelectSubset<T, ServiceSubCategoryModelUpdateArgs>
    ): Prisma__ServiceSubCategoryModelClient<ServiceSubCategoryModelGetPayload<T>>

    /**
     * Delete zero or more ServiceSubCategoryModels.
     * @param {ServiceSubCategoryModelDeleteManyArgs} args - Arguments to filter ServiceSubCategoryModels to delete.
     * @example
     * // Delete a few ServiceSubCategoryModels
     * const { count } = await prisma.serviceSubCategoryModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceSubCategoryModelDeleteManyArgs>(
      args?: SelectSubset<T, ServiceSubCategoryModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceSubCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubCategoryModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceSubCategoryModels
     * const serviceSubCategoryModel = await prisma.serviceSubCategoryModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceSubCategoryModelUpdateManyArgs>(
      args: SelectSubset<T, ServiceSubCategoryModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceSubCategoryModel.
     * @param {ServiceSubCategoryModelUpsertArgs} args - Arguments to update or create a ServiceSubCategoryModel.
     * @example
     * // Update or create a ServiceSubCategoryModel
     * const serviceSubCategoryModel = await prisma.serviceSubCategoryModel.upsert({
     *   create: {
     *     // ... data to create a ServiceSubCategoryModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceSubCategoryModel we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceSubCategoryModelUpsertArgs>(
      args: SelectSubset<T, ServiceSubCategoryModelUpsertArgs>
    ): Prisma__ServiceSubCategoryModelClient<ServiceSubCategoryModelGetPayload<T>>

    /**
     * Count the number of ServiceSubCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubCategoryModelCountArgs} args - Arguments to filter ServiceSubCategoryModels to count.
     * @example
     * // Count the number of ServiceSubCategoryModels
     * const count = await prisma.serviceSubCategoryModel.count({
     *   where: {
     *     // ... the filter for the ServiceSubCategoryModels we want to count
     *   }
     * })
    **/
    count<T extends ServiceSubCategoryModelCountArgs>(
      args?: Subset<T, ServiceSubCategoryModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceSubCategoryModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceSubCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubCategoryModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceSubCategoryModelAggregateArgs>(args: Subset<T, ServiceSubCategoryModelAggregateArgs>): Prisma.PrismaPromise<GetServiceSubCategoryModelAggregateType<T>>

    /**
     * Group by ServiceSubCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubCategoryModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceSubCategoryModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceSubCategoryModelGroupByArgs['orderBy'] }
        : { orderBy?: ServiceSubCategoryModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceSubCategoryModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceSubCategoryModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceSubCategoryModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServiceSubCategoryModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    super_category<T extends ServiceSuperCategoryModelArgs= {}>(args?: Subset<T, ServiceSuperCategoryModelArgs>): Prisma__ServiceSuperCategoryModelClient<ServiceSuperCategoryModelGetPayload<T> | Null>;

    expertises<T extends ServiceSubCategoryModel$expertisesArgs= {}>(args?: Subset<T, ServiceSubCategoryModel$expertisesArgs>): Prisma.PrismaPromise<Array<SubExpertiseModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ServiceSubCategoryModel base type for findUnique actions
   */
  export type ServiceSubCategoryModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ServiceSubCategoryModel
     */
    select?: ServiceSubCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubCategoryModelInclude | null
    /**
     * Filter, which ServiceSubCategoryModel to fetch.
     */
    where: ServiceSubCategoryModelWhereUniqueInput
  }

  /**
   * ServiceSubCategoryModel findUnique
   */
  export interface ServiceSubCategoryModelFindUniqueArgs extends ServiceSubCategoryModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceSubCategoryModel findUniqueOrThrow
   */
  export type ServiceSubCategoryModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ServiceSubCategoryModel
     */
    select?: ServiceSubCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubCategoryModelInclude | null
    /**
     * Filter, which ServiceSubCategoryModel to fetch.
     */
    where: ServiceSubCategoryModelWhereUniqueInput
  }


  /**
   * ServiceSubCategoryModel base type for findFirst actions
   */
  export type ServiceSubCategoryModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ServiceSubCategoryModel
     */
    select?: ServiceSubCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubCategoryModelInclude | null
    /**
     * Filter, which ServiceSubCategoryModel to fetch.
     */
    where?: ServiceSubCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSubCategoryModels to fetch.
     */
    orderBy?: Enumerable<ServiceSubCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceSubCategoryModels.
     */
    cursor?: ServiceSubCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSubCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSubCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceSubCategoryModels.
     */
    distinct?: Enumerable<ServiceSubCategoryModelScalarFieldEnum>
  }

  /**
   * ServiceSubCategoryModel findFirst
   */
  export interface ServiceSubCategoryModelFindFirstArgs extends ServiceSubCategoryModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceSubCategoryModel findFirstOrThrow
   */
  export type ServiceSubCategoryModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ServiceSubCategoryModel
     */
    select?: ServiceSubCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubCategoryModelInclude | null
    /**
     * Filter, which ServiceSubCategoryModel to fetch.
     */
    where?: ServiceSubCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSubCategoryModels to fetch.
     */
    orderBy?: Enumerable<ServiceSubCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceSubCategoryModels.
     */
    cursor?: ServiceSubCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSubCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSubCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceSubCategoryModels.
     */
    distinct?: Enumerable<ServiceSubCategoryModelScalarFieldEnum>
  }


  /**
   * ServiceSubCategoryModel findMany
   */
  export type ServiceSubCategoryModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the ServiceSubCategoryModel
     */
    select?: ServiceSubCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubCategoryModelInclude | null
    /**
     * Filter, which ServiceSubCategoryModels to fetch.
     */
    where?: ServiceSubCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSubCategoryModels to fetch.
     */
    orderBy?: Enumerable<ServiceSubCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceSubCategoryModels.
     */
    cursor?: ServiceSubCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSubCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSubCategoryModels.
     */
    skip?: number
    distinct?: Enumerable<ServiceSubCategoryModelScalarFieldEnum>
  }


  /**
   * ServiceSubCategoryModel create
   */
  export type ServiceSubCategoryModelCreateArgs = {
    /**
     * Select specific fields to fetch from the ServiceSubCategoryModel
     */
    select?: ServiceSubCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubCategoryModelInclude | null
    /**
     * The data needed to create a ServiceSubCategoryModel.
     */
    data: XOR<ServiceSubCategoryModelCreateInput, ServiceSubCategoryModelUncheckedCreateInput>
  }


  /**
   * ServiceSubCategoryModel createMany
   */
  export type ServiceSubCategoryModelCreateManyArgs = {
    /**
     * The data used to create many ServiceSubCategoryModels.
     */
    data: Enumerable<ServiceSubCategoryModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ServiceSubCategoryModel update
   */
  export type ServiceSubCategoryModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the ServiceSubCategoryModel
     */
    select?: ServiceSubCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubCategoryModelInclude | null
    /**
     * The data needed to update a ServiceSubCategoryModel.
     */
    data: XOR<ServiceSubCategoryModelUpdateInput, ServiceSubCategoryModelUncheckedUpdateInput>
    /**
     * Choose, which ServiceSubCategoryModel to update.
     */
    where: ServiceSubCategoryModelWhereUniqueInput
  }


  /**
   * ServiceSubCategoryModel updateMany
   */
  export type ServiceSubCategoryModelUpdateManyArgs = {
    /**
     * The data used to update ServiceSubCategoryModels.
     */
    data: XOR<ServiceSubCategoryModelUpdateManyMutationInput, ServiceSubCategoryModelUncheckedUpdateManyInput>
    /**
     * Filter which ServiceSubCategoryModels to update
     */
    where?: ServiceSubCategoryModelWhereInput
  }


  /**
   * ServiceSubCategoryModel upsert
   */
  export type ServiceSubCategoryModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the ServiceSubCategoryModel
     */
    select?: ServiceSubCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubCategoryModelInclude | null
    /**
     * The filter to search for the ServiceSubCategoryModel to update in case it exists.
     */
    where: ServiceSubCategoryModelWhereUniqueInput
    /**
     * In case the ServiceSubCategoryModel found by the `where` argument doesn't exist, create a new ServiceSubCategoryModel with this data.
     */
    create: XOR<ServiceSubCategoryModelCreateInput, ServiceSubCategoryModelUncheckedCreateInput>
    /**
     * In case the ServiceSubCategoryModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceSubCategoryModelUpdateInput, ServiceSubCategoryModelUncheckedUpdateInput>
  }


  /**
   * ServiceSubCategoryModel delete
   */
  export type ServiceSubCategoryModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the ServiceSubCategoryModel
     */
    select?: ServiceSubCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubCategoryModelInclude | null
    /**
     * Filter which ServiceSubCategoryModel to delete.
     */
    where: ServiceSubCategoryModelWhereUniqueInput
  }


  /**
   * ServiceSubCategoryModel deleteMany
   */
  export type ServiceSubCategoryModelDeleteManyArgs = {
    /**
     * Filter which ServiceSubCategoryModels to delete
     */
    where?: ServiceSubCategoryModelWhereInput
  }


  /**
   * ServiceSubCategoryModel.expertises
   */
  export type ServiceSubCategoryModel$expertisesArgs = {
    /**
     * Select specific fields to fetch from the SubExpertiseModel
     */
    select?: SubExpertiseModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubExpertiseModelInclude | null
    where?: SubExpertiseModelWhereInput
    orderBy?: Enumerable<SubExpertiseModelOrderByWithRelationInput>
    cursor?: SubExpertiseModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SubExpertiseModelScalarFieldEnum>
  }


  /**
   * ServiceSubCategoryModel without action
   */
  export type ServiceSubCategoryModelArgs = {
    /**
     * Select specific fields to fetch from the ServiceSubCategoryModel
     */
    select?: ServiceSubCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubCategoryModelInclude | null
  }



  /**
   * Model ServiceSuperCategoryModel
   */


  export type AggregateServiceSuperCategoryModel = {
    _count: ServiceSuperCategoryModelCountAggregateOutputType | null
    _min: ServiceSuperCategoryModelMinAggregateOutputType | null
    _max: ServiceSuperCategoryModelMaxAggregateOutputType | null
  }

  export type ServiceSuperCategoryModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    type: ServiceType | null
  }

  export type ServiceSuperCategoryModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    type: ServiceType | null
  }

  export type ServiceSuperCategoryModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    name: number
    type: number
    _all: number
  }


  export type ServiceSuperCategoryModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    type?: true
  }

  export type ServiceSuperCategoryModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    type?: true
  }

  export type ServiceSuperCategoryModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    type?: true
    _all?: true
  }

  export type ServiceSuperCategoryModelAggregateArgs = {
    /**
     * Filter which ServiceSuperCategoryModel to aggregate.
     */
    where?: ServiceSuperCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSuperCategoryModels to fetch.
     */
    orderBy?: Enumerable<ServiceSuperCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceSuperCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSuperCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSuperCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceSuperCategoryModels
    **/
    _count?: true | ServiceSuperCategoryModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceSuperCategoryModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceSuperCategoryModelMaxAggregateInputType
  }

  export type GetServiceSuperCategoryModelAggregateType<T extends ServiceSuperCategoryModelAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceSuperCategoryModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceSuperCategoryModel[P]>
      : GetScalarType<T[P], AggregateServiceSuperCategoryModel[P]>
  }




  export type ServiceSuperCategoryModelGroupByArgs = {
    where?: ServiceSuperCategoryModelWhereInput
    orderBy?: Enumerable<ServiceSuperCategoryModelOrderByWithAggregationInput>
    by: ServiceSuperCategoryModelScalarFieldEnum[]
    having?: ServiceSuperCategoryModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceSuperCategoryModelCountAggregateInputType | true
    _min?: ServiceSuperCategoryModelMinAggregateInputType
    _max?: ServiceSuperCategoryModelMaxAggregateInputType
  }


  export type ServiceSuperCategoryModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    name: string
    type: ServiceType
    _count: ServiceSuperCategoryModelCountAggregateOutputType | null
    _min: ServiceSuperCategoryModelMinAggregateOutputType | null
    _max: ServiceSuperCategoryModelMaxAggregateOutputType | null
  }

  type GetServiceSuperCategoryModelGroupByPayload<T extends ServiceSuperCategoryModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServiceSuperCategoryModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceSuperCategoryModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceSuperCategoryModelGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceSuperCategoryModelGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSuperCategoryModelSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    name?: boolean
    type?: boolean
    sub_categories?: boolean | ServiceSuperCategoryModel$sub_categoriesArgs
    focus_care_checks?: boolean | ServiceSuperCategoryModel$focus_care_checksArgs
    _count?: boolean | ServiceSuperCategoryModelCountOutputTypeArgs
  }


  export type ServiceSuperCategoryModelInclude = {
    sub_categories?: boolean | ServiceSuperCategoryModel$sub_categoriesArgs
    focus_care_checks?: boolean | ServiceSuperCategoryModel$focus_care_checksArgs
    _count?: boolean | ServiceSuperCategoryModelCountOutputTypeArgs
  }

  export type ServiceSuperCategoryModelGetPayload<S extends boolean | null | undefined | ServiceSuperCategoryModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ServiceSuperCategoryModel :
    S extends undefined ? never :
    S extends { include: any } & (ServiceSuperCategoryModelArgs | ServiceSuperCategoryModelFindManyArgs)
    ? ServiceSuperCategoryModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'sub_categories' ? Array < ServiceSubCategoryModelGetPayload<S['include'][P]>>  :
        P extends 'focus_care_checks' ? Array < FocusCareServiceCheckModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? ServiceSuperCategoryModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ServiceSuperCategoryModelArgs | ServiceSuperCategoryModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'sub_categories' ? Array < ServiceSubCategoryModelGetPayload<S['select'][P]>>  :
        P extends 'focus_care_checks' ? Array < FocusCareServiceCheckModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? ServiceSuperCategoryModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ServiceSuperCategoryModel ? ServiceSuperCategoryModel[P] : never
  } 
      : ServiceSuperCategoryModel


  type ServiceSuperCategoryModelCountArgs = 
    Omit<ServiceSuperCategoryModelFindManyArgs, 'select' | 'include'> & {
      select?: ServiceSuperCategoryModelCountAggregateInputType | true
    }

  export interface ServiceSuperCategoryModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ServiceSuperCategoryModel that matches the filter.
     * @param {ServiceSuperCategoryModelFindUniqueArgs} args - Arguments to find a ServiceSuperCategoryModel
     * @example
     * // Get one ServiceSuperCategoryModel
     * const serviceSuperCategoryModel = await prisma.serviceSuperCategoryModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceSuperCategoryModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServiceSuperCategoryModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ServiceSuperCategoryModel'> extends True ? Prisma__ServiceSuperCategoryModelClient<ServiceSuperCategoryModelGetPayload<T>> : Prisma__ServiceSuperCategoryModelClient<ServiceSuperCategoryModelGetPayload<T> | null, null>

    /**
     * Find one ServiceSuperCategoryModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServiceSuperCategoryModelFindUniqueOrThrowArgs} args - Arguments to find a ServiceSuperCategoryModel
     * @example
     * // Get one ServiceSuperCategoryModel
     * const serviceSuperCategoryModel = await prisma.serviceSuperCategoryModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceSuperCategoryModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ServiceSuperCategoryModelFindUniqueOrThrowArgs>
    ): Prisma__ServiceSuperCategoryModelClient<ServiceSuperCategoryModelGetPayload<T>>

    /**
     * Find the first ServiceSuperCategoryModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSuperCategoryModelFindFirstArgs} args - Arguments to find a ServiceSuperCategoryModel
     * @example
     * // Get one ServiceSuperCategoryModel
     * const serviceSuperCategoryModel = await prisma.serviceSuperCategoryModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceSuperCategoryModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServiceSuperCategoryModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ServiceSuperCategoryModel'> extends True ? Prisma__ServiceSuperCategoryModelClient<ServiceSuperCategoryModelGetPayload<T>> : Prisma__ServiceSuperCategoryModelClient<ServiceSuperCategoryModelGetPayload<T> | null, null>

    /**
     * Find the first ServiceSuperCategoryModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSuperCategoryModelFindFirstOrThrowArgs} args - Arguments to find a ServiceSuperCategoryModel
     * @example
     * // Get one ServiceSuperCategoryModel
     * const serviceSuperCategoryModel = await prisma.serviceSuperCategoryModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceSuperCategoryModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ServiceSuperCategoryModelFindFirstOrThrowArgs>
    ): Prisma__ServiceSuperCategoryModelClient<ServiceSuperCategoryModelGetPayload<T>>

    /**
     * Find zero or more ServiceSuperCategoryModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSuperCategoryModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceSuperCategoryModels
     * const serviceSuperCategoryModels = await prisma.serviceSuperCategoryModel.findMany()
     * 
     * // Get first 10 ServiceSuperCategoryModels
     * const serviceSuperCategoryModels = await prisma.serviceSuperCategoryModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceSuperCategoryModelWithIdOnly = await prisma.serviceSuperCategoryModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceSuperCategoryModelFindManyArgs>(
      args?: SelectSubset<T, ServiceSuperCategoryModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<ServiceSuperCategoryModelGetPayload<T>>>

    /**
     * Create a ServiceSuperCategoryModel.
     * @param {ServiceSuperCategoryModelCreateArgs} args - Arguments to create a ServiceSuperCategoryModel.
     * @example
     * // Create one ServiceSuperCategoryModel
     * const ServiceSuperCategoryModel = await prisma.serviceSuperCategoryModel.create({
     *   data: {
     *     // ... data to create a ServiceSuperCategoryModel
     *   }
     * })
     * 
    **/
    create<T extends ServiceSuperCategoryModelCreateArgs>(
      args: SelectSubset<T, ServiceSuperCategoryModelCreateArgs>
    ): Prisma__ServiceSuperCategoryModelClient<ServiceSuperCategoryModelGetPayload<T>>

    /**
     * Create many ServiceSuperCategoryModels.
     *     @param {ServiceSuperCategoryModelCreateManyArgs} args - Arguments to create many ServiceSuperCategoryModels.
     *     @example
     *     // Create many ServiceSuperCategoryModels
     *     const serviceSuperCategoryModel = await prisma.serviceSuperCategoryModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceSuperCategoryModelCreateManyArgs>(
      args?: SelectSubset<T, ServiceSuperCategoryModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceSuperCategoryModel.
     * @param {ServiceSuperCategoryModelDeleteArgs} args - Arguments to delete one ServiceSuperCategoryModel.
     * @example
     * // Delete one ServiceSuperCategoryModel
     * const ServiceSuperCategoryModel = await prisma.serviceSuperCategoryModel.delete({
     *   where: {
     *     // ... filter to delete one ServiceSuperCategoryModel
     *   }
     * })
     * 
    **/
    delete<T extends ServiceSuperCategoryModelDeleteArgs>(
      args: SelectSubset<T, ServiceSuperCategoryModelDeleteArgs>
    ): Prisma__ServiceSuperCategoryModelClient<ServiceSuperCategoryModelGetPayload<T>>

    /**
     * Update one ServiceSuperCategoryModel.
     * @param {ServiceSuperCategoryModelUpdateArgs} args - Arguments to update one ServiceSuperCategoryModel.
     * @example
     * // Update one ServiceSuperCategoryModel
     * const serviceSuperCategoryModel = await prisma.serviceSuperCategoryModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceSuperCategoryModelUpdateArgs>(
      args: SelectSubset<T, ServiceSuperCategoryModelUpdateArgs>
    ): Prisma__ServiceSuperCategoryModelClient<ServiceSuperCategoryModelGetPayload<T>>

    /**
     * Delete zero or more ServiceSuperCategoryModels.
     * @param {ServiceSuperCategoryModelDeleteManyArgs} args - Arguments to filter ServiceSuperCategoryModels to delete.
     * @example
     * // Delete a few ServiceSuperCategoryModels
     * const { count } = await prisma.serviceSuperCategoryModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceSuperCategoryModelDeleteManyArgs>(
      args?: SelectSubset<T, ServiceSuperCategoryModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceSuperCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSuperCategoryModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceSuperCategoryModels
     * const serviceSuperCategoryModel = await prisma.serviceSuperCategoryModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceSuperCategoryModelUpdateManyArgs>(
      args: SelectSubset<T, ServiceSuperCategoryModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceSuperCategoryModel.
     * @param {ServiceSuperCategoryModelUpsertArgs} args - Arguments to update or create a ServiceSuperCategoryModel.
     * @example
     * // Update or create a ServiceSuperCategoryModel
     * const serviceSuperCategoryModel = await prisma.serviceSuperCategoryModel.upsert({
     *   create: {
     *     // ... data to create a ServiceSuperCategoryModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceSuperCategoryModel we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceSuperCategoryModelUpsertArgs>(
      args: SelectSubset<T, ServiceSuperCategoryModelUpsertArgs>
    ): Prisma__ServiceSuperCategoryModelClient<ServiceSuperCategoryModelGetPayload<T>>

    /**
     * Count the number of ServiceSuperCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSuperCategoryModelCountArgs} args - Arguments to filter ServiceSuperCategoryModels to count.
     * @example
     * // Count the number of ServiceSuperCategoryModels
     * const count = await prisma.serviceSuperCategoryModel.count({
     *   where: {
     *     // ... the filter for the ServiceSuperCategoryModels we want to count
     *   }
     * })
    **/
    count<T extends ServiceSuperCategoryModelCountArgs>(
      args?: Subset<T, ServiceSuperCategoryModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceSuperCategoryModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceSuperCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSuperCategoryModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceSuperCategoryModelAggregateArgs>(args: Subset<T, ServiceSuperCategoryModelAggregateArgs>): Prisma.PrismaPromise<GetServiceSuperCategoryModelAggregateType<T>>

    /**
     * Group by ServiceSuperCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSuperCategoryModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceSuperCategoryModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceSuperCategoryModelGroupByArgs['orderBy'] }
        : { orderBy?: ServiceSuperCategoryModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceSuperCategoryModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceSuperCategoryModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceSuperCategoryModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServiceSuperCategoryModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    sub_categories<T extends ServiceSuperCategoryModel$sub_categoriesArgs= {}>(args?: Subset<T, ServiceSuperCategoryModel$sub_categoriesArgs>): Prisma.PrismaPromise<Array<ServiceSubCategoryModelGetPayload<T>>| Null>;

    focus_care_checks<T extends ServiceSuperCategoryModel$focus_care_checksArgs= {}>(args?: Subset<T, ServiceSuperCategoryModel$focus_care_checksArgs>): Prisma.PrismaPromise<Array<FocusCareServiceCheckModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ServiceSuperCategoryModel base type for findUnique actions
   */
  export type ServiceSuperCategoryModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ServiceSuperCategoryModel
     */
    select?: ServiceSuperCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSuperCategoryModelInclude | null
    /**
     * Filter, which ServiceSuperCategoryModel to fetch.
     */
    where: ServiceSuperCategoryModelWhereUniqueInput
  }

  /**
   * ServiceSuperCategoryModel findUnique
   */
  export interface ServiceSuperCategoryModelFindUniqueArgs extends ServiceSuperCategoryModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceSuperCategoryModel findUniqueOrThrow
   */
  export type ServiceSuperCategoryModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ServiceSuperCategoryModel
     */
    select?: ServiceSuperCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSuperCategoryModelInclude | null
    /**
     * Filter, which ServiceSuperCategoryModel to fetch.
     */
    where: ServiceSuperCategoryModelWhereUniqueInput
  }


  /**
   * ServiceSuperCategoryModel base type for findFirst actions
   */
  export type ServiceSuperCategoryModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ServiceSuperCategoryModel
     */
    select?: ServiceSuperCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSuperCategoryModelInclude | null
    /**
     * Filter, which ServiceSuperCategoryModel to fetch.
     */
    where?: ServiceSuperCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSuperCategoryModels to fetch.
     */
    orderBy?: Enumerable<ServiceSuperCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceSuperCategoryModels.
     */
    cursor?: ServiceSuperCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSuperCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSuperCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceSuperCategoryModels.
     */
    distinct?: Enumerable<ServiceSuperCategoryModelScalarFieldEnum>
  }

  /**
   * ServiceSuperCategoryModel findFirst
   */
  export interface ServiceSuperCategoryModelFindFirstArgs extends ServiceSuperCategoryModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceSuperCategoryModel findFirstOrThrow
   */
  export type ServiceSuperCategoryModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ServiceSuperCategoryModel
     */
    select?: ServiceSuperCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSuperCategoryModelInclude | null
    /**
     * Filter, which ServiceSuperCategoryModel to fetch.
     */
    where?: ServiceSuperCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSuperCategoryModels to fetch.
     */
    orderBy?: Enumerable<ServiceSuperCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceSuperCategoryModels.
     */
    cursor?: ServiceSuperCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSuperCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSuperCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceSuperCategoryModels.
     */
    distinct?: Enumerable<ServiceSuperCategoryModelScalarFieldEnum>
  }


  /**
   * ServiceSuperCategoryModel findMany
   */
  export type ServiceSuperCategoryModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the ServiceSuperCategoryModel
     */
    select?: ServiceSuperCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSuperCategoryModelInclude | null
    /**
     * Filter, which ServiceSuperCategoryModels to fetch.
     */
    where?: ServiceSuperCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSuperCategoryModels to fetch.
     */
    orderBy?: Enumerable<ServiceSuperCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceSuperCategoryModels.
     */
    cursor?: ServiceSuperCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSuperCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSuperCategoryModels.
     */
    skip?: number
    distinct?: Enumerable<ServiceSuperCategoryModelScalarFieldEnum>
  }


  /**
   * ServiceSuperCategoryModel create
   */
  export type ServiceSuperCategoryModelCreateArgs = {
    /**
     * Select specific fields to fetch from the ServiceSuperCategoryModel
     */
    select?: ServiceSuperCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSuperCategoryModelInclude | null
    /**
     * The data needed to create a ServiceSuperCategoryModel.
     */
    data: XOR<ServiceSuperCategoryModelCreateInput, ServiceSuperCategoryModelUncheckedCreateInput>
  }


  /**
   * ServiceSuperCategoryModel createMany
   */
  export type ServiceSuperCategoryModelCreateManyArgs = {
    /**
     * The data used to create many ServiceSuperCategoryModels.
     */
    data: Enumerable<ServiceSuperCategoryModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ServiceSuperCategoryModel update
   */
  export type ServiceSuperCategoryModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the ServiceSuperCategoryModel
     */
    select?: ServiceSuperCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSuperCategoryModelInclude | null
    /**
     * The data needed to update a ServiceSuperCategoryModel.
     */
    data: XOR<ServiceSuperCategoryModelUpdateInput, ServiceSuperCategoryModelUncheckedUpdateInput>
    /**
     * Choose, which ServiceSuperCategoryModel to update.
     */
    where: ServiceSuperCategoryModelWhereUniqueInput
  }


  /**
   * ServiceSuperCategoryModel updateMany
   */
  export type ServiceSuperCategoryModelUpdateManyArgs = {
    /**
     * The data used to update ServiceSuperCategoryModels.
     */
    data: XOR<ServiceSuperCategoryModelUpdateManyMutationInput, ServiceSuperCategoryModelUncheckedUpdateManyInput>
    /**
     * Filter which ServiceSuperCategoryModels to update
     */
    where?: ServiceSuperCategoryModelWhereInput
  }


  /**
   * ServiceSuperCategoryModel upsert
   */
  export type ServiceSuperCategoryModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the ServiceSuperCategoryModel
     */
    select?: ServiceSuperCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSuperCategoryModelInclude | null
    /**
     * The filter to search for the ServiceSuperCategoryModel to update in case it exists.
     */
    where: ServiceSuperCategoryModelWhereUniqueInput
    /**
     * In case the ServiceSuperCategoryModel found by the `where` argument doesn't exist, create a new ServiceSuperCategoryModel with this data.
     */
    create: XOR<ServiceSuperCategoryModelCreateInput, ServiceSuperCategoryModelUncheckedCreateInput>
    /**
     * In case the ServiceSuperCategoryModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceSuperCategoryModelUpdateInput, ServiceSuperCategoryModelUncheckedUpdateInput>
  }


  /**
   * ServiceSuperCategoryModel delete
   */
  export type ServiceSuperCategoryModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the ServiceSuperCategoryModel
     */
    select?: ServiceSuperCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSuperCategoryModelInclude | null
    /**
     * Filter which ServiceSuperCategoryModel to delete.
     */
    where: ServiceSuperCategoryModelWhereUniqueInput
  }


  /**
   * ServiceSuperCategoryModel deleteMany
   */
  export type ServiceSuperCategoryModelDeleteManyArgs = {
    /**
     * Filter which ServiceSuperCategoryModels to delete
     */
    where?: ServiceSuperCategoryModelWhereInput
  }


  /**
   * ServiceSuperCategoryModel.sub_categories
   */
  export type ServiceSuperCategoryModel$sub_categoriesArgs = {
    /**
     * Select specific fields to fetch from the ServiceSubCategoryModel
     */
    select?: ServiceSubCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubCategoryModelInclude | null
    where?: ServiceSubCategoryModelWhereInput
    orderBy?: Enumerable<ServiceSubCategoryModelOrderByWithRelationInput>
    cursor?: ServiceSubCategoryModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ServiceSubCategoryModelScalarFieldEnum>
  }


  /**
   * ServiceSuperCategoryModel.focus_care_checks
   */
  export type ServiceSuperCategoryModel$focus_care_checksArgs = {
    /**
     * Select specific fields to fetch from the FocusCareServiceCheckModel
     */
    select?: FocusCareServiceCheckModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareServiceCheckModelInclude | null
    where?: FocusCareServiceCheckModelWhereInput
    orderBy?: Enumerable<FocusCareServiceCheckModelOrderByWithRelationInput>
    cursor?: FocusCareServiceCheckModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FocusCareServiceCheckModelScalarFieldEnum>
  }


  /**
   * ServiceSuperCategoryModel without action
   */
  export type ServiceSuperCategoryModelArgs = {
    /**
     * Select specific fields to fetch from the ServiceSuperCategoryModel
     */
    select?: ServiceSuperCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSuperCategoryModelInclude | null
  }



  /**
   * Model FocusCareRequestModel
   */


  export type AggregateFocusCareRequestModel = {
    _count: FocusCareRequestModelCountAggregateOutputType | null
    _min: FocusCareRequestModelMinAggregateOutputType | null
    _max: FocusCareRequestModelMaxAggregateOutputType | null
  }

  export type FocusCareRequestModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    care_start_date: Date | null
    care_end_date: Date | null
    detail: string | null
    status: FocusCareStatus | null
    requester_id: string | null
  }

  export type FocusCareRequestModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    care_start_date: Date | null
    care_end_date: Date | null
    detail: string | null
    status: FocusCareStatus | null
    requester_id: string | null
  }

  export type FocusCareRequestModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    care_start_date: number
    care_end_date: number
    detail: number
    status: number
    requester_id: number
    _all: number
  }


  export type FocusCareRequestModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    care_start_date?: true
    care_end_date?: true
    detail?: true
    status?: true
    requester_id?: true
  }

  export type FocusCareRequestModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    care_start_date?: true
    care_end_date?: true
    detail?: true
    status?: true
    requester_id?: true
  }

  export type FocusCareRequestModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    care_start_date?: true
    care_end_date?: true
    detail?: true
    status?: true
    requester_id?: true
    _all?: true
  }

  export type FocusCareRequestModelAggregateArgs = {
    /**
     * Filter which FocusCareRequestModel to aggregate.
     */
    where?: FocusCareRequestModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FocusCareRequestModels to fetch.
     */
    orderBy?: Enumerable<FocusCareRequestModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FocusCareRequestModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FocusCareRequestModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FocusCareRequestModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FocusCareRequestModels
    **/
    _count?: true | FocusCareRequestModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FocusCareRequestModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FocusCareRequestModelMaxAggregateInputType
  }

  export type GetFocusCareRequestModelAggregateType<T extends FocusCareRequestModelAggregateArgs> = {
        [P in keyof T & keyof AggregateFocusCareRequestModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFocusCareRequestModel[P]>
      : GetScalarType<T[P], AggregateFocusCareRequestModel[P]>
  }




  export type FocusCareRequestModelGroupByArgs = {
    where?: FocusCareRequestModelWhereInput
    orderBy?: Enumerable<FocusCareRequestModelOrderByWithAggregationInput>
    by: FocusCareRequestModelScalarFieldEnum[]
    having?: FocusCareRequestModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FocusCareRequestModelCountAggregateInputType | true
    _min?: FocusCareRequestModelMinAggregateInputType
    _max?: FocusCareRequestModelMaxAggregateInputType
  }


  export type FocusCareRequestModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    care_start_date: Date
    care_end_date: Date
    detail: string
    status: FocusCareStatus
    requester_id: string
    _count: FocusCareRequestModelCountAggregateOutputType | null
    _min: FocusCareRequestModelMinAggregateOutputType | null
    _max: FocusCareRequestModelMaxAggregateOutputType | null
  }

  type GetFocusCareRequestModelGroupByPayload<T extends FocusCareRequestModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FocusCareRequestModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FocusCareRequestModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FocusCareRequestModelGroupByOutputType[P]>
            : GetScalarType<T[P], FocusCareRequestModelGroupByOutputType[P]>
        }
      >
    >


  export type FocusCareRequestModelSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    care_start_date?: boolean
    care_end_date?: boolean
    detail?: boolean
    status?: boolean
    requester_id?: boolean
    requester?: boolean | CustomerModelArgs
    consultation_times?: boolean | FocusCareRequestModel$consultation_timesArgs
    services?: boolean | FocusCareRequestModel$servicesArgs
    _count?: boolean | FocusCareRequestModelCountOutputTypeArgs
  }


  export type FocusCareRequestModelInclude = {
    requester?: boolean | CustomerModelArgs
    consultation_times?: boolean | FocusCareRequestModel$consultation_timesArgs
    services?: boolean | FocusCareRequestModel$servicesArgs
    _count?: boolean | FocusCareRequestModelCountOutputTypeArgs
  }

  export type FocusCareRequestModelGetPayload<S extends boolean | null | undefined | FocusCareRequestModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FocusCareRequestModel :
    S extends undefined ? never :
    S extends { include: any } & (FocusCareRequestModelArgs | FocusCareRequestModelFindManyArgs)
    ? FocusCareRequestModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'requester' ? CustomerModelGetPayload<S['include'][P]> :
        P extends 'consultation_times' ? Array < FocusCareConsultationTimeCheckModelGetPayload<S['include'][P]>>  :
        P extends 'services' ? Array < FocusCareServiceCheckModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? FocusCareRequestModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FocusCareRequestModelArgs | FocusCareRequestModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'requester' ? CustomerModelGetPayload<S['select'][P]> :
        P extends 'consultation_times' ? Array < FocusCareConsultationTimeCheckModelGetPayload<S['select'][P]>>  :
        P extends 'services' ? Array < FocusCareServiceCheckModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? FocusCareRequestModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof FocusCareRequestModel ? FocusCareRequestModel[P] : never
  } 
      : FocusCareRequestModel


  type FocusCareRequestModelCountArgs = 
    Omit<FocusCareRequestModelFindManyArgs, 'select' | 'include'> & {
      select?: FocusCareRequestModelCountAggregateInputType | true
    }

  export interface FocusCareRequestModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FocusCareRequestModel that matches the filter.
     * @param {FocusCareRequestModelFindUniqueArgs} args - Arguments to find a FocusCareRequestModel
     * @example
     * // Get one FocusCareRequestModel
     * const focusCareRequestModel = await prisma.focusCareRequestModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FocusCareRequestModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FocusCareRequestModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FocusCareRequestModel'> extends True ? Prisma__FocusCareRequestModelClient<FocusCareRequestModelGetPayload<T>> : Prisma__FocusCareRequestModelClient<FocusCareRequestModelGetPayload<T> | null, null>

    /**
     * Find one FocusCareRequestModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FocusCareRequestModelFindUniqueOrThrowArgs} args - Arguments to find a FocusCareRequestModel
     * @example
     * // Get one FocusCareRequestModel
     * const focusCareRequestModel = await prisma.focusCareRequestModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FocusCareRequestModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FocusCareRequestModelFindUniqueOrThrowArgs>
    ): Prisma__FocusCareRequestModelClient<FocusCareRequestModelGetPayload<T>>

    /**
     * Find the first FocusCareRequestModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FocusCareRequestModelFindFirstArgs} args - Arguments to find a FocusCareRequestModel
     * @example
     * // Get one FocusCareRequestModel
     * const focusCareRequestModel = await prisma.focusCareRequestModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FocusCareRequestModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FocusCareRequestModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FocusCareRequestModel'> extends True ? Prisma__FocusCareRequestModelClient<FocusCareRequestModelGetPayload<T>> : Prisma__FocusCareRequestModelClient<FocusCareRequestModelGetPayload<T> | null, null>

    /**
     * Find the first FocusCareRequestModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FocusCareRequestModelFindFirstOrThrowArgs} args - Arguments to find a FocusCareRequestModel
     * @example
     * // Get one FocusCareRequestModel
     * const focusCareRequestModel = await prisma.focusCareRequestModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FocusCareRequestModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FocusCareRequestModelFindFirstOrThrowArgs>
    ): Prisma__FocusCareRequestModelClient<FocusCareRequestModelGetPayload<T>>

    /**
     * Find zero or more FocusCareRequestModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FocusCareRequestModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FocusCareRequestModels
     * const focusCareRequestModels = await prisma.focusCareRequestModel.findMany()
     * 
     * // Get first 10 FocusCareRequestModels
     * const focusCareRequestModels = await prisma.focusCareRequestModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const focusCareRequestModelWithIdOnly = await prisma.focusCareRequestModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FocusCareRequestModelFindManyArgs>(
      args?: SelectSubset<T, FocusCareRequestModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<FocusCareRequestModelGetPayload<T>>>

    /**
     * Create a FocusCareRequestModel.
     * @param {FocusCareRequestModelCreateArgs} args - Arguments to create a FocusCareRequestModel.
     * @example
     * // Create one FocusCareRequestModel
     * const FocusCareRequestModel = await prisma.focusCareRequestModel.create({
     *   data: {
     *     // ... data to create a FocusCareRequestModel
     *   }
     * })
     * 
    **/
    create<T extends FocusCareRequestModelCreateArgs>(
      args: SelectSubset<T, FocusCareRequestModelCreateArgs>
    ): Prisma__FocusCareRequestModelClient<FocusCareRequestModelGetPayload<T>>

    /**
     * Create many FocusCareRequestModels.
     *     @param {FocusCareRequestModelCreateManyArgs} args - Arguments to create many FocusCareRequestModels.
     *     @example
     *     // Create many FocusCareRequestModels
     *     const focusCareRequestModel = await prisma.focusCareRequestModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FocusCareRequestModelCreateManyArgs>(
      args?: SelectSubset<T, FocusCareRequestModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FocusCareRequestModel.
     * @param {FocusCareRequestModelDeleteArgs} args - Arguments to delete one FocusCareRequestModel.
     * @example
     * // Delete one FocusCareRequestModel
     * const FocusCareRequestModel = await prisma.focusCareRequestModel.delete({
     *   where: {
     *     // ... filter to delete one FocusCareRequestModel
     *   }
     * })
     * 
    **/
    delete<T extends FocusCareRequestModelDeleteArgs>(
      args: SelectSubset<T, FocusCareRequestModelDeleteArgs>
    ): Prisma__FocusCareRequestModelClient<FocusCareRequestModelGetPayload<T>>

    /**
     * Update one FocusCareRequestModel.
     * @param {FocusCareRequestModelUpdateArgs} args - Arguments to update one FocusCareRequestModel.
     * @example
     * // Update one FocusCareRequestModel
     * const focusCareRequestModel = await prisma.focusCareRequestModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FocusCareRequestModelUpdateArgs>(
      args: SelectSubset<T, FocusCareRequestModelUpdateArgs>
    ): Prisma__FocusCareRequestModelClient<FocusCareRequestModelGetPayload<T>>

    /**
     * Delete zero or more FocusCareRequestModels.
     * @param {FocusCareRequestModelDeleteManyArgs} args - Arguments to filter FocusCareRequestModels to delete.
     * @example
     * // Delete a few FocusCareRequestModels
     * const { count } = await prisma.focusCareRequestModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FocusCareRequestModelDeleteManyArgs>(
      args?: SelectSubset<T, FocusCareRequestModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FocusCareRequestModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FocusCareRequestModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FocusCareRequestModels
     * const focusCareRequestModel = await prisma.focusCareRequestModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FocusCareRequestModelUpdateManyArgs>(
      args: SelectSubset<T, FocusCareRequestModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FocusCareRequestModel.
     * @param {FocusCareRequestModelUpsertArgs} args - Arguments to update or create a FocusCareRequestModel.
     * @example
     * // Update or create a FocusCareRequestModel
     * const focusCareRequestModel = await prisma.focusCareRequestModel.upsert({
     *   create: {
     *     // ... data to create a FocusCareRequestModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FocusCareRequestModel we want to update
     *   }
     * })
    **/
    upsert<T extends FocusCareRequestModelUpsertArgs>(
      args: SelectSubset<T, FocusCareRequestModelUpsertArgs>
    ): Prisma__FocusCareRequestModelClient<FocusCareRequestModelGetPayload<T>>

    /**
     * Count the number of FocusCareRequestModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FocusCareRequestModelCountArgs} args - Arguments to filter FocusCareRequestModels to count.
     * @example
     * // Count the number of FocusCareRequestModels
     * const count = await prisma.focusCareRequestModel.count({
     *   where: {
     *     // ... the filter for the FocusCareRequestModels we want to count
     *   }
     * })
    **/
    count<T extends FocusCareRequestModelCountArgs>(
      args?: Subset<T, FocusCareRequestModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FocusCareRequestModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FocusCareRequestModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FocusCareRequestModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FocusCareRequestModelAggregateArgs>(args: Subset<T, FocusCareRequestModelAggregateArgs>): Prisma.PrismaPromise<GetFocusCareRequestModelAggregateType<T>>

    /**
     * Group by FocusCareRequestModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FocusCareRequestModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FocusCareRequestModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FocusCareRequestModelGroupByArgs['orderBy'] }
        : { orderBy?: FocusCareRequestModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FocusCareRequestModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFocusCareRequestModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FocusCareRequestModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FocusCareRequestModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    requester<T extends CustomerModelArgs= {}>(args?: Subset<T, CustomerModelArgs>): Prisma__CustomerModelClient<CustomerModelGetPayload<T> | Null>;

    consultation_times<T extends FocusCareRequestModel$consultation_timesArgs= {}>(args?: Subset<T, FocusCareRequestModel$consultation_timesArgs>): Prisma.PrismaPromise<Array<FocusCareConsultationTimeCheckModelGetPayload<T>>| Null>;

    services<T extends FocusCareRequestModel$servicesArgs= {}>(args?: Subset<T, FocusCareRequestModel$servicesArgs>): Prisma.PrismaPromise<Array<FocusCareServiceCheckModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FocusCareRequestModel base type for findUnique actions
   */
  export type FocusCareRequestModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FocusCareRequestModel
     */
    select?: FocusCareRequestModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareRequestModelInclude | null
    /**
     * Filter, which FocusCareRequestModel to fetch.
     */
    where: FocusCareRequestModelWhereUniqueInput
  }

  /**
   * FocusCareRequestModel findUnique
   */
  export interface FocusCareRequestModelFindUniqueArgs extends FocusCareRequestModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FocusCareRequestModel findUniqueOrThrow
   */
  export type FocusCareRequestModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FocusCareRequestModel
     */
    select?: FocusCareRequestModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareRequestModelInclude | null
    /**
     * Filter, which FocusCareRequestModel to fetch.
     */
    where: FocusCareRequestModelWhereUniqueInput
  }


  /**
   * FocusCareRequestModel base type for findFirst actions
   */
  export type FocusCareRequestModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FocusCareRequestModel
     */
    select?: FocusCareRequestModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareRequestModelInclude | null
    /**
     * Filter, which FocusCareRequestModel to fetch.
     */
    where?: FocusCareRequestModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FocusCareRequestModels to fetch.
     */
    orderBy?: Enumerable<FocusCareRequestModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FocusCareRequestModels.
     */
    cursor?: FocusCareRequestModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FocusCareRequestModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FocusCareRequestModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FocusCareRequestModels.
     */
    distinct?: Enumerable<FocusCareRequestModelScalarFieldEnum>
  }

  /**
   * FocusCareRequestModel findFirst
   */
  export interface FocusCareRequestModelFindFirstArgs extends FocusCareRequestModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FocusCareRequestModel findFirstOrThrow
   */
  export type FocusCareRequestModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FocusCareRequestModel
     */
    select?: FocusCareRequestModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareRequestModelInclude | null
    /**
     * Filter, which FocusCareRequestModel to fetch.
     */
    where?: FocusCareRequestModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FocusCareRequestModels to fetch.
     */
    orderBy?: Enumerable<FocusCareRequestModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FocusCareRequestModels.
     */
    cursor?: FocusCareRequestModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FocusCareRequestModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FocusCareRequestModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FocusCareRequestModels.
     */
    distinct?: Enumerable<FocusCareRequestModelScalarFieldEnum>
  }


  /**
   * FocusCareRequestModel findMany
   */
  export type FocusCareRequestModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the FocusCareRequestModel
     */
    select?: FocusCareRequestModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareRequestModelInclude | null
    /**
     * Filter, which FocusCareRequestModels to fetch.
     */
    where?: FocusCareRequestModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FocusCareRequestModels to fetch.
     */
    orderBy?: Enumerable<FocusCareRequestModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FocusCareRequestModels.
     */
    cursor?: FocusCareRequestModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FocusCareRequestModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FocusCareRequestModels.
     */
    skip?: number
    distinct?: Enumerable<FocusCareRequestModelScalarFieldEnum>
  }


  /**
   * FocusCareRequestModel create
   */
  export type FocusCareRequestModelCreateArgs = {
    /**
     * Select specific fields to fetch from the FocusCareRequestModel
     */
    select?: FocusCareRequestModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareRequestModelInclude | null
    /**
     * The data needed to create a FocusCareRequestModel.
     */
    data: XOR<FocusCareRequestModelCreateInput, FocusCareRequestModelUncheckedCreateInput>
  }


  /**
   * FocusCareRequestModel createMany
   */
  export type FocusCareRequestModelCreateManyArgs = {
    /**
     * The data used to create many FocusCareRequestModels.
     */
    data: Enumerable<FocusCareRequestModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FocusCareRequestModel update
   */
  export type FocusCareRequestModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the FocusCareRequestModel
     */
    select?: FocusCareRequestModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareRequestModelInclude | null
    /**
     * The data needed to update a FocusCareRequestModel.
     */
    data: XOR<FocusCareRequestModelUpdateInput, FocusCareRequestModelUncheckedUpdateInput>
    /**
     * Choose, which FocusCareRequestModel to update.
     */
    where: FocusCareRequestModelWhereUniqueInput
  }


  /**
   * FocusCareRequestModel updateMany
   */
  export type FocusCareRequestModelUpdateManyArgs = {
    /**
     * The data used to update FocusCareRequestModels.
     */
    data: XOR<FocusCareRequestModelUpdateManyMutationInput, FocusCareRequestModelUncheckedUpdateManyInput>
    /**
     * Filter which FocusCareRequestModels to update
     */
    where?: FocusCareRequestModelWhereInput
  }


  /**
   * FocusCareRequestModel upsert
   */
  export type FocusCareRequestModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the FocusCareRequestModel
     */
    select?: FocusCareRequestModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareRequestModelInclude | null
    /**
     * The filter to search for the FocusCareRequestModel to update in case it exists.
     */
    where: FocusCareRequestModelWhereUniqueInput
    /**
     * In case the FocusCareRequestModel found by the `where` argument doesn't exist, create a new FocusCareRequestModel with this data.
     */
    create: XOR<FocusCareRequestModelCreateInput, FocusCareRequestModelUncheckedCreateInput>
    /**
     * In case the FocusCareRequestModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FocusCareRequestModelUpdateInput, FocusCareRequestModelUncheckedUpdateInput>
  }


  /**
   * FocusCareRequestModel delete
   */
  export type FocusCareRequestModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the FocusCareRequestModel
     */
    select?: FocusCareRequestModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareRequestModelInclude | null
    /**
     * Filter which FocusCareRequestModel to delete.
     */
    where: FocusCareRequestModelWhereUniqueInput
  }


  /**
   * FocusCareRequestModel deleteMany
   */
  export type FocusCareRequestModelDeleteManyArgs = {
    /**
     * Filter which FocusCareRequestModels to delete
     */
    where?: FocusCareRequestModelWhereInput
  }


  /**
   * FocusCareRequestModel.consultation_times
   */
  export type FocusCareRequestModel$consultation_timesArgs = {
    /**
     * Select specific fields to fetch from the FocusCareConsultationTimeCheckModel
     */
    select?: FocusCareConsultationTimeCheckModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareConsultationTimeCheckModelInclude | null
    where?: FocusCareConsultationTimeCheckModelWhereInput
    orderBy?: Enumerable<FocusCareConsultationTimeCheckModelOrderByWithRelationInput>
    cursor?: FocusCareConsultationTimeCheckModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FocusCareConsultationTimeCheckModelScalarFieldEnum>
  }


  /**
   * FocusCareRequestModel.services
   */
  export type FocusCareRequestModel$servicesArgs = {
    /**
     * Select specific fields to fetch from the FocusCareServiceCheckModel
     */
    select?: FocusCareServiceCheckModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareServiceCheckModelInclude | null
    where?: FocusCareServiceCheckModelWhereInput
    orderBy?: Enumerable<FocusCareServiceCheckModelOrderByWithRelationInput>
    cursor?: FocusCareServiceCheckModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FocusCareServiceCheckModelScalarFieldEnum>
  }


  /**
   * FocusCareRequestModel without action
   */
  export type FocusCareRequestModelArgs = {
    /**
     * Select specific fields to fetch from the FocusCareRequestModel
     */
    select?: FocusCareRequestModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareRequestModelInclude | null
  }



  /**
   * Model FocusCareServiceCheckModel
   */


  export type AggregateFocusCareServiceCheckModel = {
    _count: FocusCareServiceCheckModelCountAggregateOutputType | null
    _min: FocusCareServiceCheckModelMinAggregateOutputType | null
    _max: FocusCareServiceCheckModelMaxAggregateOutputType | null
  }

  export type FocusCareServiceCheckModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    service_super_category_id: string | null
    request_id: string | null
  }

  export type FocusCareServiceCheckModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    service_super_category_id: string | null
    request_id: string | null
  }

  export type FocusCareServiceCheckModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    service_super_category_id: number
    request_id: number
    _all: number
  }


  export type FocusCareServiceCheckModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    service_super_category_id?: true
    request_id?: true
  }

  export type FocusCareServiceCheckModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    service_super_category_id?: true
    request_id?: true
  }

  export type FocusCareServiceCheckModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    service_super_category_id?: true
    request_id?: true
    _all?: true
  }

  export type FocusCareServiceCheckModelAggregateArgs = {
    /**
     * Filter which FocusCareServiceCheckModel to aggregate.
     */
    where?: FocusCareServiceCheckModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FocusCareServiceCheckModels to fetch.
     */
    orderBy?: Enumerable<FocusCareServiceCheckModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FocusCareServiceCheckModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FocusCareServiceCheckModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FocusCareServiceCheckModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FocusCareServiceCheckModels
    **/
    _count?: true | FocusCareServiceCheckModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FocusCareServiceCheckModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FocusCareServiceCheckModelMaxAggregateInputType
  }

  export type GetFocusCareServiceCheckModelAggregateType<T extends FocusCareServiceCheckModelAggregateArgs> = {
        [P in keyof T & keyof AggregateFocusCareServiceCheckModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFocusCareServiceCheckModel[P]>
      : GetScalarType<T[P], AggregateFocusCareServiceCheckModel[P]>
  }




  export type FocusCareServiceCheckModelGroupByArgs = {
    where?: FocusCareServiceCheckModelWhereInput
    orderBy?: Enumerable<FocusCareServiceCheckModelOrderByWithAggregationInput>
    by: FocusCareServiceCheckModelScalarFieldEnum[]
    having?: FocusCareServiceCheckModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FocusCareServiceCheckModelCountAggregateInputType | true
    _min?: FocusCareServiceCheckModelMinAggregateInputType
    _max?: FocusCareServiceCheckModelMaxAggregateInputType
  }


  export type FocusCareServiceCheckModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    service_super_category_id: string
    request_id: string
    _count: FocusCareServiceCheckModelCountAggregateOutputType | null
    _min: FocusCareServiceCheckModelMinAggregateOutputType | null
    _max: FocusCareServiceCheckModelMaxAggregateOutputType | null
  }

  type GetFocusCareServiceCheckModelGroupByPayload<T extends FocusCareServiceCheckModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FocusCareServiceCheckModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FocusCareServiceCheckModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FocusCareServiceCheckModelGroupByOutputType[P]>
            : GetScalarType<T[P], FocusCareServiceCheckModelGroupByOutputType[P]>
        }
      >
    >


  export type FocusCareServiceCheckModelSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    service_super_category_id?: boolean
    request_id?: boolean
    service_super_category?: boolean | ServiceSuperCategoryModelArgs
    request?: boolean | FocusCareRequestModelArgs
  }


  export type FocusCareServiceCheckModelInclude = {
    service_super_category?: boolean | ServiceSuperCategoryModelArgs
    request?: boolean | FocusCareRequestModelArgs
  }

  export type FocusCareServiceCheckModelGetPayload<S extends boolean | null | undefined | FocusCareServiceCheckModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FocusCareServiceCheckModel :
    S extends undefined ? never :
    S extends { include: any } & (FocusCareServiceCheckModelArgs | FocusCareServiceCheckModelFindManyArgs)
    ? FocusCareServiceCheckModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'service_super_category' ? ServiceSuperCategoryModelGetPayload<S['include'][P]> :
        P extends 'request' ? FocusCareRequestModelGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FocusCareServiceCheckModelArgs | FocusCareServiceCheckModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'service_super_category' ? ServiceSuperCategoryModelGetPayload<S['select'][P]> :
        P extends 'request' ? FocusCareRequestModelGetPayload<S['select'][P]> :  P extends keyof FocusCareServiceCheckModel ? FocusCareServiceCheckModel[P] : never
  } 
      : FocusCareServiceCheckModel


  type FocusCareServiceCheckModelCountArgs = 
    Omit<FocusCareServiceCheckModelFindManyArgs, 'select' | 'include'> & {
      select?: FocusCareServiceCheckModelCountAggregateInputType | true
    }

  export interface FocusCareServiceCheckModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FocusCareServiceCheckModel that matches the filter.
     * @param {FocusCareServiceCheckModelFindUniqueArgs} args - Arguments to find a FocusCareServiceCheckModel
     * @example
     * // Get one FocusCareServiceCheckModel
     * const focusCareServiceCheckModel = await prisma.focusCareServiceCheckModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FocusCareServiceCheckModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FocusCareServiceCheckModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FocusCareServiceCheckModel'> extends True ? Prisma__FocusCareServiceCheckModelClient<FocusCareServiceCheckModelGetPayload<T>> : Prisma__FocusCareServiceCheckModelClient<FocusCareServiceCheckModelGetPayload<T> | null, null>

    /**
     * Find one FocusCareServiceCheckModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FocusCareServiceCheckModelFindUniqueOrThrowArgs} args - Arguments to find a FocusCareServiceCheckModel
     * @example
     * // Get one FocusCareServiceCheckModel
     * const focusCareServiceCheckModel = await prisma.focusCareServiceCheckModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FocusCareServiceCheckModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FocusCareServiceCheckModelFindUniqueOrThrowArgs>
    ): Prisma__FocusCareServiceCheckModelClient<FocusCareServiceCheckModelGetPayload<T>>

    /**
     * Find the first FocusCareServiceCheckModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FocusCareServiceCheckModelFindFirstArgs} args - Arguments to find a FocusCareServiceCheckModel
     * @example
     * // Get one FocusCareServiceCheckModel
     * const focusCareServiceCheckModel = await prisma.focusCareServiceCheckModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FocusCareServiceCheckModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FocusCareServiceCheckModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FocusCareServiceCheckModel'> extends True ? Prisma__FocusCareServiceCheckModelClient<FocusCareServiceCheckModelGetPayload<T>> : Prisma__FocusCareServiceCheckModelClient<FocusCareServiceCheckModelGetPayload<T> | null, null>

    /**
     * Find the first FocusCareServiceCheckModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FocusCareServiceCheckModelFindFirstOrThrowArgs} args - Arguments to find a FocusCareServiceCheckModel
     * @example
     * // Get one FocusCareServiceCheckModel
     * const focusCareServiceCheckModel = await prisma.focusCareServiceCheckModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FocusCareServiceCheckModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FocusCareServiceCheckModelFindFirstOrThrowArgs>
    ): Prisma__FocusCareServiceCheckModelClient<FocusCareServiceCheckModelGetPayload<T>>

    /**
     * Find zero or more FocusCareServiceCheckModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FocusCareServiceCheckModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FocusCareServiceCheckModels
     * const focusCareServiceCheckModels = await prisma.focusCareServiceCheckModel.findMany()
     * 
     * // Get first 10 FocusCareServiceCheckModels
     * const focusCareServiceCheckModels = await prisma.focusCareServiceCheckModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const focusCareServiceCheckModelWithIdOnly = await prisma.focusCareServiceCheckModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FocusCareServiceCheckModelFindManyArgs>(
      args?: SelectSubset<T, FocusCareServiceCheckModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<FocusCareServiceCheckModelGetPayload<T>>>

    /**
     * Create a FocusCareServiceCheckModel.
     * @param {FocusCareServiceCheckModelCreateArgs} args - Arguments to create a FocusCareServiceCheckModel.
     * @example
     * // Create one FocusCareServiceCheckModel
     * const FocusCareServiceCheckModel = await prisma.focusCareServiceCheckModel.create({
     *   data: {
     *     // ... data to create a FocusCareServiceCheckModel
     *   }
     * })
     * 
    **/
    create<T extends FocusCareServiceCheckModelCreateArgs>(
      args: SelectSubset<T, FocusCareServiceCheckModelCreateArgs>
    ): Prisma__FocusCareServiceCheckModelClient<FocusCareServiceCheckModelGetPayload<T>>

    /**
     * Create many FocusCareServiceCheckModels.
     *     @param {FocusCareServiceCheckModelCreateManyArgs} args - Arguments to create many FocusCareServiceCheckModels.
     *     @example
     *     // Create many FocusCareServiceCheckModels
     *     const focusCareServiceCheckModel = await prisma.focusCareServiceCheckModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FocusCareServiceCheckModelCreateManyArgs>(
      args?: SelectSubset<T, FocusCareServiceCheckModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FocusCareServiceCheckModel.
     * @param {FocusCareServiceCheckModelDeleteArgs} args - Arguments to delete one FocusCareServiceCheckModel.
     * @example
     * // Delete one FocusCareServiceCheckModel
     * const FocusCareServiceCheckModel = await prisma.focusCareServiceCheckModel.delete({
     *   where: {
     *     // ... filter to delete one FocusCareServiceCheckModel
     *   }
     * })
     * 
    **/
    delete<T extends FocusCareServiceCheckModelDeleteArgs>(
      args: SelectSubset<T, FocusCareServiceCheckModelDeleteArgs>
    ): Prisma__FocusCareServiceCheckModelClient<FocusCareServiceCheckModelGetPayload<T>>

    /**
     * Update one FocusCareServiceCheckModel.
     * @param {FocusCareServiceCheckModelUpdateArgs} args - Arguments to update one FocusCareServiceCheckModel.
     * @example
     * // Update one FocusCareServiceCheckModel
     * const focusCareServiceCheckModel = await prisma.focusCareServiceCheckModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FocusCareServiceCheckModelUpdateArgs>(
      args: SelectSubset<T, FocusCareServiceCheckModelUpdateArgs>
    ): Prisma__FocusCareServiceCheckModelClient<FocusCareServiceCheckModelGetPayload<T>>

    /**
     * Delete zero or more FocusCareServiceCheckModels.
     * @param {FocusCareServiceCheckModelDeleteManyArgs} args - Arguments to filter FocusCareServiceCheckModels to delete.
     * @example
     * // Delete a few FocusCareServiceCheckModels
     * const { count } = await prisma.focusCareServiceCheckModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FocusCareServiceCheckModelDeleteManyArgs>(
      args?: SelectSubset<T, FocusCareServiceCheckModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FocusCareServiceCheckModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FocusCareServiceCheckModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FocusCareServiceCheckModels
     * const focusCareServiceCheckModel = await prisma.focusCareServiceCheckModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FocusCareServiceCheckModelUpdateManyArgs>(
      args: SelectSubset<T, FocusCareServiceCheckModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FocusCareServiceCheckModel.
     * @param {FocusCareServiceCheckModelUpsertArgs} args - Arguments to update or create a FocusCareServiceCheckModel.
     * @example
     * // Update or create a FocusCareServiceCheckModel
     * const focusCareServiceCheckModel = await prisma.focusCareServiceCheckModel.upsert({
     *   create: {
     *     // ... data to create a FocusCareServiceCheckModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FocusCareServiceCheckModel we want to update
     *   }
     * })
    **/
    upsert<T extends FocusCareServiceCheckModelUpsertArgs>(
      args: SelectSubset<T, FocusCareServiceCheckModelUpsertArgs>
    ): Prisma__FocusCareServiceCheckModelClient<FocusCareServiceCheckModelGetPayload<T>>

    /**
     * Count the number of FocusCareServiceCheckModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FocusCareServiceCheckModelCountArgs} args - Arguments to filter FocusCareServiceCheckModels to count.
     * @example
     * // Count the number of FocusCareServiceCheckModels
     * const count = await prisma.focusCareServiceCheckModel.count({
     *   where: {
     *     // ... the filter for the FocusCareServiceCheckModels we want to count
     *   }
     * })
    **/
    count<T extends FocusCareServiceCheckModelCountArgs>(
      args?: Subset<T, FocusCareServiceCheckModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FocusCareServiceCheckModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FocusCareServiceCheckModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FocusCareServiceCheckModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FocusCareServiceCheckModelAggregateArgs>(args: Subset<T, FocusCareServiceCheckModelAggregateArgs>): Prisma.PrismaPromise<GetFocusCareServiceCheckModelAggregateType<T>>

    /**
     * Group by FocusCareServiceCheckModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FocusCareServiceCheckModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FocusCareServiceCheckModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FocusCareServiceCheckModelGroupByArgs['orderBy'] }
        : { orderBy?: FocusCareServiceCheckModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FocusCareServiceCheckModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFocusCareServiceCheckModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FocusCareServiceCheckModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FocusCareServiceCheckModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    service_super_category<T extends ServiceSuperCategoryModelArgs= {}>(args?: Subset<T, ServiceSuperCategoryModelArgs>): Prisma__ServiceSuperCategoryModelClient<ServiceSuperCategoryModelGetPayload<T> | Null>;

    request<T extends FocusCareRequestModelArgs= {}>(args?: Subset<T, FocusCareRequestModelArgs>): Prisma__FocusCareRequestModelClient<FocusCareRequestModelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FocusCareServiceCheckModel base type for findUnique actions
   */
  export type FocusCareServiceCheckModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FocusCareServiceCheckModel
     */
    select?: FocusCareServiceCheckModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareServiceCheckModelInclude | null
    /**
     * Filter, which FocusCareServiceCheckModel to fetch.
     */
    where: FocusCareServiceCheckModelWhereUniqueInput
  }

  /**
   * FocusCareServiceCheckModel findUnique
   */
  export interface FocusCareServiceCheckModelFindUniqueArgs extends FocusCareServiceCheckModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FocusCareServiceCheckModel findUniqueOrThrow
   */
  export type FocusCareServiceCheckModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FocusCareServiceCheckModel
     */
    select?: FocusCareServiceCheckModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareServiceCheckModelInclude | null
    /**
     * Filter, which FocusCareServiceCheckModel to fetch.
     */
    where: FocusCareServiceCheckModelWhereUniqueInput
  }


  /**
   * FocusCareServiceCheckModel base type for findFirst actions
   */
  export type FocusCareServiceCheckModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FocusCareServiceCheckModel
     */
    select?: FocusCareServiceCheckModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareServiceCheckModelInclude | null
    /**
     * Filter, which FocusCareServiceCheckModel to fetch.
     */
    where?: FocusCareServiceCheckModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FocusCareServiceCheckModels to fetch.
     */
    orderBy?: Enumerable<FocusCareServiceCheckModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FocusCareServiceCheckModels.
     */
    cursor?: FocusCareServiceCheckModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FocusCareServiceCheckModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FocusCareServiceCheckModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FocusCareServiceCheckModels.
     */
    distinct?: Enumerable<FocusCareServiceCheckModelScalarFieldEnum>
  }

  /**
   * FocusCareServiceCheckModel findFirst
   */
  export interface FocusCareServiceCheckModelFindFirstArgs extends FocusCareServiceCheckModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FocusCareServiceCheckModel findFirstOrThrow
   */
  export type FocusCareServiceCheckModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FocusCareServiceCheckModel
     */
    select?: FocusCareServiceCheckModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareServiceCheckModelInclude | null
    /**
     * Filter, which FocusCareServiceCheckModel to fetch.
     */
    where?: FocusCareServiceCheckModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FocusCareServiceCheckModels to fetch.
     */
    orderBy?: Enumerable<FocusCareServiceCheckModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FocusCareServiceCheckModels.
     */
    cursor?: FocusCareServiceCheckModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FocusCareServiceCheckModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FocusCareServiceCheckModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FocusCareServiceCheckModels.
     */
    distinct?: Enumerable<FocusCareServiceCheckModelScalarFieldEnum>
  }


  /**
   * FocusCareServiceCheckModel findMany
   */
  export type FocusCareServiceCheckModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the FocusCareServiceCheckModel
     */
    select?: FocusCareServiceCheckModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareServiceCheckModelInclude | null
    /**
     * Filter, which FocusCareServiceCheckModels to fetch.
     */
    where?: FocusCareServiceCheckModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FocusCareServiceCheckModels to fetch.
     */
    orderBy?: Enumerable<FocusCareServiceCheckModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FocusCareServiceCheckModels.
     */
    cursor?: FocusCareServiceCheckModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FocusCareServiceCheckModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FocusCareServiceCheckModels.
     */
    skip?: number
    distinct?: Enumerable<FocusCareServiceCheckModelScalarFieldEnum>
  }


  /**
   * FocusCareServiceCheckModel create
   */
  export type FocusCareServiceCheckModelCreateArgs = {
    /**
     * Select specific fields to fetch from the FocusCareServiceCheckModel
     */
    select?: FocusCareServiceCheckModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareServiceCheckModelInclude | null
    /**
     * The data needed to create a FocusCareServiceCheckModel.
     */
    data: XOR<FocusCareServiceCheckModelCreateInput, FocusCareServiceCheckModelUncheckedCreateInput>
  }


  /**
   * FocusCareServiceCheckModel createMany
   */
  export type FocusCareServiceCheckModelCreateManyArgs = {
    /**
     * The data used to create many FocusCareServiceCheckModels.
     */
    data: Enumerable<FocusCareServiceCheckModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FocusCareServiceCheckModel update
   */
  export type FocusCareServiceCheckModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the FocusCareServiceCheckModel
     */
    select?: FocusCareServiceCheckModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareServiceCheckModelInclude | null
    /**
     * The data needed to update a FocusCareServiceCheckModel.
     */
    data: XOR<FocusCareServiceCheckModelUpdateInput, FocusCareServiceCheckModelUncheckedUpdateInput>
    /**
     * Choose, which FocusCareServiceCheckModel to update.
     */
    where: FocusCareServiceCheckModelWhereUniqueInput
  }


  /**
   * FocusCareServiceCheckModel updateMany
   */
  export type FocusCareServiceCheckModelUpdateManyArgs = {
    /**
     * The data used to update FocusCareServiceCheckModels.
     */
    data: XOR<FocusCareServiceCheckModelUpdateManyMutationInput, FocusCareServiceCheckModelUncheckedUpdateManyInput>
    /**
     * Filter which FocusCareServiceCheckModels to update
     */
    where?: FocusCareServiceCheckModelWhereInput
  }


  /**
   * FocusCareServiceCheckModel upsert
   */
  export type FocusCareServiceCheckModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the FocusCareServiceCheckModel
     */
    select?: FocusCareServiceCheckModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareServiceCheckModelInclude | null
    /**
     * The filter to search for the FocusCareServiceCheckModel to update in case it exists.
     */
    where: FocusCareServiceCheckModelWhereUniqueInput
    /**
     * In case the FocusCareServiceCheckModel found by the `where` argument doesn't exist, create a new FocusCareServiceCheckModel with this data.
     */
    create: XOR<FocusCareServiceCheckModelCreateInput, FocusCareServiceCheckModelUncheckedCreateInput>
    /**
     * In case the FocusCareServiceCheckModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FocusCareServiceCheckModelUpdateInput, FocusCareServiceCheckModelUncheckedUpdateInput>
  }


  /**
   * FocusCareServiceCheckModel delete
   */
  export type FocusCareServiceCheckModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the FocusCareServiceCheckModel
     */
    select?: FocusCareServiceCheckModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareServiceCheckModelInclude | null
    /**
     * Filter which FocusCareServiceCheckModel to delete.
     */
    where: FocusCareServiceCheckModelWhereUniqueInput
  }


  /**
   * FocusCareServiceCheckModel deleteMany
   */
  export type FocusCareServiceCheckModelDeleteManyArgs = {
    /**
     * Filter which FocusCareServiceCheckModels to delete
     */
    where?: FocusCareServiceCheckModelWhereInput
  }


  /**
   * FocusCareServiceCheckModel without action
   */
  export type FocusCareServiceCheckModelArgs = {
    /**
     * Select specific fields to fetch from the FocusCareServiceCheckModel
     */
    select?: FocusCareServiceCheckModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareServiceCheckModelInclude | null
  }



  /**
   * Model FocusCareConsultationTimeCheckModel
   */


  export type AggregateFocusCareConsultationTimeCheckModel = {
    _count: FocusCareConsultationTimeCheckModelCountAggregateOutputType | null
    _min: FocusCareConsultationTimeCheckModelMinAggregateOutputType | null
    _max: FocusCareConsultationTimeCheckModelMaxAggregateOutputType | null
  }

  export type FocusCareConsultationTimeCheckModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    consultation_time_id: string | null
    request_id: string | null
  }

  export type FocusCareConsultationTimeCheckModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    consultation_time_id: string | null
    request_id: string | null
  }

  export type FocusCareConsultationTimeCheckModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    consultation_time_id: number
    request_id: number
    _all: number
  }


  export type FocusCareConsultationTimeCheckModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    consultation_time_id?: true
    request_id?: true
  }

  export type FocusCareConsultationTimeCheckModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    consultation_time_id?: true
    request_id?: true
  }

  export type FocusCareConsultationTimeCheckModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    consultation_time_id?: true
    request_id?: true
    _all?: true
  }

  export type FocusCareConsultationTimeCheckModelAggregateArgs = {
    /**
     * Filter which FocusCareConsultationTimeCheckModel to aggregate.
     */
    where?: FocusCareConsultationTimeCheckModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FocusCareConsultationTimeCheckModels to fetch.
     */
    orderBy?: Enumerable<FocusCareConsultationTimeCheckModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FocusCareConsultationTimeCheckModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FocusCareConsultationTimeCheckModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FocusCareConsultationTimeCheckModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FocusCareConsultationTimeCheckModels
    **/
    _count?: true | FocusCareConsultationTimeCheckModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FocusCareConsultationTimeCheckModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FocusCareConsultationTimeCheckModelMaxAggregateInputType
  }

  export type GetFocusCareConsultationTimeCheckModelAggregateType<T extends FocusCareConsultationTimeCheckModelAggregateArgs> = {
        [P in keyof T & keyof AggregateFocusCareConsultationTimeCheckModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFocusCareConsultationTimeCheckModel[P]>
      : GetScalarType<T[P], AggregateFocusCareConsultationTimeCheckModel[P]>
  }




  export type FocusCareConsultationTimeCheckModelGroupByArgs = {
    where?: FocusCareConsultationTimeCheckModelWhereInput
    orderBy?: Enumerable<FocusCareConsultationTimeCheckModelOrderByWithAggregationInput>
    by: FocusCareConsultationTimeCheckModelScalarFieldEnum[]
    having?: FocusCareConsultationTimeCheckModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FocusCareConsultationTimeCheckModelCountAggregateInputType | true
    _min?: FocusCareConsultationTimeCheckModelMinAggregateInputType
    _max?: FocusCareConsultationTimeCheckModelMaxAggregateInputType
  }


  export type FocusCareConsultationTimeCheckModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    consultation_time_id: string
    request_id: string
    _count: FocusCareConsultationTimeCheckModelCountAggregateOutputType | null
    _min: FocusCareConsultationTimeCheckModelMinAggregateOutputType | null
    _max: FocusCareConsultationTimeCheckModelMaxAggregateOutputType | null
  }

  type GetFocusCareConsultationTimeCheckModelGroupByPayload<T extends FocusCareConsultationTimeCheckModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FocusCareConsultationTimeCheckModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FocusCareConsultationTimeCheckModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FocusCareConsultationTimeCheckModelGroupByOutputType[P]>
            : GetScalarType<T[P], FocusCareConsultationTimeCheckModelGroupByOutputType[P]>
        }
      >
    >


  export type FocusCareConsultationTimeCheckModelSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    consultation_time_id?: boolean
    request_id?: boolean
    consultation_time?: boolean | ConsultationTimeModelArgs
    request?: boolean | FocusCareRequestModelArgs
  }


  export type FocusCareConsultationTimeCheckModelInclude = {
    consultation_time?: boolean | ConsultationTimeModelArgs
    request?: boolean | FocusCareRequestModelArgs
  }

  export type FocusCareConsultationTimeCheckModelGetPayload<S extends boolean | null | undefined | FocusCareConsultationTimeCheckModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FocusCareConsultationTimeCheckModel :
    S extends undefined ? never :
    S extends { include: any } & (FocusCareConsultationTimeCheckModelArgs | FocusCareConsultationTimeCheckModelFindManyArgs)
    ? FocusCareConsultationTimeCheckModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'consultation_time' ? ConsultationTimeModelGetPayload<S['include'][P]> :
        P extends 'request' ? FocusCareRequestModelGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FocusCareConsultationTimeCheckModelArgs | FocusCareConsultationTimeCheckModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'consultation_time' ? ConsultationTimeModelGetPayload<S['select'][P]> :
        P extends 'request' ? FocusCareRequestModelGetPayload<S['select'][P]> :  P extends keyof FocusCareConsultationTimeCheckModel ? FocusCareConsultationTimeCheckModel[P] : never
  } 
      : FocusCareConsultationTimeCheckModel


  type FocusCareConsultationTimeCheckModelCountArgs = 
    Omit<FocusCareConsultationTimeCheckModelFindManyArgs, 'select' | 'include'> & {
      select?: FocusCareConsultationTimeCheckModelCountAggregateInputType | true
    }

  export interface FocusCareConsultationTimeCheckModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one FocusCareConsultationTimeCheckModel that matches the filter.
     * @param {FocusCareConsultationTimeCheckModelFindUniqueArgs} args - Arguments to find a FocusCareConsultationTimeCheckModel
     * @example
     * // Get one FocusCareConsultationTimeCheckModel
     * const focusCareConsultationTimeCheckModel = await prisma.focusCareConsultationTimeCheckModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FocusCareConsultationTimeCheckModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FocusCareConsultationTimeCheckModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'FocusCareConsultationTimeCheckModel'> extends True ? Prisma__FocusCareConsultationTimeCheckModelClient<FocusCareConsultationTimeCheckModelGetPayload<T>> : Prisma__FocusCareConsultationTimeCheckModelClient<FocusCareConsultationTimeCheckModelGetPayload<T> | null, null>

    /**
     * Find one FocusCareConsultationTimeCheckModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FocusCareConsultationTimeCheckModelFindUniqueOrThrowArgs} args - Arguments to find a FocusCareConsultationTimeCheckModel
     * @example
     * // Get one FocusCareConsultationTimeCheckModel
     * const focusCareConsultationTimeCheckModel = await prisma.focusCareConsultationTimeCheckModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FocusCareConsultationTimeCheckModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FocusCareConsultationTimeCheckModelFindUniqueOrThrowArgs>
    ): Prisma__FocusCareConsultationTimeCheckModelClient<FocusCareConsultationTimeCheckModelGetPayload<T>>

    /**
     * Find the first FocusCareConsultationTimeCheckModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FocusCareConsultationTimeCheckModelFindFirstArgs} args - Arguments to find a FocusCareConsultationTimeCheckModel
     * @example
     * // Get one FocusCareConsultationTimeCheckModel
     * const focusCareConsultationTimeCheckModel = await prisma.focusCareConsultationTimeCheckModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FocusCareConsultationTimeCheckModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FocusCareConsultationTimeCheckModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'FocusCareConsultationTimeCheckModel'> extends True ? Prisma__FocusCareConsultationTimeCheckModelClient<FocusCareConsultationTimeCheckModelGetPayload<T>> : Prisma__FocusCareConsultationTimeCheckModelClient<FocusCareConsultationTimeCheckModelGetPayload<T> | null, null>

    /**
     * Find the first FocusCareConsultationTimeCheckModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FocusCareConsultationTimeCheckModelFindFirstOrThrowArgs} args - Arguments to find a FocusCareConsultationTimeCheckModel
     * @example
     * // Get one FocusCareConsultationTimeCheckModel
     * const focusCareConsultationTimeCheckModel = await prisma.focusCareConsultationTimeCheckModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FocusCareConsultationTimeCheckModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FocusCareConsultationTimeCheckModelFindFirstOrThrowArgs>
    ): Prisma__FocusCareConsultationTimeCheckModelClient<FocusCareConsultationTimeCheckModelGetPayload<T>>

    /**
     * Find zero or more FocusCareConsultationTimeCheckModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FocusCareConsultationTimeCheckModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FocusCareConsultationTimeCheckModels
     * const focusCareConsultationTimeCheckModels = await prisma.focusCareConsultationTimeCheckModel.findMany()
     * 
     * // Get first 10 FocusCareConsultationTimeCheckModels
     * const focusCareConsultationTimeCheckModels = await prisma.focusCareConsultationTimeCheckModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const focusCareConsultationTimeCheckModelWithIdOnly = await prisma.focusCareConsultationTimeCheckModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FocusCareConsultationTimeCheckModelFindManyArgs>(
      args?: SelectSubset<T, FocusCareConsultationTimeCheckModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<FocusCareConsultationTimeCheckModelGetPayload<T>>>

    /**
     * Create a FocusCareConsultationTimeCheckModel.
     * @param {FocusCareConsultationTimeCheckModelCreateArgs} args - Arguments to create a FocusCareConsultationTimeCheckModel.
     * @example
     * // Create one FocusCareConsultationTimeCheckModel
     * const FocusCareConsultationTimeCheckModel = await prisma.focusCareConsultationTimeCheckModel.create({
     *   data: {
     *     // ... data to create a FocusCareConsultationTimeCheckModel
     *   }
     * })
     * 
    **/
    create<T extends FocusCareConsultationTimeCheckModelCreateArgs>(
      args: SelectSubset<T, FocusCareConsultationTimeCheckModelCreateArgs>
    ): Prisma__FocusCareConsultationTimeCheckModelClient<FocusCareConsultationTimeCheckModelGetPayload<T>>

    /**
     * Create many FocusCareConsultationTimeCheckModels.
     *     @param {FocusCareConsultationTimeCheckModelCreateManyArgs} args - Arguments to create many FocusCareConsultationTimeCheckModels.
     *     @example
     *     // Create many FocusCareConsultationTimeCheckModels
     *     const focusCareConsultationTimeCheckModel = await prisma.focusCareConsultationTimeCheckModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FocusCareConsultationTimeCheckModelCreateManyArgs>(
      args?: SelectSubset<T, FocusCareConsultationTimeCheckModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FocusCareConsultationTimeCheckModel.
     * @param {FocusCareConsultationTimeCheckModelDeleteArgs} args - Arguments to delete one FocusCareConsultationTimeCheckModel.
     * @example
     * // Delete one FocusCareConsultationTimeCheckModel
     * const FocusCareConsultationTimeCheckModel = await prisma.focusCareConsultationTimeCheckModel.delete({
     *   where: {
     *     // ... filter to delete one FocusCareConsultationTimeCheckModel
     *   }
     * })
     * 
    **/
    delete<T extends FocusCareConsultationTimeCheckModelDeleteArgs>(
      args: SelectSubset<T, FocusCareConsultationTimeCheckModelDeleteArgs>
    ): Prisma__FocusCareConsultationTimeCheckModelClient<FocusCareConsultationTimeCheckModelGetPayload<T>>

    /**
     * Update one FocusCareConsultationTimeCheckModel.
     * @param {FocusCareConsultationTimeCheckModelUpdateArgs} args - Arguments to update one FocusCareConsultationTimeCheckModel.
     * @example
     * // Update one FocusCareConsultationTimeCheckModel
     * const focusCareConsultationTimeCheckModel = await prisma.focusCareConsultationTimeCheckModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FocusCareConsultationTimeCheckModelUpdateArgs>(
      args: SelectSubset<T, FocusCareConsultationTimeCheckModelUpdateArgs>
    ): Prisma__FocusCareConsultationTimeCheckModelClient<FocusCareConsultationTimeCheckModelGetPayload<T>>

    /**
     * Delete zero or more FocusCareConsultationTimeCheckModels.
     * @param {FocusCareConsultationTimeCheckModelDeleteManyArgs} args - Arguments to filter FocusCareConsultationTimeCheckModels to delete.
     * @example
     * // Delete a few FocusCareConsultationTimeCheckModels
     * const { count } = await prisma.focusCareConsultationTimeCheckModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FocusCareConsultationTimeCheckModelDeleteManyArgs>(
      args?: SelectSubset<T, FocusCareConsultationTimeCheckModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FocusCareConsultationTimeCheckModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FocusCareConsultationTimeCheckModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FocusCareConsultationTimeCheckModels
     * const focusCareConsultationTimeCheckModel = await prisma.focusCareConsultationTimeCheckModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FocusCareConsultationTimeCheckModelUpdateManyArgs>(
      args: SelectSubset<T, FocusCareConsultationTimeCheckModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FocusCareConsultationTimeCheckModel.
     * @param {FocusCareConsultationTimeCheckModelUpsertArgs} args - Arguments to update or create a FocusCareConsultationTimeCheckModel.
     * @example
     * // Update or create a FocusCareConsultationTimeCheckModel
     * const focusCareConsultationTimeCheckModel = await prisma.focusCareConsultationTimeCheckModel.upsert({
     *   create: {
     *     // ... data to create a FocusCareConsultationTimeCheckModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FocusCareConsultationTimeCheckModel we want to update
     *   }
     * })
    **/
    upsert<T extends FocusCareConsultationTimeCheckModelUpsertArgs>(
      args: SelectSubset<T, FocusCareConsultationTimeCheckModelUpsertArgs>
    ): Prisma__FocusCareConsultationTimeCheckModelClient<FocusCareConsultationTimeCheckModelGetPayload<T>>

    /**
     * Count the number of FocusCareConsultationTimeCheckModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FocusCareConsultationTimeCheckModelCountArgs} args - Arguments to filter FocusCareConsultationTimeCheckModels to count.
     * @example
     * // Count the number of FocusCareConsultationTimeCheckModels
     * const count = await prisma.focusCareConsultationTimeCheckModel.count({
     *   where: {
     *     // ... the filter for the FocusCareConsultationTimeCheckModels we want to count
     *   }
     * })
    **/
    count<T extends FocusCareConsultationTimeCheckModelCountArgs>(
      args?: Subset<T, FocusCareConsultationTimeCheckModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FocusCareConsultationTimeCheckModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FocusCareConsultationTimeCheckModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FocusCareConsultationTimeCheckModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FocusCareConsultationTimeCheckModelAggregateArgs>(args: Subset<T, FocusCareConsultationTimeCheckModelAggregateArgs>): Prisma.PrismaPromise<GetFocusCareConsultationTimeCheckModelAggregateType<T>>

    /**
     * Group by FocusCareConsultationTimeCheckModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FocusCareConsultationTimeCheckModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FocusCareConsultationTimeCheckModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FocusCareConsultationTimeCheckModelGroupByArgs['orderBy'] }
        : { orderBy?: FocusCareConsultationTimeCheckModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FocusCareConsultationTimeCheckModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFocusCareConsultationTimeCheckModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for FocusCareConsultationTimeCheckModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FocusCareConsultationTimeCheckModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    consultation_time<T extends ConsultationTimeModelArgs= {}>(args?: Subset<T, ConsultationTimeModelArgs>): Prisma__ConsultationTimeModelClient<ConsultationTimeModelGetPayload<T> | Null>;

    request<T extends FocusCareRequestModelArgs= {}>(args?: Subset<T, FocusCareRequestModelArgs>): Prisma__FocusCareRequestModelClient<FocusCareRequestModelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * FocusCareConsultationTimeCheckModel base type for findUnique actions
   */
  export type FocusCareConsultationTimeCheckModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the FocusCareConsultationTimeCheckModel
     */
    select?: FocusCareConsultationTimeCheckModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareConsultationTimeCheckModelInclude | null
    /**
     * Filter, which FocusCareConsultationTimeCheckModel to fetch.
     */
    where: FocusCareConsultationTimeCheckModelWhereUniqueInput
  }

  /**
   * FocusCareConsultationTimeCheckModel findUnique
   */
  export interface FocusCareConsultationTimeCheckModelFindUniqueArgs extends FocusCareConsultationTimeCheckModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FocusCareConsultationTimeCheckModel findUniqueOrThrow
   */
  export type FocusCareConsultationTimeCheckModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FocusCareConsultationTimeCheckModel
     */
    select?: FocusCareConsultationTimeCheckModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareConsultationTimeCheckModelInclude | null
    /**
     * Filter, which FocusCareConsultationTimeCheckModel to fetch.
     */
    where: FocusCareConsultationTimeCheckModelWhereUniqueInput
  }


  /**
   * FocusCareConsultationTimeCheckModel base type for findFirst actions
   */
  export type FocusCareConsultationTimeCheckModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the FocusCareConsultationTimeCheckModel
     */
    select?: FocusCareConsultationTimeCheckModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareConsultationTimeCheckModelInclude | null
    /**
     * Filter, which FocusCareConsultationTimeCheckModel to fetch.
     */
    where?: FocusCareConsultationTimeCheckModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FocusCareConsultationTimeCheckModels to fetch.
     */
    orderBy?: Enumerable<FocusCareConsultationTimeCheckModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FocusCareConsultationTimeCheckModels.
     */
    cursor?: FocusCareConsultationTimeCheckModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FocusCareConsultationTimeCheckModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FocusCareConsultationTimeCheckModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FocusCareConsultationTimeCheckModels.
     */
    distinct?: Enumerable<FocusCareConsultationTimeCheckModelScalarFieldEnum>
  }

  /**
   * FocusCareConsultationTimeCheckModel findFirst
   */
  export interface FocusCareConsultationTimeCheckModelFindFirstArgs extends FocusCareConsultationTimeCheckModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * FocusCareConsultationTimeCheckModel findFirstOrThrow
   */
  export type FocusCareConsultationTimeCheckModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the FocusCareConsultationTimeCheckModel
     */
    select?: FocusCareConsultationTimeCheckModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareConsultationTimeCheckModelInclude | null
    /**
     * Filter, which FocusCareConsultationTimeCheckModel to fetch.
     */
    where?: FocusCareConsultationTimeCheckModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FocusCareConsultationTimeCheckModels to fetch.
     */
    orderBy?: Enumerable<FocusCareConsultationTimeCheckModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FocusCareConsultationTimeCheckModels.
     */
    cursor?: FocusCareConsultationTimeCheckModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FocusCareConsultationTimeCheckModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FocusCareConsultationTimeCheckModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FocusCareConsultationTimeCheckModels.
     */
    distinct?: Enumerable<FocusCareConsultationTimeCheckModelScalarFieldEnum>
  }


  /**
   * FocusCareConsultationTimeCheckModel findMany
   */
  export type FocusCareConsultationTimeCheckModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the FocusCareConsultationTimeCheckModel
     */
    select?: FocusCareConsultationTimeCheckModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareConsultationTimeCheckModelInclude | null
    /**
     * Filter, which FocusCareConsultationTimeCheckModels to fetch.
     */
    where?: FocusCareConsultationTimeCheckModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FocusCareConsultationTimeCheckModels to fetch.
     */
    orderBy?: Enumerable<FocusCareConsultationTimeCheckModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FocusCareConsultationTimeCheckModels.
     */
    cursor?: FocusCareConsultationTimeCheckModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FocusCareConsultationTimeCheckModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FocusCareConsultationTimeCheckModels.
     */
    skip?: number
    distinct?: Enumerable<FocusCareConsultationTimeCheckModelScalarFieldEnum>
  }


  /**
   * FocusCareConsultationTimeCheckModel create
   */
  export type FocusCareConsultationTimeCheckModelCreateArgs = {
    /**
     * Select specific fields to fetch from the FocusCareConsultationTimeCheckModel
     */
    select?: FocusCareConsultationTimeCheckModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareConsultationTimeCheckModelInclude | null
    /**
     * The data needed to create a FocusCareConsultationTimeCheckModel.
     */
    data: XOR<FocusCareConsultationTimeCheckModelCreateInput, FocusCareConsultationTimeCheckModelUncheckedCreateInput>
  }


  /**
   * FocusCareConsultationTimeCheckModel createMany
   */
  export type FocusCareConsultationTimeCheckModelCreateManyArgs = {
    /**
     * The data used to create many FocusCareConsultationTimeCheckModels.
     */
    data: Enumerable<FocusCareConsultationTimeCheckModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * FocusCareConsultationTimeCheckModel update
   */
  export type FocusCareConsultationTimeCheckModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the FocusCareConsultationTimeCheckModel
     */
    select?: FocusCareConsultationTimeCheckModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareConsultationTimeCheckModelInclude | null
    /**
     * The data needed to update a FocusCareConsultationTimeCheckModel.
     */
    data: XOR<FocusCareConsultationTimeCheckModelUpdateInput, FocusCareConsultationTimeCheckModelUncheckedUpdateInput>
    /**
     * Choose, which FocusCareConsultationTimeCheckModel to update.
     */
    where: FocusCareConsultationTimeCheckModelWhereUniqueInput
  }


  /**
   * FocusCareConsultationTimeCheckModel updateMany
   */
  export type FocusCareConsultationTimeCheckModelUpdateManyArgs = {
    /**
     * The data used to update FocusCareConsultationTimeCheckModels.
     */
    data: XOR<FocusCareConsultationTimeCheckModelUpdateManyMutationInput, FocusCareConsultationTimeCheckModelUncheckedUpdateManyInput>
    /**
     * Filter which FocusCareConsultationTimeCheckModels to update
     */
    where?: FocusCareConsultationTimeCheckModelWhereInput
  }


  /**
   * FocusCareConsultationTimeCheckModel upsert
   */
  export type FocusCareConsultationTimeCheckModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the FocusCareConsultationTimeCheckModel
     */
    select?: FocusCareConsultationTimeCheckModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareConsultationTimeCheckModelInclude | null
    /**
     * The filter to search for the FocusCareConsultationTimeCheckModel to update in case it exists.
     */
    where: FocusCareConsultationTimeCheckModelWhereUniqueInput
    /**
     * In case the FocusCareConsultationTimeCheckModel found by the `where` argument doesn't exist, create a new FocusCareConsultationTimeCheckModel with this data.
     */
    create: XOR<FocusCareConsultationTimeCheckModelCreateInput, FocusCareConsultationTimeCheckModelUncheckedCreateInput>
    /**
     * In case the FocusCareConsultationTimeCheckModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FocusCareConsultationTimeCheckModelUpdateInput, FocusCareConsultationTimeCheckModelUncheckedUpdateInput>
  }


  /**
   * FocusCareConsultationTimeCheckModel delete
   */
  export type FocusCareConsultationTimeCheckModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the FocusCareConsultationTimeCheckModel
     */
    select?: FocusCareConsultationTimeCheckModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareConsultationTimeCheckModelInclude | null
    /**
     * Filter which FocusCareConsultationTimeCheckModel to delete.
     */
    where: FocusCareConsultationTimeCheckModelWhereUniqueInput
  }


  /**
   * FocusCareConsultationTimeCheckModel deleteMany
   */
  export type FocusCareConsultationTimeCheckModelDeleteManyArgs = {
    /**
     * Filter which FocusCareConsultationTimeCheckModels to delete
     */
    where?: FocusCareConsultationTimeCheckModelWhereInput
  }


  /**
   * FocusCareConsultationTimeCheckModel without action
   */
  export type FocusCareConsultationTimeCheckModelArgs = {
    /**
     * Select specific fields to fetch from the FocusCareConsultationTimeCheckModel
     */
    select?: FocusCareConsultationTimeCheckModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareConsultationTimeCheckModelInclude | null
  }



  /**
   * Model UserModel
   */


  export type AggregateUserModel = {
    _count: UserModelCountAggregateOutputType | null
    _min: UserModelMinAggregateOutputType | null
    _max: UserModelMaxAggregateOutputType | null
  }

  export type UserModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    email: string | null
  }

  export type UserModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    email: string | null
  }

  export type UserModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    name: number
    email: number
    _all: number
  }


  export type UserModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    email?: true
  }

  export type UserModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    email?: true
  }

  export type UserModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    email?: true
    _all?: true
  }

  export type UserModelAggregateArgs = {
    /**
     * Filter which UserModel to aggregate.
     */
    where?: UserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserModels to fetch.
     */
    orderBy?: Enumerable<UserModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserModels
    **/
    _count?: true | UserModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserModelMaxAggregateInputType
  }

  export type GetUserModelAggregateType<T extends UserModelAggregateArgs> = {
        [P in keyof T & keyof AggregateUserModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserModel[P]>
      : GetScalarType<T[P], AggregateUserModel[P]>
  }




  export type UserModelGroupByArgs = {
    where?: UserModelWhereInput
    orderBy?: Enumerable<UserModelOrderByWithAggregationInput>
    by: UserModelScalarFieldEnum[]
    having?: UserModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserModelCountAggregateInputType | true
    _min?: UserModelMinAggregateInputType
    _max?: UserModelMaxAggregateInputType
  }


  export type UserModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    name: string
    email: string | null
    _count: UserModelCountAggregateOutputType | null
    _min: UserModelMinAggregateOutputType | null
    _max: UserModelMaxAggregateOutputType | null
  }

  type GetUserModelGroupByPayload<T extends UserModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserModelGroupByOutputType[P]>
            : GetScalarType<T[P], UserModelGroupByOutputType[P]>
        }
      >
    >


  export type UserModelSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    name?: boolean
    email?: boolean
    customer?: boolean | CustomerModelArgs
    business_user?: boolean | BusinessUserModelArgs
    agreement_acceptances?: boolean | UserModel$agreement_acceptancesArgs
    _count?: boolean | UserModelCountOutputTypeArgs
  }


  export type UserModelInclude = {
    customer?: boolean | CustomerModelArgs
    business_user?: boolean | BusinessUserModelArgs
    agreement_acceptances?: boolean | UserModel$agreement_acceptancesArgs
    _count?: boolean | UserModelCountOutputTypeArgs
  }

  export type UserModelGetPayload<S extends boolean | null | undefined | UserModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserModel :
    S extends undefined ? never :
    S extends { include: any } & (UserModelArgs | UserModelFindManyArgs)
    ? UserModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'customer' ? CustomerModelGetPayload<S['include'][P]> | null :
        P extends 'business_user' ? BusinessUserModelGetPayload<S['include'][P]> | null :
        P extends 'agreement_acceptances' ? Array < AgreementAcceptanceModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserModelArgs | UserModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'customer' ? CustomerModelGetPayload<S['select'][P]> | null :
        P extends 'business_user' ? BusinessUserModelGetPayload<S['select'][P]> | null :
        P extends 'agreement_acceptances' ? Array < AgreementAcceptanceModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof UserModel ? UserModel[P] : never
  } 
      : UserModel


  type UserModelCountArgs = 
    Omit<UserModelFindManyArgs, 'select' | 'include'> & {
      select?: UserModelCountAggregateInputType | true
    }

  export interface UserModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserModel that matches the filter.
     * @param {UserModelFindUniqueArgs} args - Arguments to find a UserModel
     * @example
     * // Get one UserModel
     * const userModel = await prisma.userModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserModel'> extends True ? Prisma__UserModelClient<UserModelGetPayload<T>> : Prisma__UserModelClient<UserModelGetPayload<T> | null, null>

    /**
     * Find one UserModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserModelFindUniqueOrThrowArgs} args - Arguments to find a UserModel
     * @example
     * // Get one UserModel
     * const userModel = await prisma.userModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserModelFindUniqueOrThrowArgs>
    ): Prisma__UserModelClient<UserModelGetPayload<T>>

    /**
     * Find the first UserModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelFindFirstArgs} args - Arguments to find a UserModel
     * @example
     * // Get one UserModel
     * const userModel = await prisma.userModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserModel'> extends True ? Prisma__UserModelClient<UserModelGetPayload<T>> : Prisma__UserModelClient<UserModelGetPayload<T> | null, null>

    /**
     * Find the first UserModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelFindFirstOrThrowArgs} args - Arguments to find a UserModel
     * @example
     * // Get one UserModel
     * const userModel = await prisma.userModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserModelFindFirstOrThrowArgs>
    ): Prisma__UserModelClient<UserModelGetPayload<T>>

    /**
     * Find zero or more UserModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserModels
     * const userModels = await prisma.userModel.findMany()
     * 
     * // Get first 10 UserModels
     * const userModels = await prisma.userModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userModelWithIdOnly = await prisma.userModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserModelFindManyArgs>(
      args?: SelectSubset<T, UserModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserModelGetPayload<T>>>

    /**
     * Create a UserModel.
     * @param {UserModelCreateArgs} args - Arguments to create a UserModel.
     * @example
     * // Create one UserModel
     * const UserModel = await prisma.userModel.create({
     *   data: {
     *     // ... data to create a UserModel
     *   }
     * })
     * 
    **/
    create<T extends UserModelCreateArgs>(
      args: SelectSubset<T, UserModelCreateArgs>
    ): Prisma__UserModelClient<UserModelGetPayload<T>>

    /**
     * Create many UserModels.
     *     @param {UserModelCreateManyArgs} args - Arguments to create many UserModels.
     *     @example
     *     // Create many UserModels
     *     const userModel = await prisma.userModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserModelCreateManyArgs>(
      args?: SelectSubset<T, UserModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserModel.
     * @param {UserModelDeleteArgs} args - Arguments to delete one UserModel.
     * @example
     * // Delete one UserModel
     * const UserModel = await prisma.userModel.delete({
     *   where: {
     *     // ... filter to delete one UserModel
     *   }
     * })
     * 
    **/
    delete<T extends UserModelDeleteArgs>(
      args: SelectSubset<T, UserModelDeleteArgs>
    ): Prisma__UserModelClient<UserModelGetPayload<T>>

    /**
     * Update one UserModel.
     * @param {UserModelUpdateArgs} args - Arguments to update one UserModel.
     * @example
     * // Update one UserModel
     * const userModel = await prisma.userModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserModelUpdateArgs>(
      args: SelectSubset<T, UserModelUpdateArgs>
    ): Prisma__UserModelClient<UserModelGetPayload<T>>

    /**
     * Delete zero or more UserModels.
     * @param {UserModelDeleteManyArgs} args - Arguments to filter UserModels to delete.
     * @example
     * // Delete a few UserModels
     * const { count } = await prisma.userModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserModelDeleteManyArgs>(
      args?: SelectSubset<T, UserModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserModels
     * const userModel = await prisma.userModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserModelUpdateManyArgs>(
      args: SelectSubset<T, UserModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserModel.
     * @param {UserModelUpsertArgs} args - Arguments to update or create a UserModel.
     * @example
     * // Update or create a UserModel
     * const userModel = await prisma.userModel.upsert({
     *   create: {
     *     // ... data to create a UserModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserModel we want to update
     *   }
     * })
    **/
    upsert<T extends UserModelUpsertArgs>(
      args: SelectSubset<T, UserModelUpsertArgs>
    ): Prisma__UserModelClient<UserModelGetPayload<T>>

    /**
     * Count the number of UserModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelCountArgs} args - Arguments to filter UserModels to count.
     * @example
     * // Count the number of UserModels
     * const count = await prisma.userModel.count({
     *   where: {
     *     // ... the filter for the UserModels we want to count
     *   }
     * })
    **/
    count<T extends UserModelCountArgs>(
      args?: Subset<T, UserModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserModelAggregateArgs>(args: Subset<T, UserModelAggregateArgs>): Prisma.PrismaPromise<GetUserModelAggregateType<T>>

    /**
     * Group by UserModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserModelGroupByArgs['orderBy'] }
        : { orderBy?: UserModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    customer<T extends CustomerModelArgs= {}>(args?: Subset<T, CustomerModelArgs>): Prisma__CustomerModelClient<CustomerModelGetPayload<T> | Null>;

    business_user<T extends BusinessUserModelArgs= {}>(args?: Subset<T, BusinessUserModelArgs>): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T> | Null>;

    agreement_acceptances<T extends UserModel$agreement_acceptancesArgs= {}>(args?: Subset<T, UserModel$agreement_acceptancesArgs>): Prisma.PrismaPromise<Array<AgreementAcceptanceModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserModel base type for findUnique actions
   */
  export type UserModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude | null
    /**
     * Filter, which UserModel to fetch.
     */
    where: UserModelWhereUniqueInput
  }

  /**
   * UserModel findUnique
   */
  export interface UserModelFindUniqueArgs extends UserModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserModel findUniqueOrThrow
   */
  export type UserModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude | null
    /**
     * Filter, which UserModel to fetch.
     */
    where: UserModelWhereUniqueInput
  }


  /**
   * UserModel base type for findFirst actions
   */
  export type UserModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude | null
    /**
     * Filter, which UserModel to fetch.
     */
    where?: UserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserModels to fetch.
     */
    orderBy?: Enumerable<UserModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserModels.
     */
    cursor?: UserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserModels.
     */
    distinct?: Enumerable<UserModelScalarFieldEnum>
  }

  /**
   * UserModel findFirst
   */
  export interface UserModelFindFirstArgs extends UserModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserModel findFirstOrThrow
   */
  export type UserModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude | null
    /**
     * Filter, which UserModel to fetch.
     */
    where?: UserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserModels to fetch.
     */
    orderBy?: Enumerable<UserModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserModels.
     */
    cursor?: UserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserModels.
     */
    distinct?: Enumerable<UserModelScalarFieldEnum>
  }


  /**
   * UserModel findMany
   */
  export type UserModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude | null
    /**
     * Filter, which UserModels to fetch.
     */
    where?: UserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserModels to fetch.
     */
    orderBy?: Enumerable<UserModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserModels.
     */
    cursor?: UserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserModels.
     */
    skip?: number
    distinct?: Enumerable<UserModelScalarFieldEnum>
  }


  /**
   * UserModel create
   */
  export type UserModelCreateArgs = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude | null
    /**
     * The data needed to create a UserModel.
     */
    data: XOR<UserModelCreateInput, UserModelUncheckedCreateInput>
  }


  /**
   * UserModel createMany
   */
  export type UserModelCreateManyArgs = {
    /**
     * The data used to create many UserModels.
     */
    data: Enumerable<UserModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserModel update
   */
  export type UserModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude | null
    /**
     * The data needed to update a UserModel.
     */
    data: XOR<UserModelUpdateInput, UserModelUncheckedUpdateInput>
    /**
     * Choose, which UserModel to update.
     */
    where: UserModelWhereUniqueInput
  }


  /**
   * UserModel updateMany
   */
  export type UserModelUpdateManyArgs = {
    /**
     * The data used to update UserModels.
     */
    data: XOR<UserModelUpdateManyMutationInput, UserModelUncheckedUpdateManyInput>
    /**
     * Filter which UserModels to update
     */
    where?: UserModelWhereInput
  }


  /**
   * UserModel upsert
   */
  export type UserModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude | null
    /**
     * The filter to search for the UserModel to update in case it exists.
     */
    where: UserModelWhereUniqueInput
    /**
     * In case the UserModel found by the `where` argument doesn't exist, create a new UserModel with this data.
     */
    create: XOR<UserModelCreateInput, UserModelUncheckedCreateInput>
    /**
     * In case the UserModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserModelUpdateInput, UserModelUncheckedUpdateInput>
  }


  /**
   * UserModel delete
   */
  export type UserModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude | null
    /**
     * Filter which UserModel to delete.
     */
    where: UserModelWhereUniqueInput
  }


  /**
   * UserModel deleteMany
   */
  export type UserModelDeleteManyArgs = {
    /**
     * Filter which UserModels to delete
     */
    where?: UserModelWhereInput
  }


  /**
   * UserModel.agreement_acceptances
   */
  export type UserModel$agreement_acceptancesArgs = {
    /**
     * Select specific fields to fetch from the AgreementAcceptanceModel
     */
    select?: AgreementAcceptanceModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementAcceptanceModelInclude | null
    where?: AgreementAcceptanceModelWhereInput
    orderBy?: Enumerable<AgreementAcceptanceModelOrderByWithRelationInput>
    cursor?: AgreementAcceptanceModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AgreementAcceptanceModelScalarFieldEnum>
  }


  /**
   * UserModel without action
   */
  export type UserModelArgs = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude | null
  }



  /**
   * Model CustomerModel
   */


  export type AggregateCustomerModel = {
    _count: CustomerModelCountAggregateOutputType | null
    _min: CustomerModelMinAggregateOutputType | null
    _max: CustomerModelMaxAggregateOutputType | null
  }

  export type CustomerModelMinAggregateOutputType = {
    id: string | null
    birth: string | null
    gender: GenderType | null
    phone: string | null
    address_first: string | null
    address_second: string | null
    profile_image_url: string | null
  }

  export type CustomerModelMaxAggregateOutputType = {
    id: string | null
    birth: string | null
    gender: GenderType | null
    phone: string | null
    address_first: string | null
    address_second: string | null
    profile_image_url: string | null
  }

  export type CustomerModelCountAggregateOutputType = {
    id: number
    birth: number
    gender: number
    phone: number
    address_first: number
    address_second: number
    profile_image_url: number
    _all: number
  }


  export type CustomerModelMinAggregateInputType = {
    id?: true
    birth?: true
    gender?: true
    phone?: true
    address_first?: true
    address_second?: true
    profile_image_url?: true
  }

  export type CustomerModelMaxAggregateInputType = {
    id?: true
    birth?: true
    gender?: true
    phone?: true
    address_first?: true
    address_second?: true
    profile_image_url?: true
  }

  export type CustomerModelCountAggregateInputType = {
    id?: true
    birth?: true
    gender?: true
    phone?: true
    address_first?: true
    address_second?: true
    profile_image_url?: true
    _all?: true
  }

  export type CustomerModelAggregateArgs = {
    /**
     * Filter which CustomerModel to aggregate.
     */
    where?: CustomerModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerModels to fetch.
     */
    orderBy?: Enumerable<CustomerModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerModels
    **/
    _count?: true | CustomerModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerModelMaxAggregateInputType
  }

  export type GetCustomerModelAggregateType<T extends CustomerModelAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerModel[P]>
      : GetScalarType<T[P], AggregateCustomerModel[P]>
  }




  export type CustomerModelGroupByArgs = {
    where?: CustomerModelWhereInput
    orderBy?: Enumerable<CustomerModelOrderByWithAggregationInput>
    by: CustomerModelScalarFieldEnum[]
    having?: CustomerModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerModelCountAggregateInputType | true
    _min?: CustomerModelMinAggregateInputType
    _max?: CustomerModelMaxAggregateInputType
  }


  export type CustomerModelGroupByOutputType = {
    id: string
    birth: string | null
    gender: GenderType | null
    phone: string | null
    address_first: string | null
    address_second: string | null
    profile_image_url: string | null
    _count: CustomerModelCountAggregateOutputType | null
    _min: CustomerModelMinAggregateOutputType | null
    _max: CustomerModelMaxAggregateOutputType | null
  }

  type GetCustomerModelGroupByPayload<T extends CustomerModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CustomerModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerModelGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerModelGroupByOutputType[P]>
        }
      >
    >


  export type CustomerModelSelect = {
    id?: boolean
    birth?: boolean
    gender?: boolean
    phone?: boolean
    address_first?: boolean
    address_second?: boolean
    profile_image_url?: boolean
    base?: boolean | UserModelArgs
    oauth_accounts?: boolean | CustomerModel$oauth_accountsArgs
    reviews?: boolean | CustomerModel$reviewsArgs
    focus_care_requests?: boolean | CustomerModel$focus_care_requestsArgs
    _count?: boolean | CustomerModelCountOutputTypeArgs
  }


  export type CustomerModelInclude = {
    base?: boolean | UserModelArgs
    oauth_accounts?: boolean | CustomerModel$oauth_accountsArgs
    reviews?: boolean | CustomerModel$reviewsArgs
    focus_care_requests?: boolean | CustomerModel$focus_care_requestsArgs
    _count?: boolean | CustomerModelCountOutputTypeArgs
  }

  export type CustomerModelGetPayload<S extends boolean | null | undefined | CustomerModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CustomerModel :
    S extends undefined ? never :
    S extends { include: any } & (CustomerModelArgs | CustomerModelFindManyArgs)
    ? CustomerModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'base' ? UserModelGetPayload<S['include'][P]> :
        P extends 'oauth_accounts' ? Array < OauthAccountModelGetPayload<S['include'][P]>>  :
        P extends 'reviews' ? Array < ReviewModelGetPayload<S['include'][P]>>  :
        P extends 'focus_care_requests' ? Array < FocusCareRequestModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? CustomerModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CustomerModelArgs | CustomerModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'base' ? UserModelGetPayload<S['select'][P]> :
        P extends 'oauth_accounts' ? Array < OauthAccountModelGetPayload<S['select'][P]>>  :
        P extends 'reviews' ? Array < ReviewModelGetPayload<S['select'][P]>>  :
        P extends 'focus_care_requests' ? Array < FocusCareRequestModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? CustomerModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof CustomerModel ? CustomerModel[P] : never
  } 
      : CustomerModel


  type CustomerModelCountArgs = 
    Omit<CustomerModelFindManyArgs, 'select' | 'include'> & {
      select?: CustomerModelCountAggregateInputType | true
    }

  export interface CustomerModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one CustomerModel that matches the filter.
     * @param {CustomerModelFindUniqueArgs} args - Arguments to find a CustomerModel
     * @example
     * // Get one CustomerModel
     * const customerModel = await prisma.customerModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CustomerModel'> extends True ? Prisma__CustomerModelClient<CustomerModelGetPayload<T>> : Prisma__CustomerModelClient<CustomerModelGetPayload<T> | null, null>

    /**
     * Find one CustomerModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CustomerModelFindUniqueOrThrowArgs} args - Arguments to find a CustomerModel
     * @example
     * // Get one CustomerModel
     * const customerModel = await prisma.customerModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CustomerModelFindUniqueOrThrowArgs>
    ): Prisma__CustomerModelClient<CustomerModelGetPayload<T>>

    /**
     * Find the first CustomerModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerModelFindFirstArgs} args - Arguments to find a CustomerModel
     * @example
     * // Get one CustomerModel
     * const customerModel = await prisma.customerModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CustomerModel'> extends True ? Prisma__CustomerModelClient<CustomerModelGetPayload<T>> : Prisma__CustomerModelClient<CustomerModelGetPayload<T> | null, null>

    /**
     * Find the first CustomerModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerModelFindFirstOrThrowArgs} args - Arguments to find a CustomerModel
     * @example
     * // Get one CustomerModel
     * const customerModel = await prisma.customerModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CustomerModelFindFirstOrThrowArgs>
    ): Prisma__CustomerModelClient<CustomerModelGetPayload<T>>

    /**
     * Find zero or more CustomerModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerModels
     * const customerModels = await prisma.customerModel.findMany()
     * 
     * // Get first 10 CustomerModels
     * const customerModels = await prisma.customerModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerModelWithIdOnly = await prisma.customerModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomerModelFindManyArgs>(
      args?: SelectSubset<T, CustomerModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<CustomerModelGetPayload<T>>>

    /**
     * Create a CustomerModel.
     * @param {CustomerModelCreateArgs} args - Arguments to create a CustomerModel.
     * @example
     * // Create one CustomerModel
     * const CustomerModel = await prisma.customerModel.create({
     *   data: {
     *     // ... data to create a CustomerModel
     *   }
     * })
     * 
    **/
    create<T extends CustomerModelCreateArgs>(
      args: SelectSubset<T, CustomerModelCreateArgs>
    ): Prisma__CustomerModelClient<CustomerModelGetPayload<T>>

    /**
     * Create many CustomerModels.
     *     @param {CustomerModelCreateManyArgs} args - Arguments to create many CustomerModels.
     *     @example
     *     // Create many CustomerModels
     *     const customerModel = await prisma.customerModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerModelCreateManyArgs>(
      args?: SelectSubset<T, CustomerModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerModel.
     * @param {CustomerModelDeleteArgs} args - Arguments to delete one CustomerModel.
     * @example
     * // Delete one CustomerModel
     * const CustomerModel = await prisma.customerModel.delete({
     *   where: {
     *     // ... filter to delete one CustomerModel
     *   }
     * })
     * 
    **/
    delete<T extends CustomerModelDeleteArgs>(
      args: SelectSubset<T, CustomerModelDeleteArgs>
    ): Prisma__CustomerModelClient<CustomerModelGetPayload<T>>

    /**
     * Update one CustomerModel.
     * @param {CustomerModelUpdateArgs} args - Arguments to update one CustomerModel.
     * @example
     * // Update one CustomerModel
     * const customerModel = await prisma.customerModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerModelUpdateArgs>(
      args: SelectSubset<T, CustomerModelUpdateArgs>
    ): Prisma__CustomerModelClient<CustomerModelGetPayload<T>>

    /**
     * Delete zero or more CustomerModels.
     * @param {CustomerModelDeleteManyArgs} args - Arguments to filter CustomerModels to delete.
     * @example
     * // Delete a few CustomerModels
     * const { count } = await prisma.customerModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerModelDeleteManyArgs>(
      args?: SelectSubset<T, CustomerModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerModels
     * const customerModel = await prisma.customerModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerModelUpdateManyArgs>(
      args: SelectSubset<T, CustomerModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerModel.
     * @param {CustomerModelUpsertArgs} args - Arguments to update or create a CustomerModel.
     * @example
     * // Update or create a CustomerModel
     * const customerModel = await prisma.customerModel.upsert({
     *   create: {
     *     // ... data to create a CustomerModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerModel we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerModelUpsertArgs>(
      args: SelectSubset<T, CustomerModelUpsertArgs>
    ): Prisma__CustomerModelClient<CustomerModelGetPayload<T>>

    /**
     * Count the number of CustomerModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerModelCountArgs} args - Arguments to filter CustomerModels to count.
     * @example
     * // Count the number of CustomerModels
     * const count = await prisma.customerModel.count({
     *   where: {
     *     // ... the filter for the CustomerModels we want to count
     *   }
     * })
    **/
    count<T extends CustomerModelCountArgs>(
      args?: Subset<T, CustomerModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerModelAggregateArgs>(args: Subset<T, CustomerModelAggregateArgs>): Prisma.PrismaPromise<GetCustomerModelAggregateType<T>>

    /**
     * Group by CustomerModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerModelGroupByArgs['orderBy'] }
        : { orderBy?: CustomerModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    base<T extends UserModelArgs= {}>(args?: Subset<T, UserModelArgs>): Prisma__UserModelClient<UserModelGetPayload<T> | Null>;

    oauth_accounts<T extends CustomerModel$oauth_accountsArgs= {}>(args?: Subset<T, CustomerModel$oauth_accountsArgs>): Prisma.PrismaPromise<Array<OauthAccountModelGetPayload<T>>| Null>;

    reviews<T extends CustomerModel$reviewsArgs= {}>(args?: Subset<T, CustomerModel$reviewsArgs>): Prisma.PrismaPromise<Array<ReviewModelGetPayload<T>>| Null>;

    focus_care_requests<T extends CustomerModel$focus_care_requestsArgs= {}>(args?: Subset<T, CustomerModel$focus_care_requestsArgs>): Prisma.PrismaPromise<Array<FocusCareRequestModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CustomerModel base type for findUnique actions
   */
  export type CustomerModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude | null
    /**
     * Filter, which CustomerModel to fetch.
     */
    where: CustomerModelWhereUniqueInput
  }

  /**
   * CustomerModel findUnique
   */
  export interface CustomerModelFindUniqueArgs extends CustomerModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerModel findUniqueOrThrow
   */
  export type CustomerModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude | null
    /**
     * Filter, which CustomerModel to fetch.
     */
    where: CustomerModelWhereUniqueInput
  }


  /**
   * CustomerModel base type for findFirst actions
   */
  export type CustomerModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude | null
    /**
     * Filter, which CustomerModel to fetch.
     */
    where?: CustomerModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerModels to fetch.
     */
    orderBy?: Enumerable<CustomerModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerModels.
     */
    cursor?: CustomerModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerModels.
     */
    distinct?: Enumerable<CustomerModelScalarFieldEnum>
  }

  /**
   * CustomerModel findFirst
   */
  export interface CustomerModelFindFirstArgs extends CustomerModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerModel findFirstOrThrow
   */
  export type CustomerModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude | null
    /**
     * Filter, which CustomerModel to fetch.
     */
    where?: CustomerModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerModels to fetch.
     */
    orderBy?: Enumerable<CustomerModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerModels.
     */
    cursor?: CustomerModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerModels.
     */
    distinct?: Enumerable<CustomerModelScalarFieldEnum>
  }


  /**
   * CustomerModel findMany
   */
  export type CustomerModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude | null
    /**
     * Filter, which CustomerModels to fetch.
     */
    where?: CustomerModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerModels to fetch.
     */
    orderBy?: Enumerable<CustomerModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerModels.
     */
    cursor?: CustomerModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerModels.
     */
    skip?: number
    distinct?: Enumerable<CustomerModelScalarFieldEnum>
  }


  /**
   * CustomerModel create
   */
  export type CustomerModelCreateArgs = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude | null
    /**
     * The data needed to create a CustomerModel.
     */
    data: XOR<CustomerModelCreateInput, CustomerModelUncheckedCreateInput>
  }


  /**
   * CustomerModel createMany
   */
  export type CustomerModelCreateManyArgs = {
    /**
     * The data used to create many CustomerModels.
     */
    data: Enumerable<CustomerModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CustomerModel update
   */
  export type CustomerModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude | null
    /**
     * The data needed to update a CustomerModel.
     */
    data: XOR<CustomerModelUpdateInput, CustomerModelUncheckedUpdateInput>
    /**
     * Choose, which CustomerModel to update.
     */
    where: CustomerModelWhereUniqueInput
  }


  /**
   * CustomerModel updateMany
   */
  export type CustomerModelUpdateManyArgs = {
    /**
     * The data used to update CustomerModels.
     */
    data: XOR<CustomerModelUpdateManyMutationInput, CustomerModelUncheckedUpdateManyInput>
    /**
     * Filter which CustomerModels to update
     */
    where?: CustomerModelWhereInput
  }


  /**
   * CustomerModel upsert
   */
  export type CustomerModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude | null
    /**
     * The filter to search for the CustomerModel to update in case it exists.
     */
    where: CustomerModelWhereUniqueInput
    /**
     * In case the CustomerModel found by the `where` argument doesn't exist, create a new CustomerModel with this data.
     */
    create: XOR<CustomerModelCreateInput, CustomerModelUncheckedCreateInput>
    /**
     * In case the CustomerModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerModelUpdateInput, CustomerModelUncheckedUpdateInput>
  }


  /**
   * CustomerModel delete
   */
  export type CustomerModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude | null
    /**
     * Filter which CustomerModel to delete.
     */
    where: CustomerModelWhereUniqueInput
  }


  /**
   * CustomerModel deleteMany
   */
  export type CustomerModelDeleteManyArgs = {
    /**
     * Filter which CustomerModels to delete
     */
    where?: CustomerModelWhereInput
  }


  /**
   * CustomerModel.oauth_accounts
   */
  export type CustomerModel$oauth_accountsArgs = {
    /**
     * Select specific fields to fetch from the OauthAccountModel
     */
    select?: OauthAccountModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OauthAccountModelInclude | null
    where?: OauthAccountModelWhereInput
    orderBy?: Enumerable<OauthAccountModelOrderByWithRelationInput>
    cursor?: OauthAccountModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OauthAccountModelScalarFieldEnum>
  }


  /**
   * CustomerModel.reviews
   */
  export type CustomerModel$reviewsArgs = {
    /**
     * Select specific fields to fetch from the ReviewModel
     */
    select?: ReviewModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewModelInclude | null
    where?: ReviewModelWhereInput
    orderBy?: Enumerable<ReviewModelOrderByWithRelationInput>
    cursor?: ReviewModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReviewModelScalarFieldEnum>
  }


  /**
   * CustomerModel.focus_care_requests
   */
  export type CustomerModel$focus_care_requestsArgs = {
    /**
     * Select specific fields to fetch from the FocusCareRequestModel
     */
    select?: FocusCareRequestModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FocusCareRequestModelInclude | null
    where?: FocusCareRequestModelWhereInput
    orderBy?: Enumerable<FocusCareRequestModelOrderByWithRelationInput>
    cursor?: FocusCareRequestModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FocusCareRequestModelScalarFieldEnum>
  }


  /**
   * CustomerModel without action
   */
  export type CustomerModelArgs = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude | null
  }



  /**
   * Model BusinessUserModel
   */


  export type AggregateBusinessUserModel = {
    _count: BusinessUserModelCountAggregateOutputType | null
    _min: BusinessUserModelMinAggregateOutputType | null
    _max: BusinessUserModelMaxAggregateOutputType | null
  }

  export type BusinessUserModelMinAggregateOutputType = {
    id: string | null
    is_verified: boolean | null
    introduction_title: string | null
    introduction_content: string | null
    phone: string | null
    address_first: string | null
    address_second: string | null
    profile_image_url: string | null
  }

  export type BusinessUserModelMaxAggregateOutputType = {
    id: string | null
    is_verified: boolean | null
    introduction_title: string | null
    introduction_content: string | null
    phone: string | null
    address_first: string | null
    address_second: string | null
    profile_image_url: string | null
  }

  export type BusinessUserModelCountAggregateOutputType = {
    id: number
    is_verified: number
    introduction_title: number
    introduction_content: number
    phone: number
    address_first: number
    address_second: number
    profile_image_url: number
    _all: number
  }


  export type BusinessUserModelMinAggregateInputType = {
    id?: true
    is_verified?: true
    introduction_title?: true
    introduction_content?: true
    phone?: true
    address_first?: true
    address_second?: true
    profile_image_url?: true
  }

  export type BusinessUserModelMaxAggregateInputType = {
    id?: true
    is_verified?: true
    introduction_title?: true
    introduction_content?: true
    phone?: true
    address_first?: true
    address_second?: true
    profile_image_url?: true
  }

  export type BusinessUserModelCountAggregateInputType = {
    id?: true
    is_verified?: true
    introduction_title?: true
    introduction_content?: true
    phone?: true
    address_first?: true
    address_second?: true
    profile_image_url?: true
    _all?: true
  }

  export type BusinessUserModelAggregateArgs = {
    /**
     * Filter which BusinessUserModel to aggregate.
     */
    where?: BusinessUserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUserModels to fetch.
     */
    orderBy?: Enumerable<BusinessUserModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessUserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUserModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessUserModels
    **/
    _count?: true | BusinessUserModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessUserModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessUserModelMaxAggregateInputType
  }

  export type GetBusinessUserModelAggregateType<T extends BusinessUserModelAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessUserModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessUserModel[P]>
      : GetScalarType<T[P], AggregateBusinessUserModel[P]>
  }




  export type BusinessUserModelGroupByArgs = {
    where?: BusinessUserModelWhereInput
    orderBy?: Enumerable<BusinessUserModelOrderByWithAggregationInput>
    by: BusinessUserModelScalarFieldEnum[]
    having?: BusinessUserModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessUserModelCountAggregateInputType | true
    _min?: BusinessUserModelMinAggregateInputType
    _max?: BusinessUserModelMaxAggregateInputType
  }


  export type BusinessUserModelGroupByOutputType = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second: string | null
    profile_image_url: string
    _count: BusinessUserModelCountAggregateOutputType | null
    _min: BusinessUserModelMinAggregateOutputType | null
    _max: BusinessUserModelMaxAggregateOutputType | null
  }

  type GetBusinessUserModelGroupByPayload<T extends BusinessUserModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BusinessUserModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessUserModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessUserModelGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessUserModelGroupByOutputType[P]>
        }
      >
    >


  export type BusinessUserModelSelect = {
    id?: boolean
    is_verified?: boolean
    introduction_title?: boolean
    introduction_content?: boolean
    phone?: boolean
    address_first?: boolean
    address_second?: boolean
    profile_image_url?: boolean
    base?: boolean | UserModelArgs
    re_agent?: boolean | REAgentModelArgs
    hs_provider?: boolean | HSProviderModelArgs
    certification_images?: boolean | BusinessUserModel$certification_imagesArgs
    sub_expertises?: boolean | BusinessUserModel$sub_expertisesArgs
    oauth_accounts?: boolean | BusinessUserModel$oauth_accountsArgs
    reviews?: boolean | BusinessUserModel$reviewsArgs
    _count?: boolean | BusinessUserModelCountOutputTypeArgs
  }


  export type BusinessUserModelInclude = {
    base?: boolean | UserModelArgs
    re_agent?: boolean | REAgentModelArgs
    hs_provider?: boolean | HSProviderModelArgs
    certification_images?: boolean | BusinessUserModel$certification_imagesArgs
    sub_expertises?: boolean | BusinessUserModel$sub_expertisesArgs
    oauth_accounts?: boolean | BusinessUserModel$oauth_accountsArgs
    reviews?: boolean | BusinessUserModel$reviewsArgs
    _count?: boolean | BusinessUserModelCountOutputTypeArgs
  }

  export type BusinessUserModelGetPayload<S extends boolean | null | undefined | BusinessUserModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BusinessUserModel :
    S extends undefined ? never :
    S extends { include: any } & (BusinessUserModelArgs | BusinessUserModelFindManyArgs)
    ? BusinessUserModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'base' ? UserModelGetPayload<S['include'][P]> :
        P extends 're_agent' ? REAgentModelGetPayload<S['include'][P]> | null :
        P extends 'hs_provider' ? HSProviderModelGetPayload<S['include'][P]> | null :
        P extends 'certification_images' ? Array < BusinessCertificationImageModelGetPayload<S['include'][P]>>  :
        P extends 'sub_expertises' ? Array < SubExpertiseModelGetPayload<S['include'][P]>>  :
        P extends 'oauth_accounts' ? Array < OauthAccountModelGetPayload<S['include'][P]>>  :
        P extends 'reviews' ? Array < ReviewModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? BusinessUserModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BusinessUserModelArgs | BusinessUserModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'base' ? UserModelGetPayload<S['select'][P]> :
        P extends 're_agent' ? REAgentModelGetPayload<S['select'][P]> | null :
        P extends 'hs_provider' ? HSProviderModelGetPayload<S['select'][P]> | null :
        P extends 'certification_images' ? Array < BusinessCertificationImageModelGetPayload<S['select'][P]>>  :
        P extends 'sub_expertises' ? Array < SubExpertiseModelGetPayload<S['select'][P]>>  :
        P extends 'oauth_accounts' ? Array < OauthAccountModelGetPayload<S['select'][P]>>  :
        P extends 'reviews' ? Array < ReviewModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? BusinessUserModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BusinessUserModel ? BusinessUserModel[P] : never
  } 
      : BusinessUserModel


  type BusinessUserModelCountArgs = 
    Omit<BusinessUserModelFindManyArgs, 'select' | 'include'> & {
      select?: BusinessUserModelCountAggregateInputType | true
    }

  export interface BusinessUserModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BusinessUserModel that matches the filter.
     * @param {BusinessUserModelFindUniqueArgs} args - Arguments to find a BusinessUserModel
     * @example
     * // Get one BusinessUserModel
     * const businessUserModel = await prisma.businessUserModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BusinessUserModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BusinessUserModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BusinessUserModel'> extends True ? Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T>> : Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T> | null, null>

    /**
     * Find one BusinessUserModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BusinessUserModelFindUniqueOrThrowArgs} args - Arguments to find a BusinessUserModel
     * @example
     * // Get one BusinessUserModel
     * const businessUserModel = await prisma.businessUserModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BusinessUserModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BusinessUserModelFindUniqueOrThrowArgs>
    ): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T>>

    /**
     * Find the first BusinessUserModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUserModelFindFirstArgs} args - Arguments to find a BusinessUserModel
     * @example
     * // Get one BusinessUserModel
     * const businessUserModel = await prisma.businessUserModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BusinessUserModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BusinessUserModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BusinessUserModel'> extends True ? Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T>> : Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T> | null, null>

    /**
     * Find the first BusinessUserModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUserModelFindFirstOrThrowArgs} args - Arguments to find a BusinessUserModel
     * @example
     * // Get one BusinessUserModel
     * const businessUserModel = await prisma.businessUserModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BusinessUserModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BusinessUserModelFindFirstOrThrowArgs>
    ): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T>>

    /**
     * Find zero or more BusinessUserModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUserModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessUserModels
     * const businessUserModels = await prisma.businessUserModel.findMany()
     * 
     * // Get first 10 BusinessUserModels
     * const businessUserModels = await prisma.businessUserModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessUserModelWithIdOnly = await prisma.businessUserModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BusinessUserModelFindManyArgs>(
      args?: SelectSubset<T, BusinessUserModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<BusinessUserModelGetPayload<T>>>

    /**
     * Create a BusinessUserModel.
     * @param {BusinessUserModelCreateArgs} args - Arguments to create a BusinessUserModel.
     * @example
     * // Create one BusinessUserModel
     * const BusinessUserModel = await prisma.businessUserModel.create({
     *   data: {
     *     // ... data to create a BusinessUserModel
     *   }
     * })
     * 
    **/
    create<T extends BusinessUserModelCreateArgs>(
      args: SelectSubset<T, BusinessUserModelCreateArgs>
    ): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T>>

    /**
     * Create many BusinessUserModels.
     *     @param {BusinessUserModelCreateManyArgs} args - Arguments to create many BusinessUserModels.
     *     @example
     *     // Create many BusinessUserModels
     *     const businessUserModel = await prisma.businessUserModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BusinessUserModelCreateManyArgs>(
      args?: SelectSubset<T, BusinessUserModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BusinessUserModel.
     * @param {BusinessUserModelDeleteArgs} args - Arguments to delete one BusinessUserModel.
     * @example
     * // Delete one BusinessUserModel
     * const BusinessUserModel = await prisma.businessUserModel.delete({
     *   where: {
     *     // ... filter to delete one BusinessUserModel
     *   }
     * })
     * 
    **/
    delete<T extends BusinessUserModelDeleteArgs>(
      args: SelectSubset<T, BusinessUserModelDeleteArgs>
    ): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T>>

    /**
     * Update one BusinessUserModel.
     * @param {BusinessUserModelUpdateArgs} args - Arguments to update one BusinessUserModel.
     * @example
     * // Update one BusinessUserModel
     * const businessUserModel = await prisma.businessUserModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BusinessUserModelUpdateArgs>(
      args: SelectSubset<T, BusinessUserModelUpdateArgs>
    ): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T>>

    /**
     * Delete zero or more BusinessUserModels.
     * @param {BusinessUserModelDeleteManyArgs} args - Arguments to filter BusinessUserModels to delete.
     * @example
     * // Delete a few BusinessUserModels
     * const { count } = await prisma.businessUserModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BusinessUserModelDeleteManyArgs>(
      args?: SelectSubset<T, BusinessUserModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessUserModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUserModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessUserModels
     * const businessUserModel = await prisma.businessUserModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BusinessUserModelUpdateManyArgs>(
      args: SelectSubset<T, BusinessUserModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessUserModel.
     * @param {BusinessUserModelUpsertArgs} args - Arguments to update or create a BusinessUserModel.
     * @example
     * // Update or create a BusinessUserModel
     * const businessUserModel = await prisma.businessUserModel.upsert({
     *   create: {
     *     // ... data to create a BusinessUserModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessUserModel we want to update
     *   }
     * })
    **/
    upsert<T extends BusinessUserModelUpsertArgs>(
      args: SelectSubset<T, BusinessUserModelUpsertArgs>
    ): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T>>

    /**
     * Count the number of BusinessUserModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUserModelCountArgs} args - Arguments to filter BusinessUserModels to count.
     * @example
     * // Count the number of BusinessUserModels
     * const count = await prisma.businessUserModel.count({
     *   where: {
     *     // ... the filter for the BusinessUserModels we want to count
     *   }
     * })
    **/
    count<T extends BusinessUserModelCountArgs>(
      args?: Subset<T, BusinessUserModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessUserModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessUserModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUserModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessUserModelAggregateArgs>(args: Subset<T, BusinessUserModelAggregateArgs>): Prisma.PrismaPromise<GetBusinessUserModelAggregateType<T>>

    /**
     * Group by BusinessUserModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUserModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessUserModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessUserModelGroupByArgs['orderBy'] }
        : { orderBy?: BusinessUserModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessUserModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessUserModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessUserModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BusinessUserModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    base<T extends UserModelArgs= {}>(args?: Subset<T, UserModelArgs>): Prisma__UserModelClient<UserModelGetPayload<T> | Null>;

    re_agent<T extends REAgentModelArgs= {}>(args?: Subset<T, REAgentModelArgs>): Prisma__REAgentModelClient<REAgentModelGetPayload<T> | Null>;

    hs_provider<T extends HSProviderModelArgs= {}>(args?: Subset<T, HSProviderModelArgs>): Prisma__HSProviderModelClient<HSProviderModelGetPayload<T> | Null>;

    certification_images<T extends BusinessUserModel$certification_imagesArgs= {}>(args?: Subset<T, BusinessUserModel$certification_imagesArgs>): Prisma.PrismaPromise<Array<BusinessCertificationImageModelGetPayload<T>>| Null>;

    sub_expertises<T extends BusinessUserModel$sub_expertisesArgs= {}>(args?: Subset<T, BusinessUserModel$sub_expertisesArgs>): Prisma.PrismaPromise<Array<SubExpertiseModelGetPayload<T>>| Null>;

    oauth_accounts<T extends BusinessUserModel$oauth_accountsArgs= {}>(args?: Subset<T, BusinessUserModel$oauth_accountsArgs>): Prisma.PrismaPromise<Array<OauthAccountModelGetPayload<T>>| Null>;

    reviews<T extends BusinessUserModel$reviewsArgs= {}>(args?: Subset<T, BusinessUserModel$reviewsArgs>): Prisma.PrismaPromise<Array<ReviewModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BusinessUserModel base type for findUnique actions
   */
  export type BusinessUserModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude | null
    /**
     * Filter, which BusinessUserModel to fetch.
     */
    where: BusinessUserModelWhereUniqueInput
  }

  /**
   * BusinessUserModel findUnique
   */
  export interface BusinessUserModelFindUniqueArgs extends BusinessUserModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusinessUserModel findUniqueOrThrow
   */
  export type BusinessUserModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude | null
    /**
     * Filter, which BusinessUserModel to fetch.
     */
    where: BusinessUserModelWhereUniqueInput
  }


  /**
   * BusinessUserModel base type for findFirst actions
   */
  export type BusinessUserModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude | null
    /**
     * Filter, which BusinessUserModel to fetch.
     */
    where?: BusinessUserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUserModels to fetch.
     */
    orderBy?: Enumerable<BusinessUserModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessUserModels.
     */
    cursor?: BusinessUserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUserModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessUserModels.
     */
    distinct?: Enumerable<BusinessUserModelScalarFieldEnum>
  }

  /**
   * BusinessUserModel findFirst
   */
  export interface BusinessUserModelFindFirstArgs extends BusinessUserModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusinessUserModel findFirstOrThrow
   */
  export type BusinessUserModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude | null
    /**
     * Filter, which BusinessUserModel to fetch.
     */
    where?: BusinessUserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUserModels to fetch.
     */
    orderBy?: Enumerable<BusinessUserModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessUserModels.
     */
    cursor?: BusinessUserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUserModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessUserModels.
     */
    distinct?: Enumerable<BusinessUserModelScalarFieldEnum>
  }


  /**
   * BusinessUserModel findMany
   */
  export type BusinessUserModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude | null
    /**
     * Filter, which BusinessUserModels to fetch.
     */
    where?: BusinessUserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUserModels to fetch.
     */
    orderBy?: Enumerable<BusinessUserModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessUserModels.
     */
    cursor?: BusinessUserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUserModels.
     */
    skip?: number
    distinct?: Enumerable<BusinessUserModelScalarFieldEnum>
  }


  /**
   * BusinessUserModel create
   */
  export type BusinessUserModelCreateArgs = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude | null
    /**
     * The data needed to create a BusinessUserModel.
     */
    data: XOR<BusinessUserModelCreateInput, BusinessUserModelUncheckedCreateInput>
  }


  /**
   * BusinessUserModel createMany
   */
  export type BusinessUserModelCreateManyArgs = {
    /**
     * The data used to create many BusinessUserModels.
     */
    data: Enumerable<BusinessUserModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BusinessUserModel update
   */
  export type BusinessUserModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude | null
    /**
     * The data needed to update a BusinessUserModel.
     */
    data: XOR<BusinessUserModelUpdateInput, BusinessUserModelUncheckedUpdateInput>
    /**
     * Choose, which BusinessUserModel to update.
     */
    where: BusinessUserModelWhereUniqueInput
  }


  /**
   * BusinessUserModel updateMany
   */
  export type BusinessUserModelUpdateManyArgs = {
    /**
     * The data used to update BusinessUserModels.
     */
    data: XOR<BusinessUserModelUpdateManyMutationInput, BusinessUserModelUncheckedUpdateManyInput>
    /**
     * Filter which BusinessUserModels to update
     */
    where?: BusinessUserModelWhereInput
  }


  /**
   * BusinessUserModel upsert
   */
  export type BusinessUserModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude | null
    /**
     * The filter to search for the BusinessUserModel to update in case it exists.
     */
    where: BusinessUserModelWhereUniqueInput
    /**
     * In case the BusinessUserModel found by the `where` argument doesn't exist, create a new BusinessUserModel with this data.
     */
    create: XOR<BusinessUserModelCreateInput, BusinessUserModelUncheckedCreateInput>
    /**
     * In case the BusinessUserModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessUserModelUpdateInput, BusinessUserModelUncheckedUpdateInput>
  }


  /**
   * BusinessUserModel delete
   */
  export type BusinessUserModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude | null
    /**
     * Filter which BusinessUserModel to delete.
     */
    where: BusinessUserModelWhereUniqueInput
  }


  /**
   * BusinessUserModel deleteMany
   */
  export type BusinessUserModelDeleteManyArgs = {
    /**
     * Filter which BusinessUserModels to delete
     */
    where?: BusinessUserModelWhereInput
  }


  /**
   * BusinessUserModel.certification_images
   */
  export type BusinessUserModel$certification_imagesArgs = {
    /**
     * Select specific fields to fetch from the BusinessCertificationImageModel
     */
    select?: BusinessCertificationImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessCertificationImageModelInclude | null
    where?: BusinessCertificationImageModelWhereInput
    orderBy?: Enumerable<BusinessCertificationImageModelOrderByWithRelationInput>
    cursor?: BusinessCertificationImageModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BusinessCertificationImageModelScalarFieldEnum>
  }


  /**
   * BusinessUserModel.sub_expertises
   */
  export type BusinessUserModel$sub_expertisesArgs = {
    /**
     * Select specific fields to fetch from the SubExpertiseModel
     */
    select?: SubExpertiseModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubExpertiseModelInclude | null
    where?: SubExpertiseModelWhereInput
    orderBy?: Enumerable<SubExpertiseModelOrderByWithRelationInput>
    cursor?: SubExpertiseModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SubExpertiseModelScalarFieldEnum>
  }


  /**
   * BusinessUserModel.oauth_accounts
   */
  export type BusinessUserModel$oauth_accountsArgs = {
    /**
     * Select specific fields to fetch from the OauthAccountModel
     */
    select?: OauthAccountModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OauthAccountModelInclude | null
    where?: OauthAccountModelWhereInput
    orderBy?: Enumerable<OauthAccountModelOrderByWithRelationInput>
    cursor?: OauthAccountModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OauthAccountModelScalarFieldEnum>
  }


  /**
   * BusinessUserModel.reviews
   */
  export type BusinessUserModel$reviewsArgs = {
    /**
     * Select specific fields to fetch from the ReviewModel
     */
    select?: ReviewModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewModelInclude | null
    where?: ReviewModelWhereInput
    orderBy?: Enumerable<ReviewModelOrderByWithRelationInput>
    cursor?: ReviewModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReviewModelScalarFieldEnum>
  }


  /**
   * BusinessUserModel without action
   */
  export type BusinessUserModelArgs = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude | null
  }



  /**
   * Model SubExpertiseModel
   */


  export type AggregateSubExpertiseModel = {
    _count: SubExpertiseModelCountAggregateOutputType | null
    _min: SubExpertiseModelMinAggregateOutputType | null
    _max: SubExpertiseModelMaxAggregateOutputType | null
  }

  export type SubExpertiseModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    sub_category_id: string | null
    business_user_id: string | null
  }

  export type SubExpertiseModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    sub_category_id: string | null
    business_user_id: string | null
  }

  export type SubExpertiseModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    sub_category_id: number
    business_user_id: number
    _all: number
  }


  export type SubExpertiseModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    sub_category_id?: true
    business_user_id?: true
  }

  export type SubExpertiseModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    sub_category_id?: true
    business_user_id?: true
  }

  export type SubExpertiseModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    sub_category_id?: true
    business_user_id?: true
    _all?: true
  }

  export type SubExpertiseModelAggregateArgs = {
    /**
     * Filter which SubExpertiseModel to aggregate.
     */
    where?: SubExpertiseModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubExpertiseModels to fetch.
     */
    orderBy?: Enumerable<SubExpertiseModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubExpertiseModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubExpertiseModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubExpertiseModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubExpertiseModels
    **/
    _count?: true | SubExpertiseModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubExpertiseModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubExpertiseModelMaxAggregateInputType
  }

  export type GetSubExpertiseModelAggregateType<T extends SubExpertiseModelAggregateArgs> = {
        [P in keyof T & keyof AggregateSubExpertiseModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubExpertiseModel[P]>
      : GetScalarType<T[P], AggregateSubExpertiseModel[P]>
  }




  export type SubExpertiseModelGroupByArgs = {
    where?: SubExpertiseModelWhereInput
    orderBy?: Enumerable<SubExpertiseModelOrderByWithAggregationInput>
    by: SubExpertiseModelScalarFieldEnum[]
    having?: SubExpertiseModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubExpertiseModelCountAggregateInputType | true
    _min?: SubExpertiseModelMinAggregateInputType
    _max?: SubExpertiseModelMaxAggregateInputType
  }


  export type SubExpertiseModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    sub_category_id: string
    business_user_id: string
    _count: SubExpertiseModelCountAggregateOutputType | null
    _min: SubExpertiseModelMinAggregateOutputType | null
    _max: SubExpertiseModelMaxAggregateOutputType | null
  }

  type GetSubExpertiseModelGroupByPayload<T extends SubExpertiseModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SubExpertiseModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubExpertiseModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubExpertiseModelGroupByOutputType[P]>
            : GetScalarType<T[P], SubExpertiseModelGroupByOutputType[P]>
        }
      >
    >


  export type SubExpertiseModelSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    sub_category_id?: boolean
    business_user_id?: boolean
    sub_category?: boolean | ServiceSubCategoryModelArgs
    business_user?: boolean | BusinessUserModelArgs
  }


  export type SubExpertiseModelInclude = {
    sub_category?: boolean | ServiceSubCategoryModelArgs
    business_user?: boolean | BusinessUserModelArgs
  }

  export type SubExpertiseModelGetPayload<S extends boolean | null | undefined | SubExpertiseModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SubExpertiseModel :
    S extends undefined ? never :
    S extends { include: any } & (SubExpertiseModelArgs | SubExpertiseModelFindManyArgs)
    ? SubExpertiseModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'sub_category' ? ServiceSubCategoryModelGetPayload<S['include'][P]> :
        P extends 'business_user' ? BusinessUserModelGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SubExpertiseModelArgs | SubExpertiseModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'sub_category' ? ServiceSubCategoryModelGetPayload<S['select'][P]> :
        P extends 'business_user' ? BusinessUserModelGetPayload<S['select'][P]> :  P extends keyof SubExpertiseModel ? SubExpertiseModel[P] : never
  } 
      : SubExpertiseModel


  type SubExpertiseModelCountArgs = 
    Omit<SubExpertiseModelFindManyArgs, 'select' | 'include'> & {
      select?: SubExpertiseModelCountAggregateInputType | true
    }

  export interface SubExpertiseModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SubExpertiseModel that matches the filter.
     * @param {SubExpertiseModelFindUniqueArgs} args - Arguments to find a SubExpertiseModel
     * @example
     * // Get one SubExpertiseModel
     * const subExpertiseModel = await prisma.subExpertiseModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubExpertiseModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubExpertiseModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SubExpertiseModel'> extends True ? Prisma__SubExpertiseModelClient<SubExpertiseModelGetPayload<T>> : Prisma__SubExpertiseModelClient<SubExpertiseModelGetPayload<T> | null, null>

    /**
     * Find one SubExpertiseModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SubExpertiseModelFindUniqueOrThrowArgs} args - Arguments to find a SubExpertiseModel
     * @example
     * // Get one SubExpertiseModel
     * const subExpertiseModel = await prisma.subExpertiseModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubExpertiseModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SubExpertiseModelFindUniqueOrThrowArgs>
    ): Prisma__SubExpertiseModelClient<SubExpertiseModelGetPayload<T>>

    /**
     * Find the first SubExpertiseModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubExpertiseModelFindFirstArgs} args - Arguments to find a SubExpertiseModel
     * @example
     * // Get one SubExpertiseModel
     * const subExpertiseModel = await prisma.subExpertiseModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubExpertiseModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubExpertiseModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SubExpertiseModel'> extends True ? Prisma__SubExpertiseModelClient<SubExpertiseModelGetPayload<T>> : Prisma__SubExpertiseModelClient<SubExpertiseModelGetPayload<T> | null, null>

    /**
     * Find the first SubExpertiseModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubExpertiseModelFindFirstOrThrowArgs} args - Arguments to find a SubExpertiseModel
     * @example
     * // Get one SubExpertiseModel
     * const subExpertiseModel = await prisma.subExpertiseModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubExpertiseModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubExpertiseModelFindFirstOrThrowArgs>
    ): Prisma__SubExpertiseModelClient<SubExpertiseModelGetPayload<T>>

    /**
     * Find zero or more SubExpertiseModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubExpertiseModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubExpertiseModels
     * const subExpertiseModels = await prisma.subExpertiseModel.findMany()
     * 
     * // Get first 10 SubExpertiseModels
     * const subExpertiseModels = await prisma.subExpertiseModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subExpertiseModelWithIdOnly = await prisma.subExpertiseModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubExpertiseModelFindManyArgs>(
      args?: SelectSubset<T, SubExpertiseModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<SubExpertiseModelGetPayload<T>>>

    /**
     * Create a SubExpertiseModel.
     * @param {SubExpertiseModelCreateArgs} args - Arguments to create a SubExpertiseModel.
     * @example
     * // Create one SubExpertiseModel
     * const SubExpertiseModel = await prisma.subExpertiseModel.create({
     *   data: {
     *     // ... data to create a SubExpertiseModel
     *   }
     * })
     * 
    **/
    create<T extends SubExpertiseModelCreateArgs>(
      args: SelectSubset<T, SubExpertiseModelCreateArgs>
    ): Prisma__SubExpertiseModelClient<SubExpertiseModelGetPayload<T>>

    /**
     * Create many SubExpertiseModels.
     *     @param {SubExpertiseModelCreateManyArgs} args - Arguments to create many SubExpertiseModels.
     *     @example
     *     // Create many SubExpertiseModels
     *     const subExpertiseModel = await prisma.subExpertiseModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubExpertiseModelCreateManyArgs>(
      args?: SelectSubset<T, SubExpertiseModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SubExpertiseModel.
     * @param {SubExpertiseModelDeleteArgs} args - Arguments to delete one SubExpertiseModel.
     * @example
     * // Delete one SubExpertiseModel
     * const SubExpertiseModel = await prisma.subExpertiseModel.delete({
     *   where: {
     *     // ... filter to delete one SubExpertiseModel
     *   }
     * })
     * 
    **/
    delete<T extends SubExpertiseModelDeleteArgs>(
      args: SelectSubset<T, SubExpertiseModelDeleteArgs>
    ): Prisma__SubExpertiseModelClient<SubExpertiseModelGetPayload<T>>

    /**
     * Update one SubExpertiseModel.
     * @param {SubExpertiseModelUpdateArgs} args - Arguments to update one SubExpertiseModel.
     * @example
     * // Update one SubExpertiseModel
     * const subExpertiseModel = await prisma.subExpertiseModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubExpertiseModelUpdateArgs>(
      args: SelectSubset<T, SubExpertiseModelUpdateArgs>
    ): Prisma__SubExpertiseModelClient<SubExpertiseModelGetPayload<T>>

    /**
     * Delete zero or more SubExpertiseModels.
     * @param {SubExpertiseModelDeleteManyArgs} args - Arguments to filter SubExpertiseModels to delete.
     * @example
     * // Delete a few SubExpertiseModels
     * const { count } = await prisma.subExpertiseModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubExpertiseModelDeleteManyArgs>(
      args?: SelectSubset<T, SubExpertiseModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubExpertiseModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubExpertiseModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubExpertiseModels
     * const subExpertiseModel = await prisma.subExpertiseModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubExpertiseModelUpdateManyArgs>(
      args: SelectSubset<T, SubExpertiseModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubExpertiseModel.
     * @param {SubExpertiseModelUpsertArgs} args - Arguments to update or create a SubExpertiseModel.
     * @example
     * // Update or create a SubExpertiseModel
     * const subExpertiseModel = await prisma.subExpertiseModel.upsert({
     *   create: {
     *     // ... data to create a SubExpertiseModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubExpertiseModel we want to update
     *   }
     * })
    **/
    upsert<T extends SubExpertiseModelUpsertArgs>(
      args: SelectSubset<T, SubExpertiseModelUpsertArgs>
    ): Prisma__SubExpertiseModelClient<SubExpertiseModelGetPayload<T>>

    /**
     * Count the number of SubExpertiseModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubExpertiseModelCountArgs} args - Arguments to filter SubExpertiseModels to count.
     * @example
     * // Count the number of SubExpertiseModels
     * const count = await prisma.subExpertiseModel.count({
     *   where: {
     *     // ... the filter for the SubExpertiseModels we want to count
     *   }
     * })
    **/
    count<T extends SubExpertiseModelCountArgs>(
      args?: Subset<T, SubExpertiseModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubExpertiseModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubExpertiseModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubExpertiseModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubExpertiseModelAggregateArgs>(args: Subset<T, SubExpertiseModelAggregateArgs>): Prisma.PrismaPromise<GetSubExpertiseModelAggregateType<T>>

    /**
     * Group by SubExpertiseModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubExpertiseModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubExpertiseModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubExpertiseModelGroupByArgs['orderBy'] }
        : { orderBy?: SubExpertiseModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubExpertiseModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubExpertiseModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SubExpertiseModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubExpertiseModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    sub_category<T extends ServiceSubCategoryModelArgs= {}>(args?: Subset<T, ServiceSubCategoryModelArgs>): Prisma__ServiceSubCategoryModelClient<ServiceSubCategoryModelGetPayload<T> | Null>;

    business_user<T extends BusinessUserModelArgs= {}>(args?: Subset<T, BusinessUserModelArgs>): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SubExpertiseModel base type for findUnique actions
   */
  export type SubExpertiseModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SubExpertiseModel
     */
    select?: SubExpertiseModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubExpertiseModelInclude | null
    /**
     * Filter, which SubExpertiseModel to fetch.
     */
    where: SubExpertiseModelWhereUniqueInput
  }

  /**
   * SubExpertiseModel findUnique
   */
  export interface SubExpertiseModelFindUniqueArgs extends SubExpertiseModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SubExpertiseModel findUniqueOrThrow
   */
  export type SubExpertiseModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SubExpertiseModel
     */
    select?: SubExpertiseModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubExpertiseModelInclude | null
    /**
     * Filter, which SubExpertiseModel to fetch.
     */
    where: SubExpertiseModelWhereUniqueInput
  }


  /**
   * SubExpertiseModel base type for findFirst actions
   */
  export type SubExpertiseModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SubExpertiseModel
     */
    select?: SubExpertiseModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubExpertiseModelInclude | null
    /**
     * Filter, which SubExpertiseModel to fetch.
     */
    where?: SubExpertiseModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubExpertiseModels to fetch.
     */
    orderBy?: Enumerable<SubExpertiseModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubExpertiseModels.
     */
    cursor?: SubExpertiseModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubExpertiseModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubExpertiseModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubExpertiseModels.
     */
    distinct?: Enumerable<SubExpertiseModelScalarFieldEnum>
  }

  /**
   * SubExpertiseModel findFirst
   */
  export interface SubExpertiseModelFindFirstArgs extends SubExpertiseModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SubExpertiseModel findFirstOrThrow
   */
  export type SubExpertiseModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SubExpertiseModel
     */
    select?: SubExpertiseModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubExpertiseModelInclude | null
    /**
     * Filter, which SubExpertiseModel to fetch.
     */
    where?: SubExpertiseModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubExpertiseModels to fetch.
     */
    orderBy?: Enumerable<SubExpertiseModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubExpertiseModels.
     */
    cursor?: SubExpertiseModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubExpertiseModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubExpertiseModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubExpertiseModels.
     */
    distinct?: Enumerable<SubExpertiseModelScalarFieldEnum>
  }


  /**
   * SubExpertiseModel findMany
   */
  export type SubExpertiseModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the SubExpertiseModel
     */
    select?: SubExpertiseModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubExpertiseModelInclude | null
    /**
     * Filter, which SubExpertiseModels to fetch.
     */
    where?: SubExpertiseModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubExpertiseModels to fetch.
     */
    orderBy?: Enumerable<SubExpertiseModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubExpertiseModels.
     */
    cursor?: SubExpertiseModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubExpertiseModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubExpertiseModels.
     */
    skip?: number
    distinct?: Enumerable<SubExpertiseModelScalarFieldEnum>
  }


  /**
   * SubExpertiseModel create
   */
  export type SubExpertiseModelCreateArgs = {
    /**
     * Select specific fields to fetch from the SubExpertiseModel
     */
    select?: SubExpertiseModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubExpertiseModelInclude | null
    /**
     * The data needed to create a SubExpertiseModel.
     */
    data: XOR<SubExpertiseModelCreateInput, SubExpertiseModelUncheckedCreateInput>
  }


  /**
   * SubExpertiseModel createMany
   */
  export type SubExpertiseModelCreateManyArgs = {
    /**
     * The data used to create many SubExpertiseModels.
     */
    data: Enumerable<SubExpertiseModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SubExpertiseModel update
   */
  export type SubExpertiseModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the SubExpertiseModel
     */
    select?: SubExpertiseModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubExpertiseModelInclude | null
    /**
     * The data needed to update a SubExpertiseModel.
     */
    data: XOR<SubExpertiseModelUpdateInput, SubExpertiseModelUncheckedUpdateInput>
    /**
     * Choose, which SubExpertiseModel to update.
     */
    where: SubExpertiseModelWhereUniqueInput
  }


  /**
   * SubExpertiseModel updateMany
   */
  export type SubExpertiseModelUpdateManyArgs = {
    /**
     * The data used to update SubExpertiseModels.
     */
    data: XOR<SubExpertiseModelUpdateManyMutationInput, SubExpertiseModelUncheckedUpdateManyInput>
    /**
     * Filter which SubExpertiseModels to update
     */
    where?: SubExpertiseModelWhereInput
  }


  /**
   * SubExpertiseModel upsert
   */
  export type SubExpertiseModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the SubExpertiseModel
     */
    select?: SubExpertiseModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubExpertiseModelInclude | null
    /**
     * The filter to search for the SubExpertiseModel to update in case it exists.
     */
    where: SubExpertiseModelWhereUniqueInput
    /**
     * In case the SubExpertiseModel found by the `where` argument doesn't exist, create a new SubExpertiseModel with this data.
     */
    create: XOR<SubExpertiseModelCreateInput, SubExpertiseModelUncheckedCreateInput>
    /**
     * In case the SubExpertiseModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubExpertiseModelUpdateInput, SubExpertiseModelUncheckedUpdateInput>
  }


  /**
   * SubExpertiseModel delete
   */
  export type SubExpertiseModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the SubExpertiseModel
     */
    select?: SubExpertiseModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubExpertiseModelInclude | null
    /**
     * Filter which SubExpertiseModel to delete.
     */
    where: SubExpertiseModelWhereUniqueInput
  }


  /**
   * SubExpertiseModel deleteMany
   */
  export type SubExpertiseModelDeleteManyArgs = {
    /**
     * Filter which SubExpertiseModels to delete
     */
    where?: SubExpertiseModelWhereInput
  }


  /**
   * SubExpertiseModel without action
   */
  export type SubExpertiseModelArgs = {
    /**
     * Select specific fields to fetch from the SubExpertiseModel
     */
    select?: SubExpertiseModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubExpertiseModelInclude | null
  }



  /**
   * Model REAgentModel
   */


  export type AggregateREAgentModel = {
    _count: REAgentModelCountAggregateOutputType | null
    _min: REAgentModelMinAggregateOutputType | null
    _max: REAgentModelMaxAggregateOutputType | null
  }

  export type REAgentModelMinAggregateOutputType = {
    id: string | null
    is_licensed: boolean | null
    re_num: string | null
    re_name: string | null
    re_phone: string | null
    re_licensed_agent_name: string | null
  }

  export type REAgentModelMaxAggregateOutputType = {
    id: string | null
    is_licensed: boolean | null
    re_num: string | null
    re_name: string | null
    re_phone: string | null
    re_licensed_agent_name: string | null
  }

  export type REAgentModelCountAggregateOutputType = {
    id: number
    is_licensed: number
    re_num: number
    re_name: number
    re_phone: number
    re_licensed_agent_name: number
    _all: number
  }


  export type REAgentModelMinAggregateInputType = {
    id?: true
    is_licensed?: true
    re_num?: true
    re_name?: true
    re_phone?: true
    re_licensed_agent_name?: true
  }

  export type REAgentModelMaxAggregateInputType = {
    id?: true
    is_licensed?: true
    re_num?: true
    re_name?: true
    re_phone?: true
    re_licensed_agent_name?: true
  }

  export type REAgentModelCountAggregateInputType = {
    id?: true
    is_licensed?: true
    re_num?: true
    re_name?: true
    re_phone?: true
    re_licensed_agent_name?: true
    _all?: true
  }

  export type REAgentModelAggregateArgs = {
    /**
     * Filter which REAgentModel to aggregate.
     */
    where?: REAgentModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REAgentModels to fetch.
     */
    orderBy?: Enumerable<REAgentModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: REAgentModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REAgentModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REAgentModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned REAgentModels
    **/
    _count?: true | REAgentModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: REAgentModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: REAgentModelMaxAggregateInputType
  }

  export type GetREAgentModelAggregateType<T extends REAgentModelAggregateArgs> = {
        [P in keyof T & keyof AggregateREAgentModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateREAgentModel[P]>
      : GetScalarType<T[P], AggregateREAgentModel[P]>
  }




  export type REAgentModelGroupByArgs = {
    where?: REAgentModelWhereInput
    orderBy?: Enumerable<REAgentModelOrderByWithAggregationInput>
    by: REAgentModelScalarFieldEnum[]
    having?: REAgentModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: REAgentModelCountAggregateInputType | true
    _min?: REAgentModelMinAggregateInputType
    _max?: REAgentModelMaxAggregateInputType
  }


  export type REAgentModelGroupByOutputType = {
    id: string
    is_licensed: boolean
    re_num: string
    re_name: string
    re_phone: string
    re_licensed_agent_name: string
    _count: REAgentModelCountAggregateOutputType | null
    _min: REAgentModelMinAggregateOutputType | null
    _max: REAgentModelMaxAggregateOutputType | null
  }

  type GetREAgentModelGroupByPayload<T extends REAgentModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<REAgentModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof REAgentModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], REAgentModelGroupByOutputType[P]>
            : GetScalarType<T[P], REAgentModelGroupByOutputType[P]>
        }
      >
    >


  export type REAgentModelSelect = {
    id?: boolean
    is_licensed?: boolean
    re_num?: boolean
    re_name?: boolean
    re_phone?: boolean
    re_licensed_agent_name?: boolean
    base?: boolean | BusinessUserModelArgs
    properties?: boolean | REAgentModel$propertiesArgs
    _count?: boolean | REAgentModelCountOutputTypeArgs
  }


  export type REAgentModelInclude = {
    base?: boolean | BusinessUserModelArgs
    properties?: boolean | REAgentModel$propertiesArgs
    _count?: boolean | REAgentModelCountOutputTypeArgs
  }

  export type REAgentModelGetPayload<S extends boolean | null | undefined | REAgentModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? REAgentModel :
    S extends undefined ? never :
    S extends { include: any } & (REAgentModelArgs | REAgentModelFindManyArgs)
    ? REAgentModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'base' ? BusinessUserModelGetPayload<S['include'][P]> :
        P extends 'properties' ? Array < REProertyModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? REAgentModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (REAgentModelArgs | REAgentModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'base' ? BusinessUserModelGetPayload<S['select'][P]> :
        P extends 'properties' ? Array < REProertyModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? REAgentModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof REAgentModel ? REAgentModel[P] : never
  } 
      : REAgentModel


  type REAgentModelCountArgs = 
    Omit<REAgentModelFindManyArgs, 'select' | 'include'> & {
      select?: REAgentModelCountAggregateInputType | true
    }

  export interface REAgentModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one REAgentModel that matches the filter.
     * @param {REAgentModelFindUniqueArgs} args - Arguments to find a REAgentModel
     * @example
     * // Get one REAgentModel
     * const rEAgentModel = await prisma.rEAgentModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends REAgentModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, REAgentModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'REAgentModel'> extends True ? Prisma__REAgentModelClient<REAgentModelGetPayload<T>> : Prisma__REAgentModelClient<REAgentModelGetPayload<T> | null, null>

    /**
     * Find one REAgentModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {REAgentModelFindUniqueOrThrowArgs} args - Arguments to find a REAgentModel
     * @example
     * // Get one REAgentModel
     * const rEAgentModel = await prisma.rEAgentModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends REAgentModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, REAgentModelFindUniqueOrThrowArgs>
    ): Prisma__REAgentModelClient<REAgentModelGetPayload<T>>

    /**
     * Find the first REAgentModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REAgentModelFindFirstArgs} args - Arguments to find a REAgentModel
     * @example
     * // Get one REAgentModel
     * const rEAgentModel = await prisma.rEAgentModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends REAgentModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, REAgentModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'REAgentModel'> extends True ? Prisma__REAgentModelClient<REAgentModelGetPayload<T>> : Prisma__REAgentModelClient<REAgentModelGetPayload<T> | null, null>

    /**
     * Find the first REAgentModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REAgentModelFindFirstOrThrowArgs} args - Arguments to find a REAgentModel
     * @example
     * // Get one REAgentModel
     * const rEAgentModel = await prisma.rEAgentModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends REAgentModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, REAgentModelFindFirstOrThrowArgs>
    ): Prisma__REAgentModelClient<REAgentModelGetPayload<T>>

    /**
     * Find zero or more REAgentModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REAgentModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all REAgentModels
     * const rEAgentModels = await prisma.rEAgentModel.findMany()
     * 
     * // Get first 10 REAgentModels
     * const rEAgentModels = await prisma.rEAgentModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rEAgentModelWithIdOnly = await prisma.rEAgentModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends REAgentModelFindManyArgs>(
      args?: SelectSubset<T, REAgentModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<REAgentModelGetPayload<T>>>

    /**
     * Create a REAgentModel.
     * @param {REAgentModelCreateArgs} args - Arguments to create a REAgentModel.
     * @example
     * // Create one REAgentModel
     * const REAgentModel = await prisma.rEAgentModel.create({
     *   data: {
     *     // ... data to create a REAgentModel
     *   }
     * })
     * 
    **/
    create<T extends REAgentModelCreateArgs>(
      args: SelectSubset<T, REAgentModelCreateArgs>
    ): Prisma__REAgentModelClient<REAgentModelGetPayload<T>>

    /**
     * Create many REAgentModels.
     *     @param {REAgentModelCreateManyArgs} args - Arguments to create many REAgentModels.
     *     @example
     *     // Create many REAgentModels
     *     const rEAgentModel = await prisma.rEAgentModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends REAgentModelCreateManyArgs>(
      args?: SelectSubset<T, REAgentModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a REAgentModel.
     * @param {REAgentModelDeleteArgs} args - Arguments to delete one REAgentModel.
     * @example
     * // Delete one REAgentModel
     * const REAgentModel = await prisma.rEAgentModel.delete({
     *   where: {
     *     // ... filter to delete one REAgentModel
     *   }
     * })
     * 
    **/
    delete<T extends REAgentModelDeleteArgs>(
      args: SelectSubset<T, REAgentModelDeleteArgs>
    ): Prisma__REAgentModelClient<REAgentModelGetPayload<T>>

    /**
     * Update one REAgentModel.
     * @param {REAgentModelUpdateArgs} args - Arguments to update one REAgentModel.
     * @example
     * // Update one REAgentModel
     * const rEAgentModel = await prisma.rEAgentModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends REAgentModelUpdateArgs>(
      args: SelectSubset<T, REAgentModelUpdateArgs>
    ): Prisma__REAgentModelClient<REAgentModelGetPayload<T>>

    /**
     * Delete zero or more REAgentModels.
     * @param {REAgentModelDeleteManyArgs} args - Arguments to filter REAgentModels to delete.
     * @example
     * // Delete a few REAgentModels
     * const { count } = await prisma.rEAgentModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends REAgentModelDeleteManyArgs>(
      args?: SelectSubset<T, REAgentModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more REAgentModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REAgentModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many REAgentModels
     * const rEAgentModel = await prisma.rEAgentModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends REAgentModelUpdateManyArgs>(
      args: SelectSubset<T, REAgentModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one REAgentModel.
     * @param {REAgentModelUpsertArgs} args - Arguments to update or create a REAgentModel.
     * @example
     * // Update or create a REAgentModel
     * const rEAgentModel = await prisma.rEAgentModel.upsert({
     *   create: {
     *     // ... data to create a REAgentModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the REAgentModel we want to update
     *   }
     * })
    **/
    upsert<T extends REAgentModelUpsertArgs>(
      args: SelectSubset<T, REAgentModelUpsertArgs>
    ): Prisma__REAgentModelClient<REAgentModelGetPayload<T>>

    /**
     * Count the number of REAgentModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REAgentModelCountArgs} args - Arguments to filter REAgentModels to count.
     * @example
     * // Count the number of REAgentModels
     * const count = await prisma.rEAgentModel.count({
     *   where: {
     *     // ... the filter for the REAgentModels we want to count
     *   }
     * })
    **/
    count<T extends REAgentModelCountArgs>(
      args?: Subset<T, REAgentModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], REAgentModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a REAgentModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REAgentModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends REAgentModelAggregateArgs>(args: Subset<T, REAgentModelAggregateArgs>): Prisma.PrismaPromise<GetREAgentModelAggregateType<T>>

    /**
     * Group by REAgentModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REAgentModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends REAgentModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: REAgentModelGroupByArgs['orderBy'] }
        : { orderBy?: REAgentModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, REAgentModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetREAgentModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for REAgentModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__REAgentModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    base<T extends BusinessUserModelArgs= {}>(args?: Subset<T, BusinessUserModelArgs>): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T> | Null>;

    properties<T extends REAgentModel$propertiesArgs= {}>(args?: Subset<T, REAgentModel$propertiesArgs>): Prisma.PrismaPromise<Array<REProertyModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * REAgentModel base type for findUnique actions
   */
  export type REAgentModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the REAgentModel
     */
    select?: REAgentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REAgentModelInclude | null
    /**
     * Filter, which REAgentModel to fetch.
     */
    where: REAgentModelWhereUniqueInput
  }

  /**
   * REAgentModel findUnique
   */
  export interface REAgentModelFindUniqueArgs extends REAgentModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * REAgentModel findUniqueOrThrow
   */
  export type REAgentModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the REAgentModel
     */
    select?: REAgentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REAgentModelInclude | null
    /**
     * Filter, which REAgentModel to fetch.
     */
    where: REAgentModelWhereUniqueInput
  }


  /**
   * REAgentModel base type for findFirst actions
   */
  export type REAgentModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the REAgentModel
     */
    select?: REAgentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REAgentModelInclude | null
    /**
     * Filter, which REAgentModel to fetch.
     */
    where?: REAgentModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REAgentModels to fetch.
     */
    orderBy?: Enumerable<REAgentModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REAgentModels.
     */
    cursor?: REAgentModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REAgentModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REAgentModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REAgentModels.
     */
    distinct?: Enumerable<REAgentModelScalarFieldEnum>
  }

  /**
   * REAgentModel findFirst
   */
  export interface REAgentModelFindFirstArgs extends REAgentModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * REAgentModel findFirstOrThrow
   */
  export type REAgentModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the REAgentModel
     */
    select?: REAgentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REAgentModelInclude | null
    /**
     * Filter, which REAgentModel to fetch.
     */
    where?: REAgentModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REAgentModels to fetch.
     */
    orderBy?: Enumerable<REAgentModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REAgentModels.
     */
    cursor?: REAgentModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REAgentModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REAgentModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REAgentModels.
     */
    distinct?: Enumerable<REAgentModelScalarFieldEnum>
  }


  /**
   * REAgentModel findMany
   */
  export type REAgentModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the REAgentModel
     */
    select?: REAgentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REAgentModelInclude | null
    /**
     * Filter, which REAgentModels to fetch.
     */
    where?: REAgentModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REAgentModels to fetch.
     */
    orderBy?: Enumerable<REAgentModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing REAgentModels.
     */
    cursor?: REAgentModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REAgentModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REAgentModels.
     */
    skip?: number
    distinct?: Enumerable<REAgentModelScalarFieldEnum>
  }


  /**
   * REAgentModel create
   */
  export type REAgentModelCreateArgs = {
    /**
     * Select specific fields to fetch from the REAgentModel
     */
    select?: REAgentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REAgentModelInclude | null
    /**
     * The data needed to create a REAgentModel.
     */
    data: XOR<REAgentModelCreateInput, REAgentModelUncheckedCreateInput>
  }


  /**
   * REAgentModel createMany
   */
  export type REAgentModelCreateManyArgs = {
    /**
     * The data used to create many REAgentModels.
     */
    data: Enumerable<REAgentModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * REAgentModel update
   */
  export type REAgentModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the REAgentModel
     */
    select?: REAgentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REAgentModelInclude | null
    /**
     * The data needed to update a REAgentModel.
     */
    data: XOR<REAgentModelUpdateInput, REAgentModelUncheckedUpdateInput>
    /**
     * Choose, which REAgentModel to update.
     */
    where: REAgentModelWhereUniqueInput
  }


  /**
   * REAgentModel updateMany
   */
  export type REAgentModelUpdateManyArgs = {
    /**
     * The data used to update REAgentModels.
     */
    data: XOR<REAgentModelUpdateManyMutationInput, REAgentModelUncheckedUpdateManyInput>
    /**
     * Filter which REAgentModels to update
     */
    where?: REAgentModelWhereInput
  }


  /**
   * REAgentModel upsert
   */
  export type REAgentModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the REAgentModel
     */
    select?: REAgentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REAgentModelInclude | null
    /**
     * The filter to search for the REAgentModel to update in case it exists.
     */
    where: REAgentModelWhereUniqueInput
    /**
     * In case the REAgentModel found by the `where` argument doesn't exist, create a new REAgentModel with this data.
     */
    create: XOR<REAgentModelCreateInput, REAgentModelUncheckedCreateInput>
    /**
     * In case the REAgentModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<REAgentModelUpdateInput, REAgentModelUncheckedUpdateInput>
  }


  /**
   * REAgentModel delete
   */
  export type REAgentModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the REAgentModel
     */
    select?: REAgentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REAgentModelInclude | null
    /**
     * Filter which REAgentModel to delete.
     */
    where: REAgentModelWhereUniqueInput
  }


  /**
   * REAgentModel deleteMany
   */
  export type REAgentModelDeleteManyArgs = {
    /**
     * Filter which REAgentModels to delete
     */
    where?: REAgentModelWhereInput
  }


  /**
   * REAgentModel.properties
   */
  export type REAgentModel$propertiesArgs = {
    /**
     * Select specific fields to fetch from the REProertyModel
     */
    select?: REProertyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REProertyModelInclude | null
    where?: REProertyModelWhereInput
    orderBy?: Enumerable<REProertyModelOrderByWithRelationInput>
    cursor?: REProertyModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<REProertyModelScalarFieldEnum>
  }


  /**
   * REAgentModel without action
   */
  export type REAgentModelArgs = {
    /**
     * Select specific fields to fetch from the REAgentModel
     */
    select?: REAgentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REAgentModelInclude | null
  }



  /**
   * Model HSProviderModel
   */


  export type AggregateHSProviderModel = {
    _count: HSProviderModelCountAggregateOutputType | null
    _min: HSProviderModelMinAggregateOutputType | null
    _max: HSProviderModelMaxAggregateOutputType | null
  }

  export type HSProviderModelMinAggregateOutputType = {
    id: string | null
    business_registration_num: string | null
  }

  export type HSProviderModelMaxAggregateOutputType = {
    id: string | null
    business_registration_num: string | null
  }

  export type HSProviderModelCountAggregateOutputType = {
    id: number
    business_registration_num: number
    _all: number
  }


  export type HSProviderModelMinAggregateInputType = {
    id?: true
    business_registration_num?: true
  }

  export type HSProviderModelMaxAggregateInputType = {
    id?: true
    business_registration_num?: true
  }

  export type HSProviderModelCountAggregateInputType = {
    id?: true
    business_registration_num?: true
    _all?: true
  }

  export type HSProviderModelAggregateArgs = {
    /**
     * Filter which HSProviderModel to aggregate.
     */
    where?: HSProviderModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HSProviderModels to fetch.
     */
    orderBy?: Enumerable<HSProviderModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HSProviderModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HSProviderModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HSProviderModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HSProviderModels
    **/
    _count?: true | HSProviderModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HSProviderModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HSProviderModelMaxAggregateInputType
  }

  export type GetHSProviderModelAggregateType<T extends HSProviderModelAggregateArgs> = {
        [P in keyof T & keyof AggregateHSProviderModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHSProviderModel[P]>
      : GetScalarType<T[P], AggregateHSProviderModel[P]>
  }




  export type HSProviderModelGroupByArgs = {
    where?: HSProviderModelWhereInput
    orderBy?: Enumerable<HSProviderModelOrderByWithAggregationInput>
    by: HSProviderModelScalarFieldEnum[]
    having?: HSProviderModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HSProviderModelCountAggregateInputType | true
    _min?: HSProviderModelMinAggregateInputType
    _max?: HSProviderModelMaxAggregateInputType
  }


  export type HSProviderModelGroupByOutputType = {
    id: string
    business_registration_num: string
    _count: HSProviderModelCountAggregateOutputType | null
    _min: HSProviderModelMinAggregateOutputType | null
    _max: HSProviderModelMaxAggregateOutputType | null
  }

  type GetHSProviderModelGroupByPayload<T extends HSProviderModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HSProviderModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HSProviderModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HSProviderModelGroupByOutputType[P]>
            : GetScalarType<T[P], HSProviderModelGroupByOutputType[P]>
        }
      >
    >


  export type HSProviderModelSelect = {
    id?: boolean
    business_registration_num?: boolean
    base?: boolean | BusinessUserModelArgs
    introduction_images?: boolean | HSProviderModel$introduction_imagesArgs
    _count?: boolean | HSProviderModelCountOutputTypeArgs
  }


  export type HSProviderModelInclude = {
    base?: boolean | BusinessUserModelArgs
    introduction_images?: boolean | HSProviderModel$introduction_imagesArgs
    _count?: boolean | HSProviderModelCountOutputTypeArgs
  }

  export type HSProviderModelGetPayload<S extends boolean | null | undefined | HSProviderModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HSProviderModel :
    S extends undefined ? never :
    S extends { include: any } & (HSProviderModelArgs | HSProviderModelFindManyArgs)
    ? HSProviderModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'base' ? BusinessUserModelGetPayload<S['include'][P]> :
        P extends 'introduction_images' ? Array < HSIntroductionImageModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? HSProviderModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (HSProviderModelArgs | HSProviderModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'base' ? BusinessUserModelGetPayload<S['select'][P]> :
        P extends 'introduction_images' ? Array < HSIntroductionImageModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? HSProviderModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof HSProviderModel ? HSProviderModel[P] : never
  } 
      : HSProviderModel


  type HSProviderModelCountArgs = 
    Omit<HSProviderModelFindManyArgs, 'select' | 'include'> & {
      select?: HSProviderModelCountAggregateInputType | true
    }

  export interface HSProviderModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one HSProviderModel that matches the filter.
     * @param {HSProviderModelFindUniqueArgs} args - Arguments to find a HSProviderModel
     * @example
     * // Get one HSProviderModel
     * const hSProviderModel = await prisma.hSProviderModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HSProviderModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HSProviderModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'HSProviderModel'> extends True ? Prisma__HSProviderModelClient<HSProviderModelGetPayload<T>> : Prisma__HSProviderModelClient<HSProviderModelGetPayload<T> | null, null>

    /**
     * Find one HSProviderModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HSProviderModelFindUniqueOrThrowArgs} args - Arguments to find a HSProviderModel
     * @example
     * // Get one HSProviderModel
     * const hSProviderModel = await prisma.hSProviderModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HSProviderModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, HSProviderModelFindUniqueOrThrowArgs>
    ): Prisma__HSProviderModelClient<HSProviderModelGetPayload<T>>

    /**
     * Find the first HSProviderModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSProviderModelFindFirstArgs} args - Arguments to find a HSProviderModel
     * @example
     * // Get one HSProviderModel
     * const hSProviderModel = await prisma.hSProviderModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HSProviderModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HSProviderModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'HSProviderModel'> extends True ? Prisma__HSProviderModelClient<HSProviderModelGetPayload<T>> : Prisma__HSProviderModelClient<HSProviderModelGetPayload<T> | null, null>

    /**
     * Find the first HSProviderModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSProviderModelFindFirstOrThrowArgs} args - Arguments to find a HSProviderModel
     * @example
     * // Get one HSProviderModel
     * const hSProviderModel = await prisma.hSProviderModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HSProviderModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HSProviderModelFindFirstOrThrowArgs>
    ): Prisma__HSProviderModelClient<HSProviderModelGetPayload<T>>

    /**
     * Find zero or more HSProviderModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSProviderModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HSProviderModels
     * const hSProviderModels = await prisma.hSProviderModel.findMany()
     * 
     * // Get first 10 HSProviderModels
     * const hSProviderModels = await prisma.hSProviderModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hSProviderModelWithIdOnly = await prisma.hSProviderModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HSProviderModelFindManyArgs>(
      args?: SelectSubset<T, HSProviderModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<HSProviderModelGetPayload<T>>>

    /**
     * Create a HSProviderModel.
     * @param {HSProviderModelCreateArgs} args - Arguments to create a HSProviderModel.
     * @example
     * // Create one HSProviderModel
     * const HSProviderModel = await prisma.hSProviderModel.create({
     *   data: {
     *     // ... data to create a HSProviderModel
     *   }
     * })
     * 
    **/
    create<T extends HSProviderModelCreateArgs>(
      args: SelectSubset<T, HSProviderModelCreateArgs>
    ): Prisma__HSProviderModelClient<HSProviderModelGetPayload<T>>

    /**
     * Create many HSProviderModels.
     *     @param {HSProviderModelCreateManyArgs} args - Arguments to create many HSProviderModels.
     *     @example
     *     // Create many HSProviderModels
     *     const hSProviderModel = await prisma.hSProviderModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HSProviderModelCreateManyArgs>(
      args?: SelectSubset<T, HSProviderModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HSProviderModel.
     * @param {HSProviderModelDeleteArgs} args - Arguments to delete one HSProviderModel.
     * @example
     * // Delete one HSProviderModel
     * const HSProviderModel = await prisma.hSProviderModel.delete({
     *   where: {
     *     // ... filter to delete one HSProviderModel
     *   }
     * })
     * 
    **/
    delete<T extends HSProviderModelDeleteArgs>(
      args: SelectSubset<T, HSProviderModelDeleteArgs>
    ): Prisma__HSProviderModelClient<HSProviderModelGetPayload<T>>

    /**
     * Update one HSProviderModel.
     * @param {HSProviderModelUpdateArgs} args - Arguments to update one HSProviderModel.
     * @example
     * // Update one HSProviderModel
     * const hSProviderModel = await prisma.hSProviderModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HSProviderModelUpdateArgs>(
      args: SelectSubset<T, HSProviderModelUpdateArgs>
    ): Prisma__HSProviderModelClient<HSProviderModelGetPayload<T>>

    /**
     * Delete zero or more HSProviderModels.
     * @param {HSProviderModelDeleteManyArgs} args - Arguments to filter HSProviderModels to delete.
     * @example
     * // Delete a few HSProviderModels
     * const { count } = await prisma.hSProviderModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HSProviderModelDeleteManyArgs>(
      args?: SelectSubset<T, HSProviderModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HSProviderModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSProviderModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HSProviderModels
     * const hSProviderModel = await prisma.hSProviderModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HSProviderModelUpdateManyArgs>(
      args: SelectSubset<T, HSProviderModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HSProviderModel.
     * @param {HSProviderModelUpsertArgs} args - Arguments to update or create a HSProviderModel.
     * @example
     * // Update or create a HSProviderModel
     * const hSProviderModel = await prisma.hSProviderModel.upsert({
     *   create: {
     *     // ... data to create a HSProviderModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HSProviderModel we want to update
     *   }
     * })
    **/
    upsert<T extends HSProviderModelUpsertArgs>(
      args: SelectSubset<T, HSProviderModelUpsertArgs>
    ): Prisma__HSProviderModelClient<HSProviderModelGetPayload<T>>

    /**
     * Count the number of HSProviderModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSProviderModelCountArgs} args - Arguments to filter HSProviderModels to count.
     * @example
     * // Count the number of HSProviderModels
     * const count = await prisma.hSProviderModel.count({
     *   where: {
     *     // ... the filter for the HSProviderModels we want to count
     *   }
     * })
    **/
    count<T extends HSProviderModelCountArgs>(
      args?: Subset<T, HSProviderModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HSProviderModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HSProviderModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSProviderModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HSProviderModelAggregateArgs>(args: Subset<T, HSProviderModelAggregateArgs>): Prisma.PrismaPromise<GetHSProviderModelAggregateType<T>>

    /**
     * Group by HSProviderModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSProviderModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HSProviderModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HSProviderModelGroupByArgs['orderBy'] }
        : { orderBy?: HSProviderModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HSProviderModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHSProviderModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for HSProviderModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HSProviderModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    base<T extends BusinessUserModelArgs= {}>(args?: Subset<T, BusinessUserModelArgs>): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T> | Null>;

    introduction_images<T extends HSProviderModel$introduction_imagesArgs= {}>(args?: Subset<T, HSProviderModel$introduction_imagesArgs>): Prisma.PrismaPromise<Array<HSIntroductionImageModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * HSProviderModel base type for findUnique actions
   */
  export type HSProviderModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the HSProviderModel
     */
    select?: HSProviderModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSProviderModelInclude | null
    /**
     * Filter, which HSProviderModel to fetch.
     */
    where: HSProviderModelWhereUniqueInput
  }

  /**
   * HSProviderModel findUnique
   */
  export interface HSProviderModelFindUniqueArgs extends HSProviderModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HSProviderModel findUniqueOrThrow
   */
  export type HSProviderModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HSProviderModel
     */
    select?: HSProviderModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSProviderModelInclude | null
    /**
     * Filter, which HSProviderModel to fetch.
     */
    where: HSProviderModelWhereUniqueInput
  }


  /**
   * HSProviderModel base type for findFirst actions
   */
  export type HSProviderModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the HSProviderModel
     */
    select?: HSProviderModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSProviderModelInclude | null
    /**
     * Filter, which HSProviderModel to fetch.
     */
    where?: HSProviderModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HSProviderModels to fetch.
     */
    orderBy?: Enumerable<HSProviderModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HSProviderModels.
     */
    cursor?: HSProviderModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HSProviderModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HSProviderModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HSProviderModels.
     */
    distinct?: Enumerable<HSProviderModelScalarFieldEnum>
  }

  /**
   * HSProviderModel findFirst
   */
  export interface HSProviderModelFindFirstArgs extends HSProviderModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HSProviderModel findFirstOrThrow
   */
  export type HSProviderModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HSProviderModel
     */
    select?: HSProviderModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSProviderModelInclude | null
    /**
     * Filter, which HSProviderModel to fetch.
     */
    where?: HSProviderModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HSProviderModels to fetch.
     */
    orderBy?: Enumerable<HSProviderModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HSProviderModels.
     */
    cursor?: HSProviderModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HSProviderModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HSProviderModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HSProviderModels.
     */
    distinct?: Enumerable<HSProviderModelScalarFieldEnum>
  }


  /**
   * HSProviderModel findMany
   */
  export type HSProviderModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the HSProviderModel
     */
    select?: HSProviderModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSProviderModelInclude | null
    /**
     * Filter, which HSProviderModels to fetch.
     */
    where?: HSProviderModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HSProviderModels to fetch.
     */
    orderBy?: Enumerable<HSProviderModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HSProviderModels.
     */
    cursor?: HSProviderModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HSProviderModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HSProviderModels.
     */
    skip?: number
    distinct?: Enumerable<HSProviderModelScalarFieldEnum>
  }


  /**
   * HSProviderModel create
   */
  export type HSProviderModelCreateArgs = {
    /**
     * Select specific fields to fetch from the HSProviderModel
     */
    select?: HSProviderModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSProviderModelInclude | null
    /**
     * The data needed to create a HSProviderModel.
     */
    data: XOR<HSProviderModelCreateInput, HSProviderModelUncheckedCreateInput>
  }


  /**
   * HSProviderModel createMany
   */
  export type HSProviderModelCreateManyArgs = {
    /**
     * The data used to create many HSProviderModels.
     */
    data: Enumerable<HSProviderModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * HSProviderModel update
   */
  export type HSProviderModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the HSProviderModel
     */
    select?: HSProviderModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSProviderModelInclude | null
    /**
     * The data needed to update a HSProviderModel.
     */
    data: XOR<HSProviderModelUpdateInput, HSProviderModelUncheckedUpdateInput>
    /**
     * Choose, which HSProviderModel to update.
     */
    where: HSProviderModelWhereUniqueInput
  }


  /**
   * HSProviderModel updateMany
   */
  export type HSProviderModelUpdateManyArgs = {
    /**
     * The data used to update HSProviderModels.
     */
    data: XOR<HSProviderModelUpdateManyMutationInput, HSProviderModelUncheckedUpdateManyInput>
    /**
     * Filter which HSProviderModels to update
     */
    where?: HSProviderModelWhereInput
  }


  /**
   * HSProviderModel upsert
   */
  export type HSProviderModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the HSProviderModel
     */
    select?: HSProviderModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSProviderModelInclude | null
    /**
     * The filter to search for the HSProviderModel to update in case it exists.
     */
    where: HSProviderModelWhereUniqueInput
    /**
     * In case the HSProviderModel found by the `where` argument doesn't exist, create a new HSProviderModel with this data.
     */
    create: XOR<HSProviderModelCreateInput, HSProviderModelUncheckedCreateInput>
    /**
     * In case the HSProviderModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HSProviderModelUpdateInput, HSProviderModelUncheckedUpdateInput>
  }


  /**
   * HSProviderModel delete
   */
  export type HSProviderModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the HSProviderModel
     */
    select?: HSProviderModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSProviderModelInclude | null
    /**
     * Filter which HSProviderModel to delete.
     */
    where: HSProviderModelWhereUniqueInput
  }


  /**
   * HSProviderModel deleteMany
   */
  export type HSProviderModelDeleteManyArgs = {
    /**
     * Filter which HSProviderModels to delete
     */
    where?: HSProviderModelWhereInput
  }


  /**
   * HSProviderModel.introduction_images
   */
  export type HSProviderModel$introduction_imagesArgs = {
    /**
     * Select specific fields to fetch from the HSIntroductionImageModel
     */
    select?: HSIntroductionImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSIntroductionImageModelInclude | null
    where?: HSIntroductionImageModelWhereInput
    orderBy?: Enumerable<HSIntroductionImageModelOrderByWithRelationInput>
    cursor?: HSIntroductionImageModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HSIntroductionImageModelScalarFieldEnum>
  }


  /**
   * HSProviderModel without action
   */
  export type HSProviderModelArgs = {
    /**
     * Select specific fields to fetch from the HSProviderModel
     */
    select?: HSProviderModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSProviderModelInclude | null
  }



  /**
   * Model BusinessCertificationImageModel
   */


  export type AggregateBusinessCertificationImageModel = {
    _count: BusinessCertificationImageModelCountAggregateOutputType | null
    _min: BusinessCertificationImageModelMinAggregateOutputType | null
    _max: BusinessCertificationImageModelMaxAggregateOutputType | null
  }

  export type BusinessCertificationImageModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    business_user_id: string | null
    url: string | null
  }

  export type BusinessCertificationImageModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    business_user_id: string | null
    url: string | null
  }

  export type BusinessCertificationImageModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    business_user_id: number
    url: number
    _all: number
  }


  export type BusinessCertificationImageModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    business_user_id?: true
    url?: true
  }

  export type BusinessCertificationImageModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    business_user_id?: true
    url?: true
  }

  export type BusinessCertificationImageModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    business_user_id?: true
    url?: true
    _all?: true
  }

  export type BusinessCertificationImageModelAggregateArgs = {
    /**
     * Filter which BusinessCertificationImageModel to aggregate.
     */
    where?: BusinessCertificationImageModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessCertificationImageModels to fetch.
     */
    orderBy?: Enumerable<BusinessCertificationImageModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessCertificationImageModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessCertificationImageModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessCertificationImageModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessCertificationImageModels
    **/
    _count?: true | BusinessCertificationImageModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessCertificationImageModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessCertificationImageModelMaxAggregateInputType
  }

  export type GetBusinessCertificationImageModelAggregateType<T extends BusinessCertificationImageModelAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessCertificationImageModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessCertificationImageModel[P]>
      : GetScalarType<T[P], AggregateBusinessCertificationImageModel[P]>
  }




  export type BusinessCertificationImageModelGroupByArgs = {
    where?: BusinessCertificationImageModelWhereInput
    orderBy?: Enumerable<BusinessCertificationImageModelOrderByWithAggregationInput>
    by: BusinessCertificationImageModelScalarFieldEnum[]
    having?: BusinessCertificationImageModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessCertificationImageModelCountAggregateInputType | true
    _min?: BusinessCertificationImageModelMinAggregateInputType
    _max?: BusinessCertificationImageModelMaxAggregateInputType
  }


  export type BusinessCertificationImageModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    business_user_id: string
    url: string
    _count: BusinessCertificationImageModelCountAggregateOutputType | null
    _min: BusinessCertificationImageModelMinAggregateOutputType | null
    _max: BusinessCertificationImageModelMaxAggregateOutputType | null
  }

  type GetBusinessCertificationImageModelGroupByPayload<T extends BusinessCertificationImageModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BusinessCertificationImageModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessCertificationImageModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessCertificationImageModelGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessCertificationImageModelGroupByOutputType[P]>
        }
      >
    >


  export type BusinessCertificationImageModelSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    business_user_id?: boolean
    url?: boolean
    business_user?: boolean | BusinessUserModelArgs
  }


  export type BusinessCertificationImageModelInclude = {
    business_user?: boolean | BusinessUserModelArgs
  }

  export type BusinessCertificationImageModelGetPayload<S extends boolean | null | undefined | BusinessCertificationImageModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BusinessCertificationImageModel :
    S extends undefined ? never :
    S extends { include: any } & (BusinessCertificationImageModelArgs | BusinessCertificationImageModelFindManyArgs)
    ? BusinessCertificationImageModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'business_user' ? BusinessUserModelGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BusinessCertificationImageModelArgs | BusinessCertificationImageModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'business_user' ? BusinessUserModelGetPayload<S['select'][P]> :  P extends keyof BusinessCertificationImageModel ? BusinessCertificationImageModel[P] : never
  } 
      : BusinessCertificationImageModel


  type BusinessCertificationImageModelCountArgs = 
    Omit<BusinessCertificationImageModelFindManyArgs, 'select' | 'include'> & {
      select?: BusinessCertificationImageModelCountAggregateInputType | true
    }

  export interface BusinessCertificationImageModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BusinessCertificationImageModel that matches the filter.
     * @param {BusinessCertificationImageModelFindUniqueArgs} args - Arguments to find a BusinessCertificationImageModel
     * @example
     * // Get one BusinessCertificationImageModel
     * const businessCertificationImageModel = await prisma.businessCertificationImageModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BusinessCertificationImageModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BusinessCertificationImageModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BusinessCertificationImageModel'> extends True ? Prisma__BusinessCertificationImageModelClient<BusinessCertificationImageModelGetPayload<T>> : Prisma__BusinessCertificationImageModelClient<BusinessCertificationImageModelGetPayload<T> | null, null>

    /**
     * Find one BusinessCertificationImageModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BusinessCertificationImageModelFindUniqueOrThrowArgs} args - Arguments to find a BusinessCertificationImageModel
     * @example
     * // Get one BusinessCertificationImageModel
     * const businessCertificationImageModel = await prisma.businessCertificationImageModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BusinessCertificationImageModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BusinessCertificationImageModelFindUniqueOrThrowArgs>
    ): Prisma__BusinessCertificationImageModelClient<BusinessCertificationImageModelGetPayload<T>>

    /**
     * Find the first BusinessCertificationImageModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCertificationImageModelFindFirstArgs} args - Arguments to find a BusinessCertificationImageModel
     * @example
     * // Get one BusinessCertificationImageModel
     * const businessCertificationImageModel = await prisma.businessCertificationImageModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BusinessCertificationImageModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BusinessCertificationImageModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BusinessCertificationImageModel'> extends True ? Prisma__BusinessCertificationImageModelClient<BusinessCertificationImageModelGetPayload<T>> : Prisma__BusinessCertificationImageModelClient<BusinessCertificationImageModelGetPayload<T> | null, null>

    /**
     * Find the first BusinessCertificationImageModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCertificationImageModelFindFirstOrThrowArgs} args - Arguments to find a BusinessCertificationImageModel
     * @example
     * // Get one BusinessCertificationImageModel
     * const businessCertificationImageModel = await prisma.businessCertificationImageModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BusinessCertificationImageModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BusinessCertificationImageModelFindFirstOrThrowArgs>
    ): Prisma__BusinessCertificationImageModelClient<BusinessCertificationImageModelGetPayload<T>>

    /**
     * Find zero or more BusinessCertificationImageModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCertificationImageModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessCertificationImageModels
     * const businessCertificationImageModels = await prisma.businessCertificationImageModel.findMany()
     * 
     * // Get first 10 BusinessCertificationImageModels
     * const businessCertificationImageModels = await prisma.businessCertificationImageModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessCertificationImageModelWithIdOnly = await prisma.businessCertificationImageModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BusinessCertificationImageModelFindManyArgs>(
      args?: SelectSubset<T, BusinessCertificationImageModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<BusinessCertificationImageModelGetPayload<T>>>

    /**
     * Create a BusinessCertificationImageModel.
     * @param {BusinessCertificationImageModelCreateArgs} args - Arguments to create a BusinessCertificationImageModel.
     * @example
     * // Create one BusinessCertificationImageModel
     * const BusinessCertificationImageModel = await prisma.businessCertificationImageModel.create({
     *   data: {
     *     // ... data to create a BusinessCertificationImageModel
     *   }
     * })
     * 
    **/
    create<T extends BusinessCertificationImageModelCreateArgs>(
      args: SelectSubset<T, BusinessCertificationImageModelCreateArgs>
    ): Prisma__BusinessCertificationImageModelClient<BusinessCertificationImageModelGetPayload<T>>

    /**
     * Create many BusinessCertificationImageModels.
     *     @param {BusinessCertificationImageModelCreateManyArgs} args - Arguments to create many BusinessCertificationImageModels.
     *     @example
     *     // Create many BusinessCertificationImageModels
     *     const businessCertificationImageModel = await prisma.businessCertificationImageModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BusinessCertificationImageModelCreateManyArgs>(
      args?: SelectSubset<T, BusinessCertificationImageModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BusinessCertificationImageModel.
     * @param {BusinessCertificationImageModelDeleteArgs} args - Arguments to delete one BusinessCertificationImageModel.
     * @example
     * // Delete one BusinessCertificationImageModel
     * const BusinessCertificationImageModel = await prisma.businessCertificationImageModel.delete({
     *   where: {
     *     // ... filter to delete one BusinessCertificationImageModel
     *   }
     * })
     * 
    **/
    delete<T extends BusinessCertificationImageModelDeleteArgs>(
      args: SelectSubset<T, BusinessCertificationImageModelDeleteArgs>
    ): Prisma__BusinessCertificationImageModelClient<BusinessCertificationImageModelGetPayload<T>>

    /**
     * Update one BusinessCertificationImageModel.
     * @param {BusinessCertificationImageModelUpdateArgs} args - Arguments to update one BusinessCertificationImageModel.
     * @example
     * // Update one BusinessCertificationImageModel
     * const businessCertificationImageModel = await prisma.businessCertificationImageModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BusinessCertificationImageModelUpdateArgs>(
      args: SelectSubset<T, BusinessCertificationImageModelUpdateArgs>
    ): Prisma__BusinessCertificationImageModelClient<BusinessCertificationImageModelGetPayload<T>>

    /**
     * Delete zero or more BusinessCertificationImageModels.
     * @param {BusinessCertificationImageModelDeleteManyArgs} args - Arguments to filter BusinessCertificationImageModels to delete.
     * @example
     * // Delete a few BusinessCertificationImageModels
     * const { count } = await prisma.businessCertificationImageModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BusinessCertificationImageModelDeleteManyArgs>(
      args?: SelectSubset<T, BusinessCertificationImageModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessCertificationImageModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCertificationImageModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessCertificationImageModels
     * const businessCertificationImageModel = await prisma.businessCertificationImageModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BusinessCertificationImageModelUpdateManyArgs>(
      args: SelectSubset<T, BusinessCertificationImageModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessCertificationImageModel.
     * @param {BusinessCertificationImageModelUpsertArgs} args - Arguments to update or create a BusinessCertificationImageModel.
     * @example
     * // Update or create a BusinessCertificationImageModel
     * const businessCertificationImageModel = await prisma.businessCertificationImageModel.upsert({
     *   create: {
     *     // ... data to create a BusinessCertificationImageModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessCertificationImageModel we want to update
     *   }
     * })
    **/
    upsert<T extends BusinessCertificationImageModelUpsertArgs>(
      args: SelectSubset<T, BusinessCertificationImageModelUpsertArgs>
    ): Prisma__BusinessCertificationImageModelClient<BusinessCertificationImageModelGetPayload<T>>

    /**
     * Count the number of BusinessCertificationImageModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCertificationImageModelCountArgs} args - Arguments to filter BusinessCertificationImageModels to count.
     * @example
     * // Count the number of BusinessCertificationImageModels
     * const count = await prisma.businessCertificationImageModel.count({
     *   where: {
     *     // ... the filter for the BusinessCertificationImageModels we want to count
     *   }
     * })
    **/
    count<T extends BusinessCertificationImageModelCountArgs>(
      args?: Subset<T, BusinessCertificationImageModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessCertificationImageModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessCertificationImageModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCertificationImageModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessCertificationImageModelAggregateArgs>(args: Subset<T, BusinessCertificationImageModelAggregateArgs>): Prisma.PrismaPromise<GetBusinessCertificationImageModelAggregateType<T>>

    /**
     * Group by BusinessCertificationImageModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCertificationImageModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessCertificationImageModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessCertificationImageModelGroupByArgs['orderBy'] }
        : { orderBy?: BusinessCertificationImageModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessCertificationImageModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessCertificationImageModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessCertificationImageModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BusinessCertificationImageModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    business_user<T extends BusinessUserModelArgs= {}>(args?: Subset<T, BusinessUserModelArgs>): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BusinessCertificationImageModel base type for findUnique actions
   */
  export type BusinessCertificationImageModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BusinessCertificationImageModel
     */
    select?: BusinessCertificationImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessCertificationImageModelInclude | null
    /**
     * Filter, which BusinessCertificationImageModel to fetch.
     */
    where: BusinessCertificationImageModelWhereUniqueInput
  }

  /**
   * BusinessCertificationImageModel findUnique
   */
  export interface BusinessCertificationImageModelFindUniqueArgs extends BusinessCertificationImageModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusinessCertificationImageModel findUniqueOrThrow
   */
  export type BusinessCertificationImageModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BusinessCertificationImageModel
     */
    select?: BusinessCertificationImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessCertificationImageModelInclude | null
    /**
     * Filter, which BusinessCertificationImageModel to fetch.
     */
    where: BusinessCertificationImageModelWhereUniqueInput
  }


  /**
   * BusinessCertificationImageModel base type for findFirst actions
   */
  export type BusinessCertificationImageModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BusinessCertificationImageModel
     */
    select?: BusinessCertificationImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessCertificationImageModelInclude | null
    /**
     * Filter, which BusinessCertificationImageModel to fetch.
     */
    where?: BusinessCertificationImageModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessCertificationImageModels to fetch.
     */
    orderBy?: Enumerable<BusinessCertificationImageModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessCertificationImageModels.
     */
    cursor?: BusinessCertificationImageModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessCertificationImageModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessCertificationImageModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessCertificationImageModels.
     */
    distinct?: Enumerable<BusinessCertificationImageModelScalarFieldEnum>
  }

  /**
   * BusinessCertificationImageModel findFirst
   */
  export interface BusinessCertificationImageModelFindFirstArgs extends BusinessCertificationImageModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusinessCertificationImageModel findFirstOrThrow
   */
  export type BusinessCertificationImageModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BusinessCertificationImageModel
     */
    select?: BusinessCertificationImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessCertificationImageModelInclude | null
    /**
     * Filter, which BusinessCertificationImageModel to fetch.
     */
    where?: BusinessCertificationImageModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessCertificationImageModels to fetch.
     */
    orderBy?: Enumerable<BusinessCertificationImageModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessCertificationImageModels.
     */
    cursor?: BusinessCertificationImageModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessCertificationImageModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessCertificationImageModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessCertificationImageModels.
     */
    distinct?: Enumerable<BusinessCertificationImageModelScalarFieldEnum>
  }


  /**
   * BusinessCertificationImageModel findMany
   */
  export type BusinessCertificationImageModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the BusinessCertificationImageModel
     */
    select?: BusinessCertificationImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessCertificationImageModelInclude | null
    /**
     * Filter, which BusinessCertificationImageModels to fetch.
     */
    where?: BusinessCertificationImageModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessCertificationImageModels to fetch.
     */
    orderBy?: Enumerable<BusinessCertificationImageModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessCertificationImageModels.
     */
    cursor?: BusinessCertificationImageModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessCertificationImageModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessCertificationImageModels.
     */
    skip?: number
    distinct?: Enumerable<BusinessCertificationImageModelScalarFieldEnum>
  }


  /**
   * BusinessCertificationImageModel create
   */
  export type BusinessCertificationImageModelCreateArgs = {
    /**
     * Select specific fields to fetch from the BusinessCertificationImageModel
     */
    select?: BusinessCertificationImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessCertificationImageModelInclude | null
    /**
     * The data needed to create a BusinessCertificationImageModel.
     */
    data: XOR<BusinessCertificationImageModelCreateInput, BusinessCertificationImageModelUncheckedCreateInput>
  }


  /**
   * BusinessCertificationImageModel createMany
   */
  export type BusinessCertificationImageModelCreateManyArgs = {
    /**
     * The data used to create many BusinessCertificationImageModels.
     */
    data: Enumerable<BusinessCertificationImageModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BusinessCertificationImageModel update
   */
  export type BusinessCertificationImageModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the BusinessCertificationImageModel
     */
    select?: BusinessCertificationImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessCertificationImageModelInclude | null
    /**
     * The data needed to update a BusinessCertificationImageModel.
     */
    data: XOR<BusinessCertificationImageModelUpdateInput, BusinessCertificationImageModelUncheckedUpdateInput>
    /**
     * Choose, which BusinessCertificationImageModel to update.
     */
    where: BusinessCertificationImageModelWhereUniqueInput
  }


  /**
   * BusinessCertificationImageModel updateMany
   */
  export type BusinessCertificationImageModelUpdateManyArgs = {
    /**
     * The data used to update BusinessCertificationImageModels.
     */
    data: XOR<BusinessCertificationImageModelUpdateManyMutationInput, BusinessCertificationImageModelUncheckedUpdateManyInput>
    /**
     * Filter which BusinessCertificationImageModels to update
     */
    where?: BusinessCertificationImageModelWhereInput
  }


  /**
   * BusinessCertificationImageModel upsert
   */
  export type BusinessCertificationImageModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the BusinessCertificationImageModel
     */
    select?: BusinessCertificationImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessCertificationImageModelInclude | null
    /**
     * The filter to search for the BusinessCertificationImageModel to update in case it exists.
     */
    where: BusinessCertificationImageModelWhereUniqueInput
    /**
     * In case the BusinessCertificationImageModel found by the `where` argument doesn't exist, create a new BusinessCertificationImageModel with this data.
     */
    create: XOR<BusinessCertificationImageModelCreateInput, BusinessCertificationImageModelUncheckedCreateInput>
    /**
     * In case the BusinessCertificationImageModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessCertificationImageModelUpdateInput, BusinessCertificationImageModelUncheckedUpdateInput>
  }


  /**
   * BusinessCertificationImageModel delete
   */
  export type BusinessCertificationImageModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the BusinessCertificationImageModel
     */
    select?: BusinessCertificationImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessCertificationImageModelInclude | null
    /**
     * Filter which BusinessCertificationImageModel to delete.
     */
    where: BusinessCertificationImageModelWhereUniqueInput
  }


  /**
   * BusinessCertificationImageModel deleteMany
   */
  export type BusinessCertificationImageModelDeleteManyArgs = {
    /**
     * Filter which BusinessCertificationImageModels to delete
     */
    where?: BusinessCertificationImageModelWhereInput
  }


  /**
   * BusinessCertificationImageModel without action
   */
  export type BusinessCertificationImageModelArgs = {
    /**
     * Select specific fields to fetch from the BusinessCertificationImageModel
     */
    select?: BusinessCertificationImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessCertificationImageModelInclude | null
  }



  /**
   * Model HSIntroductionImageModel
   */


  export type AggregateHSIntroductionImageModel = {
    _count: HSIntroductionImageModelCountAggregateOutputType | null
    _min: HSIntroductionImageModelMinAggregateOutputType | null
    _max: HSIntroductionImageModelMaxAggregateOutputType | null
  }

  export type HSIntroductionImageModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    hs_provider_id: string | null
    url: string | null
  }

  export type HSIntroductionImageModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    hs_provider_id: string | null
    url: string | null
  }

  export type HSIntroductionImageModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    hs_provider_id: number
    url: number
    _all: number
  }


  export type HSIntroductionImageModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    hs_provider_id?: true
    url?: true
  }

  export type HSIntroductionImageModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    hs_provider_id?: true
    url?: true
  }

  export type HSIntroductionImageModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    hs_provider_id?: true
    url?: true
    _all?: true
  }

  export type HSIntroductionImageModelAggregateArgs = {
    /**
     * Filter which HSIntroductionImageModel to aggregate.
     */
    where?: HSIntroductionImageModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HSIntroductionImageModels to fetch.
     */
    orderBy?: Enumerable<HSIntroductionImageModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HSIntroductionImageModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HSIntroductionImageModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HSIntroductionImageModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HSIntroductionImageModels
    **/
    _count?: true | HSIntroductionImageModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HSIntroductionImageModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HSIntroductionImageModelMaxAggregateInputType
  }

  export type GetHSIntroductionImageModelAggregateType<T extends HSIntroductionImageModelAggregateArgs> = {
        [P in keyof T & keyof AggregateHSIntroductionImageModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHSIntroductionImageModel[P]>
      : GetScalarType<T[P], AggregateHSIntroductionImageModel[P]>
  }




  export type HSIntroductionImageModelGroupByArgs = {
    where?: HSIntroductionImageModelWhereInput
    orderBy?: Enumerable<HSIntroductionImageModelOrderByWithAggregationInput>
    by: HSIntroductionImageModelScalarFieldEnum[]
    having?: HSIntroductionImageModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HSIntroductionImageModelCountAggregateInputType | true
    _min?: HSIntroductionImageModelMinAggregateInputType
    _max?: HSIntroductionImageModelMaxAggregateInputType
  }


  export type HSIntroductionImageModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    hs_provider_id: string
    url: string
    _count: HSIntroductionImageModelCountAggregateOutputType | null
    _min: HSIntroductionImageModelMinAggregateOutputType | null
    _max: HSIntroductionImageModelMaxAggregateOutputType | null
  }

  type GetHSIntroductionImageModelGroupByPayload<T extends HSIntroductionImageModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HSIntroductionImageModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HSIntroductionImageModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HSIntroductionImageModelGroupByOutputType[P]>
            : GetScalarType<T[P], HSIntroductionImageModelGroupByOutputType[P]>
        }
      >
    >


  export type HSIntroductionImageModelSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    hs_provider_id?: boolean
    url?: boolean
    hs_provider?: boolean | HSProviderModelArgs
  }


  export type HSIntroductionImageModelInclude = {
    hs_provider?: boolean | HSProviderModelArgs
  }

  export type HSIntroductionImageModelGetPayload<S extends boolean | null | undefined | HSIntroductionImageModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HSIntroductionImageModel :
    S extends undefined ? never :
    S extends { include: any } & (HSIntroductionImageModelArgs | HSIntroductionImageModelFindManyArgs)
    ? HSIntroductionImageModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'hs_provider' ? HSProviderModelGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (HSIntroductionImageModelArgs | HSIntroductionImageModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'hs_provider' ? HSProviderModelGetPayload<S['select'][P]> :  P extends keyof HSIntroductionImageModel ? HSIntroductionImageModel[P] : never
  } 
      : HSIntroductionImageModel


  type HSIntroductionImageModelCountArgs = 
    Omit<HSIntroductionImageModelFindManyArgs, 'select' | 'include'> & {
      select?: HSIntroductionImageModelCountAggregateInputType | true
    }

  export interface HSIntroductionImageModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one HSIntroductionImageModel that matches the filter.
     * @param {HSIntroductionImageModelFindUniqueArgs} args - Arguments to find a HSIntroductionImageModel
     * @example
     * // Get one HSIntroductionImageModel
     * const hSIntroductionImageModel = await prisma.hSIntroductionImageModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HSIntroductionImageModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HSIntroductionImageModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'HSIntroductionImageModel'> extends True ? Prisma__HSIntroductionImageModelClient<HSIntroductionImageModelGetPayload<T>> : Prisma__HSIntroductionImageModelClient<HSIntroductionImageModelGetPayload<T> | null, null>

    /**
     * Find one HSIntroductionImageModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HSIntroductionImageModelFindUniqueOrThrowArgs} args - Arguments to find a HSIntroductionImageModel
     * @example
     * // Get one HSIntroductionImageModel
     * const hSIntroductionImageModel = await prisma.hSIntroductionImageModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HSIntroductionImageModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, HSIntroductionImageModelFindUniqueOrThrowArgs>
    ): Prisma__HSIntroductionImageModelClient<HSIntroductionImageModelGetPayload<T>>

    /**
     * Find the first HSIntroductionImageModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSIntroductionImageModelFindFirstArgs} args - Arguments to find a HSIntroductionImageModel
     * @example
     * // Get one HSIntroductionImageModel
     * const hSIntroductionImageModel = await prisma.hSIntroductionImageModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HSIntroductionImageModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HSIntroductionImageModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'HSIntroductionImageModel'> extends True ? Prisma__HSIntroductionImageModelClient<HSIntroductionImageModelGetPayload<T>> : Prisma__HSIntroductionImageModelClient<HSIntroductionImageModelGetPayload<T> | null, null>

    /**
     * Find the first HSIntroductionImageModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSIntroductionImageModelFindFirstOrThrowArgs} args - Arguments to find a HSIntroductionImageModel
     * @example
     * // Get one HSIntroductionImageModel
     * const hSIntroductionImageModel = await prisma.hSIntroductionImageModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HSIntroductionImageModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HSIntroductionImageModelFindFirstOrThrowArgs>
    ): Prisma__HSIntroductionImageModelClient<HSIntroductionImageModelGetPayload<T>>

    /**
     * Find zero or more HSIntroductionImageModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSIntroductionImageModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HSIntroductionImageModels
     * const hSIntroductionImageModels = await prisma.hSIntroductionImageModel.findMany()
     * 
     * // Get first 10 HSIntroductionImageModels
     * const hSIntroductionImageModels = await prisma.hSIntroductionImageModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hSIntroductionImageModelWithIdOnly = await prisma.hSIntroductionImageModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HSIntroductionImageModelFindManyArgs>(
      args?: SelectSubset<T, HSIntroductionImageModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<HSIntroductionImageModelGetPayload<T>>>

    /**
     * Create a HSIntroductionImageModel.
     * @param {HSIntroductionImageModelCreateArgs} args - Arguments to create a HSIntroductionImageModel.
     * @example
     * // Create one HSIntroductionImageModel
     * const HSIntroductionImageModel = await prisma.hSIntroductionImageModel.create({
     *   data: {
     *     // ... data to create a HSIntroductionImageModel
     *   }
     * })
     * 
    **/
    create<T extends HSIntroductionImageModelCreateArgs>(
      args: SelectSubset<T, HSIntroductionImageModelCreateArgs>
    ): Prisma__HSIntroductionImageModelClient<HSIntroductionImageModelGetPayload<T>>

    /**
     * Create many HSIntroductionImageModels.
     *     @param {HSIntroductionImageModelCreateManyArgs} args - Arguments to create many HSIntroductionImageModels.
     *     @example
     *     // Create many HSIntroductionImageModels
     *     const hSIntroductionImageModel = await prisma.hSIntroductionImageModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HSIntroductionImageModelCreateManyArgs>(
      args?: SelectSubset<T, HSIntroductionImageModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HSIntroductionImageModel.
     * @param {HSIntroductionImageModelDeleteArgs} args - Arguments to delete one HSIntroductionImageModel.
     * @example
     * // Delete one HSIntroductionImageModel
     * const HSIntroductionImageModel = await prisma.hSIntroductionImageModel.delete({
     *   where: {
     *     // ... filter to delete one HSIntroductionImageModel
     *   }
     * })
     * 
    **/
    delete<T extends HSIntroductionImageModelDeleteArgs>(
      args: SelectSubset<T, HSIntroductionImageModelDeleteArgs>
    ): Prisma__HSIntroductionImageModelClient<HSIntroductionImageModelGetPayload<T>>

    /**
     * Update one HSIntroductionImageModel.
     * @param {HSIntroductionImageModelUpdateArgs} args - Arguments to update one HSIntroductionImageModel.
     * @example
     * // Update one HSIntroductionImageModel
     * const hSIntroductionImageModel = await prisma.hSIntroductionImageModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HSIntroductionImageModelUpdateArgs>(
      args: SelectSubset<T, HSIntroductionImageModelUpdateArgs>
    ): Prisma__HSIntroductionImageModelClient<HSIntroductionImageModelGetPayload<T>>

    /**
     * Delete zero or more HSIntroductionImageModels.
     * @param {HSIntroductionImageModelDeleteManyArgs} args - Arguments to filter HSIntroductionImageModels to delete.
     * @example
     * // Delete a few HSIntroductionImageModels
     * const { count } = await prisma.hSIntroductionImageModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HSIntroductionImageModelDeleteManyArgs>(
      args?: SelectSubset<T, HSIntroductionImageModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HSIntroductionImageModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSIntroductionImageModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HSIntroductionImageModels
     * const hSIntroductionImageModel = await prisma.hSIntroductionImageModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HSIntroductionImageModelUpdateManyArgs>(
      args: SelectSubset<T, HSIntroductionImageModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HSIntroductionImageModel.
     * @param {HSIntroductionImageModelUpsertArgs} args - Arguments to update or create a HSIntroductionImageModel.
     * @example
     * // Update or create a HSIntroductionImageModel
     * const hSIntroductionImageModel = await prisma.hSIntroductionImageModel.upsert({
     *   create: {
     *     // ... data to create a HSIntroductionImageModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HSIntroductionImageModel we want to update
     *   }
     * })
    **/
    upsert<T extends HSIntroductionImageModelUpsertArgs>(
      args: SelectSubset<T, HSIntroductionImageModelUpsertArgs>
    ): Prisma__HSIntroductionImageModelClient<HSIntroductionImageModelGetPayload<T>>

    /**
     * Count the number of HSIntroductionImageModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSIntroductionImageModelCountArgs} args - Arguments to filter HSIntroductionImageModels to count.
     * @example
     * // Count the number of HSIntroductionImageModels
     * const count = await prisma.hSIntroductionImageModel.count({
     *   where: {
     *     // ... the filter for the HSIntroductionImageModels we want to count
     *   }
     * })
    **/
    count<T extends HSIntroductionImageModelCountArgs>(
      args?: Subset<T, HSIntroductionImageModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HSIntroductionImageModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HSIntroductionImageModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSIntroductionImageModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HSIntroductionImageModelAggregateArgs>(args: Subset<T, HSIntroductionImageModelAggregateArgs>): Prisma.PrismaPromise<GetHSIntroductionImageModelAggregateType<T>>

    /**
     * Group by HSIntroductionImageModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSIntroductionImageModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HSIntroductionImageModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HSIntroductionImageModelGroupByArgs['orderBy'] }
        : { orderBy?: HSIntroductionImageModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HSIntroductionImageModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHSIntroductionImageModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for HSIntroductionImageModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HSIntroductionImageModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    hs_provider<T extends HSProviderModelArgs= {}>(args?: Subset<T, HSProviderModelArgs>): Prisma__HSProviderModelClient<HSProviderModelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * HSIntroductionImageModel base type for findUnique actions
   */
  export type HSIntroductionImageModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the HSIntroductionImageModel
     */
    select?: HSIntroductionImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSIntroductionImageModelInclude | null
    /**
     * Filter, which HSIntroductionImageModel to fetch.
     */
    where: HSIntroductionImageModelWhereUniqueInput
  }

  /**
   * HSIntroductionImageModel findUnique
   */
  export interface HSIntroductionImageModelFindUniqueArgs extends HSIntroductionImageModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HSIntroductionImageModel findUniqueOrThrow
   */
  export type HSIntroductionImageModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HSIntroductionImageModel
     */
    select?: HSIntroductionImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSIntroductionImageModelInclude | null
    /**
     * Filter, which HSIntroductionImageModel to fetch.
     */
    where: HSIntroductionImageModelWhereUniqueInput
  }


  /**
   * HSIntroductionImageModel base type for findFirst actions
   */
  export type HSIntroductionImageModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the HSIntroductionImageModel
     */
    select?: HSIntroductionImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSIntroductionImageModelInclude | null
    /**
     * Filter, which HSIntroductionImageModel to fetch.
     */
    where?: HSIntroductionImageModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HSIntroductionImageModels to fetch.
     */
    orderBy?: Enumerable<HSIntroductionImageModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HSIntroductionImageModels.
     */
    cursor?: HSIntroductionImageModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HSIntroductionImageModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HSIntroductionImageModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HSIntroductionImageModels.
     */
    distinct?: Enumerable<HSIntroductionImageModelScalarFieldEnum>
  }

  /**
   * HSIntroductionImageModel findFirst
   */
  export interface HSIntroductionImageModelFindFirstArgs extends HSIntroductionImageModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HSIntroductionImageModel findFirstOrThrow
   */
  export type HSIntroductionImageModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HSIntroductionImageModel
     */
    select?: HSIntroductionImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSIntroductionImageModelInclude | null
    /**
     * Filter, which HSIntroductionImageModel to fetch.
     */
    where?: HSIntroductionImageModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HSIntroductionImageModels to fetch.
     */
    orderBy?: Enumerable<HSIntroductionImageModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HSIntroductionImageModels.
     */
    cursor?: HSIntroductionImageModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HSIntroductionImageModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HSIntroductionImageModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HSIntroductionImageModels.
     */
    distinct?: Enumerable<HSIntroductionImageModelScalarFieldEnum>
  }


  /**
   * HSIntroductionImageModel findMany
   */
  export type HSIntroductionImageModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the HSIntroductionImageModel
     */
    select?: HSIntroductionImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSIntroductionImageModelInclude | null
    /**
     * Filter, which HSIntroductionImageModels to fetch.
     */
    where?: HSIntroductionImageModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HSIntroductionImageModels to fetch.
     */
    orderBy?: Enumerable<HSIntroductionImageModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HSIntroductionImageModels.
     */
    cursor?: HSIntroductionImageModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HSIntroductionImageModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HSIntroductionImageModels.
     */
    skip?: number
    distinct?: Enumerable<HSIntroductionImageModelScalarFieldEnum>
  }


  /**
   * HSIntroductionImageModel create
   */
  export type HSIntroductionImageModelCreateArgs = {
    /**
     * Select specific fields to fetch from the HSIntroductionImageModel
     */
    select?: HSIntroductionImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSIntroductionImageModelInclude | null
    /**
     * The data needed to create a HSIntroductionImageModel.
     */
    data: XOR<HSIntroductionImageModelCreateInput, HSIntroductionImageModelUncheckedCreateInput>
  }


  /**
   * HSIntroductionImageModel createMany
   */
  export type HSIntroductionImageModelCreateManyArgs = {
    /**
     * The data used to create many HSIntroductionImageModels.
     */
    data: Enumerable<HSIntroductionImageModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * HSIntroductionImageModel update
   */
  export type HSIntroductionImageModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the HSIntroductionImageModel
     */
    select?: HSIntroductionImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSIntroductionImageModelInclude | null
    /**
     * The data needed to update a HSIntroductionImageModel.
     */
    data: XOR<HSIntroductionImageModelUpdateInput, HSIntroductionImageModelUncheckedUpdateInput>
    /**
     * Choose, which HSIntroductionImageModel to update.
     */
    where: HSIntroductionImageModelWhereUniqueInput
  }


  /**
   * HSIntroductionImageModel updateMany
   */
  export type HSIntroductionImageModelUpdateManyArgs = {
    /**
     * The data used to update HSIntroductionImageModels.
     */
    data: XOR<HSIntroductionImageModelUpdateManyMutationInput, HSIntroductionImageModelUncheckedUpdateManyInput>
    /**
     * Filter which HSIntroductionImageModels to update
     */
    where?: HSIntroductionImageModelWhereInput
  }


  /**
   * HSIntroductionImageModel upsert
   */
  export type HSIntroductionImageModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the HSIntroductionImageModel
     */
    select?: HSIntroductionImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSIntroductionImageModelInclude | null
    /**
     * The filter to search for the HSIntroductionImageModel to update in case it exists.
     */
    where: HSIntroductionImageModelWhereUniqueInput
    /**
     * In case the HSIntroductionImageModel found by the `where` argument doesn't exist, create a new HSIntroductionImageModel with this data.
     */
    create: XOR<HSIntroductionImageModelCreateInput, HSIntroductionImageModelUncheckedCreateInput>
    /**
     * In case the HSIntroductionImageModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HSIntroductionImageModelUpdateInput, HSIntroductionImageModelUncheckedUpdateInput>
  }


  /**
   * HSIntroductionImageModel delete
   */
  export type HSIntroductionImageModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the HSIntroductionImageModel
     */
    select?: HSIntroductionImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSIntroductionImageModelInclude | null
    /**
     * Filter which HSIntroductionImageModel to delete.
     */
    where: HSIntroductionImageModelWhereUniqueInput
  }


  /**
   * HSIntroductionImageModel deleteMany
   */
  export type HSIntroductionImageModelDeleteManyArgs = {
    /**
     * Filter which HSIntroductionImageModels to delete
     */
    where?: HSIntroductionImageModelWhereInput
  }


  /**
   * HSIntroductionImageModel without action
   */
  export type HSIntroductionImageModelArgs = {
    /**
     * Select specific fields to fetch from the HSIntroductionImageModel
     */
    select?: HSIntroductionImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSIntroductionImageModelInclude | null
  }



  /**
   * Model OauthAccountModel
   */


  export type AggregateOauthAccountModel = {
    _count: OauthAccountModelCountAggregateOutputType | null
    _min: OauthAccountModelMinAggregateOutputType | null
    _max: OauthAccountModelMaxAggregateOutputType | null
  }

  export type OauthAccountModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    oauth_type: OauthType | null
    oauth_sub: string | null
    business_user_id: string | null
    customer_id: string | null
    name: string | null
    email: string | null
    phone: string | null
    profile_image_url: string | null
    birth: string | null
    gender: GenderType | null
    address_first: string | null
    address_second: string | null
  }

  export type OauthAccountModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    oauth_type: OauthType | null
    oauth_sub: string | null
    business_user_id: string | null
    customer_id: string | null
    name: string | null
    email: string | null
    phone: string | null
    profile_image_url: string | null
    birth: string | null
    gender: GenderType | null
    address_first: string | null
    address_second: string | null
  }

  export type OauthAccountModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    oauth_type: number
    oauth_sub: number
    business_user_id: number
    customer_id: number
    name: number
    email: number
    phone: number
    profile_image_url: number
    birth: number
    gender: number
    address_first: number
    address_second: number
    _all: number
  }


  export type OauthAccountModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    oauth_type?: true
    oauth_sub?: true
    business_user_id?: true
    customer_id?: true
    name?: true
    email?: true
    phone?: true
    profile_image_url?: true
    birth?: true
    gender?: true
    address_first?: true
    address_second?: true
  }

  export type OauthAccountModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    oauth_type?: true
    oauth_sub?: true
    business_user_id?: true
    customer_id?: true
    name?: true
    email?: true
    phone?: true
    profile_image_url?: true
    birth?: true
    gender?: true
    address_first?: true
    address_second?: true
  }

  export type OauthAccountModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    oauth_type?: true
    oauth_sub?: true
    business_user_id?: true
    customer_id?: true
    name?: true
    email?: true
    phone?: true
    profile_image_url?: true
    birth?: true
    gender?: true
    address_first?: true
    address_second?: true
    _all?: true
  }

  export type OauthAccountModelAggregateArgs = {
    /**
     * Filter which OauthAccountModel to aggregate.
     */
    where?: OauthAccountModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OauthAccountModels to fetch.
     */
    orderBy?: Enumerable<OauthAccountModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OauthAccountModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OauthAccountModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OauthAccountModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OauthAccountModels
    **/
    _count?: true | OauthAccountModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OauthAccountModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OauthAccountModelMaxAggregateInputType
  }

  export type GetOauthAccountModelAggregateType<T extends OauthAccountModelAggregateArgs> = {
        [P in keyof T & keyof AggregateOauthAccountModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOauthAccountModel[P]>
      : GetScalarType<T[P], AggregateOauthAccountModel[P]>
  }




  export type OauthAccountModelGroupByArgs = {
    where?: OauthAccountModelWhereInput
    orderBy?: Enumerable<OauthAccountModelOrderByWithAggregationInput>
    by: OauthAccountModelScalarFieldEnum[]
    having?: OauthAccountModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OauthAccountModelCountAggregateInputType | true
    _min?: OauthAccountModelMinAggregateInputType
    _max?: OauthAccountModelMaxAggregateInputType
  }


  export type OauthAccountModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    oauth_type: OauthType
    oauth_sub: string
    business_user_id: string | null
    customer_id: string | null
    name: string | null
    email: string | null
    phone: string | null
    profile_image_url: string | null
    birth: string | null
    gender: GenderType | null
    address_first: string | null
    address_second: string | null
    _count: OauthAccountModelCountAggregateOutputType | null
    _min: OauthAccountModelMinAggregateOutputType | null
    _max: OauthAccountModelMaxAggregateOutputType | null
  }

  type GetOauthAccountModelGroupByPayload<T extends OauthAccountModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OauthAccountModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OauthAccountModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OauthAccountModelGroupByOutputType[P]>
            : GetScalarType<T[P], OauthAccountModelGroupByOutputType[P]>
        }
      >
    >


  export type OauthAccountModelSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    oauth_type?: boolean
    oauth_sub?: boolean
    business_user_id?: boolean
    customer_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    profile_image_url?: boolean
    birth?: boolean
    gender?: boolean
    address_first?: boolean
    address_second?: boolean
    business_user?: boolean | BusinessUserModelArgs
    customer?: boolean | CustomerModelArgs
  }


  export type OauthAccountModelInclude = {
    business_user?: boolean | BusinessUserModelArgs
    customer?: boolean | CustomerModelArgs
  }

  export type OauthAccountModelGetPayload<S extends boolean | null | undefined | OauthAccountModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OauthAccountModel :
    S extends undefined ? never :
    S extends { include: any } & (OauthAccountModelArgs | OauthAccountModelFindManyArgs)
    ? OauthAccountModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'business_user' ? BusinessUserModelGetPayload<S['include'][P]> | null :
        P extends 'customer' ? CustomerModelGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (OauthAccountModelArgs | OauthAccountModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'business_user' ? BusinessUserModelGetPayload<S['select'][P]> | null :
        P extends 'customer' ? CustomerModelGetPayload<S['select'][P]> | null :  P extends keyof OauthAccountModel ? OauthAccountModel[P] : never
  } 
      : OauthAccountModel


  type OauthAccountModelCountArgs = 
    Omit<OauthAccountModelFindManyArgs, 'select' | 'include'> & {
      select?: OauthAccountModelCountAggregateInputType | true
    }

  export interface OauthAccountModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one OauthAccountModel that matches the filter.
     * @param {OauthAccountModelFindUniqueArgs} args - Arguments to find a OauthAccountModel
     * @example
     * // Get one OauthAccountModel
     * const oauthAccountModel = await prisma.oauthAccountModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OauthAccountModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OauthAccountModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OauthAccountModel'> extends True ? Prisma__OauthAccountModelClient<OauthAccountModelGetPayload<T>> : Prisma__OauthAccountModelClient<OauthAccountModelGetPayload<T> | null, null>

    /**
     * Find one OauthAccountModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OauthAccountModelFindUniqueOrThrowArgs} args - Arguments to find a OauthAccountModel
     * @example
     * // Get one OauthAccountModel
     * const oauthAccountModel = await prisma.oauthAccountModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OauthAccountModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OauthAccountModelFindUniqueOrThrowArgs>
    ): Prisma__OauthAccountModelClient<OauthAccountModelGetPayload<T>>

    /**
     * Find the first OauthAccountModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OauthAccountModelFindFirstArgs} args - Arguments to find a OauthAccountModel
     * @example
     * // Get one OauthAccountModel
     * const oauthAccountModel = await prisma.oauthAccountModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OauthAccountModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OauthAccountModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OauthAccountModel'> extends True ? Prisma__OauthAccountModelClient<OauthAccountModelGetPayload<T>> : Prisma__OauthAccountModelClient<OauthAccountModelGetPayload<T> | null, null>

    /**
     * Find the first OauthAccountModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OauthAccountModelFindFirstOrThrowArgs} args - Arguments to find a OauthAccountModel
     * @example
     * // Get one OauthAccountModel
     * const oauthAccountModel = await prisma.oauthAccountModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OauthAccountModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OauthAccountModelFindFirstOrThrowArgs>
    ): Prisma__OauthAccountModelClient<OauthAccountModelGetPayload<T>>

    /**
     * Find zero or more OauthAccountModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OauthAccountModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OauthAccountModels
     * const oauthAccountModels = await prisma.oauthAccountModel.findMany()
     * 
     * // Get first 10 OauthAccountModels
     * const oauthAccountModels = await prisma.oauthAccountModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oauthAccountModelWithIdOnly = await prisma.oauthAccountModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OauthAccountModelFindManyArgs>(
      args?: SelectSubset<T, OauthAccountModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<OauthAccountModelGetPayload<T>>>

    /**
     * Create a OauthAccountModel.
     * @param {OauthAccountModelCreateArgs} args - Arguments to create a OauthAccountModel.
     * @example
     * // Create one OauthAccountModel
     * const OauthAccountModel = await prisma.oauthAccountModel.create({
     *   data: {
     *     // ... data to create a OauthAccountModel
     *   }
     * })
     * 
    **/
    create<T extends OauthAccountModelCreateArgs>(
      args: SelectSubset<T, OauthAccountModelCreateArgs>
    ): Prisma__OauthAccountModelClient<OauthAccountModelGetPayload<T>>

    /**
     * Create many OauthAccountModels.
     *     @param {OauthAccountModelCreateManyArgs} args - Arguments to create many OauthAccountModels.
     *     @example
     *     // Create many OauthAccountModels
     *     const oauthAccountModel = await prisma.oauthAccountModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OauthAccountModelCreateManyArgs>(
      args?: SelectSubset<T, OauthAccountModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OauthAccountModel.
     * @param {OauthAccountModelDeleteArgs} args - Arguments to delete one OauthAccountModel.
     * @example
     * // Delete one OauthAccountModel
     * const OauthAccountModel = await prisma.oauthAccountModel.delete({
     *   where: {
     *     // ... filter to delete one OauthAccountModel
     *   }
     * })
     * 
    **/
    delete<T extends OauthAccountModelDeleteArgs>(
      args: SelectSubset<T, OauthAccountModelDeleteArgs>
    ): Prisma__OauthAccountModelClient<OauthAccountModelGetPayload<T>>

    /**
     * Update one OauthAccountModel.
     * @param {OauthAccountModelUpdateArgs} args - Arguments to update one OauthAccountModel.
     * @example
     * // Update one OauthAccountModel
     * const oauthAccountModel = await prisma.oauthAccountModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OauthAccountModelUpdateArgs>(
      args: SelectSubset<T, OauthAccountModelUpdateArgs>
    ): Prisma__OauthAccountModelClient<OauthAccountModelGetPayload<T>>

    /**
     * Delete zero or more OauthAccountModels.
     * @param {OauthAccountModelDeleteManyArgs} args - Arguments to filter OauthAccountModels to delete.
     * @example
     * // Delete a few OauthAccountModels
     * const { count } = await prisma.oauthAccountModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OauthAccountModelDeleteManyArgs>(
      args?: SelectSubset<T, OauthAccountModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OauthAccountModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OauthAccountModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OauthAccountModels
     * const oauthAccountModel = await prisma.oauthAccountModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OauthAccountModelUpdateManyArgs>(
      args: SelectSubset<T, OauthAccountModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OauthAccountModel.
     * @param {OauthAccountModelUpsertArgs} args - Arguments to update or create a OauthAccountModel.
     * @example
     * // Update or create a OauthAccountModel
     * const oauthAccountModel = await prisma.oauthAccountModel.upsert({
     *   create: {
     *     // ... data to create a OauthAccountModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OauthAccountModel we want to update
     *   }
     * })
    **/
    upsert<T extends OauthAccountModelUpsertArgs>(
      args: SelectSubset<T, OauthAccountModelUpsertArgs>
    ): Prisma__OauthAccountModelClient<OauthAccountModelGetPayload<T>>

    /**
     * Count the number of OauthAccountModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OauthAccountModelCountArgs} args - Arguments to filter OauthAccountModels to count.
     * @example
     * // Count the number of OauthAccountModels
     * const count = await prisma.oauthAccountModel.count({
     *   where: {
     *     // ... the filter for the OauthAccountModels we want to count
     *   }
     * })
    **/
    count<T extends OauthAccountModelCountArgs>(
      args?: Subset<T, OauthAccountModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OauthAccountModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OauthAccountModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OauthAccountModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OauthAccountModelAggregateArgs>(args: Subset<T, OauthAccountModelAggregateArgs>): Prisma.PrismaPromise<GetOauthAccountModelAggregateType<T>>

    /**
     * Group by OauthAccountModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OauthAccountModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OauthAccountModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OauthAccountModelGroupByArgs['orderBy'] }
        : { orderBy?: OauthAccountModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OauthAccountModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOauthAccountModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OauthAccountModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OauthAccountModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    business_user<T extends BusinessUserModelArgs= {}>(args?: Subset<T, BusinessUserModelArgs>): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T> | Null>;

    customer<T extends CustomerModelArgs= {}>(args?: Subset<T, CustomerModelArgs>): Prisma__CustomerModelClient<CustomerModelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OauthAccountModel base type for findUnique actions
   */
  export type OauthAccountModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the OauthAccountModel
     */
    select?: OauthAccountModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OauthAccountModelInclude | null
    /**
     * Filter, which OauthAccountModel to fetch.
     */
    where: OauthAccountModelWhereUniqueInput
  }

  /**
   * OauthAccountModel findUnique
   */
  export interface OauthAccountModelFindUniqueArgs extends OauthAccountModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OauthAccountModel findUniqueOrThrow
   */
  export type OauthAccountModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OauthAccountModel
     */
    select?: OauthAccountModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OauthAccountModelInclude | null
    /**
     * Filter, which OauthAccountModel to fetch.
     */
    where: OauthAccountModelWhereUniqueInput
  }


  /**
   * OauthAccountModel base type for findFirst actions
   */
  export type OauthAccountModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the OauthAccountModel
     */
    select?: OauthAccountModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OauthAccountModelInclude | null
    /**
     * Filter, which OauthAccountModel to fetch.
     */
    where?: OauthAccountModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OauthAccountModels to fetch.
     */
    orderBy?: Enumerable<OauthAccountModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OauthAccountModels.
     */
    cursor?: OauthAccountModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OauthAccountModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OauthAccountModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OauthAccountModels.
     */
    distinct?: Enumerable<OauthAccountModelScalarFieldEnum>
  }

  /**
   * OauthAccountModel findFirst
   */
  export interface OauthAccountModelFindFirstArgs extends OauthAccountModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OauthAccountModel findFirstOrThrow
   */
  export type OauthAccountModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the OauthAccountModel
     */
    select?: OauthAccountModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OauthAccountModelInclude | null
    /**
     * Filter, which OauthAccountModel to fetch.
     */
    where?: OauthAccountModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OauthAccountModels to fetch.
     */
    orderBy?: Enumerable<OauthAccountModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OauthAccountModels.
     */
    cursor?: OauthAccountModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OauthAccountModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OauthAccountModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OauthAccountModels.
     */
    distinct?: Enumerable<OauthAccountModelScalarFieldEnum>
  }


  /**
   * OauthAccountModel findMany
   */
  export type OauthAccountModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the OauthAccountModel
     */
    select?: OauthAccountModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OauthAccountModelInclude | null
    /**
     * Filter, which OauthAccountModels to fetch.
     */
    where?: OauthAccountModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OauthAccountModels to fetch.
     */
    orderBy?: Enumerable<OauthAccountModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OauthAccountModels.
     */
    cursor?: OauthAccountModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OauthAccountModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OauthAccountModels.
     */
    skip?: number
    distinct?: Enumerable<OauthAccountModelScalarFieldEnum>
  }


  /**
   * OauthAccountModel create
   */
  export type OauthAccountModelCreateArgs = {
    /**
     * Select specific fields to fetch from the OauthAccountModel
     */
    select?: OauthAccountModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OauthAccountModelInclude | null
    /**
     * The data needed to create a OauthAccountModel.
     */
    data: XOR<OauthAccountModelCreateInput, OauthAccountModelUncheckedCreateInput>
  }


  /**
   * OauthAccountModel createMany
   */
  export type OauthAccountModelCreateManyArgs = {
    /**
     * The data used to create many OauthAccountModels.
     */
    data: Enumerable<OauthAccountModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OauthAccountModel update
   */
  export type OauthAccountModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the OauthAccountModel
     */
    select?: OauthAccountModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OauthAccountModelInclude | null
    /**
     * The data needed to update a OauthAccountModel.
     */
    data: XOR<OauthAccountModelUpdateInput, OauthAccountModelUncheckedUpdateInput>
    /**
     * Choose, which OauthAccountModel to update.
     */
    where: OauthAccountModelWhereUniqueInput
  }


  /**
   * OauthAccountModel updateMany
   */
  export type OauthAccountModelUpdateManyArgs = {
    /**
     * The data used to update OauthAccountModels.
     */
    data: XOR<OauthAccountModelUpdateManyMutationInput, OauthAccountModelUncheckedUpdateManyInput>
    /**
     * Filter which OauthAccountModels to update
     */
    where?: OauthAccountModelWhereInput
  }


  /**
   * OauthAccountModel upsert
   */
  export type OauthAccountModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the OauthAccountModel
     */
    select?: OauthAccountModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OauthAccountModelInclude | null
    /**
     * The filter to search for the OauthAccountModel to update in case it exists.
     */
    where: OauthAccountModelWhereUniqueInput
    /**
     * In case the OauthAccountModel found by the `where` argument doesn't exist, create a new OauthAccountModel with this data.
     */
    create: XOR<OauthAccountModelCreateInput, OauthAccountModelUncheckedCreateInput>
    /**
     * In case the OauthAccountModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OauthAccountModelUpdateInput, OauthAccountModelUncheckedUpdateInput>
  }


  /**
   * OauthAccountModel delete
   */
  export type OauthAccountModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the OauthAccountModel
     */
    select?: OauthAccountModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OauthAccountModelInclude | null
    /**
     * Filter which OauthAccountModel to delete.
     */
    where: OauthAccountModelWhereUniqueInput
  }


  /**
   * OauthAccountModel deleteMany
   */
  export type OauthAccountModelDeleteManyArgs = {
    /**
     * Filter which OauthAccountModels to delete
     */
    where?: OauthAccountModelWhereInput
  }


  /**
   * OauthAccountModel without action
   */
  export type OauthAccountModelArgs = {
    /**
     * Select specific fields to fetch from the OauthAccountModel
     */
    select?: OauthAccountModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OauthAccountModelInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AgreementAcceptanceModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    user_id: 'user_id',
    agreement_id: 'agreement_id'
  };

  export type AgreementAcceptanceModelScalarFieldEnum = (typeof AgreementAcceptanceModelScalarFieldEnum)[keyof typeof AgreementAcceptanceModelScalarFieldEnum]


  export const AgreementModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    title: 'title',
    content: 'content',
    is_required: 'is_required',
    target_type: 'target_type'
  };

  export type AgreementModelScalarFieldEnum = (typeof AgreementModelScalarFieldEnum)[keyof typeof AgreementModelScalarFieldEnum]


  export const BusinessCertificationImageModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    business_user_id: 'business_user_id',
    url: 'url'
  };

  export type BusinessCertificationImageModelScalarFieldEnum = (typeof BusinessCertificationImageModelScalarFieldEnum)[keyof typeof BusinessCertificationImageModelScalarFieldEnum]


  export const BusinessUserModelScalarFieldEnum: {
    id: 'id',
    is_verified: 'is_verified',
    introduction_title: 'introduction_title',
    introduction_content: 'introduction_content',
    phone: 'phone',
    address_first: 'address_first',
    address_second: 'address_second',
    profile_image_url: 'profile_image_url'
  };

  export type BusinessUserModelScalarFieldEnum = (typeof BusinessUserModelScalarFieldEnum)[keyof typeof BusinessUserModelScalarFieldEnum]


  export const ConsultationTimeModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    start_time: 'start_time',
    end_time: 'end_time'
  };

  export type ConsultationTimeModelScalarFieldEnum = (typeof ConsultationTimeModelScalarFieldEnum)[keyof typeof ConsultationTimeModelScalarFieldEnum]


  export const CustomerModelScalarFieldEnum: {
    id: 'id',
    birth: 'birth',
    gender: 'gender',
    phone: 'phone',
    address_first: 'address_first',
    address_second: 'address_second',
    profile_image_url: 'profile_image_url'
  };

  export type CustomerModelScalarFieldEnum = (typeof CustomerModelScalarFieldEnum)[keyof typeof CustomerModelScalarFieldEnum]


  export const FocusCareConsultationTimeCheckModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    consultation_time_id: 'consultation_time_id',
    request_id: 'request_id'
  };

  export type FocusCareConsultationTimeCheckModelScalarFieldEnum = (typeof FocusCareConsultationTimeCheckModelScalarFieldEnum)[keyof typeof FocusCareConsultationTimeCheckModelScalarFieldEnum]


  export const FocusCareRequestModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    care_start_date: 'care_start_date',
    care_end_date: 'care_end_date',
    detail: 'detail',
    status: 'status',
    requester_id: 'requester_id'
  };

  export type FocusCareRequestModelScalarFieldEnum = (typeof FocusCareRequestModelScalarFieldEnum)[keyof typeof FocusCareRequestModelScalarFieldEnum]


  export const FocusCareServiceCheckModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    service_super_category_id: 'service_super_category_id',
    request_id: 'request_id'
  };

  export type FocusCareServiceCheckModelScalarFieldEnum = (typeof FocusCareServiceCheckModelScalarFieldEnum)[keyof typeof FocusCareServiceCheckModelScalarFieldEnum]


  export const HSIntroductionImageModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    hs_provider_id: 'hs_provider_id',
    url: 'url'
  };

  export type HSIntroductionImageModelScalarFieldEnum = (typeof HSIntroductionImageModelScalarFieldEnum)[keyof typeof HSIntroductionImageModelScalarFieldEnum]


  export const HSProviderModelScalarFieldEnum: {
    id: 'id',
    business_registration_num: 'business_registration_num'
  };

  export type HSProviderModelScalarFieldEnum = (typeof HSProviderModelScalarFieldEnum)[keyof typeof HSProviderModelScalarFieldEnum]


  export const OauthAccountModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    oauth_type: 'oauth_type',
    oauth_sub: 'oauth_sub',
    business_user_id: 'business_user_id',
    customer_id: 'customer_id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    profile_image_url: 'profile_image_url',
    birth: 'birth',
    gender: 'gender',
    address_first: 'address_first',
    address_second: 'address_second'
  };

  export type OauthAccountModelScalarFieldEnum = (typeof OauthAccountModelScalarFieldEnum)[keyof typeof OauthAccountModelScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const REAgentModelScalarFieldEnum: {
    id: 'id',
    is_licensed: 'is_licensed',
    re_num: 're_num',
    re_name: 're_name',
    re_phone: 're_phone',
    re_licensed_agent_name: 're_licensed_agent_name'
  };

  export type REAgentModelScalarFieldEnum = (typeof REAgentModelScalarFieldEnum)[keyof typeof REAgentModelScalarFieldEnum]


  export const REProertyModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    name: 'name',
    main_image_url: 'main_image_url',
    re_agent_id: 're_agent_id'
  };

  export type REProertyModelScalarFieldEnum = (typeof REProertyModelScalarFieldEnum)[keyof typeof REProertyModelScalarFieldEnum]


  export const REPropertyCategoryModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    re_property_id: 're_property_id',
    sub_category_id: 'sub_category_id'
  };

  export type REPropertyCategoryModelScalarFieldEnum = (typeof REPropertyCategoryModelScalarFieldEnum)[keyof typeof REPropertyCategoryModelScalarFieldEnum]


  export const REPropertyMiddleCategoryModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    name: 'name',
    super_category_id: 'super_category_id'
  };

  export type REPropertyMiddleCategoryModelScalarFieldEnum = (typeof REPropertyMiddleCategoryModelScalarFieldEnum)[keyof typeof REPropertyMiddleCategoryModelScalarFieldEnum]


  export const REPropertySubCategoryModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    name: 'name',
    middle_category_id: 'middle_category_id'
  };

  export type REPropertySubCategoryModelScalarFieldEnum = (typeof REPropertySubCategoryModelScalarFieldEnum)[keyof typeof REPropertySubCategoryModelScalarFieldEnum]


  export const REPropertySuperCategoryModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    name: 'name'
  };

  export type REPropertySuperCategoryModelScalarFieldEnum = (typeof REPropertySuperCategoryModelScalarFieldEnum)[keyof typeof REPropertySuperCategoryModelScalarFieldEnum]


  export const RateCategoryModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    name: 'name',
    target_type: 'target_type'
  };

  export type RateCategoryModelScalarFieldEnum = (typeof RateCategoryModelScalarFieldEnum)[keyof typeof RateCategoryModelScalarFieldEnum]


  export const RateModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    score: 'score',
    category_id: 'category_id',
    review_id: 'review_id'
  };

  export type RateModelScalarFieldEnum = (typeof RateModelScalarFieldEnum)[keyof typeof RateModelScalarFieldEnum]


  export const ReviewModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    reviewer_id: 'reviewer_id',
    reviewee_id: 'reviewee_id',
    content: 'content'
  };

  export type ReviewModelScalarFieldEnum = (typeof ReviewModelScalarFieldEnum)[keyof typeof ReviewModelScalarFieldEnum]


  export const ServiceSubCategoryModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    name: 'name',
    super_category_id: 'super_category_id'
  };

  export type ServiceSubCategoryModelScalarFieldEnum = (typeof ServiceSubCategoryModelScalarFieldEnum)[keyof typeof ServiceSubCategoryModelScalarFieldEnum]


  export const ServiceSuperCategoryModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    name: 'name',
    type: 'type'
  };

  export type ServiceSuperCategoryModelScalarFieldEnum = (typeof ServiceSuperCategoryModelScalarFieldEnum)[keyof typeof ServiceSuperCategoryModelScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const SubExpertiseModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    sub_category_id: 'sub_category_id',
    business_user_id: 'business_user_id'
  };

  export type SubExpertiseModelScalarFieldEnum = (typeof SubExpertiseModelScalarFieldEnum)[keyof typeof SubExpertiseModelScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    name: 'name',
    email: 'email'
  };

  export type UserModelScalarFieldEnum = (typeof UserModelScalarFieldEnum)[keyof typeof UserModelScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type REProertyModelWhereInput = {
    AND?: Enumerable<REProertyModelWhereInput>
    OR?: Enumerable<REProertyModelWhereInput>
    NOT?: Enumerable<REProertyModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    name?: StringFilter | string
    main_image_url?: StringFilter | string
    re_agent_id?: StringFilter | string
    re_agent?: XOR<REAgentModelRelationFilter, REAgentModelWhereInput>
    categories?: REPropertyCategoryModelListRelationFilter
  }

  export type REProertyModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    main_image_url?: SortOrder
    re_agent_id?: SortOrder
    re_agent?: REAgentModelOrderByWithRelationInput
    categories?: REPropertyCategoryModelOrderByRelationAggregateInput
  }

  export type REProertyModelWhereUniqueInput = {
    id?: string
  }

  export type REProertyModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    main_image_url?: SortOrder
    re_agent_id?: SortOrder
    _count?: REProertyModelCountOrderByAggregateInput
    _max?: REProertyModelMaxOrderByAggregateInput
    _min?: REProertyModelMinOrderByAggregateInput
  }

  export type REProertyModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<REProertyModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<REProertyModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<REProertyModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    name?: StringWithAggregatesFilter | string
    main_image_url?: StringWithAggregatesFilter | string
    re_agent_id?: StringWithAggregatesFilter | string
  }

  export type REPropertyCategoryModelWhereInput = {
    AND?: Enumerable<REPropertyCategoryModelWhereInput>
    OR?: Enumerable<REPropertyCategoryModelWhereInput>
    NOT?: Enumerable<REPropertyCategoryModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    re_property_id?: StringFilter | string
    sub_category_id?: StringFilter | string
    re_property?: XOR<REProertyModelRelationFilter, REProertyModelWhereInput>
    sub_category?: XOR<REPropertySubCategoryModelRelationFilter, REPropertySubCategoryModelWhereInput>
  }

  export type REPropertyCategoryModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    re_property_id?: SortOrder
    sub_category_id?: SortOrder
    re_property?: REProertyModelOrderByWithRelationInput
    sub_category?: REPropertySubCategoryModelOrderByWithRelationInput
  }

  export type REPropertyCategoryModelWhereUniqueInput = {
    id?: string
  }

  export type REPropertyCategoryModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    re_property_id?: SortOrder
    sub_category_id?: SortOrder
    _count?: REPropertyCategoryModelCountOrderByAggregateInput
    _max?: REPropertyCategoryModelMaxOrderByAggregateInput
    _min?: REPropertyCategoryModelMinOrderByAggregateInput
  }

  export type REPropertyCategoryModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<REPropertyCategoryModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<REPropertyCategoryModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<REPropertyCategoryModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    re_property_id?: StringWithAggregatesFilter | string
    sub_category_id?: StringWithAggregatesFilter | string
  }

  export type REPropertySubCategoryModelWhereInput = {
    AND?: Enumerable<REPropertySubCategoryModelWhereInput>
    OR?: Enumerable<REPropertySubCategoryModelWhereInput>
    NOT?: Enumerable<REPropertySubCategoryModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    name?: StringFilter | string
    middle_category_id?: StringFilter | string
    middle_category?: XOR<REPropertyMiddleCategoryModelRelationFilter, REPropertyMiddleCategoryModelWhereInput>
    property_categories?: REPropertyCategoryModelListRelationFilter
  }

  export type REPropertySubCategoryModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    middle_category_id?: SortOrder
    middle_category?: REPropertyMiddleCategoryModelOrderByWithRelationInput
    property_categories?: REPropertyCategoryModelOrderByRelationAggregateInput
  }

  export type REPropertySubCategoryModelWhereUniqueInput = {
    id?: string
  }

  export type REPropertySubCategoryModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    middle_category_id?: SortOrder
    _count?: REPropertySubCategoryModelCountOrderByAggregateInput
    _max?: REPropertySubCategoryModelMaxOrderByAggregateInput
    _min?: REPropertySubCategoryModelMinOrderByAggregateInput
  }

  export type REPropertySubCategoryModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<REPropertySubCategoryModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<REPropertySubCategoryModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<REPropertySubCategoryModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    name?: StringWithAggregatesFilter | string
    middle_category_id?: StringWithAggregatesFilter | string
  }

  export type REPropertyMiddleCategoryModelWhereInput = {
    AND?: Enumerable<REPropertyMiddleCategoryModelWhereInput>
    OR?: Enumerable<REPropertyMiddleCategoryModelWhereInput>
    NOT?: Enumerable<REPropertyMiddleCategoryModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    name?: StringFilter | string
    super_category_id?: StringFilter | string
    super_category?: XOR<REPropertySuperCategoryModelRelationFilter, REPropertySuperCategoryModelWhereInput>
    sub_categories?: REPropertySubCategoryModelListRelationFilter
  }

  export type REPropertyMiddleCategoryModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    super_category_id?: SortOrder
    super_category?: REPropertySuperCategoryModelOrderByWithRelationInput
    sub_categories?: REPropertySubCategoryModelOrderByRelationAggregateInput
  }

  export type REPropertyMiddleCategoryModelWhereUniqueInput = {
    id?: string
  }

  export type REPropertyMiddleCategoryModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    super_category_id?: SortOrder
    _count?: REPropertyMiddleCategoryModelCountOrderByAggregateInput
    _max?: REPropertyMiddleCategoryModelMaxOrderByAggregateInput
    _min?: REPropertyMiddleCategoryModelMinOrderByAggregateInput
  }

  export type REPropertyMiddleCategoryModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<REPropertyMiddleCategoryModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<REPropertyMiddleCategoryModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<REPropertyMiddleCategoryModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    name?: StringWithAggregatesFilter | string
    super_category_id?: StringWithAggregatesFilter | string
  }

  export type REPropertySuperCategoryModelWhereInput = {
    AND?: Enumerable<REPropertySuperCategoryModelWhereInput>
    OR?: Enumerable<REPropertySuperCategoryModelWhereInput>
    NOT?: Enumerable<REPropertySuperCategoryModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    name?: StringFilter | string
    middle_categories?: REPropertyMiddleCategoryModelListRelationFilter
  }

  export type REPropertySuperCategoryModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    middle_categories?: REPropertyMiddleCategoryModelOrderByRelationAggregateInput
  }

  export type REPropertySuperCategoryModelWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type REPropertySuperCategoryModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    _count?: REPropertySuperCategoryModelCountOrderByAggregateInput
    _max?: REPropertySuperCategoryModelMaxOrderByAggregateInput
    _min?: REPropertySuperCategoryModelMinOrderByAggregateInput
  }

  export type REPropertySuperCategoryModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<REPropertySuperCategoryModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<REPropertySuperCategoryModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<REPropertySuperCategoryModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    name?: StringWithAggregatesFilter | string
  }

  export type ReviewModelWhereInput = {
    AND?: Enumerable<ReviewModelWhereInput>
    OR?: Enumerable<ReviewModelWhereInput>
    NOT?: Enumerable<ReviewModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    reviewer_id?: StringFilter | string
    reviewee_id?: StringFilter | string
    content?: StringFilter | string
    reviewer?: XOR<CustomerModelRelationFilter, CustomerModelWhereInput>
    reviewee?: XOR<BusinessUserModelRelationFilter, BusinessUserModelWhereInput>
    rates?: RateModelListRelationFilter
  }

  export type ReviewModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    reviewer_id?: SortOrder
    reviewee_id?: SortOrder
    content?: SortOrder
    reviewer?: CustomerModelOrderByWithRelationInput
    reviewee?: BusinessUserModelOrderByWithRelationInput
    rates?: RateModelOrderByRelationAggregateInput
  }

  export type ReviewModelWhereUniqueInput = {
    id?: string
  }

  export type ReviewModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    reviewer_id?: SortOrder
    reviewee_id?: SortOrder
    content?: SortOrder
    _count?: ReviewModelCountOrderByAggregateInput
    _max?: ReviewModelMaxOrderByAggregateInput
    _min?: ReviewModelMinOrderByAggregateInput
  }

  export type ReviewModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReviewModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReviewModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReviewModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    reviewer_id?: StringWithAggregatesFilter | string
    reviewee_id?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
  }

  export type RateModelWhereInput = {
    AND?: Enumerable<RateModelWhereInput>
    OR?: Enumerable<RateModelWhereInput>
    NOT?: Enumerable<RateModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    score?: IntFilter | number
    category_id?: StringFilter | string
    review_id?: StringFilter | string
    category?: XOR<RateCategoryModelRelationFilter, RateCategoryModelWhereInput>
    review?: XOR<ReviewModelRelationFilter, ReviewModelWhereInput>
  }

  export type RateModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    score?: SortOrder
    category_id?: SortOrder
    review_id?: SortOrder
    category?: RateCategoryModelOrderByWithRelationInput
    review?: ReviewModelOrderByWithRelationInput
  }

  export type RateModelWhereUniqueInput = {
    id?: string
    category_id_review_id?: RateModelCategory_idReview_idCompoundUniqueInput
  }

  export type RateModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    score?: SortOrder
    category_id?: SortOrder
    review_id?: SortOrder
    _count?: RateModelCountOrderByAggregateInput
    _avg?: RateModelAvgOrderByAggregateInput
    _max?: RateModelMaxOrderByAggregateInput
    _min?: RateModelMinOrderByAggregateInput
    _sum?: RateModelSumOrderByAggregateInput
  }

  export type RateModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RateModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<RateModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RateModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    score?: IntWithAggregatesFilter | number
    category_id?: StringWithAggregatesFilter | string
    review_id?: StringWithAggregatesFilter | string
  }

  export type RateCategoryModelWhereInput = {
    AND?: Enumerable<RateCategoryModelWhereInput>
    OR?: Enumerable<RateCategoryModelWhereInput>
    NOT?: Enumerable<RateCategoryModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    name?: StringFilter | string
    target_type?: EnumRateTargetTypeFilter | RateTargetType
    rates?: RateModelListRelationFilter
  }

  export type RateCategoryModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    target_type?: SortOrder
    rates?: RateModelOrderByRelationAggregateInput
  }

  export type RateCategoryModelWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type RateCategoryModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    target_type?: SortOrder
    _count?: RateCategoryModelCountOrderByAggregateInput
    _max?: RateCategoryModelMaxOrderByAggregateInput
    _min?: RateCategoryModelMinOrderByAggregateInput
  }

  export type RateCategoryModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RateCategoryModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<RateCategoryModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RateCategoryModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    name?: StringWithAggregatesFilter | string
    target_type?: EnumRateTargetTypeWithAggregatesFilter | RateTargetType
  }

  export type AgreementModelWhereInput = {
    AND?: Enumerable<AgreementModelWhereInput>
    OR?: Enumerable<AgreementModelWhereInput>
    NOT?: Enumerable<AgreementModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    title?: StringFilter | string
    content?: StringFilter | string
    is_required?: BoolFilter | boolean
    target_type?: EnumAgreementTargetTypeFilter | AgreementTargetType
    acceptances?: AgreementAcceptanceModelListRelationFilter
  }

  export type AgreementModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    title?: SortOrder
    content?: SortOrder
    is_required?: SortOrder
    target_type?: SortOrder
    acceptances?: AgreementAcceptanceModelOrderByRelationAggregateInput
  }

  export type AgreementModelWhereUniqueInput = {
    id?: string
  }

  export type AgreementModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    title?: SortOrder
    content?: SortOrder
    is_required?: SortOrder
    target_type?: SortOrder
    _count?: AgreementModelCountOrderByAggregateInput
    _max?: AgreementModelMaxOrderByAggregateInput
    _min?: AgreementModelMinOrderByAggregateInput
  }

  export type AgreementModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AgreementModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<AgreementModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AgreementModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    title?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    is_required?: BoolWithAggregatesFilter | boolean
    target_type?: EnumAgreementTargetTypeWithAggregatesFilter | AgreementTargetType
  }

  export type AgreementAcceptanceModelWhereInput = {
    AND?: Enumerable<AgreementAcceptanceModelWhereInput>
    OR?: Enumerable<AgreementAcceptanceModelWhereInput>
    NOT?: Enumerable<AgreementAcceptanceModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    user_id?: StringFilter | string
    agreement_id?: StringFilter | string
    user?: XOR<UserModelRelationFilter, UserModelWhereInput>
    agreement?: XOR<AgreementModelRelationFilter, AgreementModelWhereInput>
  }

  export type AgreementAcceptanceModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    user_id?: SortOrder
    agreement_id?: SortOrder
    user?: UserModelOrderByWithRelationInput
    agreement?: AgreementModelOrderByWithRelationInput
  }

  export type AgreementAcceptanceModelWhereUniqueInput = {
    id?: string
    user_id_agreement_id?: AgreementAcceptanceModelUser_idAgreement_idCompoundUniqueInput
  }

  export type AgreementAcceptanceModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    user_id?: SortOrder
    agreement_id?: SortOrder
    _count?: AgreementAcceptanceModelCountOrderByAggregateInput
    _max?: AgreementAcceptanceModelMaxOrderByAggregateInput
    _min?: AgreementAcceptanceModelMinOrderByAggregateInput
  }

  export type AgreementAcceptanceModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AgreementAcceptanceModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<AgreementAcceptanceModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AgreementAcceptanceModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    user_id?: StringWithAggregatesFilter | string
    agreement_id?: StringWithAggregatesFilter | string
  }

  export type ConsultationTimeModelWhereInput = {
    AND?: Enumerable<ConsultationTimeModelWhereInput>
    OR?: Enumerable<ConsultationTimeModelWhereInput>
    NOT?: Enumerable<ConsultationTimeModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    start_time?: DateTimeFilter | Date | string
    end_time?: DateTimeFilter | Date | string
    focus_care_checks?: FocusCareConsultationTimeCheckModelListRelationFilter
  }

  export type ConsultationTimeModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    focus_care_checks?: FocusCareConsultationTimeCheckModelOrderByRelationAggregateInput
  }

  export type ConsultationTimeModelWhereUniqueInput = {
    id?: string
  }

  export type ConsultationTimeModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    _count?: ConsultationTimeModelCountOrderByAggregateInput
    _max?: ConsultationTimeModelMaxOrderByAggregateInput
    _min?: ConsultationTimeModelMinOrderByAggregateInput
  }

  export type ConsultationTimeModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ConsultationTimeModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<ConsultationTimeModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ConsultationTimeModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    start_time?: DateTimeWithAggregatesFilter | Date | string
    end_time?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ServiceSubCategoryModelWhereInput = {
    AND?: Enumerable<ServiceSubCategoryModelWhereInput>
    OR?: Enumerable<ServiceSubCategoryModelWhereInput>
    NOT?: Enumerable<ServiceSubCategoryModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    name?: StringFilter | string
    super_category_id?: StringFilter | string
    super_category?: XOR<ServiceSuperCategoryModelRelationFilter, ServiceSuperCategoryModelWhereInput>
    expertises?: SubExpertiseModelListRelationFilter
  }

  export type ServiceSubCategoryModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    super_category_id?: SortOrder
    super_category?: ServiceSuperCategoryModelOrderByWithRelationInput
    expertises?: SubExpertiseModelOrderByRelationAggregateInput
  }

  export type ServiceSubCategoryModelWhereUniqueInput = {
    id?: string
  }

  export type ServiceSubCategoryModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    super_category_id?: SortOrder
    _count?: ServiceSubCategoryModelCountOrderByAggregateInput
    _max?: ServiceSubCategoryModelMaxOrderByAggregateInput
    _min?: ServiceSubCategoryModelMinOrderByAggregateInput
  }

  export type ServiceSubCategoryModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServiceSubCategoryModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServiceSubCategoryModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServiceSubCategoryModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    name?: StringWithAggregatesFilter | string
    super_category_id?: StringWithAggregatesFilter | string
  }

  export type ServiceSuperCategoryModelWhereInput = {
    AND?: Enumerable<ServiceSuperCategoryModelWhereInput>
    OR?: Enumerable<ServiceSuperCategoryModelWhereInput>
    NOT?: Enumerable<ServiceSuperCategoryModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    name?: StringFilter | string
    type?: EnumServiceTypeFilter | ServiceType
    sub_categories?: ServiceSubCategoryModelListRelationFilter
    focus_care_checks?: FocusCareServiceCheckModelListRelationFilter
  }

  export type ServiceSuperCategoryModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    type?: SortOrder
    sub_categories?: ServiceSubCategoryModelOrderByRelationAggregateInput
    focus_care_checks?: FocusCareServiceCheckModelOrderByRelationAggregateInput
  }

  export type ServiceSuperCategoryModelWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type ServiceSuperCategoryModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    type?: SortOrder
    _count?: ServiceSuperCategoryModelCountOrderByAggregateInput
    _max?: ServiceSuperCategoryModelMaxOrderByAggregateInput
    _min?: ServiceSuperCategoryModelMinOrderByAggregateInput
  }

  export type ServiceSuperCategoryModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServiceSuperCategoryModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServiceSuperCategoryModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServiceSuperCategoryModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    name?: StringWithAggregatesFilter | string
    type?: EnumServiceTypeWithAggregatesFilter | ServiceType
  }

  export type FocusCareRequestModelWhereInput = {
    AND?: Enumerable<FocusCareRequestModelWhereInput>
    OR?: Enumerable<FocusCareRequestModelWhereInput>
    NOT?: Enumerable<FocusCareRequestModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    care_start_date?: DateTimeFilter | Date | string
    care_end_date?: DateTimeFilter | Date | string
    detail?: StringFilter | string
    status?: EnumFocusCareStatusFilter | FocusCareStatus
    requester_id?: StringFilter | string
    requester?: XOR<CustomerModelRelationFilter, CustomerModelWhereInput>
    consultation_times?: FocusCareConsultationTimeCheckModelListRelationFilter
    services?: FocusCareServiceCheckModelListRelationFilter
  }

  export type FocusCareRequestModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    care_start_date?: SortOrder
    care_end_date?: SortOrder
    detail?: SortOrder
    status?: SortOrder
    requester_id?: SortOrder
    requester?: CustomerModelOrderByWithRelationInput
    consultation_times?: FocusCareConsultationTimeCheckModelOrderByRelationAggregateInput
    services?: FocusCareServiceCheckModelOrderByRelationAggregateInput
  }

  export type FocusCareRequestModelWhereUniqueInput = {
    id?: string
  }

  export type FocusCareRequestModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    care_start_date?: SortOrder
    care_end_date?: SortOrder
    detail?: SortOrder
    status?: SortOrder
    requester_id?: SortOrder
    _count?: FocusCareRequestModelCountOrderByAggregateInput
    _max?: FocusCareRequestModelMaxOrderByAggregateInput
    _min?: FocusCareRequestModelMinOrderByAggregateInput
  }

  export type FocusCareRequestModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FocusCareRequestModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<FocusCareRequestModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FocusCareRequestModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    care_start_date?: DateTimeWithAggregatesFilter | Date | string
    care_end_date?: DateTimeWithAggregatesFilter | Date | string
    detail?: StringWithAggregatesFilter | string
    status?: EnumFocusCareStatusWithAggregatesFilter | FocusCareStatus
    requester_id?: StringWithAggregatesFilter | string
  }

  export type FocusCareServiceCheckModelWhereInput = {
    AND?: Enumerable<FocusCareServiceCheckModelWhereInput>
    OR?: Enumerable<FocusCareServiceCheckModelWhereInput>
    NOT?: Enumerable<FocusCareServiceCheckModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    service_super_category_id?: StringFilter | string
    request_id?: StringFilter | string
    service_super_category?: XOR<ServiceSuperCategoryModelRelationFilter, ServiceSuperCategoryModelWhereInput>
    request?: XOR<FocusCareRequestModelRelationFilter, FocusCareRequestModelWhereInput>
  }

  export type FocusCareServiceCheckModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    service_super_category_id?: SortOrder
    request_id?: SortOrder
    service_super_category?: ServiceSuperCategoryModelOrderByWithRelationInput
    request?: FocusCareRequestModelOrderByWithRelationInput
  }

  export type FocusCareServiceCheckModelWhereUniqueInput = {
    id?: string
  }

  export type FocusCareServiceCheckModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    service_super_category_id?: SortOrder
    request_id?: SortOrder
    _count?: FocusCareServiceCheckModelCountOrderByAggregateInput
    _max?: FocusCareServiceCheckModelMaxOrderByAggregateInput
    _min?: FocusCareServiceCheckModelMinOrderByAggregateInput
  }

  export type FocusCareServiceCheckModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FocusCareServiceCheckModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<FocusCareServiceCheckModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FocusCareServiceCheckModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    service_super_category_id?: StringWithAggregatesFilter | string
    request_id?: StringWithAggregatesFilter | string
  }

  export type FocusCareConsultationTimeCheckModelWhereInput = {
    AND?: Enumerable<FocusCareConsultationTimeCheckModelWhereInput>
    OR?: Enumerable<FocusCareConsultationTimeCheckModelWhereInput>
    NOT?: Enumerable<FocusCareConsultationTimeCheckModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    consultation_time_id?: StringFilter | string
    request_id?: StringFilter | string
    consultation_time?: XOR<ConsultationTimeModelRelationFilter, ConsultationTimeModelWhereInput>
    request?: XOR<FocusCareRequestModelRelationFilter, FocusCareRequestModelWhereInput>
  }

  export type FocusCareConsultationTimeCheckModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    consultation_time_id?: SortOrder
    request_id?: SortOrder
    consultation_time?: ConsultationTimeModelOrderByWithRelationInput
    request?: FocusCareRequestModelOrderByWithRelationInput
  }

  export type FocusCareConsultationTimeCheckModelWhereUniqueInput = {
    id?: string
  }

  export type FocusCareConsultationTimeCheckModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    consultation_time_id?: SortOrder
    request_id?: SortOrder
    _count?: FocusCareConsultationTimeCheckModelCountOrderByAggregateInput
    _max?: FocusCareConsultationTimeCheckModelMaxOrderByAggregateInput
    _min?: FocusCareConsultationTimeCheckModelMinOrderByAggregateInput
  }

  export type FocusCareConsultationTimeCheckModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FocusCareConsultationTimeCheckModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<FocusCareConsultationTimeCheckModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FocusCareConsultationTimeCheckModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    consultation_time_id?: StringWithAggregatesFilter | string
    request_id?: StringWithAggregatesFilter | string
  }

  export type UserModelWhereInput = {
    AND?: Enumerable<UserModelWhereInput>
    OR?: Enumerable<UserModelWhereInput>
    NOT?: Enumerable<UserModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    name?: StringFilter | string
    email?: StringNullableFilter | string | null
    customer?: XOR<CustomerModelRelationFilter, CustomerModelWhereInput> | null
    business_user?: XOR<BusinessUserModelRelationFilter, BusinessUserModelWhereInput> | null
    agreement_acceptances?: AgreementAcceptanceModelListRelationFilter
  }

  export type UserModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    email?: SortOrder
    customer?: CustomerModelOrderByWithRelationInput
    business_user?: BusinessUserModelOrderByWithRelationInput
    agreement_acceptances?: AgreementAcceptanceModelOrderByRelationAggregateInput
  }

  export type UserModelWhereUniqueInput = {
    id?: string
  }

  export type UserModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    email?: SortOrder
    _count?: UserModelCountOrderByAggregateInput
    _max?: UserModelMaxOrderByAggregateInput
    _min?: UserModelMinOrderByAggregateInput
  }

  export type UserModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    name?: StringWithAggregatesFilter | string
    email?: StringNullableWithAggregatesFilter | string | null
  }

  export type CustomerModelWhereInput = {
    AND?: Enumerable<CustomerModelWhereInput>
    OR?: Enumerable<CustomerModelWhereInput>
    NOT?: Enumerable<CustomerModelWhereInput>
    id?: StringFilter | string
    birth?: StringNullableFilter | string | null
    gender?: EnumGenderTypeNullableFilter | GenderType | null
    phone?: StringNullableFilter | string | null
    address_first?: StringNullableFilter | string | null
    address_second?: StringNullableFilter | string | null
    profile_image_url?: StringNullableFilter | string | null
    base?: XOR<UserModelRelationFilter, UserModelWhereInput>
    oauth_accounts?: OauthAccountModelListRelationFilter
    reviews?: ReviewModelListRelationFilter
    focus_care_requests?: FocusCareRequestModelListRelationFilter
  }

  export type CustomerModelOrderByWithRelationInput = {
    id?: SortOrder
    birth?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
    profile_image_url?: SortOrder
    base?: UserModelOrderByWithRelationInput
    oauth_accounts?: OauthAccountModelOrderByRelationAggregateInput
    reviews?: ReviewModelOrderByRelationAggregateInput
    focus_care_requests?: FocusCareRequestModelOrderByRelationAggregateInput
  }

  export type CustomerModelWhereUniqueInput = {
    id?: string
  }

  export type CustomerModelOrderByWithAggregationInput = {
    id?: SortOrder
    birth?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
    profile_image_url?: SortOrder
    _count?: CustomerModelCountOrderByAggregateInput
    _max?: CustomerModelMaxOrderByAggregateInput
    _min?: CustomerModelMinOrderByAggregateInput
  }

  export type CustomerModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    birth?: StringNullableWithAggregatesFilter | string | null
    gender?: EnumGenderTypeNullableWithAggregatesFilter | GenderType | null
    phone?: StringNullableWithAggregatesFilter | string | null
    address_first?: StringNullableWithAggregatesFilter | string | null
    address_second?: StringNullableWithAggregatesFilter | string | null
    profile_image_url?: StringNullableWithAggregatesFilter | string | null
  }

  export type BusinessUserModelWhereInput = {
    AND?: Enumerable<BusinessUserModelWhereInput>
    OR?: Enumerable<BusinessUserModelWhereInput>
    NOT?: Enumerable<BusinessUserModelWhereInput>
    id?: StringFilter | string
    is_verified?: BoolFilter | boolean
    introduction_title?: StringFilter | string
    introduction_content?: StringFilter | string
    phone?: StringFilter | string
    address_first?: StringFilter | string
    address_second?: StringNullableFilter | string | null
    profile_image_url?: StringFilter | string
    base?: XOR<UserModelRelationFilter, UserModelWhereInput>
    re_agent?: XOR<REAgentModelRelationFilter, REAgentModelWhereInput> | null
    hs_provider?: XOR<HSProviderModelRelationFilter, HSProviderModelWhereInput> | null
    certification_images?: BusinessCertificationImageModelListRelationFilter
    sub_expertises?: SubExpertiseModelListRelationFilter
    oauth_accounts?: OauthAccountModelListRelationFilter
    reviews?: ReviewModelListRelationFilter
  }

  export type BusinessUserModelOrderByWithRelationInput = {
    id?: SortOrder
    is_verified?: SortOrder
    introduction_title?: SortOrder
    introduction_content?: SortOrder
    phone?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
    profile_image_url?: SortOrder
    base?: UserModelOrderByWithRelationInput
    re_agent?: REAgentModelOrderByWithRelationInput
    hs_provider?: HSProviderModelOrderByWithRelationInput
    certification_images?: BusinessCertificationImageModelOrderByRelationAggregateInput
    sub_expertises?: SubExpertiseModelOrderByRelationAggregateInput
    oauth_accounts?: OauthAccountModelOrderByRelationAggregateInput
    reviews?: ReviewModelOrderByRelationAggregateInput
  }

  export type BusinessUserModelWhereUniqueInput = {
    id?: string
  }

  export type BusinessUserModelOrderByWithAggregationInput = {
    id?: SortOrder
    is_verified?: SortOrder
    introduction_title?: SortOrder
    introduction_content?: SortOrder
    phone?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
    profile_image_url?: SortOrder
    _count?: BusinessUserModelCountOrderByAggregateInput
    _max?: BusinessUserModelMaxOrderByAggregateInput
    _min?: BusinessUserModelMinOrderByAggregateInput
  }

  export type BusinessUserModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BusinessUserModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<BusinessUserModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BusinessUserModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    is_verified?: BoolWithAggregatesFilter | boolean
    introduction_title?: StringWithAggregatesFilter | string
    introduction_content?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    address_first?: StringWithAggregatesFilter | string
    address_second?: StringNullableWithAggregatesFilter | string | null
    profile_image_url?: StringWithAggregatesFilter | string
  }

  export type SubExpertiseModelWhereInput = {
    AND?: Enumerable<SubExpertiseModelWhereInput>
    OR?: Enumerable<SubExpertiseModelWhereInput>
    NOT?: Enumerable<SubExpertiseModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    sub_category_id?: StringFilter | string
    business_user_id?: StringFilter | string
    sub_category?: XOR<ServiceSubCategoryModelRelationFilter, ServiceSubCategoryModelWhereInput>
    business_user?: XOR<BusinessUserModelRelationFilter, BusinessUserModelWhereInput>
  }

  export type SubExpertiseModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    sub_category_id?: SortOrder
    business_user_id?: SortOrder
    sub_category?: ServiceSubCategoryModelOrderByWithRelationInput
    business_user?: BusinessUserModelOrderByWithRelationInput
  }

  export type SubExpertiseModelWhereUniqueInput = {
    id?: string
    sub_category_id_business_user_id?: SubExpertiseModelSub_category_idBusiness_user_idCompoundUniqueInput
  }

  export type SubExpertiseModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    sub_category_id?: SortOrder
    business_user_id?: SortOrder
    _count?: SubExpertiseModelCountOrderByAggregateInput
    _max?: SubExpertiseModelMaxOrderByAggregateInput
    _min?: SubExpertiseModelMinOrderByAggregateInput
  }

  export type SubExpertiseModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubExpertiseModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubExpertiseModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubExpertiseModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    sub_category_id?: StringWithAggregatesFilter | string
    business_user_id?: StringWithAggregatesFilter | string
  }

  export type REAgentModelWhereInput = {
    AND?: Enumerable<REAgentModelWhereInput>
    OR?: Enumerable<REAgentModelWhereInput>
    NOT?: Enumerable<REAgentModelWhereInput>
    id?: StringFilter | string
    is_licensed?: BoolFilter | boolean
    re_num?: StringFilter | string
    re_name?: StringFilter | string
    re_phone?: StringFilter | string
    re_licensed_agent_name?: StringFilter | string
    base?: XOR<BusinessUserModelRelationFilter, BusinessUserModelWhereInput>
    properties?: REProertyModelListRelationFilter
  }

  export type REAgentModelOrderByWithRelationInput = {
    id?: SortOrder
    is_licensed?: SortOrder
    re_num?: SortOrder
    re_name?: SortOrder
    re_phone?: SortOrder
    re_licensed_agent_name?: SortOrder
    base?: BusinessUserModelOrderByWithRelationInput
    properties?: REProertyModelOrderByRelationAggregateInput
  }

  export type REAgentModelWhereUniqueInput = {
    id?: string
  }

  export type REAgentModelOrderByWithAggregationInput = {
    id?: SortOrder
    is_licensed?: SortOrder
    re_num?: SortOrder
    re_name?: SortOrder
    re_phone?: SortOrder
    re_licensed_agent_name?: SortOrder
    _count?: REAgentModelCountOrderByAggregateInput
    _max?: REAgentModelMaxOrderByAggregateInput
    _min?: REAgentModelMinOrderByAggregateInput
  }

  export type REAgentModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<REAgentModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<REAgentModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<REAgentModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    is_licensed?: BoolWithAggregatesFilter | boolean
    re_num?: StringWithAggregatesFilter | string
    re_name?: StringWithAggregatesFilter | string
    re_phone?: StringWithAggregatesFilter | string
    re_licensed_agent_name?: StringWithAggregatesFilter | string
  }

  export type HSProviderModelWhereInput = {
    AND?: Enumerable<HSProviderModelWhereInput>
    OR?: Enumerable<HSProviderModelWhereInput>
    NOT?: Enumerable<HSProviderModelWhereInput>
    id?: StringFilter | string
    business_registration_num?: StringFilter | string
    base?: XOR<BusinessUserModelRelationFilter, BusinessUserModelWhereInput>
    introduction_images?: HSIntroductionImageModelListRelationFilter
  }

  export type HSProviderModelOrderByWithRelationInput = {
    id?: SortOrder
    business_registration_num?: SortOrder
    base?: BusinessUserModelOrderByWithRelationInput
    introduction_images?: HSIntroductionImageModelOrderByRelationAggregateInput
  }

  export type HSProviderModelWhereUniqueInput = {
    id?: string
  }

  export type HSProviderModelOrderByWithAggregationInput = {
    id?: SortOrder
    business_registration_num?: SortOrder
    _count?: HSProviderModelCountOrderByAggregateInput
    _max?: HSProviderModelMaxOrderByAggregateInput
    _min?: HSProviderModelMinOrderByAggregateInput
  }

  export type HSProviderModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HSProviderModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<HSProviderModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HSProviderModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    business_registration_num?: StringWithAggregatesFilter | string
  }

  export type BusinessCertificationImageModelWhereInput = {
    AND?: Enumerable<BusinessCertificationImageModelWhereInput>
    OR?: Enumerable<BusinessCertificationImageModelWhereInput>
    NOT?: Enumerable<BusinessCertificationImageModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    business_user_id?: StringFilter | string
    url?: StringFilter | string
    business_user?: XOR<BusinessUserModelRelationFilter, BusinessUserModelWhereInput>
  }

  export type BusinessCertificationImageModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    business_user_id?: SortOrder
    url?: SortOrder
    business_user?: BusinessUserModelOrderByWithRelationInput
  }

  export type BusinessCertificationImageModelWhereUniqueInput = {
    id?: string
  }

  export type BusinessCertificationImageModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    business_user_id?: SortOrder
    url?: SortOrder
    _count?: BusinessCertificationImageModelCountOrderByAggregateInput
    _max?: BusinessCertificationImageModelMaxOrderByAggregateInput
    _min?: BusinessCertificationImageModelMinOrderByAggregateInput
  }

  export type BusinessCertificationImageModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BusinessCertificationImageModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<BusinessCertificationImageModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BusinessCertificationImageModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    business_user_id?: StringWithAggregatesFilter | string
    url?: StringWithAggregatesFilter | string
  }

  export type HSIntroductionImageModelWhereInput = {
    AND?: Enumerable<HSIntroductionImageModelWhereInput>
    OR?: Enumerable<HSIntroductionImageModelWhereInput>
    NOT?: Enumerable<HSIntroductionImageModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    hs_provider_id?: StringFilter | string
    url?: StringFilter | string
    hs_provider?: XOR<HSProviderModelRelationFilter, HSProviderModelWhereInput>
  }

  export type HSIntroductionImageModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    hs_provider_id?: SortOrder
    url?: SortOrder
    hs_provider?: HSProviderModelOrderByWithRelationInput
  }

  export type HSIntroductionImageModelWhereUniqueInput = {
    id?: string
  }

  export type HSIntroductionImageModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    hs_provider_id?: SortOrder
    url?: SortOrder
    _count?: HSIntroductionImageModelCountOrderByAggregateInput
    _max?: HSIntroductionImageModelMaxOrderByAggregateInput
    _min?: HSIntroductionImageModelMinOrderByAggregateInput
  }

  export type HSIntroductionImageModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HSIntroductionImageModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<HSIntroductionImageModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HSIntroductionImageModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    hs_provider_id?: StringWithAggregatesFilter | string
    url?: StringWithAggregatesFilter | string
  }

  export type OauthAccountModelWhereInput = {
    AND?: Enumerable<OauthAccountModelWhereInput>
    OR?: Enumerable<OauthAccountModelWhereInput>
    NOT?: Enumerable<OauthAccountModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    oauth_type?: EnumOauthTypeFilter | OauthType
    oauth_sub?: StringFilter | string
    business_user_id?: StringNullableFilter | string | null
    customer_id?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    profile_image_url?: StringNullableFilter | string | null
    birth?: StringNullableFilter | string | null
    gender?: EnumGenderTypeNullableFilter | GenderType | null
    address_first?: StringNullableFilter | string | null
    address_second?: StringNullableFilter | string | null
    business_user?: XOR<BusinessUserModelRelationFilter, BusinessUserModelWhereInput> | null
    customer?: XOR<CustomerModelRelationFilter, CustomerModelWhereInput> | null
  }

  export type OauthAccountModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    oauth_type?: SortOrder
    oauth_sub?: SortOrder
    business_user_id?: SortOrder
    customer_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    profile_image_url?: SortOrder
    birth?: SortOrder
    gender?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
    business_user?: BusinessUserModelOrderByWithRelationInput
    customer?: CustomerModelOrderByWithRelationInput
  }

  export type OauthAccountModelWhereUniqueInput = {
    id?: string
  }

  export type OauthAccountModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    oauth_type?: SortOrder
    oauth_sub?: SortOrder
    business_user_id?: SortOrder
    customer_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    profile_image_url?: SortOrder
    birth?: SortOrder
    gender?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
    _count?: OauthAccountModelCountOrderByAggregateInput
    _max?: OauthAccountModelMaxOrderByAggregateInput
    _min?: OauthAccountModelMinOrderByAggregateInput
  }

  export type OauthAccountModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OauthAccountModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<OauthAccountModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OauthAccountModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    oauth_type?: EnumOauthTypeWithAggregatesFilter | OauthType
    oauth_sub?: StringWithAggregatesFilter | string
    business_user_id?: StringNullableWithAggregatesFilter | string | null
    customer_id?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    profile_image_url?: StringNullableWithAggregatesFilter | string | null
    birth?: StringNullableWithAggregatesFilter | string | null
    gender?: EnumGenderTypeNullableWithAggregatesFilter | GenderType | null
    address_first?: StringNullableWithAggregatesFilter | string | null
    address_second?: StringNullableWithAggregatesFilter | string | null
  }

  export type REProertyModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    main_image_url: string
    re_agent: REAgentModelCreateNestedOneWithoutPropertiesInput
    categories?: REPropertyCategoryModelCreateNestedManyWithoutRe_propertyInput
  }

  export type REProertyModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    main_image_url: string
    re_agent_id: string
    categories?: REPropertyCategoryModelUncheckedCreateNestedManyWithoutRe_propertyInput
  }

  export type REProertyModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
    re_agent?: REAgentModelUpdateOneRequiredWithoutPropertiesNestedInput
    categories?: REPropertyCategoryModelUpdateManyWithoutRe_propertyNestedInput
  }

  export type REProertyModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
    re_agent_id?: StringFieldUpdateOperationsInput | string
    categories?: REPropertyCategoryModelUncheckedUpdateManyWithoutRe_propertyNestedInput
  }

  export type REProertyModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    main_image_url: string
    re_agent_id: string
  }

  export type REProertyModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
  }

  export type REProertyModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
    re_agent_id?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertyCategoryModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    re_property: REProertyModelCreateNestedOneWithoutCategoriesInput
    sub_category: REPropertySubCategoryModelCreateNestedOneWithoutProperty_categoriesInput
  }

  export type REPropertyCategoryModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    re_property_id: string
    sub_category_id: string
  }

  export type REPropertyCategoryModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    re_property?: REProertyModelUpdateOneRequiredWithoutCategoriesNestedInput
    sub_category?: REPropertySubCategoryModelUpdateOneRequiredWithoutProperty_categoriesNestedInput
  }

  export type REPropertyCategoryModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    re_property_id?: StringFieldUpdateOperationsInput | string
    sub_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertyCategoryModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    re_property_id: string
    sub_category_id: string
  }

  export type REPropertyCategoryModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type REPropertyCategoryModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    re_property_id?: StringFieldUpdateOperationsInput | string
    sub_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertySubCategoryModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    middle_category: REPropertyMiddleCategoryModelCreateNestedOneWithoutSub_categoriesInput
    property_categories?: REPropertyCategoryModelCreateNestedManyWithoutSub_categoryInput
  }

  export type REPropertySubCategoryModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    middle_category_id: string
    property_categories?: REPropertyCategoryModelUncheckedCreateNestedManyWithoutSub_categoryInput
  }

  export type REPropertySubCategoryModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    middle_category?: REPropertyMiddleCategoryModelUpdateOneRequiredWithoutSub_categoriesNestedInput
    property_categories?: REPropertyCategoryModelUpdateManyWithoutSub_categoryNestedInput
  }

  export type REPropertySubCategoryModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    middle_category_id?: StringFieldUpdateOperationsInput | string
    property_categories?: REPropertyCategoryModelUncheckedUpdateManyWithoutSub_categoryNestedInput
  }

  export type REPropertySubCategoryModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    middle_category_id: string
  }

  export type REPropertySubCategoryModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertySubCategoryModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    middle_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertyMiddleCategoryModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    super_category: REPropertySuperCategoryModelCreateNestedOneWithoutMiddle_categoriesInput
    sub_categories?: REPropertySubCategoryModelCreateNestedManyWithoutMiddle_categoryInput
  }

  export type REPropertyMiddleCategoryModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    super_category_id: string
    sub_categories?: REPropertySubCategoryModelUncheckedCreateNestedManyWithoutMiddle_categoryInput
  }

  export type REPropertyMiddleCategoryModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    super_category?: REPropertySuperCategoryModelUpdateOneRequiredWithoutMiddle_categoriesNestedInput
    sub_categories?: REPropertySubCategoryModelUpdateManyWithoutMiddle_categoryNestedInput
  }

  export type REPropertyMiddleCategoryModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    super_category_id?: StringFieldUpdateOperationsInput | string
    sub_categories?: REPropertySubCategoryModelUncheckedUpdateManyWithoutMiddle_categoryNestedInput
  }

  export type REPropertyMiddleCategoryModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    super_category_id: string
  }

  export type REPropertyMiddleCategoryModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertyMiddleCategoryModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    super_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertySuperCategoryModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    middle_categories?: REPropertyMiddleCategoryModelCreateNestedManyWithoutSuper_categoryInput
  }

  export type REPropertySuperCategoryModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    middle_categories?: REPropertyMiddleCategoryModelUncheckedCreateNestedManyWithoutSuper_categoryInput
  }

  export type REPropertySuperCategoryModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    middle_categories?: REPropertyMiddleCategoryModelUpdateManyWithoutSuper_categoryNestedInput
  }

  export type REPropertySuperCategoryModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    middle_categories?: REPropertyMiddleCategoryModelUncheckedUpdateManyWithoutSuper_categoryNestedInput
  }

  export type REPropertySuperCategoryModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
  }

  export type REPropertySuperCategoryModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertySuperCategoryModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    content: string
    reviewer: CustomerModelCreateNestedOneWithoutReviewsInput
    reviewee: BusinessUserModelCreateNestedOneWithoutReviewsInput
    rates?: RateModelCreateNestedManyWithoutReviewInput
  }

  export type ReviewModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    reviewer_id: string
    reviewee_id: string
    content: string
    rates?: RateModelUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    reviewer?: CustomerModelUpdateOneRequiredWithoutReviewsNestedInput
    reviewee?: BusinessUserModelUpdateOneRequiredWithoutReviewsNestedInput
    rates?: RateModelUpdateManyWithoutReviewNestedInput
  }

  export type ReviewModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewer_id?: StringFieldUpdateOperationsInput | string
    reviewee_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rates?: RateModelUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    reviewer_id: string
    reviewee_id: string
    content: string
  }

  export type ReviewModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewer_id?: StringFieldUpdateOperationsInput | string
    reviewee_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type RateModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    score: number
    category: RateCategoryModelCreateNestedOneWithoutRatesInput
    review: ReviewModelCreateNestedOneWithoutRatesInput
  }

  export type RateModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    score: number
    category_id: string
    review_id: string
  }

  export type RateModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
    category?: RateCategoryModelUpdateOneRequiredWithoutRatesNestedInput
    review?: ReviewModelUpdateOneRequiredWithoutRatesNestedInput
  }

  export type RateModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
    review_id?: StringFieldUpdateOperationsInput | string
  }

  export type RateModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    score: number
    category_id: string
    review_id: string
  }

  export type RateModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
  }

  export type RateModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
    review_id?: StringFieldUpdateOperationsInput | string
  }

  export type RateCategoryModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    target_type: RateTargetType
    rates?: RateModelCreateNestedManyWithoutCategoryInput
  }

  export type RateCategoryModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    target_type: RateTargetType
    rates?: RateModelUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type RateCategoryModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    target_type?: EnumRateTargetTypeFieldUpdateOperationsInput | RateTargetType
    rates?: RateModelUpdateManyWithoutCategoryNestedInput
  }

  export type RateCategoryModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    target_type?: EnumRateTargetTypeFieldUpdateOperationsInput | RateTargetType
    rates?: RateModelUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type RateCategoryModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    target_type: RateTargetType
  }

  export type RateCategoryModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    target_type?: EnumRateTargetTypeFieldUpdateOperationsInput | RateTargetType
  }

  export type RateCategoryModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    target_type?: EnumRateTargetTypeFieldUpdateOperationsInput | RateTargetType
  }

  export type AgreementModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    title: string
    content: string
    is_required: boolean
    target_type: AgreementTargetType
    acceptances?: AgreementAcceptanceModelCreateNestedManyWithoutAgreementInput
  }

  export type AgreementModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    title: string
    content: string
    is_required: boolean
    target_type: AgreementTargetType
    acceptances?: AgreementAcceptanceModelUncheckedCreateNestedManyWithoutAgreementInput
  }

  export type AgreementModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_required?: BoolFieldUpdateOperationsInput | boolean
    target_type?: EnumAgreementTargetTypeFieldUpdateOperationsInput | AgreementTargetType
    acceptances?: AgreementAcceptanceModelUpdateManyWithoutAgreementNestedInput
  }

  export type AgreementModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_required?: BoolFieldUpdateOperationsInput | boolean
    target_type?: EnumAgreementTargetTypeFieldUpdateOperationsInput | AgreementTargetType
    acceptances?: AgreementAcceptanceModelUncheckedUpdateManyWithoutAgreementNestedInput
  }

  export type AgreementModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    title: string
    content: string
    is_required: boolean
    target_type: AgreementTargetType
  }

  export type AgreementModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_required?: BoolFieldUpdateOperationsInput | boolean
    target_type?: EnumAgreementTargetTypeFieldUpdateOperationsInput | AgreementTargetType
  }

  export type AgreementModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_required?: BoolFieldUpdateOperationsInput | boolean
    target_type?: EnumAgreementTargetTypeFieldUpdateOperationsInput | AgreementTargetType
  }

  export type AgreementAcceptanceModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    user: UserModelCreateNestedOneWithoutAgreement_acceptancesInput
    agreement: AgreementModelCreateNestedOneWithoutAcceptancesInput
  }

  export type AgreementAcceptanceModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    user_id: string
    agreement_id: string
  }

  export type AgreementAcceptanceModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserModelUpdateOneRequiredWithoutAgreement_acceptancesNestedInput
    agreement?: AgreementModelUpdateOneRequiredWithoutAcceptancesNestedInput
  }

  export type AgreementAcceptanceModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    agreement_id?: StringFieldUpdateOperationsInput | string
  }

  export type AgreementAcceptanceModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    user_id: string
    agreement_id: string
  }

  export type AgreementAcceptanceModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgreementAcceptanceModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    agreement_id?: StringFieldUpdateOperationsInput | string
  }

  export type ConsultationTimeModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    start_time: Date | string
    end_time: Date | string
    focus_care_checks?: FocusCareConsultationTimeCheckModelCreateNestedManyWithoutConsultation_timeInput
  }

  export type ConsultationTimeModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    start_time: Date | string
    end_time: Date | string
    focus_care_checks?: FocusCareConsultationTimeCheckModelUncheckedCreateNestedManyWithoutConsultation_timeInput
  }

  export type ConsultationTimeModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    focus_care_checks?: FocusCareConsultationTimeCheckModelUpdateManyWithoutConsultation_timeNestedInput
  }

  export type ConsultationTimeModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    focus_care_checks?: FocusCareConsultationTimeCheckModelUncheckedUpdateManyWithoutConsultation_timeNestedInput
  }

  export type ConsultationTimeModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    start_time: Date | string
    end_time: Date | string
  }

  export type ConsultationTimeModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationTimeModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceSubCategoryModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    super_category: ServiceSuperCategoryModelCreateNestedOneWithoutSub_categoriesInput
    expertises?: SubExpertiseModelCreateNestedManyWithoutSub_categoryInput
  }

  export type ServiceSubCategoryModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    super_category_id: string
    expertises?: SubExpertiseModelUncheckedCreateNestedManyWithoutSub_categoryInput
  }

  export type ServiceSubCategoryModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    super_category?: ServiceSuperCategoryModelUpdateOneRequiredWithoutSub_categoriesNestedInput
    expertises?: SubExpertiseModelUpdateManyWithoutSub_categoryNestedInput
  }

  export type ServiceSubCategoryModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    super_category_id?: StringFieldUpdateOperationsInput | string
    expertises?: SubExpertiseModelUncheckedUpdateManyWithoutSub_categoryNestedInput
  }

  export type ServiceSubCategoryModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    super_category_id: string
  }

  export type ServiceSubCategoryModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceSubCategoryModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    super_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceSuperCategoryModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    type: ServiceType
    sub_categories?: ServiceSubCategoryModelCreateNestedManyWithoutSuper_categoryInput
    focus_care_checks?: FocusCareServiceCheckModelCreateNestedManyWithoutService_super_categoryInput
  }

  export type ServiceSuperCategoryModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    type: ServiceType
    sub_categories?: ServiceSubCategoryModelUncheckedCreateNestedManyWithoutSuper_categoryInput
    focus_care_checks?: FocusCareServiceCheckModelUncheckedCreateNestedManyWithoutService_super_categoryInput
  }

  export type ServiceSuperCategoryModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | ServiceType
    sub_categories?: ServiceSubCategoryModelUpdateManyWithoutSuper_categoryNestedInput
    focus_care_checks?: FocusCareServiceCheckModelUpdateManyWithoutService_super_categoryNestedInput
  }

  export type ServiceSuperCategoryModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | ServiceType
    sub_categories?: ServiceSubCategoryModelUncheckedUpdateManyWithoutSuper_categoryNestedInput
    focus_care_checks?: FocusCareServiceCheckModelUncheckedUpdateManyWithoutService_super_categoryNestedInput
  }

  export type ServiceSuperCategoryModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    type: ServiceType
  }

  export type ServiceSuperCategoryModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | ServiceType
  }

  export type ServiceSuperCategoryModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | ServiceType
  }

  export type FocusCareRequestModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    care_start_date: Date | string
    care_end_date: Date | string
    detail: string
    status: FocusCareStatus
    requester: CustomerModelCreateNestedOneWithoutFocus_care_requestsInput
    consultation_times?: FocusCareConsultationTimeCheckModelCreateNestedManyWithoutRequestInput
    services?: FocusCareServiceCheckModelCreateNestedManyWithoutRequestInput
  }

  export type FocusCareRequestModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    care_start_date: Date | string
    care_end_date: Date | string
    detail: string
    status: FocusCareStatus
    requester_id: string
    consultation_times?: FocusCareConsultationTimeCheckModelUncheckedCreateNestedManyWithoutRequestInput
    services?: FocusCareServiceCheckModelUncheckedCreateNestedManyWithoutRequestInput
  }

  export type FocusCareRequestModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    care_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    care_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: StringFieldUpdateOperationsInput | string
    status?: EnumFocusCareStatusFieldUpdateOperationsInput | FocusCareStatus
    requester?: CustomerModelUpdateOneRequiredWithoutFocus_care_requestsNestedInput
    consultation_times?: FocusCareConsultationTimeCheckModelUpdateManyWithoutRequestNestedInput
    services?: FocusCareServiceCheckModelUpdateManyWithoutRequestNestedInput
  }

  export type FocusCareRequestModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    care_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    care_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: StringFieldUpdateOperationsInput | string
    status?: EnumFocusCareStatusFieldUpdateOperationsInput | FocusCareStatus
    requester_id?: StringFieldUpdateOperationsInput | string
    consultation_times?: FocusCareConsultationTimeCheckModelUncheckedUpdateManyWithoutRequestNestedInput
    services?: FocusCareServiceCheckModelUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type FocusCareRequestModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    care_start_date: Date | string
    care_end_date: Date | string
    detail: string
    status: FocusCareStatus
    requester_id: string
  }

  export type FocusCareRequestModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    care_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    care_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: StringFieldUpdateOperationsInput | string
    status?: EnumFocusCareStatusFieldUpdateOperationsInput | FocusCareStatus
  }

  export type FocusCareRequestModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    care_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    care_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: StringFieldUpdateOperationsInput | string
    status?: EnumFocusCareStatusFieldUpdateOperationsInput | FocusCareStatus
    requester_id?: StringFieldUpdateOperationsInput | string
  }

  export type FocusCareServiceCheckModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    service_super_category: ServiceSuperCategoryModelCreateNestedOneWithoutFocus_care_checksInput
    request: FocusCareRequestModelCreateNestedOneWithoutServicesInput
  }

  export type FocusCareServiceCheckModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    service_super_category_id: string
    request_id: string
  }

  export type FocusCareServiceCheckModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_super_category?: ServiceSuperCategoryModelUpdateOneRequiredWithoutFocus_care_checksNestedInput
    request?: FocusCareRequestModelUpdateOneRequiredWithoutServicesNestedInput
  }

  export type FocusCareServiceCheckModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_super_category_id?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
  }

  export type FocusCareServiceCheckModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    service_super_category_id: string
    request_id: string
  }

  export type FocusCareServiceCheckModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FocusCareServiceCheckModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_super_category_id?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
  }

  export type FocusCareConsultationTimeCheckModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    consultation_time: ConsultationTimeModelCreateNestedOneWithoutFocus_care_checksInput
    request: FocusCareRequestModelCreateNestedOneWithoutConsultation_timesInput
  }

  export type FocusCareConsultationTimeCheckModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    consultation_time_id: string
    request_id: string
  }

  export type FocusCareConsultationTimeCheckModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consultation_time?: ConsultationTimeModelUpdateOneRequiredWithoutFocus_care_checksNestedInput
    request?: FocusCareRequestModelUpdateOneRequiredWithoutConsultation_timesNestedInput
  }

  export type FocusCareConsultationTimeCheckModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consultation_time_id?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
  }

  export type FocusCareConsultationTimeCheckModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    consultation_time_id: string
    request_id: string
  }

  export type FocusCareConsultationTimeCheckModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FocusCareConsultationTimeCheckModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consultation_time_id?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
  }

  export type UserModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    email?: string | null
    customer?: CustomerModelCreateNestedOneWithoutBaseInput
    business_user?: BusinessUserModelCreateNestedOneWithoutBaseInput
    agreement_acceptances?: AgreementAcceptanceModelCreateNestedManyWithoutUserInput
  }

  export type UserModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    email?: string | null
    customer?: CustomerModelUncheckedCreateNestedOneWithoutBaseInput
    business_user?: BusinessUserModelUncheckedCreateNestedOneWithoutBaseInput
    agreement_acceptances?: AgreementAcceptanceModelUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerModelUpdateOneWithoutBaseNestedInput
    business_user?: BusinessUserModelUpdateOneWithoutBaseNestedInput
    agreement_acceptances?: AgreementAcceptanceModelUpdateManyWithoutUserNestedInput
  }

  export type UserModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerModelUncheckedUpdateOneWithoutBaseNestedInput
    business_user?: BusinessUserModelUncheckedUpdateOneWithoutBaseNestedInput
    agreement_acceptances?: AgreementAcceptanceModelUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    email?: string | null
  }

  export type UserModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerModelCreateInput = {
    birth?: string | null
    gender?: GenderType | null
    phone?: string | null
    address_first?: string | null
    address_second?: string | null
    profile_image_url?: string | null
    base: UserModelCreateNestedOneWithoutCustomerInput
    oauth_accounts?: OauthAccountModelCreateNestedManyWithoutCustomerInput
    reviews?: ReviewModelCreateNestedManyWithoutReviewerInput
    focus_care_requests?: FocusCareRequestModelCreateNestedManyWithoutRequesterInput
  }

  export type CustomerModelUncheckedCreateInput = {
    id: string
    birth?: string | null
    gender?: GenderType | null
    phone?: string | null
    address_first?: string | null
    address_second?: string | null
    profile_image_url?: string | null
    oauth_accounts?: OauthAccountModelUncheckedCreateNestedManyWithoutCustomerInput
    reviews?: ReviewModelUncheckedCreateNestedManyWithoutReviewerInput
    focus_care_requests?: FocusCareRequestModelUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type CustomerModelUpdateInput = {
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    base?: UserModelUpdateOneRequiredWithoutCustomerNestedInput
    oauth_accounts?: OauthAccountModelUpdateManyWithoutCustomerNestedInput
    reviews?: ReviewModelUpdateManyWithoutReviewerNestedInput
    focus_care_requests?: FocusCareRequestModelUpdateManyWithoutRequesterNestedInput
  }

  export type CustomerModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_accounts?: OauthAccountModelUncheckedUpdateManyWithoutCustomerNestedInput
    reviews?: ReviewModelUncheckedUpdateManyWithoutReviewerNestedInput
    focus_care_requests?: FocusCareRequestModelUncheckedUpdateManyWithoutRequesterNestedInput
  }

  export type CustomerModelCreateManyInput = {
    id: string
    birth?: string | null
    gender?: GenderType | null
    phone?: string | null
    address_first?: string | null
    address_second?: string | null
    profile_image_url?: string | null
  }

  export type CustomerModelUpdateManyMutationInput = {
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusinessUserModelCreateInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    base: UserModelCreateNestedOneWithoutBusiness_userInput
    re_agent?: REAgentModelCreateNestedOneWithoutBaseInput
    hs_provider?: HSProviderModelCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelCreateNestedManyWithoutBusiness_userInput
    sub_expertises?: SubExpertiseModelCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelCreateNestedManyWithoutBusiness_userInput
    reviews?: ReviewModelCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelUncheckedCreateInput = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    re_agent?: REAgentModelUncheckedCreateNestedOneWithoutBaseInput
    hs_provider?: HSProviderModelUncheckedCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelUncheckedCreateNestedManyWithoutBusiness_userInput
    sub_expertises?: SubExpertiseModelUncheckedCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelUncheckedCreateNestedManyWithoutBusiness_userInput
    reviews?: ReviewModelUncheckedCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelUpdateInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    base?: UserModelUpdateOneRequiredWithoutBusiness_userNestedInput
    re_agent?: REAgentModelUpdateOneWithoutBaseNestedInput
    hs_provider?: HSProviderModelUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUpdateManyWithoutBusiness_userNestedInput
    sub_expertises?: SubExpertiseModelUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUpdateManyWithoutBusiness_userNestedInput
    reviews?: ReviewModelUpdateManyWithoutRevieweeNestedInput
  }

  export type BusinessUserModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    re_agent?: REAgentModelUncheckedUpdateOneWithoutBaseNestedInput
    hs_provider?: HSProviderModelUncheckedUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    sub_expertises?: SubExpertiseModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    reviews?: ReviewModelUncheckedUpdateManyWithoutRevieweeNestedInput
  }

  export type BusinessUserModelCreateManyInput = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
  }

  export type BusinessUserModelUpdateManyMutationInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUserModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
  }

  export type SubExpertiseModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    sub_category: ServiceSubCategoryModelCreateNestedOneWithoutExpertisesInput
    business_user: BusinessUserModelCreateNestedOneWithoutSub_expertisesInput
  }

  export type SubExpertiseModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    sub_category_id: string
    business_user_id: string
  }

  export type SubExpertiseModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_category?: ServiceSubCategoryModelUpdateOneRequiredWithoutExpertisesNestedInput
    business_user?: BusinessUserModelUpdateOneRequiredWithoutSub_expertisesNestedInput
  }

  export type SubExpertiseModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_category_id?: StringFieldUpdateOperationsInput | string
    business_user_id?: StringFieldUpdateOperationsInput | string
  }

  export type SubExpertiseModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    sub_category_id: string
    business_user_id: string
  }

  export type SubExpertiseModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubExpertiseModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_category_id?: StringFieldUpdateOperationsInput | string
    business_user_id?: StringFieldUpdateOperationsInput | string
  }

  export type REAgentModelCreateInput = {
    is_licensed: boolean
    re_num: string
    re_name: string
    re_phone: string
    re_licensed_agent_name: string
    base: BusinessUserModelCreateNestedOneWithoutRe_agentInput
    properties?: REProertyModelCreateNestedManyWithoutRe_agentInput
  }

  export type REAgentModelUncheckedCreateInput = {
    id: string
    is_licensed: boolean
    re_num: string
    re_name: string
    re_phone: string
    re_licensed_agent_name: string
    properties?: REProertyModelUncheckedCreateNestedManyWithoutRe_agentInput
  }

  export type REAgentModelUpdateInput = {
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    re_num?: StringFieldUpdateOperationsInput | string
    re_name?: StringFieldUpdateOperationsInput | string
    re_phone?: StringFieldUpdateOperationsInput | string
    re_licensed_agent_name?: StringFieldUpdateOperationsInput | string
    base?: BusinessUserModelUpdateOneRequiredWithoutRe_agentNestedInput
    properties?: REProertyModelUpdateManyWithoutRe_agentNestedInput
  }

  export type REAgentModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    re_num?: StringFieldUpdateOperationsInput | string
    re_name?: StringFieldUpdateOperationsInput | string
    re_phone?: StringFieldUpdateOperationsInput | string
    re_licensed_agent_name?: StringFieldUpdateOperationsInput | string
    properties?: REProertyModelUncheckedUpdateManyWithoutRe_agentNestedInput
  }

  export type REAgentModelCreateManyInput = {
    id: string
    is_licensed: boolean
    re_num: string
    re_name: string
    re_phone: string
    re_licensed_agent_name: string
  }

  export type REAgentModelUpdateManyMutationInput = {
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    re_num?: StringFieldUpdateOperationsInput | string
    re_name?: StringFieldUpdateOperationsInput | string
    re_phone?: StringFieldUpdateOperationsInput | string
    re_licensed_agent_name?: StringFieldUpdateOperationsInput | string
  }

  export type REAgentModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    re_num?: StringFieldUpdateOperationsInput | string
    re_name?: StringFieldUpdateOperationsInput | string
    re_phone?: StringFieldUpdateOperationsInput | string
    re_licensed_agent_name?: StringFieldUpdateOperationsInput | string
  }

  export type HSProviderModelCreateInput = {
    business_registration_num: string
    base: BusinessUserModelCreateNestedOneWithoutHs_providerInput
    introduction_images?: HSIntroductionImageModelCreateNestedManyWithoutHs_providerInput
  }

  export type HSProviderModelUncheckedCreateInput = {
    id: string
    business_registration_num: string
    introduction_images?: HSIntroductionImageModelUncheckedCreateNestedManyWithoutHs_providerInput
  }

  export type HSProviderModelUpdateInput = {
    business_registration_num?: StringFieldUpdateOperationsInput | string
    base?: BusinessUserModelUpdateOneRequiredWithoutHs_providerNestedInput
    introduction_images?: HSIntroductionImageModelUpdateManyWithoutHs_providerNestedInput
  }

  export type HSProviderModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    business_registration_num?: StringFieldUpdateOperationsInput | string
    introduction_images?: HSIntroductionImageModelUncheckedUpdateManyWithoutHs_providerNestedInput
  }

  export type HSProviderModelCreateManyInput = {
    id: string
    business_registration_num: string
  }

  export type HSProviderModelUpdateManyMutationInput = {
    business_registration_num?: StringFieldUpdateOperationsInput | string
  }

  export type HSProviderModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    business_registration_num?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessCertificationImageModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    url: string
    business_user: BusinessUserModelCreateNestedOneWithoutCertification_imagesInput
  }

  export type BusinessCertificationImageModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    business_user_id: string
    url: string
  }

  export type BusinessCertificationImageModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: StringFieldUpdateOperationsInput | string
    business_user?: BusinessUserModelUpdateOneRequiredWithoutCertification_imagesNestedInput
  }

  export type BusinessCertificationImageModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business_user_id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessCertificationImageModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    business_user_id: string
    url: string
  }

  export type BusinessCertificationImageModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessCertificationImageModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business_user_id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type HSIntroductionImageModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    url: string
    hs_provider: HSProviderModelCreateNestedOneWithoutIntroduction_imagesInput
  }

  export type HSIntroductionImageModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    hs_provider_id: string
    url: string
  }

  export type HSIntroductionImageModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: StringFieldUpdateOperationsInput | string
    hs_provider?: HSProviderModelUpdateOneRequiredWithoutIntroduction_imagesNestedInput
  }

  export type HSIntroductionImageModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hs_provider_id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type HSIntroductionImageModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    hs_provider_id: string
    url: string
  }

  export type HSIntroductionImageModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: StringFieldUpdateOperationsInput | string
  }

  export type HSIntroductionImageModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hs_provider_id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type OauthAccountModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    oauth_type: OauthType
    oauth_sub: string
    name?: string | null
    email?: string | null
    phone?: string | null
    profile_image_url?: string | null
    birth?: string | null
    gender?: GenderType | null
    address_first?: string | null
    address_second?: string | null
    business_user?: BusinessUserModelCreateNestedOneWithoutOauth_accountsInput
    customer?: CustomerModelCreateNestedOneWithoutOauth_accountsInput
  }

  export type OauthAccountModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    oauth_type: OauthType
    oauth_sub: string
    business_user_id?: string | null
    customer_id?: string | null
    name?: string | null
    email?: string | null
    phone?: string | null
    profile_image_url?: string | null
    birth?: string | null
    gender?: GenderType | null
    address_first?: string | null
    address_second?: string | null
  }

  export type OauthAccountModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauth_type?: EnumOauthTypeFieldUpdateOperationsInput | OauthType
    oauth_sub?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    business_user?: BusinessUserModelUpdateOneWithoutOauth_accountsNestedInput
    customer?: CustomerModelUpdateOneWithoutOauth_accountsNestedInput
  }

  export type OauthAccountModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauth_type?: EnumOauthTypeFieldUpdateOperationsInput | OauthType
    oauth_sub?: StringFieldUpdateOperationsInput | string
    business_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OauthAccountModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    oauth_type: OauthType
    oauth_sub: string
    business_user_id?: string | null
    customer_id?: string | null
    name?: string | null
    email?: string | null
    phone?: string | null
    profile_image_url?: string | null
    birth?: string | null
    gender?: GenderType | null
    address_first?: string | null
    address_second?: string | null
  }

  export type OauthAccountModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauth_type?: EnumOauthTypeFieldUpdateOperationsInput | OauthType
    oauth_sub?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OauthAccountModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauth_type?: EnumOauthTypeFieldUpdateOperationsInput | OauthType
    oauth_sub?: StringFieldUpdateOperationsInput | string
    business_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type REAgentModelRelationFilter = {
    is?: REAgentModelWhereInput | null
    isNot?: REAgentModelWhereInput | null
  }

  export type REPropertyCategoryModelListRelationFilter = {
    every?: REPropertyCategoryModelWhereInput
    some?: REPropertyCategoryModelWhereInput
    none?: REPropertyCategoryModelWhereInput
  }

  export type REPropertyCategoryModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type REProertyModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    main_image_url?: SortOrder
    re_agent_id?: SortOrder
  }

  export type REProertyModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    main_image_url?: SortOrder
    re_agent_id?: SortOrder
  }

  export type REProertyModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    main_image_url?: SortOrder
    re_agent_id?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type REProertyModelRelationFilter = {
    is?: REProertyModelWhereInput
    isNot?: REProertyModelWhereInput
  }

  export type REPropertySubCategoryModelRelationFilter = {
    is?: REPropertySubCategoryModelWhereInput
    isNot?: REPropertySubCategoryModelWhereInput
  }

  export type REPropertyCategoryModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    re_property_id?: SortOrder
    sub_category_id?: SortOrder
  }

  export type REPropertyCategoryModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    re_property_id?: SortOrder
    sub_category_id?: SortOrder
  }

  export type REPropertyCategoryModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    re_property_id?: SortOrder
    sub_category_id?: SortOrder
  }

  export type REPropertyMiddleCategoryModelRelationFilter = {
    is?: REPropertyMiddleCategoryModelWhereInput
    isNot?: REPropertyMiddleCategoryModelWhereInput
  }

  export type REPropertySubCategoryModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    middle_category_id?: SortOrder
  }

  export type REPropertySubCategoryModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    middle_category_id?: SortOrder
  }

  export type REPropertySubCategoryModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    middle_category_id?: SortOrder
  }

  export type REPropertySuperCategoryModelRelationFilter = {
    is?: REPropertySuperCategoryModelWhereInput
    isNot?: REPropertySuperCategoryModelWhereInput
  }

  export type REPropertySubCategoryModelListRelationFilter = {
    every?: REPropertySubCategoryModelWhereInput
    some?: REPropertySubCategoryModelWhereInput
    none?: REPropertySubCategoryModelWhereInput
  }

  export type REPropertySubCategoryModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type REPropertyMiddleCategoryModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    super_category_id?: SortOrder
  }

  export type REPropertyMiddleCategoryModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    super_category_id?: SortOrder
  }

  export type REPropertyMiddleCategoryModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    super_category_id?: SortOrder
  }

  export type REPropertyMiddleCategoryModelListRelationFilter = {
    every?: REPropertyMiddleCategoryModelWhereInput
    some?: REPropertyMiddleCategoryModelWhereInput
    none?: REPropertyMiddleCategoryModelWhereInput
  }

  export type REPropertyMiddleCategoryModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type REPropertySuperCategoryModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
  }

  export type REPropertySuperCategoryModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
  }

  export type REPropertySuperCategoryModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
  }

  export type CustomerModelRelationFilter = {
    is?: CustomerModelWhereInput | null
    isNot?: CustomerModelWhereInput | null
  }

  export type BusinessUserModelRelationFilter = {
    is?: BusinessUserModelWhereInput | null
    isNot?: BusinessUserModelWhereInput | null
  }

  export type RateModelListRelationFilter = {
    every?: RateModelWhereInput
    some?: RateModelWhereInput
    none?: RateModelWhereInput
  }

  export type RateModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    reviewer_id?: SortOrder
    reviewee_id?: SortOrder
    content?: SortOrder
  }

  export type ReviewModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    reviewer_id?: SortOrder
    reviewee_id?: SortOrder
    content?: SortOrder
  }

  export type ReviewModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    reviewer_id?: SortOrder
    reviewee_id?: SortOrder
    content?: SortOrder
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type RateCategoryModelRelationFilter = {
    is?: RateCategoryModelWhereInput
    isNot?: RateCategoryModelWhereInput
  }

  export type ReviewModelRelationFilter = {
    is?: ReviewModelWhereInput
    isNot?: ReviewModelWhereInput
  }

  export type RateModelCategory_idReview_idCompoundUniqueInput = {
    category_id: string
    review_id: string
  }

  export type RateModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    score?: SortOrder
    category_id?: SortOrder
    review_id?: SortOrder
  }

  export type RateModelAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type RateModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    score?: SortOrder
    category_id?: SortOrder
    review_id?: SortOrder
  }

  export type RateModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    score?: SortOrder
    category_id?: SortOrder
    review_id?: SortOrder
  }

  export type RateModelSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type EnumRateTargetTypeFilter = {
    equals?: RateTargetType
    in?: Enumerable<RateTargetType>
    notIn?: Enumerable<RateTargetType>
    not?: NestedEnumRateTargetTypeFilter | RateTargetType
  }

  export type RateCategoryModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    target_type?: SortOrder
  }

  export type RateCategoryModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    target_type?: SortOrder
  }

  export type RateCategoryModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    target_type?: SortOrder
  }

  export type EnumRateTargetTypeWithAggregatesFilter = {
    equals?: RateTargetType
    in?: Enumerable<RateTargetType>
    notIn?: Enumerable<RateTargetType>
    not?: NestedEnumRateTargetTypeWithAggregatesFilter | RateTargetType
    _count?: NestedIntFilter
    _min?: NestedEnumRateTargetTypeFilter
    _max?: NestedEnumRateTargetTypeFilter
  }

  export type EnumAgreementTargetTypeFilter = {
    equals?: AgreementTargetType
    in?: Enumerable<AgreementTargetType>
    notIn?: Enumerable<AgreementTargetType>
    not?: NestedEnumAgreementTargetTypeFilter | AgreementTargetType
  }

  export type AgreementAcceptanceModelListRelationFilter = {
    every?: AgreementAcceptanceModelWhereInput
    some?: AgreementAcceptanceModelWhereInput
    none?: AgreementAcceptanceModelWhereInput
  }

  export type AgreementAcceptanceModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgreementModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    title?: SortOrder
    content?: SortOrder
    is_required?: SortOrder
    target_type?: SortOrder
  }

  export type AgreementModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    title?: SortOrder
    content?: SortOrder
    is_required?: SortOrder
    target_type?: SortOrder
  }

  export type AgreementModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    title?: SortOrder
    content?: SortOrder
    is_required?: SortOrder
    target_type?: SortOrder
  }

  export type EnumAgreementTargetTypeWithAggregatesFilter = {
    equals?: AgreementTargetType
    in?: Enumerable<AgreementTargetType>
    notIn?: Enumerable<AgreementTargetType>
    not?: NestedEnumAgreementTargetTypeWithAggregatesFilter | AgreementTargetType
    _count?: NestedIntFilter
    _min?: NestedEnumAgreementTargetTypeFilter
    _max?: NestedEnumAgreementTargetTypeFilter
  }

  export type UserModelRelationFilter = {
    is?: UserModelWhereInput
    isNot?: UserModelWhereInput
  }

  export type AgreementModelRelationFilter = {
    is?: AgreementModelWhereInput
    isNot?: AgreementModelWhereInput
  }

  export type AgreementAcceptanceModelUser_idAgreement_idCompoundUniqueInput = {
    user_id: string
    agreement_id: string
  }

  export type AgreementAcceptanceModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    user_id?: SortOrder
    agreement_id?: SortOrder
  }

  export type AgreementAcceptanceModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    user_id?: SortOrder
    agreement_id?: SortOrder
  }

  export type AgreementAcceptanceModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    user_id?: SortOrder
    agreement_id?: SortOrder
  }

  export type FocusCareConsultationTimeCheckModelListRelationFilter = {
    every?: FocusCareConsultationTimeCheckModelWhereInput
    some?: FocusCareConsultationTimeCheckModelWhereInput
    none?: FocusCareConsultationTimeCheckModelWhereInput
  }

  export type FocusCareConsultationTimeCheckModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConsultationTimeModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type ConsultationTimeModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type ConsultationTimeModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type ServiceSuperCategoryModelRelationFilter = {
    is?: ServiceSuperCategoryModelWhereInput
    isNot?: ServiceSuperCategoryModelWhereInput
  }

  export type SubExpertiseModelListRelationFilter = {
    every?: SubExpertiseModelWhereInput
    some?: SubExpertiseModelWhereInput
    none?: SubExpertiseModelWhereInput
  }

  export type SubExpertiseModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceSubCategoryModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    super_category_id?: SortOrder
  }

  export type ServiceSubCategoryModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    super_category_id?: SortOrder
  }

  export type ServiceSubCategoryModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    super_category_id?: SortOrder
  }

  export type EnumServiceTypeFilter = {
    equals?: ServiceType
    in?: Enumerable<ServiceType>
    notIn?: Enumerable<ServiceType>
    not?: NestedEnumServiceTypeFilter | ServiceType
  }

  export type ServiceSubCategoryModelListRelationFilter = {
    every?: ServiceSubCategoryModelWhereInput
    some?: ServiceSubCategoryModelWhereInput
    none?: ServiceSubCategoryModelWhereInput
  }

  export type FocusCareServiceCheckModelListRelationFilter = {
    every?: FocusCareServiceCheckModelWhereInput
    some?: FocusCareServiceCheckModelWhereInput
    none?: FocusCareServiceCheckModelWhereInput
  }

  export type ServiceSubCategoryModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FocusCareServiceCheckModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceSuperCategoryModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type ServiceSuperCategoryModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type ServiceSuperCategoryModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type EnumServiceTypeWithAggregatesFilter = {
    equals?: ServiceType
    in?: Enumerable<ServiceType>
    notIn?: Enumerable<ServiceType>
    not?: NestedEnumServiceTypeWithAggregatesFilter | ServiceType
    _count?: NestedIntFilter
    _min?: NestedEnumServiceTypeFilter
    _max?: NestedEnumServiceTypeFilter
  }

  export type EnumFocusCareStatusFilter = {
    equals?: FocusCareStatus
    in?: Enumerable<FocusCareStatus>
    notIn?: Enumerable<FocusCareStatus>
    not?: NestedEnumFocusCareStatusFilter | FocusCareStatus
  }

  export type FocusCareRequestModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    care_start_date?: SortOrder
    care_end_date?: SortOrder
    detail?: SortOrder
    status?: SortOrder
    requester_id?: SortOrder
  }

  export type FocusCareRequestModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    care_start_date?: SortOrder
    care_end_date?: SortOrder
    detail?: SortOrder
    status?: SortOrder
    requester_id?: SortOrder
  }

  export type FocusCareRequestModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    care_start_date?: SortOrder
    care_end_date?: SortOrder
    detail?: SortOrder
    status?: SortOrder
    requester_id?: SortOrder
  }

  export type EnumFocusCareStatusWithAggregatesFilter = {
    equals?: FocusCareStatus
    in?: Enumerable<FocusCareStatus>
    notIn?: Enumerable<FocusCareStatus>
    not?: NestedEnumFocusCareStatusWithAggregatesFilter | FocusCareStatus
    _count?: NestedIntFilter
    _min?: NestedEnumFocusCareStatusFilter
    _max?: NestedEnumFocusCareStatusFilter
  }

  export type FocusCareRequestModelRelationFilter = {
    is?: FocusCareRequestModelWhereInput
    isNot?: FocusCareRequestModelWhereInput
  }

  export type FocusCareServiceCheckModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    service_super_category_id?: SortOrder
    request_id?: SortOrder
  }

  export type FocusCareServiceCheckModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    service_super_category_id?: SortOrder
    request_id?: SortOrder
  }

  export type FocusCareServiceCheckModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    service_super_category_id?: SortOrder
    request_id?: SortOrder
  }

  export type ConsultationTimeModelRelationFilter = {
    is?: ConsultationTimeModelWhereInput
    isNot?: ConsultationTimeModelWhereInput
  }

  export type FocusCareConsultationTimeCheckModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    consultation_time_id?: SortOrder
    request_id?: SortOrder
  }

  export type FocusCareConsultationTimeCheckModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    consultation_time_id?: SortOrder
    request_id?: SortOrder
  }

  export type FocusCareConsultationTimeCheckModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    consultation_time_id?: SortOrder
    request_id?: SortOrder
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type UserModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    email?: SortOrder
  }

  export type UserModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    email?: SortOrder
  }

  export type UserModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    email?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type EnumGenderTypeNullableFilter = {
    equals?: GenderType | null
    in?: Enumerable<GenderType> | null
    notIn?: Enumerable<GenderType> | null
    not?: NestedEnumGenderTypeNullableFilter | GenderType | null
  }

  export type OauthAccountModelListRelationFilter = {
    every?: OauthAccountModelWhereInput
    some?: OauthAccountModelWhereInput
    none?: OauthAccountModelWhereInput
  }

  export type ReviewModelListRelationFilter = {
    every?: ReviewModelWhereInput
    some?: ReviewModelWhereInput
    none?: ReviewModelWhereInput
  }

  export type FocusCareRequestModelListRelationFilter = {
    every?: FocusCareRequestModelWhereInput
    some?: FocusCareRequestModelWhereInput
    none?: FocusCareRequestModelWhereInput
  }

  export type OauthAccountModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FocusCareRequestModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerModelCountOrderByAggregateInput = {
    id?: SortOrder
    birth?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
    profile_image_url?: SortOrder
  }

  export type CustomerModelMaxOrderByAggregateInput = {
    id?: SortOrder
    birth?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
    profile_image_url?: SortOrder
  }

  export type CustomerModelMinOrderByAggregateInput = {
    id?: SortOrder
    birth?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
    profile_image_url?: SortOrder
  }

  export type EnumGenderTypeNullableWithAggregatesFilter = {
    equals?: GenderType | null
    in?: Enumerable<GenderType> | null
    notIn?: Enumerable<GenderType> | null
    not?: NestedEnumGenderTypeNullableWithAggregatesFilter | GenderType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumGenderTypeNullableFilter
    _max?: NestedEnumGenderTypeNullableFilter
  }

  export type HSProviderModelRelationFilter = {
    is?: HSProviderModelWhereInput
    isNot?: HSProviderModelWhereInput
  }

  export type BusinessCertificationImageModelListRelationFilter = {
    every?: BusinessCertificationImageModelWhereInput
    some?: BusinessCertificationImageModelWhereInput
    none?: BusinessCertificationImageModelWhereInput
  }

  export type BusinessCertificationImageModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessUserModelCountOrderByAggregateInput = {
    id?: SortOrder
    is_verified?: SortOrder
    introduction_title?: SortOrder
    introduction_content?: SortOrder
    phone?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
    profile_image_url?: SortOrder
  }

  export type BusinessUserModelMaxOrderByAggregateInput = {
    id?: SortOrder
    is_verified?: SortOrder
    introduction_title?: SortOrder
    introduction_content?: SortOrder
    phone?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
    profile_image_url?: SortOrder
  }

  export type BusinessUserModelMinOrderByAggregateInput = {
    id?: SortOrder
    is_verified?: SortOrder
    introduction_title?: SortOrder
    introduction_content?: SortOrder
    phone?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
    profile_image_url?: SortOrder
  }

  export type ServiceSubCategoryModelRelationFilter = {
    is?: ServiceSubCategoryModelWhereInput
    isNot?: ServiceSubCategoryModelWhereInput
  }

  export type SubExpertiseModelSub_category_idBusiness_user_idCompoundUniqueInput = {
    sub_category_id: string
    business_user_id: string
  }

  export type SubExpertiseModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    sub_category_id?: SortOrder
    business_user_id?: SortOrder
  }

  export type SubExpertiseModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    sub_category_id?: SortOrder
    business_user_id?: SortOrder
  }

  export type SubExpertiseModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    sub_category_id?: SortOrder
    business_user_id?: SortOrder
  }

  export type REProertyModelListRelationFilter = {
    every?: REProertyModelWhereInput
    some?: REProertyModelWhereInput
    none?: REProertyModelWhereInput
  }

  export type REProertyModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type REAgentModelCountOrderByAggregateInput = {
    id?: SortOrder
    is_licensed?: SortOrder
    re_num?: SortOrder
    re_name?: SortOrder
    re_phone?: SortOrder
    re_licensed_agent_name?: SortOrder
  }

  export type REAgentModelMaxOrderByAggregateInput = {
    id?: SortOrder
    is_licensed?: SortOrder
    re_num?: SortOrder
    re_name?: SortOrder
    re_phone?: SortOrder
    re_licensed_agent_name?: SortOrder
  }

  export type REAgentModelMinOrderByAggregateInput = {
    id?: SortOrder
    is_licensed?: SortOrder
    re_num?: SortOrder
    re_name?: SortOrder
    re_phone?: SortOrder
    re_licensed_agent_name?: SortOrder
  }

  export type HSIntroductionImageModelListRelationFilter = {
    every?: HSIntroductionImageModelWhereInput
    some?: HSIntroductionImageModelWhereInput
    none?: HSIntroductionImageModelWhereInput
  }

  export type HSIntroductionImageModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HSProviderModelCountOrderByAggregateInput = {
    id?: SortOrder
    business_registration_num?: SortOrder
  }

  export type HSProviderModelMaxOrderByAggregateInput = {
    id?: SortOrder
    business_registration_num?: SortOrder
  }

  export type HSProviderModelMinOrderByAggregateInput = {
    id?: SortOrder
    business_registration_num?: SortOrder
  }

  export type BusinessCertificationImageModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    business_user_id?: SortOrder
    url?: SortOrder
  }

  export type BusinessCertificationImageModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    business_user_id?: SortOrder
    url?: SortOrder
  }

  export type BusinessCertificationImageModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    business_user_id?: SortOrder
    url?: SortOrder
  }

  export type HSIntroductionImageModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    hs_provider_id?: SortOrder
    url?: SortOrder
  }

  export type HSIntroductionImageModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    hs_provider_id?: SortOrder
    url?: SortOrder
  }

  export type HSIntroductionImageModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    hs_provider_id?: SortOrder
    url?: SortOrder
  }

  export type EnumOauthTypeFilter = {
    equals?: OauthType
    in?: Enumerable<OauthType>
    notIn?: Enumerable<OauthType>
    not?: NestedEnumOauthTypeFilter | OauthType
  }

  export type OauthAccountModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    oauth_type?: SortOrder
    oauth_sub?: SortOrder
    business_user_id?: SortOrder
    customer_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    profile_image_url?: SortOrder
    birth?: SortOrder
    gender?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
  }

  export type OauthAccountModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    oauth_type?: SortOrder
    oauth_sub?: SortOrder
    business_user_id?: SortOrder
    customer_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    profile_image_url?: SortOrder
    birth?: SortOrder
    gender?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
  }

  export type OauthAccountModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    oauth_type?: SortOrder
    oauth_sub?: SortOrder
    business_user_id?: SortOrder
    customer_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    profile_image_url?: SortOrder
    birth?: SortOrder
    gender?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
  }

  export type EnumOauthTypeWithAggregatesFilter = {
    equals?: OauthType
    in?: Enumerable<OauthType>
    notIn?: Enumerable<OauthType>
    not?: NestedEnumOauthTypeWithAggregatesFilter | OauthType
    _count?: NestedIntFilter
    _min?: NestedEnumOauthTypeFilter
    _max?: NestedEnumOauthTypeFilter
  }

  export type REAgentModelCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<REAgentModelCreateWithoutPropertiesInput, REAgentModelUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: REAgentModelCreateOrConnectWithoutPropertiesInput
    connect?: REAgentModelWhereUniqueInput
  }

  export type REPropertyCategoryModelCreateNestedManyWithoutRe_propertyInput = {
    create?: XOR<Enumerable<REPropertyCategoryModelCreateWithoutRe_propertyInput>, Enumerable<REPropertyCategoryModelUncheckedCreateWithoutRe_propertyInput>>
    connectOrCreate?: Enumerable<REPropertyCategoryModelCreateOrConnectWithoutRe_propertyInput>
    createMany?: REPropertyCategoryModelCreateManyRe_propertyInputEnvelope
    connect?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
  }

  export type REPropertyCategoryModelUncheckedCreateNestedManyWithoutRe_propertyInput = {
    create?: XOR<Enumerable<REPropertyCategoryModelCreateWithoutRe_propertyInput>, Enumerable<REPropertyCategoryModelUncheckedCreateWithoutRe_propertyInput>>
    connectOrCreate?: Enumerable<REPropertyCategoryModelCreateOrConnectWithoutRe_propertyInput>
    createMany?: REPropertyCategoryModelCreateManyRe_propertyInputEnvelope
    connect?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type REAgentModelUpdateOneRequiredWithoutPropertiesNestedInput = {
    create?: XOR<REAgentModelCreateWithoutPropertiesInput, REAgentModelUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: REAgentModelCreateOrConnectWithoutPropertiesInput
    upsert?: REAgentModelUpsertWithoutPropertiesInput
    connect?: REAgentModelWhereUniqueInput
    update?: XOR<REAgentModelUpdateWithoutPropertiesInput, REAgentModelUncheckedUpdateWithoutPropertiesInput>
  }

  export type REPropertyCategoryModelUpdateManyWithoutRe_propertyNestedInput = {
    create?: XOR<Enumerable<REPropertyCategoryModelCreateWithoutRe_propertyInput>, Enumerable<REPropertyCategoryModelUncheckedCreateWithoutRe_propertyInput>>
    connectOrCreate?: Enumerable<REPropertyCategoryModelCreateOrConnectWithoutRe_propertyInput>
    upsert?: Enumerable<REPropertyCategoryModelUpsertWithWhereUniqueWithoutRe_propertyInput>
    createMany?: REPropertyCategoryModelCreateManyRe_propertyInputEnvelope
    set?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    disconnect?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    delete?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    connect?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    update?: Enumerable<REPropertyCategoryModelUpdateWithWhereUniqueWithoutRe_propertyInput>
    updateMany?: Enumerable<REPropertyCategoryModelUpdateManyWithWhereWithoutRe_propertyInput>
    deleteMany?: Enumerable<REPropertyCategoryModelScalarWhereInput>
  }

  export type REPropertyCategoryModelUncheckedUpdateManyWithoutRe_propertyNestedInput = {
    create?: XOR<Enumerable<REPropertyCategoryModelCreateWithoutRe_propertyInput>, Enumerable<REPropertyCategoryModelUncheckedCreateWithoutRe_propertyInput>>
    connectOrCreate?: Enumerable<REPropertyCategoryModelCreateOrConnectWithoutRe_propertyInput>
    upsert?: Enumerable<REPropertyCategoryModelUpsertWithWhereUniqueWithoutRe_propertyInput>
    createMany?: REPropertyCategoryModelCreateManyRe_propertyInputEnvelope
    set?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    disconnect?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    delete?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    connect?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    update?: Enumerable<REPropertyCategoryModelUpdateWithWhereUniqueWithoutRe_propertyInput>
    updateMany?: Enumerable<REPropertyCategoryModelUpdateManyWithWhereWithoutRe_propertyInput>
    deleteMany?: Enumerable<REPropertyCategoryModelScalarWhereInput>
  }

  export type REProertyModelCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<REProertyModelCreateWithoutCategoriesInput, REProertyModelUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: REProertyModelCreateOrConnectWithoutCategoriesInput
    connect?: REProertyModelWhereUniqueInput
  }

  export type REPropertySubCategoryModelCreateNestedOneWithoutProperty_categoriesInput = {
    create?: XOR<REPropertySubCategoryModelCreateWithoutProperty_categoriesInput, REPropertySubCategoryModelUncheckedCreateWithoutProperty_categoriesInput>
    connectOrCreate?: REPropertySubCategoryModelCreateOrConnectWithoutProperty_categoriesInput
    connect?: REPropertySubCategoryModelWhereUniqueInput
  }

  export type REProertyModelUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<REProertyModelCreateWithoutCategoriesInput, REProertyModelUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: REProertyModelCreateOrConnectWithoutCategoriesInput
    upsert?: REProertyModelUpsertWithoutCategoriesInput
    connect?: REProertyModelWhereUniqueInput
    update?: XOR<REProertyModelUpdateWithoutCategoriesInput, REProertyModelUncheckedUpdateWithoutCategoriesInput>
  }

  export type REPropertySubCategoryModelUpdateOneRequiredWithoutProperty_categoriesNestedInput = {
    create?: XOR<REPropertySubCategoryModelCreateWithoutProperty_categoriesInput, REPropertySubCategoryModelUncheckedCreateWithoutProperty_categoriesInput>
    connectOrCreate?: REPropertySubCategoryModelCreateOrConnectWithoutProperty_categoriesInput
    upsert?: REPropertySubCategoryModelUpsertWithoutProperty_categoriesInput
    connect?: REPropertySubCategoryModelWhereUniqueInput
    update?: XOR<REPropertySubCategoryModelUpdateWithoutProperty_categoriesInput, REPropertySubCategoryModelUncheckedUpdateWithoutProperty_categoriesInput>
  }

  export type REPropertyMiddleCategoryModelCreateNestedOneWithoutSub_categoriesInput = {
    create?: XOR<REPropertyMiddleCategoryModelCreateWithoutSub_categoriesInput, REPropertyMiddleCategoryModelUncheckedCreateWithoutSub_categoriesInput>
    connectOrCreate?: REPropertyMiddleCategoryModelCreateOrConnectWithoutSub_categoriesInput
    connect?: REPropertyMiddleCategoryModelWhereUniqueInput
  }

  export type REPropertyCategoryModelCreateNestedManyWithoutSub_categoryInput = {
    create?: XOR<Enumerable<REPropertyCategoryModelCreateWithoutSub_categoryInput>, Enumerable<REPropertyCategoryModelUncheckedCreateWithoutSub_categoryInput>>
    connectOrCreate?: Enumerable<REPropertyCategoryModelCreateOrConnectWithoutSub_categoryInput>
    createMany?: REPropertyCategoryModelCreateManySub_categoryInputEnvelope
    connect?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
  }

  export type REPropertyCategoryModelUncheckedCreateNestedManyWithoutSub_categoryInput = {
    create?: XOR<Enumerable<REPropertyCategoryModelCreateWithoutSub_categoryInput>, Enumerable<REPropertyCategoryModelUncheckedCreateWithoutSub_categoryInput>>
    connectOrCreate?: Enumerable<REPropertyCategoryModelCreateOrConnectWithoutSub_categoryInput>
    createMany?: REPropertyCategoryModelCreateManySub_categoryInputEnvelope
    connect?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
  }

  export type REPropertyMiddleCategoryModelUpdateOneRequiredWithoutSub_categoriesNestedInput = {
    create?: XOR<REPropertyMiddleCategoryModelCreateWithoutSub_categoriesInput, REPropertyMiddleCategoryModelUncheckedCreateWithoutSub_categoriesInput>
    connectOrCreate?: REPropertyMiddleCategoryModelCreateOrConnectWithoutSub_categoriesInput
    upsert?: REPropertyMiddleCategoryModelUpsertWithoutSub_categoriesInput
    connect?: REPropertyMiddleCategoryModelWhereUniqueInput
    update?: XOR<REPropertyMiddleCategoryModelUpdateWithoutSub_categoriesInput, REPropertyMiddleCategoryModelUncheckedUpdateWithoutSub_categoriesInput>
  }

  export type REPropertyCategoryModelUpdateManyWithoutSub_categoryNestedInput = {
    create?: XOR<Enumerable<REPropertyCategoryModelCreateWithoutSub_categoryInput>, Enumerable<REPropertyCategoryModelUncheckedCreateWithoutSub_categoryInput>>
    connectOrCreate?: Enumerable<REPropertyCategoryModelCreateOrConnectWithoutSub_categoryInput>
    upsert?: Enumerable<REPropertyCategoryModelUpsertWithWhereUniqueWithoutSub_categoryInput>
    createMany?: REPropertyCategoryModelCreateManySub_categoryInputEnvelope
    set?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    disconnect?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    delete?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    connect?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    update?: Enumerable<REPropertyCategoryModelUpdateWithWhereUniqueWithoutSub_categoryInput>
    updateMany?: Enumerable<REPropertyCategoryModelUpdateManyWithWhereWithoutSub_categoryInput>
    deleteMany?: Enumerable<REPropertyCategoryModelScalarWhereInput>
  }

  export type REPropertyCategoryModelUncheckedUpdateManyWithoutSub_categoryNestedInput = {
    create?: XOR<Enumerable<REPropertyCategoryModelCreateWithoutSub_categoryInput>, Enumerable<REPropertyCategoryModelUncheckedCreateWithoutSub_categoryInput>>
    connectOrCreate?: Enumerable<REPropertyCategoryModelCreateOrConnectWithoutSub_categoryInput>
    upsert?: Enumerable<REPropertyCategoryModelUpsertWithWhereUniqueWithoutSub_categoryInput>
    createMany?: REPropertyCategoryModelCreateManySub_categoryInputEnvelope
    set?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    disconnect?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    delete?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    connect?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    update?: Enumerable<REPropertyCategoryModelUpdateWithWhereUniqueWithoutSub_categoryInput>
    updateMany?: Enumerable<REPropertyCategoryModelUpdateManyWithWhereWithoutSub_categoryInput>
    deleteMany?: Enumerable<REPropertyCategoryModelScalarWhereInput>
  }

  export type REPropertySuperCategoryModelCreateNestedOneWithoutMiddle_categoriesInput = {
    create?: XOR<REPropertySuperCategoryModelCreateWithoutMiddle_categoriesInput, REPropertySuperCategoryModelUncheckedCreateWithoutMiddle_categoriesInput>
    connectOrCreate?: REPropertySuperCategoryModelCreateOrConnectWithoutMiddle_categoriesInput
    connect?: REPropertySuperCategoryModelWhereUniqueInput
  }

  export type REPropertySubCategoryModelCreateNestedManyWithoutMiddle_categoryInput = {
    create?: XOR<Enumerable<REPropertySubCategoryModelCreateWithoutMiddle_categoryInput>, Enumerable<REPropertySubCategoryModelUncheckedCreateWithoutMiddle_categoryInput>>
    connectOrCreate?: Enumerable<REPropertySubCategoryModelCreateOrConnectWithoutMiddle_categoryInput>
    createMany?: REPropertySubCategoryModelCreateManyMiddle_categoryInputEnvelope
    connect?: Enumerable<REPropertySubCategoryModelWhereUniqueInput>
  }

  export type REPropertySubCategoryModelUncheckedCreateNestedManyWithoutMiddle_categoryInput = {
    create?: XOR<Enumerable<REPropertySubCategoryModelCreateWithoutMiddle_categoryInput>, Enumerable<REPropertySubCategoryModelUncheckedCreateWithoutMiddle_categoryInput>>
    connectOrCreate?: Enumerable<REPropertySubCategoryModelCreateOrConnectWithoutMiddle_categoryInput>
    createMany?: REPropertySubCategoryModelCreateManyMiddle_categoryInputEnvelope
    connect?: Enumerable<REPropertySubCategoryModelWhereUniqueInput>
  }

  export type REPropertySuperCategoryModelUpdateOneRequiredWithoutMiddle_categoriesNestedInput = {
    create?: XOR<REPropertySuperCategoryModelCreateWithoutMiddle_categoriesInput, REPropertySuperCategoryModelUncheckedCreateWithoutMiddle_categoriesInput>
    connectOrCreate?: REPropertySuperCategoryModelCreateOrConnectWithoutMiddle_categoriesInput
    upsert?: REPropertySuperCategoryModelUpsertWithoutMiddle_categoriesInput
    connect?: REPropertySuperCategoryModelWhereUniqueInput
    update?: XOR<REPropertySuperCategoryModelUpdateWithoutMiddle_categoriesInput, REPropertySuperCategoryModelUncheckedUpdateWithoutMiddle_categoriesInput>
  }

  export type REPropertySubCategoryModelUpdateManyWithoutMiddle_categoryNestedInput = {
    create?: XOR<Enumerable<REPropertySubCategoryModelCreateWithoutMiddle_categoryInput>, Enumerable<REPropertySubCategoryModelUncheckedCreateWithoutMiddle_categoryInput>>
    connectOrCreate?: Enumerable<REPropertySubCategoryModelCreateOrConnectWithoutMiddle_categoryInput>
    upsert?: Enumerable<REPropertySubCategoryModelUpsertWithWhereUniqueWithoutMiddle_categoryInput>
    createMany?: REPropertySubCategoryModelCreateManyMiddle_categoryInputEnvelope
    set?: Enumerable<REPropertySubCategoryModelWhereUniqueInput>
    disconnect?: Enumerable<REPropertySubCategoryModelWhereUniqueInput>
    delete?: Enumerable<REPropertySubCategoryModelWhereUniqueInput>
    connect?: Enumerable<REPropertySubCategoryModelWhereUniqueInput>
    update?: Enumerable<REPropertySubCategoryModelUpdateWithWhereUniqueWithoutMiddle_categoryInput>
    updateMany?: Enumerable<REPropertySubCategoryModelUpdateManyWithWhereWithoutMiddle_categoryInput>
    deleteMany?: Enumerable<REPropertySubCategoryModelScalarWhereInput>
  }

  export type REPropertySubCategoryModelUncheckedUpdateManyWithoutMiddle_categoryNestedInput = {
    create?: XOR<Enumerable<REPropertySubCategoryModelCreateWithoutMiddle_categoryInput>, Enumerable<REPropertySubCategoryModelUncheckedCreateWithoutMiddle_categoryInput>>
    connectOrCreate?: Enumerable<REPropertySubCategoryModelCreateOrConnectWithoutMiddle_categoryInput>
    upsert?: Enumerable<REPropertySubCategoryModelUpsertWithWhereUniqueWithoutMiddle_categoryInput>
    createMany?: REPropertySubCategoryModelCreateManyMiddle_categoryInputEnvelope
    set?: Enumerable<REPropertySubCategoryModelWhereUniqueInput>
    disconnect?: Enumerable<REPropertySubCategoryModelWhereUniqueInput>
    delete?: Enumerable<REPropertySubCategoryModelWhereUniqueInput>
    connect?: Enumerable<REPropertySubCategoryModelWhereUniqueInput>
    update?: Enumerable<REPropertySubCategoryModelUpdateWithWhereUniqueWithoutMiddle_categoryInput>
    updateMany?: Enumerable<REPropertySubCategoryModelUpdateManyWithWhereWithoutMiddle_categoryInput>
    deleteMany?: Enumerable<REPropertySubCategoryModelScalarWhereInput>
  }

  export type REPropertyMiddleCategoryModelCreateNestedManyWithoutSuper_categoryInput = {
    create?: XOR<Enumerable<REPropertyMiddleCategoryModelCreateWithoutSuper_categoryInput>, Enumerable<REPropertyMiddleCategoryModelUncheckedCreateWithoutSuper_categoryInput>>
    connectOrCreate?: Enumerable<REPropertyMiddleCategoryModelCreateOrConnectWithoutSuper_categoryInput>
    createMany?: REPropertyMiddleCategoryModelCreateManySuper_categoryInputEnvelope
    connect?: Enumerable<REPropertyMiddleCategoryModelWhereUniqueInput>
  }

  export type REPropertyMiddleCategoryModelUncheckedCreateNestedManyWithoutSuper_categoryInput = {
    create?: XOR<Enumerable<REPropertyMiddleCategoryModelCreateWithoutSuper_categoryInput>, Enumerable<REPropertyMiddleCategoryModelUncheckedCreateWithoutSuper_categoryInput>>
    connectOrCreate?: Enumerable<REPropertyMiddleCategoryModelCreateOrConnectWithoutSuper_categoryInput>
    createMany?: REPropertyMiddleCategoryModelCreateManySuper_categoryInputEnvelope
    connect?: Enumerable<REPropertyMiddleCategoryModelWhereUniqueInput>
  }

  export type REPropertyMiddleCategoryModelUpdateManyWithoutSuper_categoryNestedInput = {
    create?: XOR<Enumerable<REPropertyMiddleCategoryModelCreateWithoutSuper_categoryInput>, Enumerable<REPropertyMiddleCategoryModelUncheckedCreateWithoutSuper_categoryInput>>
    connectOrCreate?: Enumerable<REPropertyMiddleCategoryModelCreateOrConnectWithoutSuper_categoryInput>
    upsert?: Enumerable<REPropertyMiddleCategoryModelUpsertWithWhereUniqueWithoutSuper_categoryInput>
    createMany?: REPropertyMiddleCategoryModelCreateManySuper_categoryInputEnvelope
    set?: Enumerable<REPropertyMiddleCategoryModelWhereUniqueInput>
    disconnect?: Enumerable<REPropertyMiddleCategoryModelWhereUniqueInput>
    delete?: Enumerable<REPropertyMiddleCategoryModelWhereUniqueInput>
    connect?: Enumerable<REPropertyMiddleCategoryModelWhereUniqueInput>
    update?: Enumerable<REPropertyMiddleCategoryModelUpdateWithWhereUniqueWithoutSuper_categoryInput>
    updateMany?: Enumerable<REPropertyMiddleCategoryModelUpdateManyWithWhereWithoutSuper_categoryInput>
    deleteMany?: Enumerable<REPropertyMiddleCategoryModelScalarWhereInput>
  }

  export type REPropertyMiddleCategoryModelUncheckedUpdateManyWithoutSuper_categoryNestedInput = {
    create?: XOR<Enumerable<REPropertyMiddleCategoryModelCreateWithoutSuper_categoryInput>, Enumerable<REPropertyMiddleCategoryModelUncheckedCreateWithoutSuper_categoryInput>>
    connectOrCreate?: Enumerable<REPropertyMiddleCategoryModelCreateOrConnectWithoutSuper_categoryInput>
    upsert?: Enumerable<REPropertyMiddleCategoryModelUpsertWithWhereUniqueWithoutSuper_categoryInput>
    createMany?: REPropertyMiddleCategoryModelCreateManySuper_categoryInputEnvelope
    set?: Enumerable<REPropertyMiddleCategoryModelWhereUniqueInput>
    disconnect?: Enumerable<REPropertyMiddleCategoryModelWhereUniqueInput>
    delete?: Enumerable<REPropertyMiddleCategoryModelWhereUniqueInput>
    connect?: Enumerable<REPropertyMiddleCategoryModelWhereUniqueInput>
    update?: Enumerable<REPropertyMiddleCategoryModelUpdateWithWhereUniqueWithoutSuper_categoryInput>
    updateMany?: Enumerable<REPropertyMiddleCategoryModelUpdateManyWithWhereWithoutSuper_categoryInput>
    deleteMany?: Enumerable<REPropertyMiddleCategoryModelScalarWhereInput>
  }

  export type CustomerModelCreateNestedOneWithoutReviewsInput = {
    create?: XOR<CustomerModelCreateWithoutReviewsInput, CustomerModelUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutReviewsInput
    connect?: CustomerModelWhereUniqueInput
  }

  export type BusinessUserModelCreateNestedOneWithoutReviewsInput = {
    create?: XOR<BusinessUserModelCreateWithoutReviewsInput, BusinessUserModelUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutReviewsInput
    connect?: BusinessUserModelWhereUniqueInput
  }

  export type RateModelCreateNestedManyWithoutReviewInput = {
    create?: XOR<Enumerable<RateModelCreateWithoutReviewInput>, Enumerable<RateModelUncheckedCreateWithoutReviewInput>>
    connectOrCreate?: Enumerable<RateModelCreateOrConnectWithoutReviewInput>
    createMany?: RateModelCreateManyReviewInputEnvelope
    connect?: Enumerable<RateModelWhereUniqueInput>
  }

  export type RateModelUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<Enumerable<RateModelCreateWithoutReviewInput>, Enumerable<RateModelUncheckedCreateWithoutReviewInput>>
    connectOrCreate?: Enumerable<RateModelCreateOrConnectWithoutReviewInput>
    createMany?: RateModelCreateManyReviewInputEnvelope
    connect?: Enumerable<RateModelWhereUniqueInput>
  }

  export type CustomerModelUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<CustomerModelCreateWithoutReviewsInput, CustomerModelUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutReviewsInput
    upsert?: CustomerModelUpsertWithoutReviewsInput
    connect?: CustomerModelWhereUniqueInput
    update?: XOR<CustomerModelUpdateWithoutReviewsInput, CustomerModelUncheckedUpdateWithoutReviewsInput>
  }

  export type BusinessUserModelUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<BusinessUserModelCreateWithoutReviewsInput, BusinessUserModelUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutReviewsInput
    upsert?: BusinessUserModelUpsertWithoutReviewsInput
    connect?: BusinessUserModelWhereUniqueInput
    update?: XOR<BusinessUserModelUpdateWithoutReviewsInput, BusinessUserModelUncheckedUpdateWithoutReviewsInput>
  }

  export type RateModelUpdateManyWithoutReviewNestedInput = {
    create?: XOR<Enumerable<RateModelCreateWithoutReviewInput>, Enumerable<RateModelUncheckedCreateWithoutReviewInput>>
    connectOrCreate?: Enumerable<RateModelCreateOrConnectWithoutReviewInput>
    upsert?: Enumerable<RateModelUpsertWithWhereUniqueWithoutReviewInput>
    createMany?: RateModelCreateManyReviewInputEnvelope
    set?: Enumerable<RateModelWhereUniqueInput>
    disconnect?: Enumerable<RateModelWhereUniqueInput>
    delete?: Enumerable<RateModelWhereUniqueInput>
    connect?: Enumerable<RateModelWhereUniqueInput>
    update?: Enumerable<RateModelUpdateWithWhereUniqueWithoutReviewInput>
    updateMany?: Enumerable<RateModelUpdateManyWithWhereWithoutReviewInput>
    deleteMany?: Enumerable<RateModelScalarWhereInput>
  }

  export type RateModelUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<Enumerable<RateModelCreateWithoutReviewInput>, Enumerable<RateModelUncheckedCreateWithoutReviewInput>>
    connectOrCreate?: Enumerable<RateModelCreateOrConnectWithoutReviewInput>
    upsert?: Enumerable<RateModelUpsertWithWhereUniqueWithoutReviewInput>
    createMany?: RateModelCreateManyReviewInputEnvelope
    set?: Enumerable<RateModelWhereUniqueInput>
    disconnect?: Enumerable<RateModelWhereUniqueInput>
    delete?: Enumerable<RateModelWhereUniqueInput>
    connect?: Enumerable<RateModelWhereUniqueInput>
    update?: Enumerable<RateModelUpdateWithWhereUniqueWithoutReviewInput>
    updateMany?: Enumerable<RateModelUpdateManyWithWhereWithoutReviewInput>
    deleteMany?: Enumerable<RateModelScalarWhereInput>
  }

  export type RateCategoryModelCreateNestedOneWithoutRatesInput = {
    create?: XOR<RateCategoryModelCreateWithoutRatesInput, RateCategoryModelUncheckedCreateWithoutRatesInput>
    connectOrCreate?: RateCategoryModelCreateOrConnectWithoutRatesInput
    connect?: RateCategoryModelWhereUniqueInput
  }

  export type ReviewModelCreateNestedOneWithoutRatesInput = {
    create?: XOR<ReviewModelCreateWithoutRatesInput, ReviewModelUncheckedCreateWithoutRatesInput>
    connectOrCreate?: ReviewModelCreateOrConnectWithoutRatesInput
    connect?: ReviewModelWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RateCategoryModelUpdateOneRequiredWithoutRatesNestedInput = {
    create?: XOR<RateCategoryModelCreateWithoutRatesInput, RateCategoryModelUncheckedCreateWithoutRatesInput>
    connectOrCreate?: RateCategoryModelCreateOrConnectWithoutRatesInput
    upsert?: RateCategoryModelUpsertWithoutRatesInput
    connect?: RateCategoryModelWhereUniqueInput
    update?: XOR<RateCategoryModelUpdateWithoutRatesInput, RateCategoryModelUncheckedUpdateWithoutRatesInput>
  }

  export type ReviewModelUpdateOneRequiredWithoutRatesNestedInput = {
    create?: XOR<ReviewModelCreateWithoutRatesInput, ReviewModelUncheckedCreateWithoutRatesInput>
    connectOrCreate?: ReviewModelCreateOrConnectWithoutRatesInput
    upsert?: ReviewModelUpsertWithoutRatesInput
    connect?: ReviewModelWhereUniqueInput
    update?: XOR<ReviewModelUpdateWithoutRatesInput, ReviewModelUncheckedUpdateWithoutRatesInput>
  }

  export type RateModelCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<RateModelCreateWithoutCategoryInput>, Enumerable<RateModelUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<RateModelCreateOrConnectWithoutCategoryInput>
    createMany?: RateModelCreateManyCategoryInputEnvelope
    connect?: Enumerable<RateModelWhereUniqueInput>
  }

  export type RateModelUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<RateModelCreateWithoutCategoryInput>, Enumerable<RateModelUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<RateModelCreateOrConnectWithoutCategoryInput>
    createMany?: RateModelCreateManyCategoryInputEnvelope
    connect?: Enumerable<RateModelWhereUniqueInput>
  }

  export type EnumRateTargetTypeFieldUpdateOperationsInput = {
    set?: RateTargetType
  }

  export type RateModelUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<RateModelCreateWithoutCategoryInput>, Enumerable<RateModelUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<RateModelCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<RateModelUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: RateModelCreateManyCategoryInputEnvelope
    set?: Enumerable<RateModelWhereUniqueInput>
    disconnect?: Enumerable<RateModelWhereUniqueInput>
    delete?: Enumerable<RateModelWhereUniqueInput>
    connect?: Enumerable<RateModelWhereUniqueInput>
    update?: Enumerable<RateModelUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<RateModelUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<RateModelScalarWhereInput>
  }

  export type RateModelUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<RateModelCreateWithoutCategoryInput>, Enumerable<RateModelUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<RateModelCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<RateModelUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: RateModelCreateManyCategoryInputEnvelope
    set?: Enumerable<RateModelWhereUniqueInput>
    disconnect?: Enumerable<RateModelWhereUniqueInput>
    delete?: Enumerable<RateModelWhereUniqueInput>
    connect?: Enumerable<RateModelWhereUniqueInput>
    update?: Enumerable<RateModelUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<RateModelUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<RateModelScalarWhereInput>
  }

  export type AgreementAcceptanceModelCreateNestedManyWithoutAgreementInput = {
    create?: XOR<Enumerable<AgreementAcceptanceModelCreateWithoutAgreementInput>, Enumerable<AgreementAcceptanceModelUncheckedCreateWithoutAgreementInput>>
    connectOrCreate?: Enumerable<AgreementAcceptanceModelCreateOrConnectWithoutAgreementInput>
    createMany?: AgreementAcceptanceModelCreateManyAgreementInputEnvelope
    connect?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
  }

  export type AgreementAcceptanceModelUncheckedCreateNestedManyWithoutAgreementInput = {
    create?: XOR<Enumerable<AgreementAcceptanceModelCreateWithoutAgreementInput>, Enumerable<AgreementAcceptanceModelUncheckedCreateWithoutAgreementInput>>
    connectOrCreate?: Enumerable<AgreementAcceptanceModelCreateOrConnectWithoutAgreementInput>
    createMany?: AgreementAcceptanceModelCreateManyAgreementInputEnvelope
    connect?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
  }

  export type EnumAgreementTargetTypeFieldUpdateOperationsInput = {
    set?: AgreementTargetType
  }

  export type AgreementAcceptanceModelUpdateManyWithoutAgreementNestedInput = {
    create?: XOR<Enumerable<AgreementAcceptanceModelCreateWithoutAgreementInput>, Enumerable<AgreementAcceptanceModelUncheckedCreateWithoutAgreementInput>>
    connectOrCreate?: Enumerable<AgreementAcceptanceModelCreateOrConnectWithoutAgreementInput>
    upsert?: Enumerable<AgreementAcceptanceModelUpsertWithWhereUniqueWithoutAgreementInput>
    createMany?: AgreementAcceptanceModelCreateManyAgreementInputEnvelope
    set?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    disconnect?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    delete?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    connect?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    update?: Enumerable<AgreementAcceptanceModelUpdateWithWhereUniqueWithoutAgreementInput>
    updateMany?: Enumerable<AgreementAcceptanceModelUpdateManyWithWhereWithoutAgreementInput>
    deleteMany?: Enumerable<AgreementAcceptanceModelScalarWhereInput>
  }

  export type AgreementAcceptanceModelUncheckedUpdateManyWithoutAgreementNestedInput = {
    create?: XOR<Enumerable<AgreementAcceptanceModelCreateWithoutAgreementInput>, Enumerable<AgreementAcceptanceModelUncheckedCreateWithoutAgreementInput>>
    connectOrCreate?: Enumerable<AgreementAcceptanceModelCreateOrConnectWithoutAgreementInput>
    upsert?: Enumerable<AgreementAcceptanceModelUpsertWithWhereUniqueWithoutAgreementInput>
    createMany?: AgreementAcceptanceModelCreateManyAgreementInputEnvelope
    set?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    disconnect?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    delete?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    connect?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    update?: Enumerable<AgreementAcceptanceModelUpdateWithWhereUniqueWithoutAgreementInput>
    updateMany?: Enumerable<AgreementAcceptanceModelUpdateManyWithWhereWithoutAgreementInput>
    deleteMany?: Enumerable<AgreementAcceptanceModelScalarWhereInput>
  }

  export type UserModelCreateNestedOneWithoutAgreement_acceptancesInput = {
    create?: XOR<UserModelCreateWithoutAgreement_acceptancesInput, UserModelUncheckedCreateWithoutAgreement_acceptancesInput>
    connectOrCreate?: UserModelCreateOrConnectWithoutAgreement_acceptancesInput
    connect?: UserModelWhereUniqueInput
  }

  export type AgreementModelCreateNestedOneWithoutAcceptancesInput = {
    create?: XOR<AgreementModelCreateWithoutAcceptancesInput, AgreementModelUncheckedCreateWithoutAcceptancesInput>
    connectOrCreate?: AgreementModelCreateOrConnectWithoutAcceptancesInput
    connect?: AgreementModelWhereUniqueInput
  }

  export type UserModelUpdateOneRequiredWithoutAgreement_acceptancesNestedInput = {
    create?: XOR<UserModelCreateWithoutAgreement_acceptancesInput, UserModelUncheckedCreateWithoutAgreement_acceptancesInput>
    connectOrCreate?: UserModelCreateOrConnectWithoutAgreement_acceptancesInput
    upsert?: UserModelUpsertWithoutAgreement_acceptancesInput
    connect?: UserModelWhereUniqueInput
    update?: XOR<UserModelUpdateWithoutAgreement_acceptancesInput, UserModelUncheckedUpdateWithoutAgreement_acceptancesInput>
  }

  export type AgreementModelUpdateOneRequiredWithoutAcceptancesNestedInput = {
    create?: XOR<AgreementModelCreateWithoutAcceptancesInput, AgreementModelUncheckedCreateWithoutAcceptancesInput>
    connectOrCreate?: AgreementModelCreateOrConnectWithoutAcceptancesInput
    upsert?: AgreementModelUpsertWithoutAcceptancesInput
    connect?: AgreementModelWhereUniqueInput
    update?: XOR<AgreementModelUpdateWithoutAcceptancesInput, AgreementModelUncheckedUpdateWithoutAcceptancesInput>
  }

  export type FocusCareConsultationTimeCheckModelCreateNestedManyWithoutConsultation_timeInput = {
    create?: XOR<Enumerable<FocusCareConsultationTimeCheckModelCreateWithoutConsultation_timeInput>, Enumerable<FocusCareConsultationTimeCheckModelUncheckedCreateWithoutConsultation_timeInput>>
    connectOrCreate?: Enumerable<FocusCareConsultationTimeCheckModelCreateOrConnectWithoutConsultation_timeInput>
    createMany?: FocusCareConsultationTimeCheckModelCreateManyConsultation_timeInputEnvelope
    connect?: Enumerable<FocusCareConsultationTimeCheckModelWhereUniqueInput>
  }

  export type FocusCareConsultationTimeCheckModelUncheckedCreateNestedManyWithoutConsultation_timeInput = {
    create?: XOR<Enumerable<FocusCareConsultationTimeCheckModelCreateWithoutConsultation_timeInput>, Enumerable<FocusCareConsultationTimeCheckModelUncheckedCreateWithoutConsultation_timeInput>>
    connectOrCreate?: Enumerable<FocusCareConsultationTimeCheckModelCreateOrConnectWithoutConsultation_timeInput>
    createMany?: FocusCareConsultationTimeCheckModelCreateManyConsultation_timeInputEnvelope
    connect?: Enumerable<FocusCareConsultationTimeCheckModelWhereUniqueInput>
  }

  export type FocusCareConsultationTimeCheckModelUpdateManyWithoutConsultation_timeNestedInput = {
    create?: XOR<Enumerable<FocusCareConsultationTimeCheckModelCreateWithoutConsultation_timeInput>, Enumerable<FocusCareConsultationTimeCheckModelUncheckedCreateWithoutConsultation_timeInput>>
    connectOrCreate?: Enumerable<FocusCareConsultationTimeCheckModelCreateOrConnectWithoutConsultation_timeInput>
    upsert?: Enumerable<FocusCareConsultationTimeCheckModelUpsertWithWhereUniqueWithoutConsultation_timeInput>
    createMany?: FocusCareConsultationTimeCheckModelCreateManyConsultation_timeInputEnvelope
    set?: Enumerable<FocusCareConsultationTimeCheckModelWhereUniqueInput>
    disconnect?: Enumerable<FocusCareConsultationTimeCheckModelWhereUniqueInput>
    delete?: Enumerable<FocusCareConsultationTimeCheckModelWhereUniqueInput>
    connect?: Enumerable<FocusCareConsultationTimeCheckModelWhereUniqueInput>
    update?: Enumerable<FocusCareConsultationTimeCheckModelUpdateWithWhereUniqueWithoutConsultation_timeInput>
    updateMany?: Enumerable<FocusCareConsultationTimeCheckModelUpdateManyWithWhereWithoutConsultation_timeInput>
    deleteMany?: Enumerable<FocusCareConsultationTimeCheckModelScalarWhereInput>
  }

  export type FocusCareConsultationTimeCheckModelUncheckedUpdateManyWithoutConsultation_timeNestedInput = {
    create?: XOR<Enumerable<FocusCareConsultationTimeCheckModelCreateWithoutConsultation_timeInput>, Enumerable<FocusCareConsultationTimeCheckModelUncheckedCreateWithoutConsultation_timeInput>>
    connectOrCreate?: Enumerable<FocusCareConsultationTimeCheckModelCreateOrConnectWithoutConsultation_timeInput>
    upsert?: Enumerable<FocusCareConsultationTimeCheckModelUpsertWithWhereUniqueWithoutConsultation_timeInput>
    createMany?: FocusCareConsultationTimeCheckModelCreateManyConsultation_timeInputEnvelope
    set?: Enumerable<FocusCareConsultationTimeCheckModelWhereUniqueInput>
    disconnect?: Enumerable<FocusCareConsultationTimeCheckModelWhereUniqueInput>
    delete?: Enumerable<FocusCareConsultationTimeCheckModelWhereUniqueInput>
    connect?: Enumerable<FocusCareConsultationTimeCheckModelWhereUniqueInput>
    update?: Enumerable<FocusCareConsultationTimeCheckModelUpdateWithWhereUniqueWithoutConsultation_timeInput>
    updateMany?: Enumerable<FocusCareConsultationTimeCheckModelUpdateManyWithWhereWithoutConsultation_timeInput>
    deleteMany?: Enumerable<FocusCareConsultationTimeCheckModelScalarWhereInput>
  }

  export type ServiceSuperCategoryModelCreateNestedOneWithoutSub_categoriesInput = {
    create?: XOR<ServiceSuperCategoryModelCreateWithoutSub_categoriesInput, ServiceSuperCategoryModelUncheckedCreateWithoutSub_categoriesInput>
    connectOrCreate?: ServiceSuperCategoryModelCreateOrConnectWithoutSub_categoriesInput
    connect?: ServiceSuperCategoryModelWhereUniqueInput
  }

  export type SubExpertiseModelCreateNestedManyWithoutSub_categoryInput = {
    create?: XOR<Enumerable<SubExpertiseModelCreateWithoutSub_categoryInput>, Enumerable<SubExpertiseModelUncheckedCreateWithoutSub_categoryInput>>
    connectOrCreate?: Enumerable<SubExpertiseModelCreateOrConnectWithoutSub_categoryInput>
    createMany?: SubExpertiseModelCreateManySub_categoryInputEnvelope
    connect?: Enumerable<SubExpertiseModelWhereUniqueInput>
  }

  export type SubExpertiseModelUncheckedCreateNestedManyWithoutSub_categoryInput = {
    create?: XOR<Enumerable<SubExpertiseModelCreateWithoutSub_categoryInput>, Enumerable<SubExpertiseModelUncheckedCreateWithoutSub_categoryInput>>
    connectOrCreate?: Enumerable<SubExpertiseModelCreateOrConnectWithoutSub_categoryInput>
    createMany?: SubExpertiseModelCreateManySub_categoryInputEnvelope
    connect?: Enumerable<SubExpertiseModelWhereUniqueInput>
  }

  export type ServiceSuperCategoryModelUpdateOneRequiredWithoutSub_categoriesNestedInput = {
    create?: XOR<ServiceSuperCategoryModelCreateWithoutSub_categoriesInput, ServiceSuperCategoryModelUncheckedCreateWithoutSub_categoriesInput>
    connectOrCreate?: ServiceSuperCategoryModelCreateOrConnectWithoutSub_categoriesInput
    upsert?: ServiceSuperCategoryModelUpsertWithoutSub_categoriesInput
    connect?: ServiceSuperCategoryModelWhereUniqueInput
    update?: XOR<ServiceSuperCategoryModelUpdateWithoutSub_categoriesInput, ServiceSuperCategoryModelUncheckedUpdateWithoutSub_categoriesInput>
  }

  export type SubExpertiseModelUpdateManyWithoutSub_categoryNestedInput = {
    create?: XOR<Enumerable<SubExpertiseModelCreateWithoutSub_categoryInput>, Enumerable<SubExpertiseModelUncheckedCreateWithoutSub_categoryInput>>
    connectOrCreate?: Enumerable<SubExpertiseModelCreateOrConnectWithoutSub_categoryInput>
    upsert?: Enumerable<SubExpertiseModelUpsertWithWhereUniqueWithoutSub_categoryInput>
    createMany?: SubExpertiseModelCreateManySub_categoryInputEnvelope
    set?: Enumerable<SubExpertiseModelWhereUniqueInput>
    disconnect?: Enumerable<SubExpertiseModelWhereUniqueInput>
    delete?: Enumerable<SubExpertiseModelWhereUniqueInput>
    connect?: Enumerable<SubExpertiseModelWhereUniqueInput>
    update?: Enumerable<SubExpertiseModelUpdateWithWhereUniqueWithoutSub_categoryInput>
    updateMany?: Enumerable<SubExpertiseModelUpdateManyWithWhereWithoutSub_categoryInput>
    deleteMany?: Enumerable<SubExpertiseModelScalarWhereInput>
  }

  export type SubExpertiseModelUncheckedUpdateManyWithoutSub_categoryNestedInput = {
    create?: XOR<Enumerable<SubExpertiseModelCreateWithoutSub_categoryInput>, Enumerable<SubExpertiseModelUncheckedCreateWithoutSub_categoryInput>>
    connectOrCreate?: Enumerable<SubExpertiseModelCreateOrConnectWithoutSub_categoryInput>
    upsert?: Enumerable<SubExpertiseModelUpsertWithWhereUniqueWithoutSub_categoryInput>
    createMany?: SubExpertiseModelCreateManySub_categoryInputEnvelope
    set?: Enumerable<SubExpertiseModelWhereUniqueInput>
    disconnect?: Enumerable<SubExpertiseModelWhereUniqueInput>
    delete?: Enumerable<SubExpertiseModelWhereUniqueInput>
    connect?: Enumerable<SubExpertiseModelWhereUniqueInput>
    update?: Enumerable<SubExpertiseModelUpdateWithWhereUniqueWithoutSub_categoryInput>
    updateMany?: Enumerable<SubExpertiseModelUpdateManyWithWhereWithoutSub_categoryInput>
    deleteMany?: Enumerable<SubExpertiseModelScalarWhereInput>
  }

  export type ServiceSubCategoryModelCreateNestedManyWithoutSuper_categoryInput = {
    create?: XOR<Enumerable<ServiceSubCategoryModelCreateWithoutSuper_categoryInput>, Enumerable<ServiceSubCategoryModelUncheckedCreateWithoutSuper_categoryInput>>
    connectOrCreate?: Enumerable<ServiceSubCategoryModelCreateOrConnectWithoutSuper_categoryInput>
    createMany?: ServiceSubCategoryModelCreateManySuper_categoryInputEnvelope
    connect?: Enumerable<ServiceSubCategoryModelWhereUniqueInput>
  }

  export type FocusCareServiceCheckModelCreateNestedManyWithoutService_super_categoryInput = {
    create?: XOR<Enumerable<FocusCareServiceCheckModelCreateWithoutService_super_categoryInput>, Enumerable<FocusCareServiceCheckModelUncheckedCreateWithoutService_super_categoryInput>>
    connectOrCreate?: Enumerable<FocusCareServiceCheckModelCreateOrConnectWithoutService_super_categoryInput>
    createMany?: FocusCareServiceCheckModelCreateManyService_super_categoryInputEnvelope
    connect?: Enumerable<FocusCareServiceCheckModelWhereUniqueInput>
  }

  export type ServiceSubCategoryModelUncheckedCreateNestedManyWithoutSuper_categoryInput = {
    create?: XOR<Enumerable<ServiceSubCategoryModelCreateWithoutSuper_categoryInput>, Enumerable<ServiceSubCategoryModelUncheckedCreateWithoutSuper_categoryInput>>
    connectOrCreate?: Enumerable<ServiceSubCategoryModelCreateOrConnectWithoutSuper_categoryInput>
    createMany?: ServiceSubCategoryModelCreateManySuper_categoryInputEnvelope
    connect?: Enumerable<ServiceSubCategoryModelWhereUniqueInput>
  }

  export type FocusCareServiceCheckModelUncheckedCreateNestedManyWithoutService_super_categoryInput = {
    create?: XOR<Enumerable<FocusCareServiceCheckModelCreateWithoutService_super_categoryInput>, Enumerable<FocusCareServiceCheckModelUncheckedCreateWithoutService_super_categoryInput>>
    connectOrCreate?: Enumerable<FocusCareServiceCheckModelCreateOrConnectWithoutService_super_categoryInput>
    createMany?: FocusCareServiceCheckModelCreateManyService_super_categoryInputEnvelope
    connect?: Enumerable<FocusCareServiceCheckModelWhereUniqueInput>
  }

  export type EnumServiceTypeFieldUpdateOperationsInput = {
    set?: ServiceType
  }

  export type ServiceSubCategoryModelUpdateManyWithoutSuper_categoryNestedInput = {
    create?: XOR<Enumerable<ServiceSubCategoryModelCreateWithoutSuper_categoryInput>, Enumerable<ServiceSubCategoryModelUncheckedCreateWithoutSuper_categoryInput>>
    connectOrCreate?: Enumerable<ServiceSubCategoryModelCreateOrConnectWithoutSuper_categoryInput>
    upsert?: Enumerable<ServiceSubCategoryModelUpsertWithWhereUniqueWithoutSuper_categoryInput>
    createMany?: ServiceSubCategoryModelCreateManySuper_categoryInputEnvelope
    set?: Enumerable<ServiceSubCategoryModelWhereUniqueInput>
    disconnect?: Enumerable<ServiceSubCategoryModelWhereUniqueInput>
    delete?: Enumerable<ServiceSubCategoryModelWhereUniqueInput>
    connect?: Enumerable<ServiceSubCategoryModelWhereUniqueInput>
    update?: Enumerable<ServiceSubCategoryModelUpdateWithWhereUniqueWithoutSuper_categoryInput>
    updateMany?: Enumerable<ServiceSubCategoryModelUpdateManyWithWhereWithoutSuper_categoryInput>
    deleteMany?: Enumerable<ServiceSubCategoryModelScalarWhereInput>
  }

  export type FocusCareServiceCheckModelUpdateManyWithoutService_super_categoryNestedInput = {
    create?: XOR<Enumerable<FocusCareServiceCheckModelCreateWithoutService_super_categoryInput>, Enumerable<FocusCareServiceCheckModelUncheckedCreateWithoutService_super_categoryInput>>
    connectOrCreate?: Enumerable<FocusCareServiceCheckModelCreateOrConnectWithoutService_super_categoryInput>
    upsert?: Enumerable<FocusCareServiceCheckModelUpsertWithWhereUniqueWithoutService_super_categoryInput>
    createMany?: FocusCareServiceCheckModelCreateManyService_super_categoryInputEnvelope
    set?: Enumerable<FocusCareServiceCheckModelWhereUniqueInput>
    disconnect?: Enumerable<FocusCareServiceCheckModelWhereUniqueInput>
    delete?: Enumerable<FocusCareServiceCheckModelWhereUniqueInput>
    connect?: Enumerable<FocusCareServiceCheckModelWhereUniqueInput>
    update?: Enumerable<FocusCareServiceCheckModelUpdateWithWhereUniqueWithoutService_super_categoryInput>
    updateMany?: Enumerable<FocusCareServiceCheckModelUpdateManyWithWhereWithoutService_super_categoryInput>
    deleteMany?: Enumerable<FocusCareServiceCheckModelScalarWhereInput>
  }

  export type ServiceSubCategoryModelUncheckedUpdateManyWithoutSuper_categoryNestedInput = {
    create?: XOR<Enumerable<ServiceSubCategoryModelCreateWithoutSuper_categoryInput>, Enumerable<ServiceSubCategoryModelUncheckedCreateWithoutSuper_categoryInput>>
    connectOrCreate?: Enumerable<ServiceSubCategoryModelCreateOrConnectWithoutSuper_categoryInput>
    upsert?: Enumerable<ServiceSubCategoryModelUpsertWithWhereUniqueWithoutSuper_categoryInput>
    createMany?: ServiceSubCategoryModelCreateManySuper_categoryInputEnvelope
    set?: Enumerable<ServiceSubCategoryModelWhereUniqueInput>
    disconnect?: Enumerable<ServiceSubCategoryModelWhereUniqueInput>
    delete?: Enumerable<ServiceSubCategoryModelWhereUniqueInput>
    connect?: Enumerable<ServiceSubCategoryModelWhereUniqueInput>
    update?: Enumerable<ServiceSubCategoryModelUpdateWithWhereUniqueWithoutSuper_categoryInput>
    updateMany?: Enumerable<ServiceSubCategoryModelUpdateManyWithWhereWithoutSuper_categoryInput>
    deleteMany?: Enumerable<ServiceSubCategoryModelScalarWhereInput>
  }

  export type FocusCareServiceCheckModelUncheckedUpdateManyWithoutService_super_categoryNestedInput = {
    create?: XOR<Enumerable<FocusCareServiceCheckModelCreateWithoutService_super_categoryInput>, Enumerable<FocusCareServiceCheckModelUncheckedCreateWithoutService_super_categoryInput>>
    connectOrCreate?: Enumerable<FocusCareServiceCheckModelCreateOrConnectWithoutService_super_categoryInput>
    upsert?: Enumerable<FocusCareServiceCheckModelUpsertWithWhereUniqueWithoutService_super_categoryInput>
    createMany?: FocusCareServiceCheckModelCreateManyService_super_categoryInputEnvelope
    set?: Enumerable<FocusCareServiceCheckModelWhereUniqueInput>
    disconnect?: Enumerable<FocusCareServiceCheckModelWhereUniqueInput>
    delete?: Enumerable<FocusCareServiceCheckModelWhereUniqueInput>
    connect?: Enumerable<FocusCareServiceCheckModelWhereUniqueInput>
    update?: Enumerable<FocusCareServiceCheckModelUpdateWithWhereUniqueWithoutService_super_categoryInput>
    updateMany?: Enumerable<FocusCareServiceCheckModelUpdateManyWithWhereWithoutService_super_categoryInput>
    deleteMany?: Enumerable<FocusCareServiceCheckModelScalarWhereInput>
  }

  export type CustomerModelCreateNestedOneWithoutFocus_care_requestsInput = {
    create?: XOR<CustomerModelCreateWithoutFocus_care_requestsInput, CustomerModelUncheckedCreateWithoutFocus_care_requestsInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutFocus_care_requestsInput
    connect?: CustomerModelWhereUniqueInput
  }

  export type FocusCareConsultationTimeCheckModelCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<FocusCareConsultationTimeCheckModelCreateWithoutRequestInput>, Enumerable<FocusCareConsultationTimeCheckModelUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<FocusCareConsultationTimeCheckModelCreateOrConnectWithoutRequestInput>
    createMany?: FocusCareConsultationTimeCheckModelCreateManyRequestInputEnvelope
    connect?: Enumerable<FocusCareConsultationTimeCheckModelWhereUniqueInput>
  }

  export type FocusCareServiceCheckModelCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<FocusCareServiceCheckModelCreateWithoutRequestInput>, Enumerable<FocusCareServiceCheckModelUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<FocusCareServiceCheckModelCreateOrConnectWithoutRequestInput>
    createMany?: FocusCareServiceCheckModelCreateManyRequestInputEnvelope
    connect?: Enumerable<FocusCareServiceCheckModelWhereUniqueInput>
  }

  export type FocusCareConsultationTimeCheckModelUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<FocusCareConsultationTimeCheckModelCreateWithoutRequestInput>, Enumerable<FocusCareConsultationTimeCheckModelUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<FocusCareConsultationTimeCheckModelCreateOrConnectWithoutRequestInput>
    createMany?: FocusCareConsultationTimeCheckModelCreateManyRequestInputEnvelope
    connect?: Enumerable<FocusCareConsultationTimeCheckModelWhereUniqueInput>
  }

  export type FocusCareServiceCheckModelUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<FocusCareServiceCheckModelCreateWithoutRequestInput>, Enumerable<FocusCareServiceCheckModelUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<FocusCareServiceCheckModelCreateOrConnectWithoutRequestInput>
    createMany?: FocusCareServiceCheckModelCreateManyRequestInputEnvelope
    connect?: Enumerable<FocusCareServiceCheckModelWhereUniqueInput>
  }

  export type EnumFocusCareStatusFieldUpdateOperationsInput = {
    set?: FocusCareStatus
  }

  export type CustomerModelUpdateOneRequiredWithoutFocus_care_requestsNestedInput = {
    create?: XOR<CustomerModelCreateWithoutFocus_care_requestsInput, CustomerModelUncheckedCreateWithoutFocus_care_requestsInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutFocus_care_requestsInput
    upsert?: CustomerModelUpsertWithoutFocus_care_requestsInput
    connect?: CustomerModelWhereUniqueInput
    update?: XOR<CustomerModelUpdateWithoutFocus_care_requestsInput, CustomerModelUncheckedUpdateWithoutFocus_care_requestsInput>
  }

  export type FocusCareConsultationTimeCheckModelUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<FocusCareConsultationTimeCheckModelCreateWithoutRequestInput>, Enumerable<FocusCareConsultationTimeCheckModelUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<FocusCareConsultationTimeCheckModelCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<FocusCareConsultationTimeCheckModelUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: FocusCareConsultationTimeCheckModelCreateManyRequestInputEnvelope
    set?: Enumerable<FocusCareConsultationTimeCheckModelWhereUniqueInput>
    disconnect?: Enumerable<FocusCareConsultationTimeCheckModelWhereUniqueInput>
    delete?: Enumerable<FocusCareConsultationTimeCheckModelWhereUniqueInput>
    connect?: Enumerable<FocusCareConsultationTimeCheckModelWhereUniqueInput>
    update?: Enumerable<FocusCareConsultationTimeCheckModelUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<FocusCareConsultationTimeCheckModelUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<FocusCareConsultationTimeCheckModelScalarWhereInput>
  }

  export type FocusCareServiceCheckModelUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<FocusCareServiceCheckModelCreateWithoutRequestInput>, Enumerable<FocusCareServiceCheckModelUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<FocusCareServiceCheckModelCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<FocusCareServiceCheckModelUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: FocusCareServiceCheckModelCreateManyRequestInputEnvelope
    set?: Enumerable<FocusCareServiceCheckModelWhereUniqueInput>
    disconnect?: Enumerable<FocusCareServiceCheckModelWhereUniqueInput>
    delete?: Enumerable<FocusCareServiceCheckModelWhereUniqueInput>
    connect?: Enumerable<FocusCareServiceCheckModelWhereUniqueInput>
    update?: Enumerable<FocusCareServiceCheckModelUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<FocusCareServiceCheckModelUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<FocusCareServiceCheckModelScalarWhereInput>
  }

  export type FocusCareConsultationTimeCheckModelUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<FocusCareConsultationTimeCheckModelCreateWithoutRequestInput>, Enumerable<FocusCareConsultationTimeCheckModelUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<FocusCareConsultationTimeCheckModelCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<FocusCareConsultationTimeCheckModelUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: FocusCareConsultationTimeCheckModelCreateManyRequestInputEnvelope
    set?: Enumerable<FocusCareConsultationTimeCheckModelWhereUniqueInput>
    disconnect?: Enumerable<FocusCareConsultationTimeCheckModelWhereUniqueInput>
    delete?: Enumerable<FocusCareConsultationTimeCheckModelWhereUniqueInput>
    connect?: Enumerable<FocusCareConsultationTimeCheckModelWhereUniqueInput>
    update?: Enumerable<FocusCareConsultationTimeCheckModelUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<FocusCareConsultationTimeCheckModelUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<FocusCareConsultationTimeCheckModelScalarWhereInput>
  }

  export type FocusCareServiceCheckModelUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<FocusCareServiceCheckModelCreateWithoutRequestInput>, Enumerable<FocusCareServiceCheckModelUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<FocusCareServiceCheckModelCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<FocusCareServiceCheckModelUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: FocusCareServiceCheckModelCreateManyRequestInputEnvelope
    set?: Enumerable<FocusCareServiceCheckModelWhereUniqueInput>
    disconnect?: Enumerable<FocusCareServiceCheckModelWhereUniqueInput>
    delete?: Enumerable<FocusCareServiceCheckModelWhereUniqueInput>
    connect?: Enumerable<FocusCareServiceCheckModelWhereUniqueInput>
    update?: Enumerable<FocusCareServiceCheckModelUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<FocusCareServiceCheckModelUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<FocusCareServiceCheckModelScalarWhereInput>
  }

  export type ServiceSuperCategoryModelCreateNestedOneWithoutFocus_care_checksInput = {
    create?: XOR<ServiceSuperCategoryModelCreateWithoutFocus_care_checksInput, ServiceSuperCategoryModelUncheckedCreateWithoutFocus_care_checksInput>
    connectOrCreate?: ServiceSuperCategoryModelCreateOrConnectWithoutFocus_care_checksInput
    connect?: ServiceSuperCategoryModelWhereUniqueInput
  }

  export type FocusCareRequestModelCreateNestedOneWithoutServicesInput = {
    create?: XOR<FocusCareRequestModelCreateWithoutServicesInput, FocusCareRequestModelUncheckedCreateWithoutServicesInput>
    connectOrCreate?: FocusCareRequestModelCreateOrConnectWithoutServicesInput
    connect?: FocusCareRequestModelWhereUniqueInput
  }

  export type ServiceSuperCategoryModelUpdateOneRequiredWithoutFocus_care_checksNestedInput = {
    create?: XOR<ServiceSuperCategoryModelCreateWithoutFocus_care_checksInput, ServiceSuperCategoryModelUncheckedCreateWithoutFocus_care_checksInput>
    connectOrCreate?: ServiceSuperCategoryModelCreateOrConnectWithoutFocus_care_checksInput
    upsert?: ServiceSuperCategoryModelUpsertWithoutFocus_care_checksInput
    connect?: ServiceSuperCategoryModelWhereUniqueInput
    update?: XOR<ServiceSuperCategoryModelUpdateWithoutFocus_care_checksInput, ServiceSuperCategoryModelUncheckedUpdateWithoutFocus_care_checksInput>
  }

  export type FocusCareRequestModelUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<FocusCareRequestModelCreateWithoutServicesInput, FocusCareRequestModelUncheckedCreateWithoutServicesInput>
    connectOrCreate?: FocusCareRequestModelCreateOrConnectWithoutServicesInput
    upsert?: FocusCareRequestModelUpsertWithoutServicesInput
    connect?: FocusCareRequestModelWhereUniqueInput
    update?: XOR<FocusCareRequestModelUpdateWithoutServicesInput, FocusCareRequestModelUncheckedUpdateWithoutServicesInput>
  }

  export type ConsultationTimeModelCreateNestedOneWithoutFocus_care_checksInput = {
    create?: XOR<ConsultationTimeModelCreateWithoutFocus_care_checksInput, ConsultationTimeModelUncheckedCreateWithoutFocus_care_checksInput>
    connectOrCreate?: ConsultationTimeModelCreateOrConnectWithoutFocus_care_checksInput
    connect?: ConsultationTimeModelWhereUniqueInput
  }

  export type FocusCareRequestModelCreateNestedOneWithoutConsultation_timesInput = {
    create?: XOR<FocusCareRequestModelCreateWithoutConsultation_timesInput, FocusCareRequestModelUncheckedCreateWithoutConsultation_timesInput>
    connectOrCreate?: FocusCareRequestModelCreateOrConnectWithoutConsultation_timesInput
    connect?: FocusCareRequestModelWhereUniqueInput
  }

  export type ConsultationTimeModelUpdateOneRequiredWithoutFocus_care_checksNestedInput = {
    create?: XOR<ConsultationTimeModelCreateWithoutFocus_care_checksInput, ConsultationTimeModelUncheckedCreateWithoutFocus_care_checksInput>
    connectOrCreate?: ConsultationTimeModelCreateOrConnectWithoutFocus_care_checksInput
    upsert?: ConsultationTimeModelUpsertWithoutFocus_care_checksInput
    connect?: ConsultationTimeModelWhereUniqueInput
    update?: XOR<ConsultationTimeModelUpdateWithoutFocus_care_checksInput, ConsultationTimeModelUncheckedUpdateWithoutFocus_care_checksInput>
  }

  export type FocusCareRequestModelUpdateOneRequiredWithoutConsultation_timesNestedInput = {
    create?: XOR<FocusCareRequestModelCreateWithoutConsultation_timesInput, FocusCareRequestModelUncheckedCreateWithoutConsultation_timesInput>
    connectOrCreate?: FocusCareRequestModelCreateOrConnectWithoutConsultation_timesInput
    upsert?: FocusCareRequestModelUpsertWithoutConsultation_timesInput
    connect?: FocusCareRequestModelWhereUniqueInput
    update?: XOR<FocusCareRequestModelUpdateWithoutConsultation_timesInput, FocusCareRequestModelUncheckedUpdateWithoutConsultation_timesInput>
  }

  export type CustomerModelCreateNestedOneWithoutBaseInput = {
    create?: XOR<CustomerModelCreateWithoutBaseInput, CustomerModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutBaseInput
    connect?: CustomerModelWhereUniqueInput
  }

  export type BusinessUserModelCreateNestedOneWithoutBaseInput = {
    create?: XOR<BusinessUserModelCreateWithoutBaseInput, BusinessUserModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutBaseInput
    connect?: BusinessUserModelWhereUniqueInput
  }

  export type AgreementAcceptanceModelCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AgreementAcceptanceModelCreateWithoutUserInput>, Enumerable<AgreementAcceptanceModelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AgreementAcceptanceModelCreateOrConnectWithoutUserInput>
    createMany?: AgreementAcceptanceModelCreateManyUserInputEnvelope
    connect?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
  }

  export type CustomerModelUncheckedCreateNestedOneWithoutBaseInput = {
    create?: XOR<CustomerModelCreateWithoutBaseInput, CustomerModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutBaseInput
    connect?: CustomerModelWhereUniqueInput
  }

  export type BusinessUserModelUncheckedCreateNestedOneWithoutBaseInput = {
    create?: XOR<BusinessUserModelCreateWithoutBaseInput, BusinessUserModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutBaseInput
    connect?: BusinessUserModelWhereUniqueInput
  }

  export type AgreementAcceptanceModelUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AgreementAcceptanceModelCreateWithoutUserInput>, Enumerable<AgreementAcceptanceModelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AgreementAcceptanceModelCreateOrConnectWithoutUserInput>
    createMany?: AgreementAcceptanceModelCreateManyUserInputEnvelope
    connect?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type CustomerModelUpdateOneWithoutBaseNestedInput = {
    create?: XOR<CustomerModelCreateWithoutBaseInput, CustomerModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutBaseInput
    upsert?: CustomerModelUpsertWithoutBaseInput
    disconnect?: boolean
    delete?: boolean
    connect?: CustomerModelWhereUniqueInput
    update?: XOR<CustomerModelUpdateWithoutBaseInput, CustomerModelUncheckedUpdateWithoutBaseInput>
  }

  export type BusinessUserModelUpdateOneWithoutBaseNestedInput = {
    create?: XOR<BusinessUserModelCreateWithoutBaseInput, BusinessUserModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutBaseInput
    upsert?: BusinessUserModelUpsertWithoutBaseInput
    disconnect?: boolean
    delete?: boolean
    connect?: BusinessUserModelWhereUniqueInput
    update?: XOR<BusinessUserModelUpdateWithoutBaseInput, BusinessUserModelUncheckedUpdateWithoutBaseInput>
  }

  export type AgreementAcceptanceModelUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AgreementAcceptanceModelCreateWithoutUserInput>, Enumerable<AgreementAcceptanceModelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AgreementAcceptanceModelCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AgreementAcceptanceModelUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AgreementAcceptanceModelCreateManyUserInputEnvelope
    set?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    disconnect?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    delete?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    connect?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    update?: Enumerable<AgreementAcceptanceModelUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AgreementAcceptanceModelUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AgreementAcceptanceModelScalarWhereInput>
  }

  export type CustomerModelUncheckedUpdateOneWithoutBaseNestedInput = {
    create?: XOR<CustomerModelCreateWithoutBaseInput, CustomerModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutBaseInput
    upsert?: CustomerModelUpsertWithoutBaseInput
    disconnect?: boolean
    delete?: boolean
    connect?: CustomerModelWhereUniqueInput
    update?: XOR<CustomerModelUpdateWithoutBaseInput, CustomerModelUncheckedUpdateWithoutBaseInput>
  }

  export type BusinessUserModelUncheckedUpdateOneWithoutBaseNestedInput = {
    create?: XOR<BusinessUserModelCreateWithoutBaseInput, BusinessUserModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutBaseInput
    upsert?: BusinessUserModelUpsertWithoutBaseInput
    disconnect?: boolean
    delete?: boolean
    connect?: BusinessUserModelWhereUniqueInput
    update?: XOR<BusinessUserModelUpdateWithoutBaseInput, BusinessUserModelUncheckedUpdateWithoutBaseInput>
  }

  export type AgreementAcceptanceModelUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AgreementAcceptanceModelCreateWithoutUserInput>, Enumerable<AgreementAcceptanceModelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AgreementAcceptanceModelCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AgreementAcceptanceModelUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AgreementAcceptanceModelCreateManyUserInputEnvelope
    set?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    disconnect?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    delete?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    connect?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    update?: Enumerable<AgreementAcceptanceModelUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AgreementAcceptanceModelUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AgreementAcceptanceModelScalarWhereInput>
  }

  export type UserModelCreateNestedOneWithoutCustomerInput = {
    create?: XOR<UserModelCreateWithoutCustomerInput, UserModelUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: UserModelCreateOrConnectWithoutCustomerInput
    connect?: UserModelWhereUniqueInput
  }

  export type OauthAccountModelCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<OauthAccountModelCreateWithoutCustomerInput>, Enumerable<OauthAccountModelUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<OauthAccountModelCreateOrConnectWithoutCustomerInput>
    createMany?: OauthAccountModelCreateManyCustomerInputEnvelope
    connect?: Enumerable<OauthAccountModelWhereUniqueInput>
  }

  export type ReviewModelCreateNestedManyWithoutReviewerInput = {
    create?: XOR<Enumerable<ReviewModelCreateWithoutReviewerInput>, Enumerable<ReviewModelUncheckedCreateWithoutReviewerInput>>
    connectOrCreate?: Enumerable<ReviewModelCreateOrConnectWithoutReviewerInput>
    createMany?: ReviewModelCreateManyReviewerInputEnvelope
    connect?: Enumerable<ReviewModelWhereUniqueInput>
  }

  export type FocusCareRequestModelCreateNestedManyWithoutRequesterInput = {
    create?: XOR<Enumerable<FocusCareRequestModelCreateWithoutRequesterInput>, Enumerable<FocusCareRequestModelUncheckedCreateWithoutRequesterInput>>
    connectOrCreate?: Enumerable<FocusCareRequestModelCreateOrConnectWithoutRequesterInput>
    createMany?: FocusCareRequestModelCreateManyRequesterInputEnvelope
    connect?: Enumerable<FocusCareRequestModelWhereUniqueInput>
  }

  export type OauthAccountModelUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<OauthAccountModelCreateWithoutCustomerInput>, Enumerable<OauthAccountModelUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<OauthAccountModelCreateOrConnectWithoutCustomerInput>
    createMany?: OauthAccountModelCreateManyCustomerInputEnvelope
    connect?: Enumerable<OauthAccountModelWhereUniqueInput>
  }

  export type ReviewModelUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<Enumerable<ReviewModelCreateWithoutReviewerInput>, Enumerable<ReviewModelUncheckedCreateWithoutReviewerInput>>
    connectOrCreate?: Enumerable<ReviewModelCreateOrConnectWithoutReviewerInput>
    createMany?: ReviewModelCreateManyReviewerInputEnvelope
    connect?: Enumerable<ReviewModelWhereUniqueInput>
  }

  export type FocusCareRequestModelUncheckedCreateNestedManyWithoutRequesterInput = {
    create?: XOR<Enumerable<FocusCareRequestModelCreateWithoutRequesterInput>, Enumerable<FocusCareRequestModelUncheckedCreateWithoutRequesterInput>>
    connectOrCreate?: Enumerable<FocusCareRequestModelCreateOrConnectWithoutRequesterInput>
    createMany?: FocusCareRequestModelCreateManyRequesterInputEnvelope
    connect?: Enumerable<FocusCareRequestModelWhereUniqueInput>
  }

  export type NullableEnumGenderTypeFieldUpdateOperationsInput = {
    set?: GenderType | null
  }

  export type UserModelUpdateOneRequiredWithoutCustomerNestedInput = {
    create?: XOR<UserModelCreateWithoutCustomerInput, UserModelUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: UserModelCreateOrConnectWithoutCustomerInput
    upsert?: UserModelUpsertWithoutCustomerInput
    connect?: UserModelWhereUniqueInput
    update?: XOR<UserModelUpdateWithoutCustomerInput, UserModelUncheckedUpdateWithoutCustomerInput>
  }

  export type OauthAccountModelUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<OauthAccountModelCreateWithoutCustomerInput>, Enumerable<OauthAccountModelUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<OauthAccountModelCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<OauthAccountModelUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: OauthAccountModelCreateManyCustomerInputEnvelope
    set?: Enumerable<OauthAccountModelWhereUniqueInput>
    disconnect?: Enumerable<OauthAccountModelWhereUniqueInput>
    delete?: Enumerable<OauthAccountModelWhereUniqueInput>
    connect?: Enumerable<OauthAccountModelWhereUniqueInput>
    update?: Enumerable<OauthAccountModelUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<OauthAccountModelUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<OauthAccountModelScalarWhereInput>
  }

  export type ReviewModelUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<Enumerable<ReviewModelCreateWithoutReviewerInput>, Enumerable<ReviewModelUncheckedCreateWithoutReviewerInput>>
    connectOrCreate?: Enumerable<ReviewModelCreateOrConnectWithoutReviewerInput>
    upsert?: Enumerable<ReviewModelUpsertWithWhereUniqueWithoutReviewerInput>
    createMany?: ReviewModelCreateManyReviewerInputEnvelope
    set?: Enumerable<ReviewModelWhereUniqueInput>
    disconnect?: Enumerable<ReviewModelWhereUniqueInput>
    delete?: Enumerable<ReviewModelWhereUniqueInput>
    connect?: Enumerable<ReviewModelWhereUniqueInput>
    update?: Enumerable<ReviewModelUpdateWithWhereUniqueWithoutReviewerInput>
    updateMany?: Enumerable<ReviewModelUpdateManyWithWhereWithoutReviewerInput>
    deleteMany?: Enumerable<ReviewModelScalarWhereInput>
  }

  export type FocusCareRequestModelUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<Enumerable<FocusCareRequestModelCreateWithoutRequesterInput>, Enumerable<FocusCareRequestModelUncheckedCreateWithoutRequesterInput>>
    connectOrCreate?: Enumerable<FocusCareRequestModelCreateOrConnectWithoutRequesterInput>
    upsert?: Enumerable<FocusCareRequestModelUpsertWithWhereUniqueWithoutRequesterInput>
    createMany?: FocusCareRequestModelCreateManyRequesterInputEnvelope
    set?: Enumerable<FocusCareRequestModelWhereUniqueInput>
    disconnect?: Enumerable<FocusCareRequestModelWhereUniqueInput>
    delete?: Enumerable<FocusCareRequestModelWhereUniqueInput>
    connect?: Enumerable<FocusCareRequestModelWhereUniqueInput>
    update?: Enumerable<FocusCareRequestModelUpdateWithWhereUniqueWithoutRequesterInput>
    updateMany?: Enumerable<FocusCareRequestModelUpdateManyWithWhereWithoutRequesterInput>
    deleteMany?: Enumerable<FocusCareRequestModelScalarWhereInput>
  }

  export type OauthAccountModelUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<OauthAccountModelCreateWithoutCustomerInput>, Enumerable<OauthAccountModelUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<OauthAccountModelCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<OauthAccountModelUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: OauthAccountModelCreateManyCustomerInputEnvelope
    set?: Enumerable<OauthAccountModelWhereUniqueInput>
    disconnect?: Enumerable<OauthAccountModelWhereUniqueInput>
    delete?: Enumerable<OauthAccountModelWhereUniqueInput>
    connect?: Enumerable<OauthAccountModelWhereUniqueInput>
    update?: Enumerable<OauthAccountModelUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<OauthAccountModelUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<OauthAccountModelScalarWhereInput>
  }

  export type ReviewModelUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<Enumerable<ReviewModelCreateWithoutReviewerInput>, Enumerable<ReviewModelUncheckedCreateWithoutReviewerInput>>
    connectOrCreate?: Enumerable<ReviewModelCreateOrConnectWithoutReviewerInput>
    upsert?: Enumerable<ReviewModelUpsertWithWhereUniqueWithoutReviewerInput>
    createMany?: ReviewModelCreateManyReviewerInputEnvelope
    set?: Enumerable<ReviewModelWhereUniqueInput>
    disconnect?: Enumerable<ReviewModelWhereUniqueInput>
    delete?: Enumerable<ReviewModelWhereUniqueInput>
    connect?: Enumerable<ReviewModelWhereUniqueInput>
    update?: Enumerable<ReviewModelUpdateWithWhereUniqueWithoutReviewerInput>
    updateMany?: Enumerable<ReviewModelUpdateManyWithWhereWithoutReviewerInput>
    deleteMany?: Enumerable<ReviewModelScalarWhereInput>
  }

  export type FocusCareRequestModelUncheckedUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<Enumerable<FocusCareRequestModelCreateWithoutRequesterInput>, Enumerable<FocusCareRequestModelUncheckedCreateWithoutRequesterInput>>
    connectOrCreate?: Enumerable<FocusCareRequestModelCreateOrConnectWithoutRequesterInput>
    upsert?: Enumerable<FocusCareRequestModelUpsertWithWhereUniqueWithoutRequesterInput>
    createMany?: FocusCareRequestModelCreateManyRequesterInputEnvelope
    set?: Enumerable<FocusCareRequestModelWhereUniqueInput>
    disconnect?: Enumerable<FocusCareRequestModelWhereUniqueInput>
    delete?: Enumerable<FocusCareRequestModelWhereUniqueInput>
    connect?: Enumerable<FocusCareRequestModelWhereUniqueInput>
    update?: Enumerable<FocusCareRequestModelUpdateWithWhereUniqueWithoutRequesterInput>
    updateMany?: Enumerable<FocusCareRequestModelUpdateManyWithWhereWithoutRequesterInput>
    deleteMany?: Enumerable<FocusCareRequestModelScalarWhereInput>
  }

  export type UserModelCreateNestedOneWithoutBusiness_userInput = {
    create?: XOR<UserModelCreateWithoutBusiness_userInput, UserModelUncheckedCreateWithoutBusiness_userInput>
    connectOrCreate?: UserModelCreateOrConnectWithoutBusiness_userInput
    connect?: UserModelWhereUniqueInput
  }

  export type REAgentModelCreateNestedOneWithoutBaseInput = {
    create?: XOR<REAgentModelCreateWithoutBaseInput, REAgentModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: REAgentModelCreateOrConnectWithoutBaseInput
    connect?: REAgentModelWhereUniqueInput
  }

  export type HSProviderModelCreateNestedOneWithoutBaseInput = {
    create?: XOR<HSProviderModelCreateWithoutBaseInput, HSProviderModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: HSProviderModelCreateOrConnectWithoutBaseInput
    connect?: HSProviderModelWhereUniqueInput
  }

  export type BusinessCertificationImageModelCreateNestedManyWithoutBusiness_userInput = {
    create?: XOR<Enumerable<BusinessCertificationImageModelCreateWithoutBusiness_userInput>, Enumerable<BusinessCertificationImageModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<BusinessCertificationImageModelCreateOrConnectWithoutBusiness_userInput>
    createMany?: BusinessCertificationImageModelCreateManyBusiness_userInputEnvelope
    connect?: Enumerable<BusinessCertificationImageModelWhereUniqueInput>
  }

  export type SubExpertiseModelCreateNestedManyWithoutBusiness_userInput = {
    create?: XOR<Enumerable<SubExpertiseModelCreateWithoutBusiness_userInput>, Enumerable<SubExpertiseModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<SubExpertiseModelCreateOrConnectWithoutBusiness_userInput>
    createMany?: SubExpertiseModelCreateManyBusiness_userInputEnvelope
    connect?: Enumerable<SubExpertiseModelWhereUniqueInput>
  }

  export type OauthAccountModelCreateNestedManyWithoutBusiness_userInput = {
    create?: XOR<Enumerable<OauthAccountModelCreateWithoutBusiness_userInput>, Enumerable<OauthAccountModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<OauthAccountModelCreateOrConnectWithoutBusiness_userInput>
    createMany?: OauthAccountModelCreateManyBusiness_userInputEnvelope
    connect?: Enumerable<OauthAccountModelWhereUniqueInput>
  }

  export type ReviewModelCreateNestedManyWithoutRevieweeInput = {
    create?: XOR<Enumerable<ReviewModelCreateWithoutRevieweeInput>, Enumerable<ReviewModelUncheckedCreateWithoutRevieweeInput>>
    connectOrCreate?: Enumerable<ReviewModelCreateOrConnectWithoutRevieweeInput>
    createMany?: ReviewModelCreateManyRevieweeInputEnvelope
    connect?: Enumerable<ReviewModelWhereUniqueInput>
  }

  export type REAgentModelUncheckedCreateNestedOneWithoutBaseInput = {
    create?: XOR<REAgentModelCreateWithoutBaseInput, REAgentModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: REAgentModelCreateOrConnectWithoutBaseInput
    connect?: REAgentModelWhereUniqueInput
  }

  export type HSProviderModelUncheckedCreateNestedOneWithoutBaseInput = {
    create?: XOR<HSProviderModelCreateWithoutBaseInput, HSProviderModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: HSProviderModelCreateOrConnectWithoutBaseInput
    connect?: HSProviderModelWhereUniqueInput
  }

  export type BusinessCertificationImageModelUncheckedCreateNestedManyWithoutBusiness_userInput = {
    create?: XOR<Enumerable<BusinessCertificationImageModelCreateWithoutBusiness_userInput>, Enumerable<BusinessCertificationImageModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<BusinessCertificationImageModelCreateOrConnectWithoutBusiness_userInput>
    createMany?: BusinessCertificationImageModelCreateManyBusiness_userInputEnvelope
    connect?: Enumerable<BusinessCertificationImageModelWhereUniqueInput>
  }

  export type SubExpertiseModelUncheckedCreateNestedManyWithoutBusiness_userInput = {
    create?: XOR<Enumerable<SubExpertiseModelCreateWithoutBusiness_userInput>, Enumerable<SubExpertiseModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<SubExpertiseModelCreateOrConnectWithoutBusiness_userInput>
    createMany?: SubExpertiseModelCreateManyBusiness_userInputEnvelope
    connect?: Enumerable<SubExpertiseModelWhereUniqueInput>
  }

  export type OauthAccountModelUncheckedCreateNestedManyWithoutBusiness_userInput = {
    create?: XOR<Enumerable<OauthAccountModelCreateWithoutBusiness_userInput>, Enumerable<OauthAccountModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<OauthAccountModelCreateOrConnectWithoutBusiness_userInput>
    createMany?: OauthAccountModelCreateManyBusiness_userInputEnvelope
    connect?: Enumerable<OauthAccountModelWhereUniqueInput>
  }

  export type ReviewModelUncheckedCreateNestedManyWithoutRevieweeInput = {
    create?: XOR<Enumerable<ReviewModelCreateWithoutRevieweeInput>, Enumerable<ReviewModelUncheckedCreateWithoutRevieweeInput>>
    connectOrCreate?: Enumerable<ReviewModelCreateOrConnectWithoutRevieweeInput>
    createMany?: ReviewModelCreateManyRevieweeInputEnvelope
    connect?: Enumerable<ReviewModelWhereUniqueInput>
  }

  export type UserModelUpdateOneRequiredWithoutBusiness_userNestedInput = {
    create?: XOR<UserModelCreateWithoutBusiness_userInput, UserModelUncheckedCreateWithoutBusiness_userInput>
    connectOrCreate?: UserModelCreateOrConnectWithoutBusiness_userInput
    upsert?: UserModelUpsertWithoutBusiness_userInput
    connect?: UserModelWhereUniqueInput
    update?: XOR<UserModelUpdateWithoutBusiness_userInput, UserModelUncheckedUpdateWithoutBusiness_userInput>
  }

  export type REAgentModelUpdateOneWithoutBaseNestedInput = {
    create?: XOR<REAgentModelCreateWithoutBaseInput, REAgentModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: REAgentModelCreateOrConnectWithoutBaseInput
    upsert?: REAgentModelUpsertWithoutBaseInput
    disconnect?: boolean
    delete?: boolean
    connect?: REAgentModelWhereUniqueInput
    update?: XOR<REAgentModelUpdateWithoutBaseInput, REAgentModelUncheckedUpdateWithoutBaseInput>
  }

  export type HSProviderModelUpdateOneWithoutBaseNestedInput = {
    create?: XOR<HSProviderModelCreateWithoutBaseInput, HSProviderModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: HSProviderModelCreateOrConnectWithoutBaseInput
    upsert?: HSProviderModelUpsertWithoutBaseInput
    disconnect?: boolean
    delete?: boolean
    connect?: HSProviderModelWhereUniqueInput
    update?: XOR<HSProviderModelUpdateWithoutBaseInput, HSProviderModelUncheckedUpdateWithoutBaseInput>
  }

  export type BusinessCertificationImageModelUpdateManyWithoutBusiness_userNestedInput = {
    create?: XOR<Enumerable<BusinessCertificationImageModelCreateWithoutBusiness_userInput>, Enumerable<BusinessCertificationImageModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<BusinessCertificationImageModelCreateOrConnectWithoutBusiness_userInput>
    upsert?: Enumerable<BusinessCertificationImageModelUpsertWithWhereUniqueWithoutBusiness_userInput>
    createMany?: BusinessCertificationImageModelCreateManyBusiness_userInputEnvelope
    set?: Enumerable<BusinessCertificationImageModelWhereUniqueInput>
    disconnect?: Enumerable<BusinessCertificationImageModelWhereUniqueInput>
    delete?: Enumerable<BusinessCertificationImageModelWhereUniqueInput>
    connect?: Enumerable<BusinessCertificationImageModelWhereUniqueInput>
    update?: Enumerable<BusinessCertificationImageModelUpdateWithWhereUniqueWithoutBusiness_userInput>
    updateMany?: Enumerable<BusinessCertificationImageModelUpdateManyWithWhereWithoutBusiness_userInput>
    deleteMany?: Enumerable<BusinessCertificationImageModelScalarWhereInput>
  }

  export type SubExpertiseModelUpdateManyWithoutBusiness_userNestedInput = {
    create?: XOR<Enumerable<SubExpertiseModelCreateWithoutBusiness_userInput>, Enumerable<SubExpertiseModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<SubExpertiseModelCreateOrConnectWithoutBusiness_userInput>
    upsert?: Enumerable<SubExpertiseModelUpsertWithWhereUniqueWithoutBusiness_userInput>
    createMany?: SubExpertiseModelCreateManyBusiness_userInputEnvelope
    set?: Enumerable<SubExpertiseModelWhereUniqueInput>
    disconnect?: Enumerable<SubExpertiseModelWhereUniqueInput>
    delete?: Enumerable<SubExpertiseModelWhereUniqueInput>
    connect?: Enumerable<SubExpertiseModelWhereUniqueInput>
    update?: Enumerable<SubExpertiseModelUpdateWithWhereUniqueWithoutBusiness_userInput>
    updateMany?: Enumerable<SubExpertiseModelUpdateManyWithWhereWithoutBusiness_userInput>
    deleteMany?: Enumerable<SubExpertiseModelScalarWhereInput>
  }

  export type OauthAccountModelUpdateManyWithoutBusiness_userNestedInput = {
    create?: XOR<Enumerable<OauthAccountModelCreateWithoutBusiness_userInput>, Enumerable<OauthAccountModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<OauthAccountModelCreateOrConnectWithoutBusiness_userInput>
    upsert?: Enumerable<OauthAccountModelUpsertWithWhereUniqueWithoutBusiness_userInput>
    createMany?: OauthAccountModelCreateManyBusiness_userInputEnvelope
    set?: Enumerable<OauthAccountModelWhereUniqueInput>
    disconnect?: Enumerable<OauthAccountModelWhereUniqueInput>
    delete?: Enumerable<OauthAccountModelWhereUniqueInput>
    connect?: Enumerable<OauthAccountModelWhereUniqueInput>
    update?: Enumerable<OauthAccountModelUpdateWithWhereUniqueWithoutBusiness_userInput>
    updateMany?: Enumerable<OauthAccountModelUpdateManyWithWhereWithoutBusiness_userInput>
    deleteMany?: Enumerable<OauthAccountModelScalarWhereInput>
  }

  export type ReviewModelUpdateManyWithoutRevieweeNestedInput = {
    create?: XOR<Enumerable<ReviewModelCreateWithoutRevieweeInput>, Enumerable<ReviewModelUncheckedCreateWithoutRevieweeInput>>
    connectOrCreate?: Enumerable<ReviewModelCreateOrConnectWithoutRevieweeInput>
    upsert?: Enumerable<ReviewModelUpsertWithWhereUniqueWithoutRevieweeInput>
    createMany?: ReviewModelCreateManyRevieweeInputEnvelope
    set?: Enumerable<ReviewModelWhereUniqueInput>
    disconnect?: Enumerable<ReviewModelWhereUniqueInput>
    delete?: Enumerable<ReviewModelWhereUniqueInput>
    connect?: Enumerable<ReviewModelWhereUniqueInput>
    update?: Enumerable<ReviewModelUpdateWithWhereUniqueWithoutRevieweeInput>
    updateMany?: Enumerable<ReviewModelUpdateManyWithWhereWithoutRevieweeInput>
    deleteMany?: Enumerable<ReviewModelScalarWhereInput>
  }

  export type REAgentModelUncheckedUpdateOneWithoutBaseNestedInput = {
    create?: XOR<REAgentModelCreateWithoutBaseInput, REAgentModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: REAgentModelCreateOrConnectWithoutBaseInput
    upsert?: REAgentModelUpsertWithoutBaseInput
    disconnect?: boolean
    delete?: boolean
    connect?: REAgentModelWhereUniqueInput
    update?: XOR<REAgentModelUpdateWithoutBaseInput, REAgentModelUncheckedUpdateWithoutBaseInput>
  }

  export type HSProviderModelUncheckedUpdateOneWithoutBaseNestedInput = {
    create?: XOR<HSProviderModelCreateWithoutBaseInput, HSProviderModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: HSProviderModelCreateOrConnectWithoutBaseInput
    upsert?: HSProviderModelUpsertWithoutBaseInput
    disconnect?: boolean
    delete?: boolean
    connect?: HSProviderModelWhereUniqueInput
    update?: XOR<HSProviderModelUpdateWithoutBaseInput, HSProviderModelUncheckedUpdateWithoutBaseInput>
  }

  export type BusinessCertificationImageModelUncheckedUpdateManyWithoutBusiness_userNestedInput = {
    create?: XOR<Enumerable<BusinessCertificationImageModelCreateWithoutBusiness_userInput>, Enumerable<BusinessCertificationImageModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<BusinessCertificationImageModelCreateOrConnectWithoutBusiness_userInput>
    upsert?: Enumerable<BusinessCertificationImageModelUpsertWithWhereUniqueWithoutBusiness_userInput>
    createMany?: BusinessCertificationImageModelCreateManyBusiness_userInputEnvelope
    set?: Enumerable<BusinessCertificationImageModelWhereUniqueInput>
    disconnect?: Enumerable<BusinessCertificationImageModelWhereUniqueInput>
    delete?: Enumerable<BusinessCertificationImageModelWhereUniqueInput>
    connect?: Enumerable<BusinessCertificationImageModelWhereUniqueInput>
    update?: Enumerable<BusinessCertificationImageModelUpdateWithWhereUniqueWithoutBusiness_userInput>
    updateMany?: Enumerable<BusinessCertificationImageModelUpdateManyWithWhereWithoutBusiness_userInput>
    deleteMany?: Enumerable<BusinessCertificationImageModelScalarWhereInput>
  }

  export type SubExpertiseModelUncheckedUpdateManyWithoutBusiness_userNestedInput = {
    create?: XOR<Enumerable<SubExpertiseModelCreateWithoutBusiness_userInput>, Enumerable<SubExpertiseModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<SubExpertiseModelCreateOrConnectWithoutBusiness_userInput>
    upsert?: Enumerable<SubExpertiseModelUpsertWithWhereUniqueWithoutBusiness_userInput>
    createMany?: SubExpertiseModelCreateManyBusiness_userInputEnvelope
    set?: Enumerable<SubExpertiseModelWhereUniqueInput>
    disconnect?: Enumerable<SubExpertiseModelWhereUniqueInput>
    delete?: Enumerable<SubExpertiseModelWhereUniqueInput>
    connect?: Enumerable<SubExpertiseModelWhereUniqueInput>
    update?: Enumerable<SubExpertiseModelUpdateWithWhereUniqueWithoutBusiness_userInput>
    updateMany?: Enumerable<SubExpertiseModelUpdateManyWithWhereWithoutBusiness_userInput>
    deleteMany?: Enumerable<SubExpertiseModelScalarWhereInput>
  }

  export type OauthAccountModelUncheckedUpdateManyWithoutBusiness_userNestedInput = {
    create?: XOR<Enumerable<OauthAccountModelCreateWithoutBusiness_userInput>, Enumerable<OauthAccountModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<OauthAccountModelCreateOrConnectWithoutBusiness_userInput>
    upsert?: Enumerable<OauthAccountModelUpsertWithWhereUniqueWithoutBusiness_userInput>
    createMany?: OauthAccountModelCreateManyBusiness_userInputEnvelope
    set?: Enumerable<OauthAccountModelWhereUniqueInput>
    disconnect?: Enumerable<OauthAccountModelWhereUniqueInput>
    delete?: Enumerable<OauthAccountModelWhereUniqueInput>
    connect?: Enumerable<OauthAccountModelWhereUniqueInput>
    update?: Enumerable<OauthAccountModelUpdateWithWhereUniqueWithoutBusiness_userInput>
    updateMany?: Enumerable<OauthAccountModelUpdateManyWithWhereWithoutBusiness_userInput>
    deleteMany?: Enumerable<OauthAccountModelScalarWhereInput>
  }

  export type ReviewModelUncheckedUpdateManyWithoutRevieweeNestedInput = {
    create?: XOR<Enumerable<ReviewModelCreateWithoutRevieweeInput>, Enumerable<ReviewModelUncheckedCreateWithoutRevieweeInput>>
    connectOrCreate?: Enumerable<ReviewModelCreateOrConnectWithoutRevieweeInput>
    upsert?: Enumerable<ReviewModelUpsertWithWhereUniqueWithoutRevieweeInput>
    createMany?: ReviewModelCreateManyRevieweeInputEnvelope
    set?: Enumerable<ReviewModelWhereUniqueInput>
    disconnect?: Enumerable<ReviewModelWhereUniqueInput>
    delete?: Enumerable<ReviewModelWhereUniqueInput>
    connect?: Enumerable<ReviewModelWhereUniqueInput>
    update?: Enumerable<ReviewModelUpdateWithWhereUniqueWithoutRevieweeInput>
    updateMany?: Enumerable<ReviewModelUpdateManyWithWhereWithoutRevieweeInput>
    deleteMany?: Enumerable<ReviewModelScalarWhereInput>
  }

  export type ServiceSubCategoryModelCreateNestedOneWithoutExpertisesInput = {
    create?: XOR<ServiceSubCategoryModelCreateWithoutExpertisesInput, ServiceSubCategoryModelUncheckedCreateWithoutExpertisesInput>
    connectOrCreate?: ServiceSubCategoryModelCreateOrConnectWithoutExpertisesInput
    connect?: ServiceSubCategoryModelWhereUniqueInput
  }

  export type BusinessUserModelCreateNestedOneWithoutSub_expertisesInput = {
    create?: XOR<BusinessUserModelCreateWithoutSub_expertisesInput, BusinessUserModelUncheckedCreateWithoutSub_expertisesInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutSub_expertisesInput
    connect?: BusinessUserModelWhereUniqueInput
  }

  export type ServiceSubCategoryModelUpdateOneRequiredWithoutExpertisesNestedInput = {
    create?: XOR<ServiceSubCategoryModelCreateWithoutExpertisesInput, ServiceSubCategoryModelUncheckedCreateWithoutExpertisesInput>
    connectOrCreate?: ServiceSubCategoryModelCreateOrConnectWithoutExpertisesInput
    upsert?: ServiceSubCategoryModelUpsertWithoutExpertisesInput
    connect?: ServiceSubCategoryModelWhereUniqueInput
    update?: XOR<ServiceSubCategoryModelUpdateWithoutExpertisesInput, ServiceSubCategoryModelUncheckedUpdateWithoutExpertisesInput>
  }

  export type BusinessUserModelUpdateOneRequiredWithoutSub_expertisesNestedInput = {
    create?: XOR<BusinessUserModelCreateWithoutSub_expertisesInput, BusinessUserModelUncheckedCreateWithoutSub_expertisesInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutSub_expertisesInput
    upsert?: BusinessUserModelUpsertWithoutSub_expertisesInput
    connect?: BusinessUserModelWhereUniqueInput
    update?: XOR<BusinessUserModelUpdateWithoutSub_expertisesInput, BusinessUserModelUncheckedUpdateWithoutSub_expertisesInput>
  }

  export type BusinessUserModelCreateNestedOneWithoutRe_agentInput = {
    create?: XOR<BusinessUserModelCreateWithoutRe_agentInput, BusinessUserModelUncheckedCreateWithoutRe_agentInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutRe_agentInput
    connect?: BusinessUserModelWhereUniqueInput
  }

  export type REProertyModelCreateNestedManyWithoutRe_agentInput = {
    create?: XOR<Enumerable<REProertyModelCreateWithoutRe_agentInput>, Enumerable<REProertyModelUncheckedCreateWithoutRe_agentInput>>
    connectOrCreate?: Enumerable<REProertyModelCreateOrConnectWithoutRe_agentInput>
    createMany?: REProertyModelCreateManyRe_agentInputEnvelope
    connect?: Enumerable<REProertyModelWhereUniqueInput>
  }

  export type REProertyModelUncheckedCreateNestedManyWithoutRe_agentInput = {
    create?: XOR<Enumerable<REProertyModelCreateWithoutRe_agentInput>, Enumerable<REProertyModelUncheckedCreateWithoutRe_agentInput>>
    connectOrCreate?: Enumerable<REProertyModelCreateOrConnectWithoutRe_agentInput>
    createMany?: REProertyModelCreateManyRe_agentInputEnvelope
    connect?: Enumerable<REProertyModelWhereUniqueInput>
  }

  export type BusinessUserModelUpdateOneRequiredWithoutRe_agentNestedInput = {
    create?: XOR<BusinessUserModelCreateWithoutRe_agentInput, BusinessUserModelUncheckedCreateWithoutRe_agentInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutRe_agentInput
    upsert?: BusinessUserModelUpsertWithoutRe_agentInput
    connect?: BusinessUserModelWhereUniqueInput
    update?: XOR<BusinessUserModelUpdateWithoutRe_agentInput, BusinessUserModelUncheckedUpdateWithoutRe_agentInput>
  }

  export type REProertyModelUpdateManyWithoutRe_agentNestedInput = {
    create?: XOR<Enumerable<REProertyModelCreateWithoutRe_agentInput>, Enumerable<REProertyModelUncheckedCreateWithoutRe_agentInput>>
    connectOrCreate?: Enumerable<REProertyModelCreateOrConnectWithoutRe_agentInput>
    upsert?: Enumerable<REProertyModelUpsertWithWhereUniqueWithoutRe_agentInput>
    createMany?: REProertyModelCreateManyRe_agentInputEnvelope
    set?: Enumerable<REProertyModelWhereUniqueInput>
    disconnect?: Enumerable<REProertyModelWhereUniqueInput>
    delete?: Enumerable<REProertyModelWhereUniqueInput>
    connect?: Enumerable<REProertyModelWhereUniqueInput>
    update?: Enumerable<REProertyModelUpdateWithWhereUniqueWithoutRe_agentInput>
    updateMany?: Enumerable<REProertyModelUpdateManyWithWhereWithoutRe_agentInput>
    deleteMany?: Enumerable<REProertyModelScalarWhereInput>
  }

  export type REProertyModelUncheckedUpdateManyWithoutRe_agentNestedInput = {
    create?: XOR<Enumerable<REProertyModelCreateWithoutRe_agentInput>, Enumerable<REProertyModelUncheckedCreateWithoutRe_agentInput>>
    connectOrCreate?: Enumerable<REProertyModelCreateOrConnectWithoutRe_agentInput>
    upsert?: Enumerable<REProertyModelUpsertWithWhereUniqueWithoutRe_agentInput>
    createMany?: REProertyModelCreateManyRe_agentInputEnvelope
    set?: Enumerable<REProertyModelWhereUniqueInput>
    disconnect?: Enumerable<REProertyModelWhereUniqueInput>
    delete?: Enumerable<REProertyModelWhereUniqueInput>
    connect?: Enumerable<REProertyModelWhereUniqueInput>
    update?: Enumerable<REProertyModelUpdateWithWhereUniqueWithoutRe_agentInput>
    updateMany?: Enumerable<REProertyModelUpdateManyWithWhereWithoutRe_agentInput>
    deleteMany?: Enumerable<REProertyModelScalarWhereInput>
  }

  export type BusinessUserModelCreateNestedOneWithoutHs_providerInput = {
    create?: XOR<BusinessUserModelCreateWithoutHs_providerInput, BusinessUserModelUncheckedCreateWithoutHs_providerInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutHs_providerInput
    connect?: BusinessUserModelWhereUniqueInput
  }

  export type HSIntroductionImageModelCreateNestedManyWithoutHs_providerInput = {
    create?: XOR<Enumerable<HSIntroductionImageModelCreateWithoutHs_providerInput>, Enumerable<HSIntroductionImageModelUncheckedCreateWithoutHs_providerInput>>
    connectOrCreate?: Enumerable<HSIntroductionImageModelCreateOrConnectWithoutHs_providerInput>
    createMany?: HSIntroductionImageModelCreateManyHs_providerInputEnvelope
    connect?: Enumerable<HSIntroductionImageModelWhereUniqueInput>
  }

  export type HSIntroductionImageModelUncheckedCreateNestedManyWithoutHs_providerInput = {
    create?: XOR<Enumerable<HSIntroductionImageModelCreateWithoutHs_providerInput>, Enumerable<HSIntroductionImageModelUncheckedCreateWithoutHs_providerInput>>
    connectOrCreate?: Enumerable<HSIntroductionImageModelCreateOrConnectWithoutHs_providerInput>
    createMany?: HSIntroductionImageModelCreateManyHs_providerInputEnvelope
    connect?: Enumerable<HSIntroductionImageModelWhereUniqueInput>
  }

  export type BusinessUserModelUpdateOneRequiredWithoutHs_providerNestedInput = {
    create?: XOR<BusinessUserModelCreateWithoutHs_providerInput, BusinessUserModelUncheckedCreateWithoutHs_providerInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutHs_providerInput
    upsert?: BusinessUserModelUpsertWithoutHs_providerInput
    connect?: BusinessUserModelWhereUniqueInput
    update?: XOR<BusinessUserModelUpdateWithoutHs_providerInput, BusinessUserModelUncheckedUpdateWithoutHs_providerInput>
  }

  export type HSIntroductionImageModelUpdateManyWithoutHs_providerNestedInput = {
    create?: XOR<Enumerable<HSIntroductionImageModelCreateWithoutHs_providerInput>, Enumerable<HSIntroductionImageModelUncheckedCreateWithoutHs_providerInput>>
    connectOrCreate?: Enumerable<HSIntroductionImageModelCreateOrConnectWithoutHs_providerInput>
    upsert?: Enumerable<HSIntroductionImageModelUpsertWithWhereUniqueWithoutHs_providerInput>
    createMany?: HSIntroductionImageModelCreateManyHs_providerInputEnvelope
    set?: Enumerable<HSIntroductionImageModelWhereUniqueInput>
    disconnect?: Enumerable<HSIntroductionImageModelWhereUniqueInput>
    delete?: Enumerable<HSIntroductionImageModelWhereUniqueInput>
    connect?: Enumerable<HSIntroductionImageModelWhereUniqueInput>
    update?: Enumerable<HSIntroductionImageModelUpdateWithWhereUniqueWithoutHs_providerInput>
    updateMany?: Enumerable<HSIntroductionImageModelUpdateManyWithWhereWithoutHs_providerInput>
    deleteMany?: Enumerable<HSIntroductionImageModelScalarWhereInput>
  }

  export type HSIntroductionImageModelUncheckedUpdateManyWithoutHs_providerNestedInput = {
    create?: XOR<Enumerable<HSIntroductionImageModelCreateWithoutHs_providerInput>, Enumerable<HSIntroductionImageModelUncheckedCreateWithoutHs_providerInput>>
    connectOrCreate?: Enumerable<HSIntroductionImageModelCreateOrConnectWithoutHs_providerInput>
    upsert?: Enumerable<HSIntroductionImageModelUpsertWithWhereUniqueWithoutHs_providerInput>
    createMany?: HSIntroductionImageModelCreateManyHs_providerInputEnvelope
    set?: Enumerable<HSIntroductionImageModelWhereUniqueInput>
    disconnect?: Enumerable<HSIntroductionImageModelWhereUniqueInput>
    delete?: Enumerable<HSIntroductionImageModelWhereUniqueInput>
    connect?: Enumerable<HSIntroductionImageModelWhereUniqueInput>
    update?: Enumerable<HSIntroductionImageModelUpdateWithWhereUniqueWithoutHs_providerInput>
    updateMany?: Enumerable<HSIntroductionImageModelUpdateManyWithWhereWithoutHs_providerInput>
    deleteMany?: Enumerable<HSIntroductionImageModelScalarWhereInput>
  }

  export type BusinessUserModelCreateNestedOneWithoutCertification_imagesInput = {
    create?: XOR<BusinessUserModelCreateWithoutCertification_imagesInput, BusinessUserModelUncheckedCreateWithoutCertification_imagesInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutCertification_imagesInput
    connect?: BusinessUserModelWhereUniqueInput
  }

  export type BusinessUserModelUpdateOneRequiredWithoutCertification_imagesNestedInput = {
    create?: XOR<BusinessUserModelCreateWithoutCertification_imagesInput, BusinessUserModelUncheckedCreateWithoutCertification_imagesInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutCertification_imagesInput
    upsert?: BusinessUserModelUpsertWithoutCertification_imagesInput
    connect?: BusinessUserModelWhereUniqueInput
    update?: XOR<BusinessUserModelUpdateWithoutCertification_imagesInput, BusinessUserModelUncheckedUpdateWithoutCertification_imagesInput>
  }

  export type HSProviderModelCreateNestedOneWithoutIntroduction_imagesInput = {
    create?: XOR<HSProviderModelCreateWithoutIntroduction_imagesInput, HSProviderModelUncheckedCreateWithoutIntroduction_imagesInput>
    connectOrCreate?: HSProviderModelCreateOrConnectWithoutIntroduction_imagesInput
    connect?: HSProviderModelWhereUniqueInput
  }

  export type HSProviderModelUpdateOneRequiredWithoutIntroduction_imagesNestedInput = {
    create?: XOR<HSProviderModelCreateWithoutIntroduction_imagesInput, HSProviderModelUncheckedCreateWithoutIntroduction_imagesInput>
    connectOrCreate?: HSProviderModelCreateOrConnectWithoutIntroduction_imagesInput
    upsert?: HSProviderModelUpsertWithoutIntroduction_imagesInput
    connect?: HSProviderModelWhereUniqueInput
    update?: XOR<HSProviderModelUpdateWithoutIntroduction_imagesInput, HSProviderModelUncheckedUpdateWithoutIntroduction_imagesInput>
  }

  export type BusinessUserModelCreateNestedOneWithoutOauth_accountsInput = {
    create?: XOR<BusinessUserModelCreateWithoutOauth_accountsInput, BusinessUserModelUncheckedCreateWithoutOauth_accountsInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutOauth_accountsInput
    connect?: BusinessUserModelWhereUniqueInput
  }

  export type CustomerModelCreateNestedOneWithoutOauth_accountsInput = {
    create?: XOR<CustomerModelCreateWithoutOauth_accountsInput, CustomerModelUncheckedCreateWithoutOauth_accountsInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutOauth_accountsInput
    connect?: CustomerModelWhereUniqueInput
  }

  export type EnumOauthTypeFieldUpdateOperationsInput = {
    set?: OauthType
  }

  export type BusinessUserModelUpdateOneWithoutOauth_accountsNestedInput = {
    create?: XOR<BusinessUserModelCreateWithoutOauth_accountsInput, BusinessUserModelUncheckedCreateWithoutOauth_accountsInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutOauth_accountsInput
    upsert?: BusinessUserModelUpsertWithoutOauth_accountsInput
    disconnect?: boolean
    delete?: boolean
    connect?: BusinessUserModelWhereUniqueInput
    update?: XOR<BusinessUserModelUpdateWithoutOauth_accountsInput, BusinessUserModelUncheckedUpdateWithoutOauth_accountsInput>
  }

  export type CustomerModelUpdateOneWithoutOauth_accountsNestedInput = {
    create?: XOR<CustomerModelCreateWithoutOauth_accountsInput, CustomerModelUncheckedCreateWithoutOauth_accountsInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutOauth_accountsInput
    upsert?: CustomerModelUpsertWithoutOauth_accountsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CustomerModelWhereUniqueInput
    update?: XOR<CustomerModelUpdateWithoutOauth_accountsInput, CustomerModelUncheckedUpdateWithoutOauth_accountsInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedEnumRateTargetTypeFilter = {
    equals?: RateTargetType
    in?: Enumerable<RateTargetType>
    notIn?: Enumerable<RateTargetType>
    not?: NestedEnumRateTargetTypeFilter | RateTargetType
  }

  export type NestedEnumRateTargetTypeWithAggregatesFilter = {
    equals?: RateTargetType
    in?: Enumerable<RateTargetType>
    notIn?: Enumerable<RateTargetType>
    not?: NestedEnumRateTargetTypeWithAggregatesFilter | RateTargetType
    _count?: NestedIntFilter
    _min?: NestedEnumRateTargetTypeFilter
    _max?: NestedEnumRateTargetTypeFilter
  }

  export type NestedEnumAgreementTargetTypeFilter = {
    equals?: AgreementTargetType
    in?: Enumerable<AgreementTargetType>
    notIn?: Enumerable<AgreementTargetType>
    not?: NestedEnumAgreementTargetTypeFilter | AgreementTargetType
  }

  export type NestedEnumAgreementTargetTypeWithAggregatesFilter = {
    equals?: AgreementTargetType
    in?: Enumerable<AgreementTargetType>
    notIn?: Enumerable<AgreementTargetType>
    not?: NestedEnumAgreementTargetTypeWithAggregatesFilter | AgreementTargetType
    _count?: NestedIntFilter
    _min?: NestedEnumAgreementTargetTypeFilter
    _max?: NestedEnumAgreementTargetTypeFilter
  }

  export type NestedEnumServiceTypeFilter = {
    equals?: ServiceType
    in?: Enumerable<ServiceType>
    notIn?: Enumerable<ServiceType>
    not?: NestedEnumServiceTypeFilter | ServiceType
  }

  export type NestedEnumServiceTypeWithAggregatesFilter = {
    equals?: ServiceType
    in?: Enumerable<ServiceType>
    notIn?: Enumerable<ServiceType>
    not?: NestedEnumServiceTypeWithAggregatesFilter | ServiceType
    _count?: NestedIntFilter
    _min?: NestedEnumServiceTypeFilter
    _max?: NestedEnumServiceTypeFilter
  }

  export type NestedEnumFocusCareStatusFilter = {
    equals?: FocusCareStatus
    in?: Enumerable<FocusCareStatus>
    notIn?: Enumerable<FocusCareStatus>
    not?: NestedEnumFocusCareStatusFilter | FocusCareStatus
  }

  export type NestedEnumFocusCareStatusWithAggregatesFilter = {
    equals?: FocusCareStatus
    in?: Enumerable<FocusCareStatus>
    notIn?: Enumerable<FocusCareStatus>
    not?: NestedEnumFocusCareStatusWithAggregatesFilter | FocusCareStatus
    _count?: NestedIntFilter
    _min?: NestedEnumFocusCareStatusFilter
    _max?: NestedEnumFocusCareStatusFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedEnumGenderTypeNullableFilter = {
    equals?: GenderType | null
    in?: Enumerable<GenderType> | null
    notIn?: Enumerable<GenderType> | null
    not?: NestedEnumGenderTypeNullableFilter | GenderType | null
  }

  export type NestedEnumGenderTypeNullableWithAggregatesFilter = {
    equals?: GenderType | null
    in?: Enumerable<GenderType> | null
    notIn?: Enumerable<GenderType> | null
    not?: NestedEnumGenderTypeNullableWithAggregatesFilter | GenderType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumGenderTypeNullableFilter
    _max?: NestedEnumGenderTypeNullableFilter
  }

  export type NestedEnumOauthTypeFilter = {
    equals?: OauthType
    in?: Enumerable<OauthType>
    notIn?: Enumerable<OauthType>
    not?: NestedEnumOauthTypeFilter | OauthType
  }

  export type NestedEnumOauthTypeWithAggregatesFilter = {
    equals?: OauthType
    in?: Enumerable<OauthType>
    notIn?: Enumerable<OauthType>
    not?: NestedEnumOauthTypeWithAggregatesFilter | OauthType
    _count?: NestedIntFilter
    _min?: NestedEnumOauthTypeFilter
    _max?: NestedEnumOauthTypeFilter
  }

  export type REAgentModelCreateWithoutPropertiesInput = {
    is_licensed: boolean
    re_num: string
    re_name: string
    re_phone: string
    re_licensed_agent_name: string
    base: BusinessUserModelCreateNestedOneWithoutRe_agentInput
  }

  export type REAgentModelUncheckedCreateWithoutPropertiesInput = {
    id: string
    is_licensed: boolean
    re_num: string
    re_name: string
    re_phone: string
    re_licensed_agent_name: string
  }

  export type REAgentModelCreateOrConnectWithoutPropertiesInput = {
    where: REAgentModelWhereUniqueInput
    create: XOR<REAgentModelCreateWithoutPropertiesInput, REAgentModelUncheckedCreateWithoutPropertiesInput>
  }

  export type REPropertyCategoryModelCreateWithoutRe_propertyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    sub_category: REPropertySubCategoryModelCreateNestedOneWithoutProperty_categoriesInput
  }

  export type REPropertyCategoryModelUncheckedCreateWithoutRe_propertyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    sub_category_id: string
  }

  export type REPropertyCategoryModelCreateOrConnectWithoutRe_propertyInput = {
    where: REPropertyCategoryModelWhereUniqueInput
    create: XOR<REPropertyCategoryModelCreateWithoutRe_propertyInput, REPropertyCategoryModelUncheckedCreateWithoutRe_propertyInput>
  }

  export type REPropertyCategoryModelCreateManyRe_propertyInputEnvelope = {
    data: Enumerable<REPropertyCategoryModelCreateManyRe_propertyInput>
    skipDuplicates?: boolean
  }

  export type REAgentModelUpsertWithoutPropertiesInput = {
    update: XOR<REAgentModelUpdateWithoutPropertiesInput, REAgentModelUncheckedUpdateWithoutPropertiesInput>
    create: XOR<REAgentModelCreateWithoutPropertiesInput, REAgentModelUncheckedCreateWithoutPropertiesInput>
  }

  export type REAgentModelUpdateWithoutPropertiesInput = {
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    re_num?: StringFieldUpdateOperationsInput | string
    re_name?: StringFieldUpdateOperationsInput | string
    re_phone?: StringFieldUpdateOperationsInput | string
    re_licensed_agent_name?: StringFieldUpdateOperationsInput | string
    base?: BusinessUserModelUpdateOneRequiredWithoutRe_agentNestedInput
  }

  export type REAgentModelUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    re_num?: StringFieldUpdateOperationsInput | string
    re_name?: StringFieldUpdateOperationsInput | string
    re_phone?: StringFieldUpdateOperationsInput | string
    re_licensed_agent_name?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertyCategoryModelUpsertWithWhereUniqueWithoutRe_propertyInput = {
    where: REPropertyCategoryModelWhereUniqueInput
    update: XOR<REPropertyCategoryModelUpdateWithoutRe_propertyInput, REPropertyCategoryModelUncheckedUpdateWithoutRe_propertyInput>
    create: XOR<REPropertyCategoryModelCreateWithoutRe_propertyInput, REPropertyCategoryModelUncheckedCreateWithoutRe_propertyInput>
  }

  export type REPropertyCategoryModelUpdateWithWhereUniqueWithoutRe_propertyInput = {
    where: REPropertyCategoryModelWhereUniqueInput
    data: XOR<REPropertyCategoryModelUpdateWithoutRe_propertyInput, REPropertyCategoryModelUncheckedUpdateWithoutRe_propertyInput>
  }

  export type REPropertyCategoryModelUpdateManyWithWhereWithoutRe_propertyInput = {
    where: REPropertyCategoryModelScalarWhereInput
    data: XOR<REPropertyCategoryModelUpdateManyMutationInput, REPropertyCategoryModelUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type REPropertyCategoryModelScalarWhereInput = {
    AND?: Enumerable<REPropertyCategoryModelScalarWhereInput>
    OR?: Enumerable<REPropertyCategoryModelScalarWhereInput>
    NOT?: Enumerable<REPropertyCategoryModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    re_property_id?: StringFilter | string
    sub_category_id?: StringFilter | string
  }

  export type REProertyModelCreateWithoutCategoriesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    main_image_url: string
    re_agent: REAgentModelCreateNestedOneWithoutPropertiesInput
  }

  export type REProertyModelUncheckedCreateWithoutCategoriesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    main_image_url: string
    re_agent_id: string
  }

  export type REProertyModelCreateOrConnectWithoutCategoriesInput = {
    where: REProertyModelWhereUniqueInput
    create: XOR<REProertyModelCreateWithoutCategoriesInput, REProertyModelUncheckedCreateWithoutCategoriesInput>
  }

  export type REPropertySubCategoryModelCreateWithoutProperty_categoriesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    middle_category: REPropertyMiddleCategoryModelCreateNestedOneWithoutSub_categoriesInput
  }

  export type REPropertySubCategoryModelUncheckedCreateWithoutProperty_categoriesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    middle_category_id: string
  }

  export type REPropertySubCategoryModelCreateOrConnectWithoutProperty_categoriesInput = {
    where: REPropertySubCategoryModelWhereUniqueInput
    create: XOR<REPropertySubCategoryModelCreateWithoutProperty_categoriesInput, REPropertySubCategoryModelUncheckedCreateWithoutProperty_categoriesInput>
  }

  export type REProertyModelUpsertWithoutCategoriesInput = {
    update: XOR<REProertyModelUpdateWithoutCategoriesInput, REProertyModelUncheckedUpdateWithoutCategoriesInput>
    create: XOR<REProertyModelCreateWithoutCategoriesInput, REProertyModelUncheckedCreateWithoutCategoriesInput>
  }

  export type REProertyModelUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
    re_agent?: REAgentModelUpdateOneRequiredWithoutPropertiesNestedInput
  }

  export type REProertyModelUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
    re_agent_id?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertySubCategoryModelUpsertWithoutProperty_categoriesInput = {
    update: XOR<REPropertySubCategoryModelUpdateWithoutProperty_categoriesInput, REPropertySubCategoryModelUncheckedUpdateWithoutProperty_categoriesInput>
    create: XOR<REPropertySubCategoryModelCreateWithoutProperty_categoriesInput, REPropertySubCategoryModelUncheckedCreateWithoutProperty_categoriesInput>
  }

  export type REPropertySubCategoryModelUpdateWithoutProperty_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    middle_category?: REPropertyMiddleCategoryModelUpdateOneRequiredWithoutSub_categoriesNestedInput
  }

  export type REPropertySubCategoryModelUncheckedUpdateWithoutProperty_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    middle_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertyMiddleCategoryModelCreateWithoutSub_categoriesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    super_category: REPropertySuperCategoryModelCreateNestedOneWithoutMiddle_categoriesInput
  }

  export type REPropertyMiddleCategoryModelUncheckedCreateWithoutSub_categoriesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    super_category_id: string
  }

  export type REPropertyMiddleCategoryModelCreateOrConnectWithoutSub_categoriesInput = {
    where: REPropertyMiddleCategoryModelWhereUniqueInput
    create: XOR<REPropertyMiddleCategoryModelCreateWithoutSub_categoriesInput, REPropertyMiddleCategoryModelUncheckedCreateWithoutSub_categoriesInput>
  }

  export type REPropertyCategoryModelCreateWithoutSub_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    re_property: REProertyModelCreateNestedOneWithoutCategoriesInput
  }

  export type REPropertyCategoryModelUncheckedCreateWithoutSub_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    re_property_id: string
  }

  export type REPropertyCategoryModelCreateOrConnectWithoutSub_categoryInput = {
    where: REPropertyCategoryModelWhereUniqueInput
    create: XOR<REPropertyCategoryModelCreateWithoutSub_categoryInput, REPropertyCategoryModelUncheckedCreateWithoutSub_categoryInput>
  }

  export type REPropertyCategoryModelCreateManySub_categoryInputEnvelope = {
    data: Enumerable<REPropertyCategoryModelCreateManySub_categoryInput>
    skipDuplicates?: boolean
  }

  export type REPropertyMiddleCategoryModelUpsertWithoutSub_categoriesInput = {
    update: XOR<REPropertyMiddleCategoryModelUpdateWithoutSub_categoriesInput, REPropertyMiddleCategoryModelUncheckedUpdateWithoutSub_categoriesInput>
    create: XOR<REPropertyMiddleCategoryModelCreateWithoutSub_categoriesInput, REPropertyMiddleCategoryModelUncheckedCreateWithoutSub_categoriesInput>
  }

  export type REPropertyMiddleCategoryModelUpdateWithoutSub_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    super_category?: REPropertySuperCategoryModelUpdateOneRequiredWithoutMiddle_categoriesNestedInput
  }

  export type REPropertyMiddleCategoryModelUncheckedUpdateWithoutSub_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    super_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertyCategoryModelUpsertWithWhereUniqueWithoutSub_categoryInput = {
    where: REPropertyCategoryModelWhereUniqueInput
    update: XOR<REPropertyCategoryModelUpdateWithoutSub_categoryInput, REPropertyCategoryModelUncheckedUpdateWithoutSub_categoryInput>
    create: XOR<REPropertyCategoryModelCreateWithoutSub_categoryInput, REPropertyCategoryModelUncheckedCreateWithoutSub_categoryInput>
  }

  export type REPropertyCategoryModelUpdateWithWhereUniqueWithoutSub_categoryInput = {
    where: REPropertyCategoryModelWhereUniqueInput
    data: XOR<REPropertyCategoryModelUpdateWithoutSub_categoryInput, REPropertyCategoryModelUncheckedUpdateWithoutSub_categoryInput>
  }

  export type REPropertyCategoryModelUpdateManyWithWhereWithoutSub_categoryInput = {
    where: REPropertyCategoryModelScalarWhereInput
    data: XOR<REPropertyCategoryModelUpdateManyMutationInput, REPropertyCategoryModelUncheckedUpdateManyWithoutProperty_categoriesInput>
  }

  export type REPropertySuperCategoryModelCreateWithoutMiddle_categoriesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
  }

  export type REPropertySuperCategoryModelUncheckedCreateWithoutMiddle_categoriesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
  }

  export type REPropertySuperCategoryModelCreateOrConnectWithoutMiddle_categoriesInput = {
    where: REPropertySuperCategoryModelWhereUniqueInput
    create: XOR<REPropertySuperCategoryModelCreateWithoutMiddle_categoriesInput, REPropertySuperCategoryModelUncheckedCreateWithoutMiddle_categoriesInput>
  }

  export type REPropertySubCategoryModelCreateWithoutMiddle_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    property_categories?: REPropertyCategoryModelCreateNestedManyWithoutSub_categoryInput
  }

  export type REPropertySubCategoryModelUncheckedCreateWithoutMiddle_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    property_categories?: REPropertyCategoryModelUncheckedCreateNestedManyWithoutSub_categoryInput
  }

  export type REPropertySubCategoryModelCreateOrConnectWithoutMiddle_categoryInput = {
    where: REPropertySubCategoryModelWhereUniqueInput
    create: XOR<REPropertySubCategoryModelCreateWithoutMiddle_categoryInput, REPropertySubCategoryModelUncheckedCreateWithoutMiddle_categoryInput>
  }

  export type REPropertySubCategoryModelCreateManyMiddle_categoryInputEnvelope = {
    data: Enumerable<REPropertySubCategoryModelCreateManyMiddle_categoryInput>
    skipDuplicates?: boolean
  }

  export type REPropertySuperCategoryModelUpsertWithoutMiddle_categoriesInput = {
    update: XOR<REPropertySuperCategoryModelUpdateWithoutMiddle_categoriesInput, REPropertySuperCategoryModelUncheckedUpdateWithoutMiddle_categoriesInput>
    create: XOR<REPropertySuperCategoryModelCreateWithoutMiddle_categoriesInput, REPropertySuperCategoryModelUncheckedCreateWithoutMiddle_categoriesInput>
  }

  export type REPropertySuperCategoryModelUpdateWithoutMiddle_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertySuperCategoryModelUncheckedUpdateWithoutMiddle_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertySubCategoryModelUpsertWithWhereUniqueWithoutMiddle_categoryInput = {
    where: REPropertySubCategoryModelWhereUniqueInput
    update: XOR<REPropertySubCategoryModelUpdateWithoutMiddle_categoryInput, REPropertySubCategoryModelUncheckedUpdateWithoutMiddle_categoryInput>
    create: XOR<REPropertySubCategoryModelCreateWithoutMiddle_categoryInput, REPropertySubCategoryModelUncheckedCreateWithoutMiddle_categoryInput>
  }

  export type REPropertySubCategoryModelUpdateWithWhereUniqueWithoutMiddle_categoryInput = {
    where: REPropertySubCategoryModelWhereUniqueInput
    data: XOR<REPropertySubCategoryModelUpdateWithoutMiddle_categoryInput, REPropertySubCategoryModelUncheckedUpdateWithoutMiddle_categoryInput>
  }

  export type REPropertySubCategoryModelUpdateManyWithWhereWithoutMiddle_categoryInput = {
    where: REPropertySubCategoryModelScalarWhereInput
    data: XOR<REPropertySubCategoryModelUpdateManyMutationInput, REPropertySubCategoryModelUncheckedUpdateManyWithoutSub_categoriesInput>
  }

  export type REPropertySubCategoryModelScalarWhereInput = {
    AND?: Enumerable<REPropertySubCategoryModelScalarWhereInput>
    OR?: Enumerable<REPropertySubCategoryModelScalarWhereInput>
    NOT?: Enumerable<REPropertySubCategoryModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    name?: StringFilter | string
    middle_category_id?: StringFilter | string
  }

  export type REPropertyMiddleCategoryModelCreateWithoutSuper_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    sub_categories?: REPropertySubCategoryModelCreateNestedManyWithoutMiddle_categoryInput
  }

  export type REPropertyMiddleCategoryModelUncheckedCreateWithoutSuper_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    sub_categories?: REPropertySubCategoryModelUncheckedCreateNestedManyWithoutMiddle_categoryInput
  }

  export type REPropertyMiddleCategoryModelCreateOrConnectWithoutSuper_categoryInput = {
    where: REPropertyMiddleCategoryModelWhereUniqueInput
    create: XOR<REPropertyMiddleCategoryModelCreateWithoutSuper_categoryInput, REPropertyMiddleCategoryModelUncheckedCreateWithoutSuper_categoryInput>
  }

  export type REPropertyMiddleCategoryModelCreateManySuper_categoryInputEnvelope = {
    data: Enumerable<REPropertyMiddleCategoryModelCreateManySuper_categoryInput>
    skipDuplicates?: boolean
  }

  export type REPropertyMiddleCategoryModelUpsertWithWhereUniqueWithoutSuper_categoryInput = {
    where: REPropertyMiddleCategoryModelWhereUniqueInput
    update: XOR<REPropertyMiddleCategoryModelUpdateWithoutSuper_categoryInput, REPropertyMiddleCategoryModelUncheckedUpdateWithoutSuper_categoryInput>
    create: XOR<REPropertyMiddleCategoryModelCreateWithoutSuper_categoryInput, REPropertyMiddleCategoryModelUncheckedCreateWithoutSuper_categoryInput>
  }

  export type REPropertyMiddleCategoryModelUpdateWithWhereUniqueWithoutSuper_categoryInput = {
    where: REPropertyMiddleCategoryModelWhereUniqueInput
    data: XOR<REPropertyMiddleCategoryModelUpdateWithoutSuper_categoryInput, REPropertyMiddleCategoryModelUncheckedUpdateWithoutSuper_categoryInput>
  }

  export type REPropertyMiddleCategoryModelUpdateManyWithWhereWithoutSuper_categoryInput = {
    where: REPropertyMiddleCategoryModelScalarWhereInput
    data: XOR<REPropertyMiddleCategoryModelUpdateManyMutationInput, REPropertyMiddleCategoryModelUncheckedUpdateManyWithoutMiddle_categoriesInput>
  }

  export type REPropertyMiddleCategoryModelScalarWhereInput = {
    AND?: Enumerable<REPropertyMiddleCategoryModelScalarWhereInput>
    OR?: Enumerable<REPropertyMiddleCategoryModelScalarWhereInput>
    NOT?: Enumerable<REPropertyMiddleCategoryModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    name?: StringFilter | string
    super_category_id?: StringFilter | string
  }

  export type CustomerModelCreateWithoutReviewsInput = {
    birth?: string | null
    gender?: GenderType | null
    phone?: string | null
    address_first?: string | null
    address_second?: string | null
    profile_image_url?: string | null
    base: UserModelCreateNestedOneWithoutCustomerInput
    oauth_accounts?: OauthAccountModelCreateNestedManyWithoutCustomerInput
    focus_care_requests?: FocusCareRequestModelCreateNestedManyWithoutRequesterInput
  }

  export type CustomerModelUncheckedCreateWithoutReviewsInput = {
    id: string
    birth?: string | null
    gender?: GenderType | null
    phone?: string | null
    address_first?: string | null
    address_second?: string | null
    profile_image_url?: string | null
    oauth_accounts?: OauthAccountModelUncheckedCreateNestedManyWithoutCustomerInput
    focus_care_requests?: FocusCareRequestModelUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type CustomerModelCreateOrConnectWithoutReviewsInput = {
    where: CustomerModelWhereUniqueInput
    create: XOR<CustomerModelCreateWithoutReviewsInput, CustomerModelUncheckedCreateWithoutReviewsInput>
  }

  export type BusinessUserModelCreateWithoutReviewsInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    base: UserModelCreateNestedOneWithoutBusiness_userInput
    re_agent?: REAgentModelCreateNestedOneWithoutBaseInput
    hs_provider?: HSProviderModelCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelCreateNestedManyWithoutBusiness_userInput
    sub_expertises?: SubExpertiseModelCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelCreateNestedManyWithoutBusiness_userInput
  }

  export type BusinessUserModelUncheckedCreateWithoutReviewsInput = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    re_agent?: REAgentModelUncheckedCreateNestedOneWithoutBaseInput
    hs_provider?: HSProviderModelUncheckedCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelUncheckedCreateNestedManyWithoutBusiness_userInput
    sub_expertises?: SubExpertiseModelUncheckedCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelUncheckedCreateNestedManyWithoutBusiness_userInput
  }

  export type BusinessUserModelCreateOrConnectWithoutReviewsInput = {
    where: BusinessUserModelWhereUniqueInput
    create: XOR<BusinessUserModelCreateWithoutReviewsInput, BusinessUserModelUncheckedCreateWithoutReviewsInput>
  }

  export type RateModelCreateWithoutReviewInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    score: number
    category: RateCategoryModelCreateNestedOneWithoutRatesInput
  }

  export type RateModelUncheckedCreateWithoutReviewInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    score: number
    category_id: string
  }

  export type RateModelCreateOrConnectWithoutReviewInput = {
    where: RateModelWhereUniqueInput
    create: XOR<RateModelCreateWithoutReviewInput, RateModelUncheckedCreateWithoutReviewInput>
  }

  export type RateModelCreateManyReviewInputEnvelope = {
    data: Enumerable<RateModelCreateManyReviewInput>
    skipDuplicates?: boolean
  }

  export type CustomerModelUpsertWithoutReviewsInput = {
    update: XOR<CustomerModelUpdateWithoutReviewsInput, CustomerModelUncheckedUpdateWithoutReviewsInput>
    create: XOR<CustomerModelCreateWithoutReviewsInput, CustomerModelUncheckedCreateWithoutReviewsInput>
  }

  export type CustomerModelUpdateWithoutReviewsInput = {
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    base?: UserModelUpdateOneRequiredWithoutCustomerNestedInput
    oauth_accounts?: OauthAccountModelUpdateManyWithoutCustomerNestedInput
    focus_care_requests?: FocusCareRequestModelUpdateManyWithoutRequesterNestedInput
  }

  export type CustomerModelUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_accounts?: OauthAccountModelUncheckedUpdateManyWithoutCustomerNestedInput
    focus_care_requests?: FocusCareRequestModelUncheckedUpdateManyWithoutRequesterNestedInput
  }

  export type BusinessUserModelUpsertWithoutReviewsInput = {
    update: XOR<BusinessUserModelUpdateWithoutReviewsInput, BusinessUserModelUncheckedUpdateWithoutReviewsInput>
    create: XOR<BusinessUserModelCreateWithoutReviewsInput, BusinessUserModelUncheckedCreateWithoutReviewsInput>
  }

  export type BusinessUserModelUpdateWithoutReviewsInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    base?: UserModelUpdateOneRequiredWithoutBusiness_userNestedInput
    re_agent?: REAgentModelUpdateOneWithoutBaseNestedInput
    hs_provider?: HSProviderModelUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUpdateManyWithoutBusiness_userNestedInput
    sub_expertises?: SubExpertiseModelUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUpdateManyWithoutBusiness_userNestedInput
  }

  export type BusinessUserModelUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    re_agent?: REAgentModelUncheckedUpdateOneWithoutBaseNestedInput
    hs_provider?: HSProviderModelUncheckedUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    sub_expertises?: SubExpertiseModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUncheckedUpdateManyWithoutBusiness_userNestedInput
  }

  export type RateModelUpsertWithWhereUniqueWithoutReviewInput = {
    where: RateModelWhereUniqueInput
    update: XOR<RateModelUpdateWithoutReviewInput, RateModelUncheckedUpdateWithoutReviewInput>
    create: XOR<RateModelCreateWithoutReviewInput, RateModelUncheckedCreateWithoutReviewInput>
  }

  export type RateModelUpdateWithWhereUniqueWithoutReviewInput = {
    where: RateModelWhereUniqueInput
    data: XOR<RateModelUpdateWithoutReviewInput, RateModelUncheckedUpdateWithoutReviewInput>
  }

  export type RateModelUpdateManyWithWhereWithoutReviewInput = {
    where: RateModelScalarWhereInput
    data: XOR<RateModelUpdateManyMutationInput, RateModelUncheckedUpdateManyWithoutRatesInput>
  }

  export type RateModelScalarWhereInput = {
    AND?: Enumerable<RateModelScalarWhereInput>
    OR?: Enumerable<RateModelScalarWhereInput>
    NOT?: Enumerable<RateModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    score?: IntFilter | number
    category_id?: StringFilter | string
    review_id?: StringFilter | string
  }

  export type RateCategoryModelCreateWithoutRatesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    target_type: RateTargetType
  }

  export type RateCategoryModelUncheckedCreateWithoutRatesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    target_type: RateTargetType
  }

  export type RateCategoryModelCreateOrConnectWithoutRatesInput = {
    where: RateCategoryModelWhereUniqueInput
    create: XOR<RateCategoryModelCreateWithoutRatesInput, RateCategoryModelUncheckedCreateWithoutRatesInput>
  }

  export type ReviewModelCreateWithoutRatesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    content: string
    reviewer: CustomerModelCreateNestedOneWithoutReviewsInput
    reviewee: BusinessUserModelCreateNestedOneWithoutReviewsInput
  }

  export type ReviewModelUncheckedCreateWithoutRatesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    reviewer_id: string
    reviewee_id: string
    content: string
  }

  export type ReviewModelCreateOrConnectWithoutRatesInput = {
    where: ReviewModelWhereUniqueInput
    create: XOR<ReviewModelCreateWithoutRatesInput, ReviewModelUncheckedCreateWithoutRatesInput>
  }

  export type RateCategoryModelUpsertWithoutRatesInput = {
    update: XOR<RateCategoryModelUpdateWithoutRatesInput, RateCategoryModelUncheckedUpdateWithoutRatesInput>
    create: XOR<RateCategoryModelCreateWithoutRatesInput, RateCategoryModelUncheckedCreateWithoutRatesInput>
  }

  export type RateCategoryModelUpdateWithoutRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    target_type?: EnumRateTargetTypeFieldUpdateOperationsInput | RateTargetType
  }

  export type RateCategoryModelUncheckedUpdateWithoutRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    target_type?: EnumRateTargetTypeFieldUpdateOperationsInput | RateTargetType
  }

  export type ReviewModelUpsertWithoutRatesInput = {
    update: XOR<ReviewModelUpdateWithoutRatesInput, ReviewModelUncheckedUpdateWithoutRatesInput>
    create: XOR<ReviewModelCreateWithoutRatesInput, ReviewModelUncheckedCreateWithoutRatesInput>
  }

  export type ReviewModelUpdateWithoutRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    reviewer?: CustomerModelUpdateOneRequiredWithoutReviewsNestedInput
    reviewee?: BusinessUserModelUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewModelUncheckedUpdateWithoutRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewer_id?: StringFieldUpdateOperationsInput | string
    reviewee_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type RateModelCreateWithoutCategoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    score: number
    review: ReviewModelCreateNestedOneWithoutRatesInput
  }

  export type RateModelUncheckedCreateWithoutCategoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    score: number
    review_id: string
  }

  export type RateModelCreateOrConnectWithoutCategoryInput = {
    where: RateModelWhereUniqueInput
    create: XOR<RateModelCreateWithoutCategoryInput, RateModelUncheckedCreateWithoutCategoryInput>
  }

  export type RateModelCreateManyCategoryInputEnvelope = {
    data: Enumerable<RateModelCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type RateModelUpsertWithWhereUniqueWithoutCategoryInput = {
    where: RateModelWhereUniqueInput
    update: XOR<RateModelUpdateWithoutCategoryInput, RateModelUncheckedUpdateWithoutCategoryInput>
    create: XOR<RateModelCreateWithoutCategoryInput, RateModelUncheckedCreateWithoutCategoryInput>
  }

  export type RateModelUpdateWithWhereUniqueWithoutCategoryInput = {
    where: RateModelWhereUniqueInput
    data: XOR<RateModelUpdateWithoutCategoryInput, RateModelUncheckedUpdateWithoutCategoryInput>
  }

  export type RateModelUpdateManyWithWhereWithoutCategoryInput = {
    where: RateModelScalarWhereInput
    data: XOR<RateModelUpdateManyMutationInput, RateModelUncheckedUpdateManyWithoutRatesInput>
  }

  export type AgreementAcceptanceModelCreateWithoutAgreementInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    user: UserModelCreateNestedOneWithoutAgreement_acceptancesInput
  }

  export type AgreementAcceptanceModelUncheckedCreateWithoutAgreementInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    user_id: string
  }

  export type AgreementAcceptanceModelCreateOrConnectWithoutAgreementInput = {
    where: AgreementAcceptanceModelWhereUniqueInput
    create: XOR<AgreementAcceptanceModelCreateWithoutAgreementInput, AgreementAcceptanceModelUncheckedCreateWithoutAgreementInput>
  }

  export type AgreementAcceptanceModelCreateManyAgreementInputEnvelope = {
    data: Enumerable<AgreementAcceptanceModelCreateManyAgreementInput>
    skipDuplicates?: boolean
  }

  export type AgreementAcceptanceModelUpsertWithWhereUniqueWithoutAgreementInput = {
    where: AgreementAcceptanceModelWhereUniqueInput
    update: XOR<AgreementAcceptanceModelUpdateWithoutAgreementInput, AgreementAcceptanceModelUncheckedUpdateWithoutAgreementInput>
    create: XOR<AgreementAcceptanceModelCreateWithoutAgreementInput, AgreementAcceptanceModelUncheckedCreateWithoutAgreementInput>
  }

  export type AgreementAcceptanceModelUpdateWithWhereUniqueWithoutAgreementInput = {
    where: AgreementAcceptanceModelWhereUniqueInput
    data: XOR<AgreementAcceptanceModelUpdateWithoutAgreementInput, AgreementAcceptanceModelUncheckedUpdateWithoutAgreementInput>
  }

  export type AgreementAcceptanceModelUpdateManyWithWhereWithoutAgreementInput = {
    where: AgreementAcceptanceModelScalarWhereInput
    data: XOR<AgreementAcceptanceModelUpdateManyMutationInput, AgreementAcceptanceModelUncheckedUpdateManyWithoutAcceptancesInput>
  }

  export type AgreementAcceptanceModelScalarWhereInput = {
    AND?: Enumerable<AgreementAcceptanceModelScalarWhereInput>
    OR?: Enumerable<AgreementAcceptanceModelScalarWhereInput>
    NOT?: Enumerable<AgreementAcceptanceModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    user_id?: StringFilter | string
    agreement_id?: StringFilter | string
  }

  export type UserModelCreateWithoutAgreement_acceptancesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    email?: string | null
    customer?: CustomerModelCreateNestedOneWithoutBaseInput
    business_user?: BusinessUserModelCreateNestedOneWithoutBaseInput
  }

  export type UserModelUncheckedCreateWithoutAgreement_acceptancesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    email?: string | null
    customer?: CustomerModelUncheckedCreateNestedOneWithoutBaseInput
    business_user?: BusinessUserModelUncheckedCreateNestedOneWithoutBaseInput
  }

  export type UserModelCreateOrConnectWithoutAgreement_acceptancesInput = {
    where: UserModelWhereUniqueInput
    create: XOR<UserModelCreateWithoutAgreement_acceptancesInput, UserModelUncheckedCreateWithoutAgreement_acceptancesInput>
  }

  export type AgreementModelCreateWithoutAcceptancesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    title: string
    content: string
    is_required: boolean
    target_type: AgreementTargetType
  }

  export type AgreementModelUncheckedCreateWithoutAcceptancesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    title: string
    content: string
    is_required: boolean
    target_type: AgreementTargetType
  }

  export type AgreementModelCreateOrConnectWithoutAcceptancesInput = {
    where: AgreementModelWhereUniqueInput
    create: XOR<AgreementModelCreateWithoutAcceptancesInput, AgreementModelUncheckedCreateWithoutAcceptancesInput>
  }

  export type UserModelUpsertWithoutAgreement_acceptancesInput = {
    update: XOR<UserModelUpdateWithoutAgreement_acceptancesInput, UserModelUncheckedUpdateWithoutAgreement_acceptancesInput>
    create: XOR<UserModelCreateWithoutAgreement_acceptancesInput, UserModelUncheckedCreateWithoutAgreement_acceptancesInput>
  }

  export type UserModelUpdateWithoutAgreement_acceptancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerModelUpdateOneWithoutBaseNestedInput
    business_user?: BusinessUserModelUpdateOneWithoutBaseNestedInput
  }

  export type UserModelUncheckedUpdateWithoutAgreement_acceptancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerModelUncheckedUpdateOneWithoutBaseNestedInput
    business_user?: BusinessUserModelUncheckedUpdateOneWithoutBaseNestedInput
  }

  export type AgreementModelUpsertWithoutAcceptancesInput = {
    update: XOR<AgreementModelUpdateWithoutAcceptancesInput, AgreementModelUncheckedUpdateWithoutAcceptancesInput>
    create: XOR<AgreementModelCreateWithoutAcceptancesInput, AgreementModelUncheckedCreateWithoutAcceptancesInput>
  }

  export type AgreementModelUpdateWithoutAcceptancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_required?: BoolFieldUpdateOperationsInput | boolean
    target_type?: EnumAgreementTargetTypeFieldUpdateOperationsInput | AgreementTargetType
  }

  export type AgreementModelUncheckedUpdateWithoutAcceptancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_required?: BoolFieldUpdateOperationsInput | boolean
    target_type?: EnumAgreementTargetTypeFieldUpdateOperationsInput | AgreementTargetType
  }

  export type FocusCareConsultationTimeCheckModelCreateWithoutConsultation_timeInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    request: FocusCareRequestModelCreateNestedOneWithoutConsultation_timesInput
  }

  export type FocusCareConsultationTimeCheckModelUncheckedCreateWithoutConsultation_timeInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    request_id: string
  }

  export type FocusCareConsultationTimeCheckModelCreateOrConnectWithoutConsultation_timeInput = {
    where: FocusCareConsultationTimeCheckModelWhereUniqueInput
    create: XOR<FocusCareConsultationTimeCheckModelCreateWithoutConsultation_timeInput, FocusCareConsultationTimeCheckModelUncheckedCreateWithoutConsultation_timeInput>
  }

  export type FocusCareConsultationTimeCheckModelCreateManyConsultation_timeInputEnvelope = {
    data: Enumerable<FocusCareConsultationTimeCheckModelCreateManyConsultation_timeInput>
    skipDuplicates?: boolean
  }

  export type FocusCareConsultationTimeCheckModelUpsertWithWhereUniqueWithoutConsultation_timeInput = {
    where: FocusCareConsultationTimeCheckModelWhereUniqueInput
    update: XOR<FocusCareConsultationTimeCheckModelUpdateWithoutConsultation_timeInput, FocusCareConsultationTimeCheckModelUncheckedUpdateWithoutConsultation_timeInput>
    create: XOR<FocusCareConsultationTimeCheckModelCreateWithoutConsultation_timeInput, FocusCareConsultationTimeCheckModelUncheckedCreateWithoutConsultation_timeInput>
  }

  export type FocusCareConsultationTimeCheckModelUpdateWithWhereUniqueWithoutConsultation_timeInput = {
    where: FocusCareConsultationTimeCheckModelWhereUniqueInput
    data: XOR<FocusCareConsultationTimeCheckModelUpdateWithoutConsultation_timeInput, FocusCareConsultationTimeCheckModelUncheckedUpdateWithoutConsultation_timeInput>
  }

  export type FocusCareConsultationTimeCheckModelUpdateManyWithWhereWithoutConsultation_timeInput = {
    where: FocusCareConsultationTimeCheckModelScalarWhereInput
    data: XOR<FocusCareConsultationTimeCheckModelUpdateManyMutationInput, FocusCareConsultationTimeCheckModelUncheckedUpdateManyWithoutFocus_care_checksInput>
  }

  export type FocusCareConsultationTimeCheckModelScalarWhereInput = {
    AND?: Enumerable<FocusCareConsultationTimeCheckModelScalarWhereInput>
    OR?: Enumerable<FocusCareConsultationTimeCheckModelScalarWhereInput>
    NOT?: Enumerable<FocusCareConsultationTimeCheckModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    consultation_time_id?: StringFilter | string
    request_id?: StringFilter | string
  }

  export type ServiceSuperCategoryModelCreateWithoutSub_categoriesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    type: ServiceType
    focus_care_checks?: FocusCareServiceCheckModelCreateNestedManyWithoutService_super_categoryInput
  }

  export type ServiceSuperCategoryModelUncheckedCreateWithoutSub_categoriesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    type: ServiceType
    focus_care_checks?: FocusCareServiceCheckModelUncheckedCreateNestedManyWithoutService_super_categoryInput
  }

  export type ServiceSuperCategoryModelCreateOrConnectWithoutSub_categoriesInput = {
    where: ServiceSuperCategoryModelWhereUniqueInput
    create: XOR<ServiceSuperCategoryModelCreateWithoutSub_categoriesInput, ServiceSuperCategoryModelUncheckedCreateWithoutSub_categoriesInput>
  }

  export type SubExpertiseModelCreateWithoutSub_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    business_user: BusinessUserModelCreateNestedOneWithoutSub_expertisesInput
  }

  export type SubExpertiseModelUncheckedCreateWithoutSub_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    business_user_id: string
  }

  export type SubExpertiseModelCreateOrConnectWithoutSub_categoryInput = {
    where: SubExpertiseModelWhereUniqueInput
    create: XOR<SubExpertiseModelCreateWithoutSub_categoryInput, SubExpertiseModelUncheckedCreateWithoutSub_categoryInput>
  }

  export type SubExpertiseModelCreateManySub_categoryInputEnvelope = {
    data: Enumerable<SubExpertiseModelCreateManySub_categoryInput>
    skipDuplicates?: boolean
  }

  export type ServiceSuperCategoryModelUpsertWithoutSub_categoriesInput = {
    update: XOR<ServiceSuperCategoryModelUpdateWithoutSub_categoriesInput, ServiceSuperCategoryModelUncheckedUpdateWithoutSub_categoriesInput>
    create: XOR<ServiceSuperCategoryModelCreateWithoutSub_categoriesInput, ServiceSuperCategoryModelUncheckedCreateWithoutSub_categoriesInput>
  }

  export type ServiceSuperCategoryModelUpdateWithoutSub_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | ServiceType
    focus_care_checks?: FocusCareServiceCheckModelUpdateManyWithoutService_super_categoryNestedInput
  }

  export type ServiceSuperCategoryModelUncheckedUpdateWithoutSub_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | ServiceType
    focus_care_checks?: FocusCareServiceCheckModelUncheckedUpdateManyWithoutService_super_categoryNestedInput
  }

  export type SubExpertiseModelUpsertWithWhereUniqueWithoutSub_categoryInput = {
    where: SubExpertiseModelWhereUniqueInput
    update: XOR<SubExpertiseModelUpdateWithoutSub_categoryInput, SubExpertiseModelUncheckedUpdateWithoutSub_categoryInput>
    create: XOR<SubExpertiseModelCreateWithoutSub_categoryInput, SubExpertiseModelUncheckedCreateWithoutSub_categoryInput>
  }

  export type SubExpertiseModelUpdateWithWhereUniqueWithoutSub_categoryInput = {
    where: SubExpertiseModelWhereUniqueInput
    data: XOR<SubExpertiseModelUpdateWithoutSub_categoryInput, SubExpertiseModelUncheckedUpdateWithoutSub_categoryInput>
  }

  export type SubExpertiseModelUpdateManyWithWhereWithoutSub_categoryInput = {
    where: SubExpertiseModelScalarWhereInput
    data: XOR<SubExpertiseModelUpdateManyMutationInput, SubExpertiseModelUncheckedUpdateManyWithoutExpertisesInput>
  }

  export type SubExpertiseModelScalarWhereInput = {
    AND?: Enumerable<SubExpertiseModelScalarWhereInput>
    OR?: Enumerable<SubExpertiseModelScalarWhereInput>
    NOT?: Enumerable<SubExpertiseModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    sub_category_id?: StringFilter | string
    business_user_id?: StringFilter | string
  }

  export type ServiceSubCategoryModelCreateWithoutSuper_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    expertises?: SubExpertiseModelCreateNestedManyWithoutSub_categoryInput
  }

  export type ServiceSubCategoryModelUncheckedCreateWithoutSuper_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    expertises?: SubExpertiseModelUncheckedCreateNestedManyWithoutSub_categoryInput
  }

  export type ServiceSubCategoryModelCreateOrConnectWithoutSuper_categoryInput = {
    where: ServiceSubCategoryModelWhereUniqueInput
    create: XOR<ServiceSubCategoryModelCreateWithoutSuper_categoryInput, ServiceSubCategoryModelUncheckedCreateWithoutSuper_categoryInput>
  }

  export type ServiceSubCategoryModelCreateManySuper_categoryInputEnvelope = {
    data: Enumerable<ServiceSubCategoryModelCreateManySuper_categoryInput>
    skipDuplicates?: boolean
  }

  export type FocusCareServiceCheckModelCreateWithoutService_super_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    request: FocusCareRequestModelCreateNestedOneWithoutServicesInput
  }

  export type FocusCareServiceCheckModelUncheckedCreateWithoutService_super_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    request_id: string
  }

  export type FocusCareServiceCheckModelCreateOrConnectWithoutService_super_categoryInput = {
    where: FocusCareServiceCheckModelWhereUniqueInput
    create: XOR<FocusCareServiceCheckModelCreateWithoutService_super_categoryInput, FocusCareServiceCheckModelUncheckedCreateWithoutService_super_categoryInput>
  }

  export type FocusCareServiceCheckModelCreateManyService_super_categoryInputEnvelope = {
    data: Enumerable<FocusCareServiceCheckModelCreateManyService_super_categoryInput>
    skipDuplicates?: boolean
  }

  export type ServiceSubCategoryModelUpsertWithWhereUniqueWithoutSuper_categoryInput = {
    where: ServiceSubCategoryModelWhereUniqueInput
    update: XOR<ServiceSubCategoryModelUpdateWithoutSuper_categoryInput, ServiceSubCategoryModelUncheckedUpdateWithoutSuper_categoryInput>
    create: XOR<ServiceSubCategoryModelCreateWithoutSuper_categoryInput, ServiceSubCategoryModelUncheckedCreateWithoutSuper_categoryInput>
  }

  export type ServiceSubCategoryModelUpdateWithWhereUniqueWithoutSuper_categoryInput = {
    where: ServiceSubCategoryModelWhereUniqueInput
    data: XOR<ServiceSubCategoryModelUpdateWithoutSuper_categoryInput, ServiceSubCategoryModelUncheckedUpdateWithoutSuper_categoryInput>
  }

  export type ServiceSubCategoryModelUpdateManyWithWhereWithoutSuper_categoryInput = {
    where: ServiceSubCategoryModelScalarWhereInput
    data: XOR<ServiceSubCategoryModelUpdateManyMutationInput, ServiceSubCategoryModelUncheckedUpdateManyWithoutSub_categoriesInput>
  }

  export type ServiceSubCategoryModelScalarWhereInput = {
    AND?: Enumerable<ServiceSubCategoryModelScalarWhereInput>
    OR?: Enumerable<ServiceSubCategoryModelScalarWhereInput>
    NOT?: Enumerable<ServiceSubCategoryModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    name?: StringFilter | string
    super_category_id?: StringFilter | string
  }

  export type FocusCareServiceCheckModelUpsertWithWhereUniqueWithoutService_super_categoryInput = {
    where: FocusCareServiceCheckModelWhereUniqueInput
    update: XOR<FocusCareServiceCheckModelUpdateWithoutService_super_categoryInput, FocusCareServiceCheckModelUncheckedUpdateWithoutService_super_categoryInput>
    create: XOR<FocusCareServiceCheckModelCreateWithoutService_super_categoryInput, FocusCareServiceCheckModelUncheckedCreateWithoutService_super_categoryInput>
  }

  export type FocusCareServiceCheckModelUpdateWithWhereUniqueWithoutService_super_categoryInput = {
    where: FocusCareServiceCheckModelWhereUniqueInput
    data: XOR<FocusCareServiceCheckModelUpdateWithoutService_super_categoryInput, FocusCareServiceCheckModelUncheckedUpdateWithoutService_super_categoryInput>
  }

  export type FocusCareServiceCheckModelUpdateManyWithWhereWithoutService_super_categoryInput = {
    where: FocusCareServiceCheckModelScalarWhereInput
    data: XOR<FocusCareServiceCheckModelUpdateManyMutationInput, FocusCareServiceCheckModelUncheckedUpdateManyWithoutFocus_care_checksInput>
  }

  export type FocusCareServiceCheckModelScalarWhereInput = {
    AND?: Enumerable<FocusCareServiceCheckModelScalarWhereInput>
    OR?: Enumerable<FocusCareServiceCheckModelScalarWhereInput>
    NOT?: Enumerable<FocusCareServiceCheckModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    service_super_category_id?: StringFilter | string
    request_id?: StringFilter | string
  }

  export type CustomerModelCreateWithoutFocus_care_requestsInput = {
    birth?: string | null
    gender?: GenderType | null
    phone?: string | null
    address_first?: string | null
    address_second?: string | null
    profile_image_url?: string | null
    base: UserModelCreateNestedOneWithoutCustomerInput
    oauth_accounts?: OauthAccountModelCreateNestedManyWithoutCustomerInput
    reviews?: ReviewModelCreateNestedManyWithoutReviewerInput
  }

  export type CustomerModelUncheckedCreateWithoutFocus_care_requestsInput = {
    id: string
    birth?: string | null
    gender?: GenderType | null
    phone?: string | null
    address_first?: string | null
    address_second?: string | null
    profile_image_url?: string | null
    oauth_accounts?: OauthAccountModelUncheckedCreateNestedManyWithoutCustomerInput
    reviews?: ReviewModelUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type CustomerModelCreateOrConnectWithoutFocus_care_requestsInput = {
    where: CustomerModelWhereUniqueInput
    create: XOR<CustomerModelCreateWithoutFocus_care_requestsInput, CustomerModelUncheckedCreateWithoutFocus_care_requestsInput>
  }

  export type FocusCareConsultationTimeCheckModelCreateWithoutRequestInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    consultation_time: ConsultationTimeModelCreateNestedOneWithoutFocus_care_checksInput
  }

  export type FocusCareConsultationTimeCheckModelUncheckedCreateWithoutRequestInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    consultation_time_id: string
  }

  export type FocusCareConsultationTimeCheckModelCreateOrConnectWithoutRequestInput = {
    where: FocusCareConsultationTimeCheckModelWhereUniqueInput
    create: XOR<FocusCareConsultationTimeCheckModelCreateWithoutRequestInput, FocusCareConsultationTimeCheckModelUncheckedCreateWithoutRequestInput>
  }

  export type FocusCareConsultationTimeCheckModelCreateManyRequestInputEnvelope = {
    data: Enumerable<FocusCareConsultationTimeCheckModelCreateManyRequestInput>
    skipDuplicates?: boolean
  }

  export type FocusCareServiceCheckModelCreateWithoutRequestInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    service_super_category: ServiceSuperCategoryModelCreateNestedOneWithoutFocus_care_checksInput
  }

  export type FocusCareServiceCheckModelUncheckedCreateWithoutRequestInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    service_super_category_id: string
  }

  export type FocusCareServiceCheckModelCreateOrConnectWithoutRequestInput = {
    where: FocusCareServiceCheckModelWhereUniqueInput
    create: XOR<FocusCareServiceCheckModelCreateWithoutRequestInput, FocusCareServiceCheckModelUncheckedCreateWithoutRequestInput>
  }

  export type FocusCareServiceCheckModelCreateManyRequestInputEnvelope = {
    data: Enumerable<FocusCareServiceCheckModelCreateManyRequestInput>
    skipDuplicates?: boolean
  }

  export type CustomerModelUpsertWithoutFocus_care_requestsInput = {
    update: XOR<CustomerModelUpdateWithoutFocus_care_requestsInput, CustomerModelUncheckedUpdateWithoutFocus_care_requestsInput>
    create: XOR<CustomerModelCreateWithoutFocus_care_requestsInput, CustomerModelUncheckedCreateWithoutFocus_care_requestsInput>
  }

  export type CustomerModelUpdateWithoutFocus_care_requestsInput = {
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    base?: UserModelUpdateOneRequiredWithoutCustomerNestedInput
    oauth_accounts?: OauthAccountModelUpdateManyWithoutCustomerNestedInput
    reviews?: ReviewModelUpdateManyWithoutReviewerNestedInput
  }

  export type CustomerModelUncheckedUpdateWithoutFocus_care_requestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_accounts?: OauthAccountModelUncheckedUpdateManyWithoutCustomerNestedInput
    reviews?: ReviewModelUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type FocusCareConsultationTimeCheckModelUpsertWithWhereUniqueWithoutRequestInput = {
    where: FocusCareConsultationTimeCheckModelWhereUniqueInput
    update: XOR<FocusCareConsultationTimeCheckModelUpdateWithoutRequestInput, FocusCareConsultationTimeCheckModelUncheckedUpdateWithoutRequestInput>
    create: XOR<FocusCareConsultationTimeCheckModelCreateWithoutRequestInput, FocusCareConsultationTimeCheckModelUncheckedCreateWithoutRequestInput>
  }

  export type FocusCareConsultationTimeCheckModelUpdateWithWhereUniqueWithoutRequestInput = {
    where: FocusCareConsultationTimeCheckModelWhereUniqueInput
    data: XOR<FocusCareConsultationTimeCheckModelUpdateWithoutRequestInput, FocusCareConsultationTimeCheckModelUncheckedUpdateWithoutRequestInput>
  }

  export type FocusCareConsultationTimeCheckModelUpdateManyWithWhereWithoutRequestInput = {
    where: FocusCareConsultationTimeCheckModelScalarWhereInput
    data: XOR<FocusCareConsultationTimeCheckModelUpdateManyMutationInput, FocusCareConsultationTimeCheckModelUncheckedUpdateManyWithoutConsultation_timesInput>
  }

  export type FocusCareServiceCheckModelUpsertWithWhereUniqueWithoutRequestInput = {
    where: FocusCareServiceCheckModelWhereUniqueInput
    update: XOR<FocusCareServiceCheckModelUpdateWithoutRequestInput, FocusCareServiceCheckModelUncheckedUpdateWithoutRequestInput>
    create: XOR<FocusCareServiceCheckModelCreateWithoutRequestInput, FocusCareServiceCheckModelUncheckedCreateWithoutRequestInput>
  }

  export type FocusCareServiceCheckModelUpdateWithWhereUniqueWithoutRequestInput = {
    where: FocusCareServiceCheckModelWhereUniqueInput
    data: XOR<FocusCareServiceCheckModelUpdateWithoutRequestInput, FocusCareServiceCheckModelUncheckedUpdateWithoutRequestInput>
  }

  export type FocusCareServiceCheckModelUpdateManyWithWhereWithoutRequestInput = {
    where: FocusCareServiceCheckModelScalarWhereInput
    data: XOR<FocusCareServiceCheckModelUpdateManyMutationInput, FocusCareServiceCheckModelUncheckedUpdateManyWithoutServicesInput>
  }

  export type ServiceSuperCategoryModelCreateWithoutFocus_care_checksInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    type: ServiceType
    sub_categories?: ServiceSubCategoryModelCreateNestedManyWithoutSuper_categoryInput
  }

  export type ServiceSuperCategoryModelUncheckedCreateWithoutFocus_care_checksInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    type: ServiceType
    sub_categories?: ServiceSubCategoryModelUncheckedCreateNestedManyWithoutSuper_categoryInput
  }

  export type ServiceSuperCategoryModelCreateOrConnectWithoutFocus_care_checksInput = {
    where: ServiceSuperCategoryModelWhereUniqueInput
    create: XOR<ServiceSuperCategoryModelCreateWithoutFocus_care_checksInput, ServiceSuperCategoryModelUncheckedCreateWithoutFocus_care_checksInput>
  }

  export type FocusCareRequestModelCreateWithoutServicesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    care_start_date: Date | string
    care_end_date: Date | string
    detail: string
    status: FocusCareStatus
    requester: CustomerModelCreateNestedOneWithoutFocus_care_requestsInput
    consultation_times?: FocusCareConsultationTimeCheckModelCreateNestedManyWithoutRequestInput
  }

  export type FocusCareRequestModelUncheckedCreateWithoutServicesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    care_start_date: Date | string
    care_end_date: Date | string
    detail: string
    status: FocusCareStatus
    requester_id: string
    consultation_times?: FocusCareConsultationTimeCheckModelUncheckedCreateNestedManyWithoutRequestInput
  }

  export type FocusCareRequestModelCreateOrConnectWithoutServicesInput = {
    where: FocusCareRequestModelWhereUniqueInput
    create: XOR<FocusCareRequestModelCreateWithoutServicesInput, FocusCareRequestModelUncheckedCreateWithoutServicesInput>
  }

  export type ServiceSuperCategoryModelUpsertWithoutFocus_care_checksInput = {
    update: XOR<ServiceSuperCategoryModelUpdateWithoutFocus_care_checksInput, ServiceSuperCategoryModelUncheckedUpdateWithoutFocus_care_checksInput>
    create: XOR<ServiceSuperCategoryModelCreateWithoutFocus_care_checksInput, ServiceSuperCategoryModelUncheckedCreateWithoutFocus_care_checksInput>
  }

  export type ServiceSuperCategoryModelUpdateWithoutFocus_care_checksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | ServiceType
    sub_categories?: ServiceSubCategoryModelUpdateManyWithoutSuper_categoryNestedInput
  }

  export type ServiceSuperCategoryModelUncheckedUpdateWithoutFocus_care_checksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | ServiceType
    sub_categories?: ServiceSubCategoryModelUncheckedUpdateManyWithoutSuper_categoryNestedInput
  }

  export type FocusCareRequestModelUpsertWithoutServicesInput = {
    update: XOR<FocusCareRequestModelUpdateWithoutServicesInput, FocusCareRequestModelUncheckedUpdateWithoutServicesInput>
    create: XOR<FocusCareRequestModelCreateWithoutServicesInput, FocusCareRequestModelUncheckedCreateWithoutServicesInput>
  }

  export type FocusCareRequestModelUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    care_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    care_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: StringFieldUpdateOperationsInput | string
    status?: EnumFocusCareStatusFieldUpdateOperationsInput | FocusCareStatus
    requester?: CustomerModelUpdateOneRequiredWithoutFocus_care_requestsNestedInput
    consultation_times?: FocusCareConsultationTimeCheckModelUpdateManyWithoutRequestNestedInput
  }

  export type FocusCareRequestModelUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    care_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    care_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: StringFieldUpdateOperationsInput | string
    status?: EnumFocusCareStatusFieldUpdateOperationsInput | FocusCareStatus
    requester_id?: StringFieldUpdateOperationsInput | string
    consultation_times?: FocusCareConsultationTimeCheckModelUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type ConsultationTimeModelCreateWithoutFocus_care_checksInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    start_time: Date | string
    end_time: Date | string
  }

  export type ConsultationTimeModelUncheckedCreateWithoutFocus_care_checksInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    start_time: Date | string
    end_time: Date | string
  }

  export type ConsultationTimeModelCreateOrConnectWithoutFocus_care_checksInput = {
    where: ConsultationTimeModelWhereUniqueInput
    create: XOR<ConsultationTimeModelCreateWithoutFocus_care_checksInput, ConsultationTimeModelUncheckedCreateWithoutFocus_care_checksInput>
  }

  export type FocusCareRequestModelCreateWithoutConsultation_timesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    care_start_date: Date | string
    care_end_date: Date | string
    detail: string
    status: FocusCareStatus
    requester: CustomerModelCreateNestedOneWithoutFocus_care_requestsInput
    services?: FocusCareServiceCheckModelCreateNestedManyWithoutRequestInput
  }

  export type FocusCareRequestModelUncheckedCreateWithoutConsultation_timesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    care_start_date: Date | string
    care_end_date: Date | string
    detail: string
    status: FocusCareStatus
    requester_id: string
    services?: FocusCareServiceCheckModelUncheckedCreateNestedManyWithoutRequestInput
  }

  export type FocusCareRequestModelCreateOrConnectWithoutConsultation_timesInput = {
    where: FocusCareRequestModelWhereUniqueInput
    create: XOR<FocusCareRequestModelCreateWithoutConsultation_timesInput, FocusCareRequestModelUncheckedCreateWithoutConsultation_timesInput>
  }

  export type ConsultationTimeModelUpsertWithoutFocus_care_checksInput = {
    update: XOR<ConsultationTimeModelUpdateWithoutFocus_care_checksInput, ConsultationTimeModelUncheckedUpdateWithoutFocus_care_checksInput>
    create: XOR<ConsultationTimeModelCreateWithoutFocus_care_checksInput, ConsultationTimeModelUncheckedCreateWithoutFocus_care_checksInput>
  }

  export type ConsultationTimeModelUpdateWithoutFocus_care_checksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationTimeModelUncheckedUpdateWithoutFocus_care_checksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FocusCareRequestModelUpsertWithoutConsultation_timesInput = {
    update: XOR<FocusCareRequestModelUpdateWithoutConsultation_timesInput, FocusCareRequestModelUncheckedUpdateWithoutConsultation_timesInput>
    create: XOR<FocusCareRequestModelCreateWithoutConsultation_timesInput, FocusCareRequestModelUncheckedCreateWithoutConsultation_timesInput>
  }

  export type FocusCareRequestModelUpdateWithoutConsultation_timesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    care_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    care_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: StringFieldUpdateOperationsInput | string
    status?: EnumFocusCareStatusFieldUpdateOperationsInput | FocusCareStatus
    requester?: CustomerModelUpdateOneRequiredWithoutFocus_care_requestsNestedInput
    services?: FocusCareServiceCheckModelUpdateManyWithoutRequestNestedInput
  }

  export type FocusCareRequestModelUncheckedUpdateWithoutConsultation_timesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    care_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    care_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: StringFieldUpdateOperationsInput | string
    status?: EnumFocusCareStatusFieldUpdateOperationsInput | FocusCareStatus
    requester_id?: StringFieldUpdateOperationsInput | string
    services?: FocusCareServiceCheckModelUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type CustomerModelCreateWithoutBaseInput = {
    birth?: string | null
    gender?: GenderType | null
    phone?: string | null
    address_first?: string | null
    address_second?: string | null
    profile_image_url?: string | null
    oauth_accounts?: OauthAccountModelCreateNestedManyWithoutCustomerInput
    reviews?: ReviewModelCreateNestedManyWithoutReviewerInput
    focus_care_requests?: FocusCareRequestModelCreateNestedManyWithoutRequesterInput
  }

  export type CustomerModelUncheckedCreateWithoutBaseInput = {
    birth?: string | null
    gender?: GenderType | null
    phone?: string | null
    address_first?: string | null
    address_second?: string | null
    profile_image_url?: string | null
    oauth_accounts?: OauthAccountModelUncheckedCreateNestedManyWithoutCustomerInput
    reviews?: ReviewModelUncheckedCreateNestedManyWithoutReviewerInput
    focus_care_requests?: FocusCareRequestModelUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type CustomerModelCreateOrConnectWithoutBaseInput = {
    where: CustomerModelWhereUniqueInput
    create: XOR<CustomerModelCreateWithoutBaseInput, CustomerModelUncheckedCreateWithoutBaseInput>
  }

  export type BusinessUserModelCreateWithoutBaseInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    re_agent?: REAgentModelCreateNestedOneWithoutBaseInput
    hs_provider?: HSProviderModelCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelCreateNestedManyWithoutBusiness_userInput
    sub_expertises?: SubExpertiseModelCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelCreateNestedManyWithoutBusiness_userInput
    reviews?: ReviewModelCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelUncheckedCreateWithoutBaseInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    re_agent?: REAgentModelUncheckedCreateNestedOneWithoutBaseInput
    hs_provider?: HSProviderModelUncheckedCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelUncheckedCreateNestedManyWithoutBusiness_userInput
    sub_expertises?: SubExpertiseModelUncheckedCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelUncheckedCreateNestedManyWithoutBusiness_userInput
    reviews?: ReviewModelUncheckedCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelCreateOrConnectWithoutBaseInput = {
    where: BusinessUserModelWhereUniqueInput
    create: XOR<BusinessUserModelCreateWithoutBaseInput, BusinessUserModelUncheckedCreateWithoutBaseInput>
  }

  export type AgreementAcceptanceModelCreateWithoutUserInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    agreement: AgreementModelCreateNestedOneWithoutAcceptancesInput
  }

  export type AgreementAcceptanceModelUncheckedCreateWithoutUserInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    agreement_id: string
  }

  export type AgreementAcceptanceModelCreateOrConnectWithoutUserInput = {
    where: AgreementAcceptanceModelWhereUniqueInput
    create: XOR<AgreementAcceptanceModelCreateWithoutUserInput, AgreementAcceptanceModelUncheckedCreateWithoutUserInput>
  }

  export type AgreementAcceptanceModelCreateManyUserInputEnvelope = {
    data: Enumerable<AgreementAcceptanceModelCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CustomerModelUpsertWithoutBaseInput = {
    update: XOR<CustomerModelUpdateWithoutBaseInput, CustomerModelUncheckedUpdateWithoutBaseInput>
    create: XOR<CustomerModelCreateWithoutBaseInput, CustomerModelUncheckedCreateWithoutBaseInput>
  }

  export type CustomerModelUpdateWithoutBaseInput = {
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_accounts?: OauthAccountModelUpdateManyWithoutCustomerNestedInput
    reviews?: ReviewModelUpdateManyWithoutReviewerNestedInput
    focus_care_requests?: FocusCareRequestModelUpdateManyWithoutRequesterNestedInput
  }

  export type CustomerModelUncheckedUpdateWithoutBaseInput = {
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_accounts?: OauthAccountModelUncheckedUpdateManyWithoutCustomerNestedInput
    reviews?: ReviewModelUncheckedUpdateManyWithoutReviewerNestedInput
    focus_care_requests?: FocusCareRequestModelUncheckedUpdateManyWithoutRequesterNestedInput
  }

  export type BusinessUserModelUpsertWithoutBaseInput = {
    update: XOR<BusinessUserModelUpdateWithoutBaseInput, BusinessUserModelUncheckedUpdateWithoutBaseInput>
    create: XOR<BusinessUserModelCreateWithoutBaseInput, BusinessUserModelUncheckedCreateWithoutBaseInput>
  }

  export type BusinessUserModelUpdateWithoutBaseInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    re_agent?: REAgentModelUpdateOneWithoutBaseNestedInput
    hs_provider?: HSProviderModelUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUpdateManyWithoutBusiness_userNestedInput
    sub_expertises?: SubExpertiseModelUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUpdateManyWithoutBusiness_userNestedInput
    reviews?: ReviewModelUpdateManyWithoutRevieweeNestedInput
  }

  export type BusinessUserModelUncheckedUpdateWithoutBaseInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    re_agent?: REAgentModelUncheckedUpdateOneWithoutBaseNestedInput
    hs_provider?: HSProviderModelUncheckedUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    sub_expertises?: SubExpertiseModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    reviews?: ReviewModelUncheckedUpdateManyWithoutRevieweeNestedInput
  }

  export type AgreementAcceptanceModelUpsertWithWhereUniqueWithoutUserInput = {
    where: AgreementAcceptanceModelWhereUniqueInput
    update: XOR<AgreementAcceptanceModelUpdateWithoutUserInput, AgreementAcceptanceModelUncheckedUpdateWithoutUserInput>
    create: XOR<AgreementAcceptanceModelCreateWithoutUserInput, AgreementAcceptanceModelUncheckedCreateWithoutUserInput>
  }

  export type AgreementAcceptanceModelUpdateWithWhereUniqueWithoutUserInput = {
    where: AgreementAcceptanceModelWhereUniqueInput
    data: XOR<AgreementAcceptanceModelUpdateWithoutUserInput, AgreementAcceptanceModelUncheckedUpdateWithoutUserInput>
  }

  export type AgreementAcceptanceModelUpdateManyWithWhereWithoutUserInput = {
    where: AgreementAcceptanceModelScalarWhereInput
    data: XOR<AgreementAcceptanceModelUpdateManyMutationInput, AgreementAcceptanceModelUncheckedUpdateManyWithoutAgreement_acceptancesInput>
  }

  export type UserModelCreateWithoutCustomerInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    email?: string | null
    business_user?: BusinessUserModelCreateNestedOneWithoutBaseInput
    agreement_acceptances?: AgreementAcceptanceModelCreateNestedManyWithoutUserInput
  }

  export type UserModelUncheckedCreateWithoutCustomerInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    email?: string | null
    business_user?: BusinessUserModelUncheckedCreateNestedOneWithoutBaseInput
    agreement_acceptances?: AgreementAcceptanceModelUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserModelCreateOrConnectWithoutCustomerInput = {
    where: UserModelWhereUniqueInput
    create: XOR<UserModelCreateWithoutCustomerInput, UserModelUncheckedCreateWithoutCustomerInput>
  }

  export type OauthAccountModelCreateWithoutCustomerInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    oauth_type: OauthType
    oauth_sub: string
    name?: string | null
    email?: string | null
    phone?: string | null
    profile_image_url?: string | null
    birth?: string | null
    gender?: GenderType | null
    address_first?: string | null
    address_second?: string | null
    business_user?: BusinessUserModelCreateNestedOneWithoutOauth_accountsInput
  }

  export type OauthAccountModelUncheckedCreateWithoutCustomerInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    oauth_type: OauthType
    oauth_sub: string
    business_user_id?: string | null
    name?: string | null
    email?: string | null
    phone?: string | null
    profile_image_url?: string | null
    birth?: string | null
    gender?: GenderType | null
    address_first?: string | null
    address_second?: string | null
  }

  export type OauthAccountModelCreateOrConnectWithoutCustomerInput = {
    where: OauthAccountModelWhereUniqueInput
    create: XOR<OauthAccountModelCreateWithoutCustomerInput, OauthAccountModelUncheckedCreateWithoutCustomerInput>
  }

  export type OauthAccountModelCreateManyCustomerInputEnvelope = {
    data: Enumerable<OauthAccountModelCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type ReviewModelCreateWithoutReviewerInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    content: string
    reviewee: BusinessUserModelCreateNestedOneWithoutReviewsInput
    rates?: RateModelCreateNestedManyWithoutReviewInput
  }

  export type ReviewModelUncheckedCreateWithoutReviewerInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    reviewee_id: string
    content: string
    rates?: RateModelUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewModelCreateOrConnectWithoutReviewerInput = {
    where: ReviewModelWhereUniqueInput
    create: XOR<ReviewModelCreateWithoutReviewerInput, ReviewModelUncheckedCreateWithoutReviewerInput>
  }

  export type ReviewModelCreateManyReviewerInputEnvelope = {
    data: Enumerable<ReviewModelCreateManyReviewerInput>
    skipDuplicates?: boolean
  }

  export type FocusCareRequestModelCreateWithoutRequesterInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    care_start_date: Date | string
    care_end_date: Date | string
    detail: string
    status: FocusCareStatus
    consultation_times?: FocusCareConsultationTimeCheckModelCreateNestedManyWithoutRequestInput
    services?: FocusCareServiceCheckModelCreateNestedManyWithoutRequestInput
  }

  export type FocusCareRequestModelUncheckedCreateWithoutRequesterInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    care_start_date: Date | string
    care_end_date: Date | string
    detail: string
    status: FocusCareStatus
    consultation_times?: FocusCareConsultationTimeCheckModelUncheckedCreateNestedManyWithoutRequestInput
    services?: FocusCareServiceCheckModelUncheckedCreateNestedManyWithoutRequestInput
  }

  export type FocusCareRequestModelCreateOrConnectWithoutRequesterInput = {
    where: FocusCareRequestModelWhereUniqueInput
    create: XOR<FocusCareRequestModelCreateWithoutRequesterInput, FocusCareRequestModelUncheckedCreateWithoutRequesterInput>
  }

  export type FocusCareRequestModelCreateManyRequesterInputEnvelope = {
    data: Enumerable<FocusCareRequestModelCreateManyRequesterInput>
    skipDuplicates?: boolean
  }

  export type UserModelUpsertWithoutCustomerInput = {
    update: XOR<UserModelUpdateWithoutCustomerInput, UserModelUncheckedUpdateWithoutCustomerInput>
    create: XOR<UserModelCreateWithoutCustomerInput, UserModelUncheckedCreateWithoutCustomerInput>
  }

  export type UserModelUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    business_user?: BusinessUserModelUpdateOneWithoutBaseNestedInput
    agreement_acceptances?: AgreementAcceptanceModelUpdateManyWithoutUserNestedInput
  }

  export type UserModelUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    business_user?: BusinessUserModelUncheckedUpdateOneWithoutBaseNestedInput
    agreement_acceptances?: AgreementAcceptanceModelUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OauthAccountModelUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OauthAccountModelWhereUniqueInput
    update: XOR<OauthAccountModelUpdateWithoutCustomerInput, OauthAccountModelUncheckedUpdateWithoutCustomerInput>
    create: XOR<OauthAccountModelCreateWithoutCustomerInput, OauthAccountModelUncheckedCreateWithoutCustomerInput>
  }

  export type OauthAccountModelUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OauthAccountModelWhereUniqueInput
    data: XOR<OauthAccountModelUpdateWithoutCustomerInput, OauthAccountModelUncheckedUpdateWithoutCustomerInput>
  }

  export type OauthAccountModelUpdateManyWithWhereWithoutCustomerInput = {
    where: OauthAccountModelScalarWhereInput
    data: XOR<OauthAccountModelUpdateManyMutationInput, OauthAccountModelUncheckedUpdateManyWithoutOauth_accountsInput>
  }

  export type OauthAccountModelScalarWhereInput = {
    AND?: Enumerable<OauthAccountModelScalarWhereInput>
    OR?: Enumerable<OauthAccountModelScalarWhereInput>
    NOT?: Enumerable<OauthAccountModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    oauth_type?: EnumOauthTypeFilter | OauthType
    oauth_sub?: StringFilter | string
    business_user_id?: StringNullableFilter | string | null
    customer_id?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    profile_image_url?: StringNullableFilter | string | null
    birth?: StringNullableFilter | string | null
    gender?: EnumGenderTypeNullableFilter | GenderType | null
    address_first?: StringNullableFilter | string | null
    address_second?: StringNullableFilter | string | null
  }

  export type ReviewModelUpsertWithWhereUniqueWithoutReviewerInput = {
    where: ReviewModelWhereUniqueInput
    update: XOR<ReviewModelUpdateWithoutReviewerInput, ReviewModelUncheckedUpdateWithoutReviewerInput>
    create: XOR<ReviewModelCreateWithoutReviewerInput, ReviewModelUncheckedCreateWithoutReviewerInput>
  }

  export type ReviewModelUpdateWithWhereUniqueWithoutReviewerInput = {
    where: ReviewModelWhereUniqueInput
    data: XOR<ReviewModelUpdateWithoutReviewerInput, ReviewModelUncheckedUpdateWithoutReviewerInput>
  }

  export type ReviewModelUpdateManyWithWhereWithoutReviewerInput = {
    where: ReviewModelScalarWhereInput
    data: XOR<ReviewModelUpdateManyMutationInput, ReviewModelUncheckedUpdateManyWithoutReviewsInput>
  }

  export type ReviewModelScalarWhereInput = {
    AND?: Enumerable<ReviewModelScalarWhereInput>
    OR?: Enumerable<ReviewModelScalarWhereInput>
    NOT?: Enumerable<ReviewModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    reviewer_id?: StringFilter | string
    reviewee_id?: StringFilter | string
    content?: StringFilter | string
  }

  export type FocusCareRequestModelUpsertWithWhereUniqueWithoutRequesterInput = {
    where: FocusCareRequestModelWhereUniqueInput
    update: XOR<FocusCareRequestModelUpdateWithoutRequesterInput, FocusCareRequestModelUncheckedUpdateWithoutRequesterInput>
    create: XOR<FocusCareRequestModelCreateWithoutRequesterInput, FocusCareRequestModelUncheckedCreateWithoutRequesterInput>
  }

  export type FocusCareRequestModelUpdateWithWhereUniqueWithoutRequesterInput = {
    where: FocusCareRequestModelWhereUniqueInput
    data: XOR<FocusCareRequestModelUpdateWithoutRequesterInput, FocusCareRequestModelUncheckedUpdateWithoutRequesterInput>
  }

  export type FocusCareRequestModelUpdateManyWithWhereWithoutRequesterInput = {
    where: FocusCareRequestModelScalarWhereInput
    data: XOR<FocusCareRequestModelUpdateManyMutationInput, FocusCareRequestModelUncheckedUpdateManyWithoutFocus_care_requestsInput>
  }

  export type FocusCareRequestModelScalarWhereInput = {
    AND?: Enumerable<FocusCareRequestModelScalarWhereInput>
    OR?: Enumerable<FocusCareRequestModelScalarWhereInput>
    NOT?: Enumerable<FocusCareRequestModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    care_start_date?: DateTimeFilter | Date | string
    care_end_date?: DateTimeFilter | Date | string
    detail?: StringFilter | string
    status?: EnumFocusCareStatusFilter | FocusCareStatus
    requester_id?: StringFilter | string
  }

  export type UserModelCreateWithoutBusiness_userInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    email?: string | null
    customer?: CustomerModelCreateNestedOneWithoutBaseInput
    agreement_acceptances?: AgreementAcceptanceModelCreateNestedManyWithoutUserInput
  }

  export type UserModelUncheckedCreateWithoutBusiness_userInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    email?: string | null
    customer?: CustomerModelUncheckedCreateNestedOneWithoutBaseInput
    agreement_acceptances?: AgreementAcceptanceModelUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserModelCreateOrConnectWithoutBusiness_userInput = {
    where: UserModelWhereUniqueInput
    create: XOR<UserModelCreateWithoutBusiness_userInput, UserModelUncheckedCreateWithoutBusiness_userInput>
  }

  export type REAgentModelCreateWithoutBaseInput = {
    is_licensed: boolean
    re_num: string
    re_name: string
    re_phone: string
    re_licensed_agent_name: string
    properties?: REProertyModelCreateNestedManyWithoutRe_agentInput
  }

  export type REAgentModelUncheckedCreateWithoutBaseInput = {
    is_licensed: boolean
    re_num: string
    re_name: string
    re_phone: string
    re_licensed_agent_name: string
    properties?: REProertyModelUncheckedCreateNestedManyWithoutRe_agentInput
  }

  export type REAgentModelCreateOrConnectWithoutBaseInput = {
    where: REAgentModelWhereUniqueInput
    create: XOR<REAgentModelCreateWithoutBaseInput, REAgentModelUncheckedCreateWithoutBaseInput>
  }

  export type HSProviderModelCreateWithoutBaseInput = {
    business_registration_num: string
    introduction_images?: HSIntroductionImageModelCreateNestedManyWithoutHs_providerInput
  }

  export type HSProviderModelUncheckedCreateWithoutBaseInput = {
    business_registration_num: string
    introduction_images?: HSIntroductionImageModelUncheckedCreateNestedManyWithoutHs_providerInput
  }

  export type HSProviderModelCreateOrConnectWithoutBaseInput = {
    where: HSProviderModelWhereUniqueInput
    create: XOR<HSProviderModelCreateWithoutBaseInput, HSProviderModelUncheckedCreateWithoutBaseInput>
  }

  export type BusinessCertificationImageModelCreateWithoutBusiness_userInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    url: string
  }

  export type BusinessCertificationImageModelUncheckedCreateWithoutBusiness_userInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    url: string
  }

  export type BusinessCertificationImageModelCreateOrConnectWithoutBusiness_userInput = {
    where: BusinessCertificationImageModelWhereUniqueInput
    create: XOR<BusinessCertificationImageModelCreateWithoutBusiness_userInput, BusinessCertificationImageModelUncheckedCreateWithoutBusiness_userInput>
  }

  export type BusinessCertificationImageModelCreateManyBusiness_userInputEnvelope = {
    data: Enumerable<BusinessCertificationImageModelCreateManyBusiness_userInput>
    skipDuplicates?: boolean
  }

  export type SubExpertiseModelCreateWithoutBusiness_userInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    sub_category: ServiceSubCategoryModelCreateNestedOneWithoutExpertisesInput
  }

  export type SubExpertiseModelUncheckedCreateWithoutBusiness_userInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    sub_category_id: string
  }

  export type SubExpertiseModelCreateOrConnectWithoutBusiness_userInput = {
    where: SubExpertiseModelWhereUniqueInput
    create: XOR<SubExpertiseModelCreateWithoutBusiness_userInput, SubExpertiseModelUncheckedCreateWithoutBusiness_userInput>
  }

  export type SubExpertiseModelCreateManyBusiness_userInputEnvelope = {
    data: Enumerable<SubExpertiseModelCreateManyBusiness_userInput>
    skipDuplicates?: boolean
  }

  export type OauthAccountModelCreateWithoutBusiness_userInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    oauth_type: OauthType
    oauth_sub: string
    name?: string | null
    email?: string | null
    phone?: string | null
    profile_image_url?: string | null
    birth?: string | null
    gender?: GenderType | null
    address_first?: string | null
    address_second?: string | null
    customer?: CustomerModelCreateNestedOneWithoutOauth_accountsInput
  }

  export type OauthAccountModelUncheckedCreateWithoutBusiness_userInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    oauth_type: OauthType
    oauth_sub: string
    customer_id?: string | null
    name?: string | null
    email?: string | null
    phone?: string | null
    profile_image_url?: string | null
    birth?: string | null
    gender?: GenderType | null
    address_first?: string | null
    address_second?: string | null
  }

  export type OauthAccountModelCreateOrConnectWithoutBusiness_userInput = {
    where: OauthAccountModelWhereUniqueInput
    create: XOR<OauthAccountModelCreateWithoutBusiness_userInput, OauthAccountModelUncheckedCreateWithoutBusiness_userInput>
  }

  export type OauthAccountModelCreateManyBusiness_userInputEnvelope = {
    data: Enumerable<OauthAccountModelCreateManyBusiness_userInput>
    skipDuplicates?: boolean
  }

  export type ReviewModelCreateWithoutRevieweeInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    content: string
    reviewer: CustomerModelCreateNestedOneWithoutReviewsInput
    rates?: RateModelCreateNestedManyWithoutReviewInput
  }

  export type ReviewModelUncheckedCreateWithoutRevieweeInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    reviewer_id: string
    content: string
    rates?: RateModelUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewModelCreateOrConnectWithoutRevieweeInput = {
    where: ReviewModelWhereUniqueInput
    create: XOR<ReviewModelCreateWithoutRevieweeInput, ReviewModelUncheckedCreateWithoutRevieweeInput>
  }

  export type ReviewModelCreateManyRevieweeInputEnvelope = {
    data: Enumerable<ReviewModelCreateManyRevieweeInput>
    skipDuplicates?: boolean
  }

  export type UserModelUpsertWithoutBusiness_userInput = {
    update: XOR<UserModelUpdateWithoutBusiness_userInput, UserModelUncheckedUpdateWithoutBusiness_userInput>
    create: XOR<UserModelCreateWithoutBusiness_userInput, UserModelUncheckedCreateWithoutBusiness_userInput>
  }

  export type UserModelUpdateWithoutBusiness_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerModelUpdateOneWithoutBaseNestedInput
    agreement_acceptances?: AgreementAcceptanceModelUpdateManyWithoutUserNestedInput
  }

  export type UserModelUncheckedUpdateWithoutBusiness_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerModelUncheckedUpdateOneWithoutBaseNestedInput
    agreement_acceptances?: AgreementAcceptanceModelUncheckedUpdateManyWithoutUserNestedInput
  }

  export type REAgentModelUpsertWithoutBaseInput = {
    update: XOR<REAgentModelUpdateWithoutBaseInput, REAgentModelUncheckedUpdateWithoutBaseInput>
    create: XOR<REAgentModelCreateWithoutBaseInput, REAgentModelUncheckedCreateWithoutBaseInput>
  }

  export type REAgentModelUpdateWithoutBaseInput = {
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    re_num?: StringFieldUpdateOperationsInput | string
    re_name?: StringFieldUpdateOperationsInput | string
    re_phone?: StringFieldUpdateOperationsInput | string
    re_licensed_agent_name?: StringFieldUpdateOperationsInput | string
    properties?: REProertyModelUpdateManyWithoutRe_agentNestedInput
  }

  export type REAgentModelUncheckedUpdateWithoutBaseInput = {
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    re_num?: StringFieldUpdateOperationsInput | string
    re_name?: StringFieldUpdateOperationsInput | string
    re_phone?: StringFieldUpdateOperationsInput | string
    re_licensed_agent_name?: StringFieldUpdateOperationsInput | string
    properties?: REProertyModelUncheckedUpdateManyWithoutRe_agentNestedInput
  }

  export type HSProviderModelUpsertWithoutBaseInput = {
    update: XOR<HSProviderModelUpdateWithoutBaseInput, HSProviderModelUncheckedUpdateWithoutBaseInput>
    create: XOR<HSProviderModelCreateWithoutBaseInput, HSProviderModelUncheckedCreateWithoutBaseInput>
  }

  export type HSProviderModelUpdateWithoutBaseInput = {
    business_registration_num?: StringFieldUpdateOperationsInput | string
    introduction_images?: HSIntroductionImageModelUpdateManyWithoutHs_providerNestedInput
  }

  export type HSProviderModelUncheckedUpdateWithoutBaseInput = {
    business_registration_num?: StringFieldUpdateOperationsInput | string
    introduction_images?: HSIntroductionImageModelUncheckedUpdateManyWithoutHs_providerNestedInput
  }

  export type BusinessCertificationImageModelUpsertWithWhereUniqueWithoutBusiness_userInput = {
    where: BusinessCertificationImageModelWhereUniqueInput
    update: XOR<BusinessCertificationImageModelUpdateWithoutBusiness_userInput, BusinessCertificationImageModelUncheckedUpdateWithoutBusiness_userInput>
    create: XOR<BusinessCertificationImageModelCreateWithoutBusiness_userInput, BusinessCertificationImageModelUncheckedCreateWithoutBusiness_userInput>
  }

  export type BusinessCertificationImageModelUpdateWithWhereUniqueWithoutBusiness_userInput = {
    where: BusinessCertificationImageModelWhereUniqueInput
    data: XOR<BusinessCertificationImageModelUpdateWithoutBusiness_userInput, BusinessCertificationImageModelUncheckedUpdateWithoutBusiness_userInput>
  }

  export type BusinessCertificationImageModelUpdateManyWithWhereWithoutBusiness_userInput = {
    where: BusinessCertificationImageModelScalarWhereInput
    data: XOR<BusinessCertificationImageModelUpdateManyMutationInput, BusinessCertificationImageModelUncheckedUpdateManyWithoutCertification_imagesInput>
  }

  export type BusinessCertificationImageModelScalarWhereInput = {
    AND?: Enumerable<BusinessCertificationImageModelScalarWhereInput>
    OR?: Enumerable<BusinessCertificationImageModelScalarWhereInput>
    NOT?: Enumerable<BusinessCertificationImageModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    business_user_id?: StringFilter | string
    url?: StringFilter | string
  }

  export type SubExpertiseModelUpsertWithWhereUniqueWithoutBusiness_userInput = {
    where: SubExpertiseModelWhereUniqueInput
    update: XOR<SubExpertiseModelUpdateWithoutBusiness_userInput, SubExpertiseModelUncheckedUpdateWithoutBusiness_userInput>
    create: XOR<SubExpertiseModelCreateWithoutBusiness_userInput, SubExpertiseModelUncheckedCreateWithoutBusiness_userInput>
  }

  export type SubExpertiseModelUpdateWithWhereUniqueWithoutBusiness_userInput = {
    where: SubExpertiseModelWhereUniqueInput
    data: XOR<SubExpertiseModelUpdateWithoutBusiness_userInput, SubExpertiseModelUncheckedUpdateWithoutBusiness_userInput>
  }

  export type SubExpertiseModelUpdateManyWithWhereWithoutBusiness_userInput = {
    where: SubExpertiseModelScalarWhereInput
    data: XOR<SubExpertiseModelUpdateManyMutationInput, SubExpertiseModelUncheckedUpdateManyWithoutSub_expertisesInput>
  }

  export type OauthAccountModelUpsertWithWhereUniqueWithoutBusiness_userInput = {
    where: OauthAccountModelWhereUniqueInput
    update: XOR<OauthAccountModelUpdateWithoutBusiness_userInput, OauthAccountModelUncheckedUpdateWithoutBusiness_userInput>
    create: XOR<OauthAccountModelCreateWithoutBusiness_userInput, OauthAccountModelUncheckedCreateWithoutBusiness_userInput>
  }

  export type OauthAccountModelUpdateWithWhereUniqueWithoutBusiness_userInput = {
    where: OauthAccountModelWhereUniqueInput
    data: XOR<OauthAccountModelUpdateWithoutBusiness_userInput, OauthAccountModelUncheckedUpdateWithoutBusiness_userInput>
  }

  export type OauthAccountModelUpdateManyWithWhereWithoutBusiness_userInput = {
    where: OauthAccountModelScalarWhereInput
    data: XOR<OauthAccountModelUpdateManyMutationInput, OauthAccountModelUncheckedUpdateManyWithoutOauth_accountsInput>
  }

  export type ReviewModelUpsertWithWhereUniqueWithoutRevieweeInput = {
    where: ReviewModelWhereUniqueInput
    update: XOR<ReviewModelUpdateWithoutRevieweeInput, ReviewModelUncheckedUpdateWithoutRevieweeInput>
    create: XOR<ReviewModelCreateWithoutRevieweeInput, ReviewModelUncheckedCreateWithoutRevieweeInput>
  }

  export type ReviewModelUpdateWithWhereUniqueWithoutRevieweeInput = {
    where: ReviewModelWhereUniqueInput
    data: XOR<ReviewModelUpdateWithoutRevieweeInput, ReviewModelUncheckedUpdateWithoutRevieweeInput>
  }

  export type ReviewModelUpdateManyWithWhereWithoutRevieweeInput = {
    where: ReviewModelScalarWhereInput
    data: XOR<ReviewModelUpdateManyMutationInput, ReviewModelUncheckedUpdateManyWithoutReviewsInput>
  }

  export type ServiceSubCategoryModelCreateWithoutExpertisesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    super_category: ServiceSuperCategoryModelCreateNestedOneWithoutSub_categoriesInput
  }

  export type ServiceSubCategoryModelUncheckedCreateWithoutExpertisesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    super_category_id: string
  }

  export type ServiceSubCategoryModelCreateOrConnectWithoutExpertisesInput = {
    where: ServiceSubCategoryModelWhereUniqueInput
    create: XOR<ServiceSubCategoryModelCreateWithoutExpertisesInput, ServiceSubCategoryModelUncheckedCreateWithoutExpertisesInput>
  }

  export type BusinessUserModelCreateWithoutSub_expertisesInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    base: UserModelCreateNestedOneWithoutBusiness_userInput
    re_agent?: REAgentModelCreateNestedOneWithoutBaseInput
    hs_provider?: HSProviderModelCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelCreateNestedManyWithoutBusiness_userInput
    reviews?: ReviewModelCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelUncheckedCreateWithoutSub_expertisesInput = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    re_agent?: REAgentModelUncheckedCreateNestedOneWithoutBaseInput
    hs_provider?: HSProviderModelUncheckedCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelUncheckedCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelUncheckedCreateNestedManyWithoutBusiness_userInput
    reviews?: ReviewModelUncheckedCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelCreateOrConnectWithoutSub_expertisesInput = {
    where: BusinessUserModelWhereUniqueInput
    create: XOR<BusinessUserModelCreateWithoutSub_expertisesInput, BusinessUserModelUncheckedCreateWithoutSub_expertisesInput>
  }

  export type ServiceSubCategoryModelUpsertWithoutExpertisesInput = {
    update: XOR<ServiceSubCategoryModelUpdateWithoutExpertisesInput, ServiceSubCategoryModelUncheckedUpdateWithoutExpertisesInput>
    create: XOR<ServiceSubCategoryModelCreateWithoutExpertisesInput, ServiceSubCategoryModelUncheckedCreateWithoutExpertisesInput>
  }

  export type ServiceSubCategoryModelUpdateWithoutExpertisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    super_category?: ServiceSuperCategoryModelUpdateOneRequiredWithoutSub_categoriesNestedInput
  }

  export type ServiceSubCategoryModelUncheckedUpdateWithoutExpertisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    super_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUserModelUpsertWithoutSub_expertisesInput = {
    update: XOR<BusinessUserModelUpdateWithoutSub_expertisesInput, BusinessUserModelUncheckedUpdateWithoutSub_expertisesInput>
    create: XOR<BusinessUserModelCreateWithoutSub_expertisesInput, BusinessUserModelUncheckedCreateWithoutSub_expertisesInput>
  }

  export type BusinessUserModelUpdateWithoutSub_expertisesInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    base?: UserModelUpdateOneRequiredWithoutBusiness_userNestedInput
    re_agent?: REAgentModelUpdateOneWithoutBaseNestedInput
    hs_provider?: HSProviderModelUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUpdateManyWithoutBusiness_userNestedInput
    reviews?: ReviewModelUpdateManyWithoutRevieweeNestedInput
  }

  export type BusinessUserModelUncheckedUpdateWithoutSub_expertisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    re_agent?: REAgentModelUncheckedUpdateOneWithoutBaseNestedInput
    hs_provider?: HSProviderModelUncheckedUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    reviews?: ReviewModelUncheckedUpdateManyWithoutRevieweeNestedInput
  }

  export type BusinessUserModelCreateWithoutRe_agentInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    base: UserModelCreateNestedOneWithoutBusiness_userInput
    hs_provider?: HSProviderModelCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelCreateNestedManyWithoutBusiness_userInput
    sub_expertises?: SubExpertiseModelCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelCreateNestedManyWithoutBusiness_userInput
    reviews?: ReviewModelCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelUncheckedCreateWithoutRe_agentInput = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    hs_provider?: HSProviderModelUncheckedCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelUncheckedCreateNestedManyWithoutBusiness_userInput
    sub_expertises?: SubExpertiseModelUncheckedCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelUncheckedCreateNestedManyWithoutBusiness_userInput
    reviews?: ReviewModelUncheckedCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelCreateOrConnectWithoutRe_agentInput = {
    where: BusinessUserModelWhereUniqueInput
    create: XOR<BusinessUserModelCreateWithoutRe_agentInput, BusinessUserModelUncheckedCreateWithoutRe_agentInput>
  }

  export type REProertyModelCreateWithoutRe_agentInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    main_image_url: string
    categories?: REPropertyCategoryModelCreateNestedManyWithoutRe_propertyInput
  }

  export type REProertyModelUncheckedCreateWithoutRe_agentInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    main_image_url: string
    categories?: REPropertyCategoryModelUncheckedCreateNestedManyWithoutRe_propertyInput
  }

  export type REProertyModelCreateOrConnectWithoutRe_agentInput = {
    where: REProertyModelWhereUniqueInput
    create: XOR<REProertyModelCreateWithoutRe_agentInput, REProertyModelUncheckedCreateWithoutRe_agentInput>
  }

  export type REProertyModelCreateManyRe_agentInputEnvelope = {
    data: Enumerable<REProertyModelCreateManyRe_agentInput>
    skipDuplicates?: boolean
  }

  export type BusinessUserModelUpsertWithoutRe_agentInput = {
    update: XOR<BusinessUserModelUpdateWithoutRe_agentInput, BusinessUserModelUncheckedUpdateWithoutRe_agentInput>
    create: XOR<BusinessUserModelCreateWithoutRe_agentInput, BusinessUserModelUncheckedCreateWithoutRe_agentInput>
  }

  export type BusinessUserModelUpdateWithoutRe_agentInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    base?: UserModelUpdateOneRequiredWithoutBusiness_userNestedInput
    hs_provider?: HSProviderModelUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUpdateManyWithoutBusiness_userNestedInput
    sub_expertises?: SubExpertiseModelUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUpdateManyWithoutBusiness_userNestedInput
    reviews?: ReviewModelUpdateManyWithoutRevieweeNestedInput
  }

  export type BusinessUserModelUncheckedUpdateWithoutRe_agentInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    hs_provider?: HSProviderModelUncheckedUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    sub_expertises?: SubExpertiseModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    reviews?: ReviewModelUncheckedUpdateManyWithoutRevieweeNestedInput
  }

  export type REProertyModelUpsertWithWhereUniqueWithoutRe_agentInput = {
    where: REProertyModelWhereUniqueInput
    update: XOR<REProertyModelUpdateWithoutRe_agentInput, REProertyModelUncheckedUpdateWithoutRe_agentInput>
    create: XOR<REProertyModelCreateWithoutRe_agentInput, REProertyModelUncheckedCreateWithoutRe_agentInput>
  }

  export type REProertyModelUpdateWithWhereUniqueWithoutRe_agentInput = {
    where: REProertyModelWhereUniqueInput
    data: XOR<REProertyModelUpdateWithoutRe_agentInput, REProertyModelUncheckedUpdateWithoutRe_agentInput>
  }

  export type REProertyModelUpdateManyWithWhereWithoutRe_agentInput = {
    where: REProertyModelScalarWhereInput
    data: XOR<REProertyModelUpdateManyMutationInput, REProertyModelUncheckedUpdateManyWithoutPropertiesInput>
  }

  export type REProertyModelScalarWhereInput = {
    AND?: Enumerable<REProertyModelScalarWhereInput>
    OR?: Enumerable<REProertyModelScalarWhereInput>
    NOT?: Enumerable<REProertyModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    name?: StringFilter | string
    main_image_url?: StringFilter | string
    re_agent_id?: StringFilter | string
  }

  export type BusinessUserModelCreateWithoutHs_providerInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    base: UserModelCreateNestedOneWithoutBusiness_userInput
    re_agent?: REAgentModelCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelCreateNestedManyWithoutBusiness_userInput
    sub_expertises?: SubExpertiseModelCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelCreateNestedManyWithoutBusiness_userInput
    reviews?: ReviewModelCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelUncheckedCreateWithoutHs_providerInput = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    re_agent?: REAgentModelUncheckedCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelUncheckedCreateNestedManyWithoutBusiness_userInput
    sub_expertises?: SubExpertiseModelUncheckedCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelUncheckedCreateNestedManyWithoutBusiness_userInput
    reviews?: ReviewModelUncheckedCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelCreateOrConnectWithoutHs_providerInput = {
    where: BusinessUserModelWhereUniqueInput
    create: XOR<BusinessUserModelCreateWithoutHs_providerInput, BusinessUserModelUncheckedCreateWithoutHs_providerInput>
  }

  export type HSIntroductionImageModelCreateWithoutHs_providerInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    url: string
  }

  export type HSIntroductionImageModelUncheckedCreateWithoutHs_providerInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    url: string
  }

  export type HSIntroductionImageModelCreateOrConnectWithoutHs_providerInput = {
    where: HSIntroductionImageModelWhereUniqueInput
    create: XOR<HSIntroductionImageModelCreateWithoutHs_providerInput, HSIntroductionImageModelUncheckedCreateWithoutHs_providerInput>
  }

  export type HSIntroductionImageModelCreateManyHs_providerInputEnvelope = {
    data: Enumerable<HSIntroductionImageModelCreateManyHs_providerInput>
    skipDuplicates?: boolean
  }

  export type BusinessUserModelUpsertWithoutHs_providerInput = {
    update: XOR<BusinessUserModelUpdateWithoutHs_providerInput, BusinessUserModelUncheckedUpdateWithoutHs_providerInput>
    create: XOR<BusinessUserModelCreateWithoutHs_providerInput, BusinessUserModelUncheckedCreateWithoutHs_providerInput>
  }

  export type BusinessUserModelUpdateWithoutHs_providerInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    base?: UserModelUpdateOneRequiredWithoutBusiness_userNestedInput
    re_agent?: REAgentModelUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUpdateManyWithoutBusiness_userNestedInput
    sub_expertises?: SubExpertiseModelUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUpdateManyWithoutBusiness_userNestedInput
    reviews?: ReviewModelUpdateManyWithoutRevieweeNestedInput
  }

  export type BusinessUserModelUncheckedUpdateWithoutHs_providerInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    re_agent?: REAgentModelUncheckedUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    sub_expertises?: SubExpertiseModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    reviews?: ReviewModelUncheckedUpdateManyWithoutRevieweeNestedInput
  }

  export type HSIntroductionImageModelUpsertWithWhereUniqueWithoutHs_providerInput = {
    where: HSIntroductionImageModelWhereUniqueInput
    update: XOR<HSIntroductionImageModelUpdateWithoutHs_providerInput, HSIntroductionImageModelUncheckedUpdateWithoutHs_providerInput>
    create: XOR<HSIntroductionImageModelCreateWithoutHs_providerInput, HSIntroductionImageModelUncheckedCreateWithoutHs_providerInput>
  }

  export type HSIntroductionImageModelUpdateWithWhereUniqueWithoutHs_providerInput = {
    where: HSIntroductionImageModelWhereUniqueInput
    data: XOR<HSIntroductionImageModelUpdateWithoutHs_providerInput, HSIntroductionImageModelUncheckedUpdateWithoutHs_providerInput>
  }

  export type HSIntroductionImageModelUpdateManyWithWhereWithoutHs_providerInput = {
    where: HSIntroductionImageModelScalarWhereInput
    data: XOR<HSIntroductionImageModelUpdateManyMutationInput, HSIntroductionImageModelUncheckedUpdateManyWithoutIntroduction_imagesInput>
  }

  export type HSIntroductionImageModelScalarWhereInput = {
    AND?: Enumerable<HSIntroductionImageModelScalarWhereInput>
    OR?: Enumerable<HSIntroductionImageModelScalarWhereInput>
    NOT?: Enumerable<HSIntroductionImageModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    hs_provider_id?: StringFilter | string
    url?: StringFilter | string
  }

  export type BusinessUserModelCreateWithoutCertification_imagesInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    base: UserModelCreateNestedOneWithoutBusiness_userInput
    re_agent?: REAgentModelCreateNestedOneWithoutBaseInput
    hs_provider?: HSProviderModelCreateNestedOneWithoutBaseInput
    sub_expertises?: SubExpertiseModelCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelCreateNestedManyWithoutBusiness_userInput
    reviews?: ReviewModelCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelUncheckedCreateWithoutCertification_imagesInput = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    re_agent?: REAgentModelUncheckedCreateNestedOneWithoutBaseInput
    hs_provider?: HSProviderModelUncheckedCreateNestedOneWithoutBaseInput
    sub_expertises?: SubExpertiseModelUncheckedCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelUncheckedCreateNestedManyWithoutBusiness_userInput
    reviews?: ReviewModelUncheckedCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelCreateOrConnectWithoutCertification_imagesInput = {
    where: BusinessUserModelWhereUniqueInput
    create: XOR<BusinessUserModelCreateWithoutCertification_imagesInput, BusinessUserModelUncheckedCreateWithoutCertification_imagesInput>
  }

  export type BusinessUserModelUpsertWithoutCertification_imagesInput = {
    update: XOR<BusinessUserModelUpdateWithoutCertification_imagesInput, BusinessUserModelUncheckedUpdateWithoutCertification_imagesInput>
    create: XOR<BusinessUserModelCreateWithoutCertification_imagesInput, BusinessUserModelUncheckedCreateWithoutCertification_imagesInput>
  }

  export type BusinessUserModelUpdateWithoutCertification_imagesInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    base?: UserModelUpdateOneRequiredWithoutBusiness_userNestedInput
    re_agent?: REAgentModelUpdateOneWithoutBaseNestedInput
    hs_provider?: HSProviderModelUpdateOneWithoutBaseNestedInput
    sub_expertises?: SubExpertiseModelUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUpdateManyWithoutBusiness_userNestedInput
    reviews?: ReviewModelUpdateManyWithoutRevieweeNestedInput
  }

  export type BusinessUserModelUncheckedUpdateWithoutCertification_imagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    re_agent?: REAgentModelUncheckedUpdateOneWithoutBaseNestedInput
    hs_provider?: HSProviderModelUncheckedUpdateOneWithoutBaseNestedInput
    sub_expertises?: SubExpertiseModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    reviews?: ReviewModelUncheckedUpdateManyWithoutRevieweeNestedInput
  }

  export type HSProviderModelCreateWithoutIntroduction_imagesInput = {
    business_registration_num: string
    base: BusinessUserModelCreateNestedOneWithoutHs_providerInput
  }

  export type HSProviderModelUncheckedCreateWithoutIntroduction_imagesInput = {
    id: string
    business_registration_num: string
  }

  export type HSProviderModelCreateOrConnectWithoutIntroduction_imagesInput = {
    where: HSProviderModelWhereUniqueInput
    create: XOR<HSProviderModelCreateWithoutIntroduction_imagesInput, HSProviderModelUncheckedCreateWithoutIntroduction_imagesInput>
  }

  export type HSProviderModelUpsertWithoutIntroduction_imagesInput = {
    update: XOR<HSProviderModelUpdateWithoutIntroduction_imagesInput, HSProviderModelUncheckedUpdateWithoutIntroduction_imagesInput>
    create: XOR<HSProviderModelCreateWithoutIntroduction_imagesInput, HSProviderModelUncheckedCreateWithoutIntroduction_imagesInput>
  }

  export type HSProviderModelUpdateWithoutIntroduction_imagesInput = {
    business_registration_num?: StringFieldUpdateOperationsInput | string
    base?: BusinessUserModelUpdateOneRequiredWithoutHs_providerNestedInput
  }

  export type HSProviderModelUncheckedUpdateWithoutIntroduction_imagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    business_registration_num?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUserModelCreateWithoutOauth_accountsInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    base: UserModelCreateNestedOneWithoutBusiness_userInput
    re_agent?: REAgentModelCreateNestedOneWithoutBaseInput
    hs_provider?: HSProviderModelCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelCreateNestedManyWithoutBusiness_userInput
    sub_expertises?: SubExpertiseModelCreateNestedManyWithoutBusiness_userInput
    reviews?: ReviewModelCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelUncheckedCreateWithoutOauth_accountsInput = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    re_agent?: REAgentModelUncheckedCreateNestedOneWithoutBaseInput
    hs_provider?: HSProviderModelUncheckedCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelUncheckedCreateNestedManyWithoutBusiness_userInput
    sub_expertises?: SubExpertiseModelUncheckedCreateNestedManyWithoutBusiness_userInput
    reviews?: ReviewModelUncheckedCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelCreateOrConnectWithoutOauth_accountsInput = {
    where: BusinessUserModelWhereUniqueInput
    create: XOR<BusinessUserModelCreateWithoutOauth_accountsInput, BusinessUserModelUncheckedCreateWithoutOauth_accountsInput>
  }

  export type CustomerModelCreateWithoutOauth_accountsInput = {
    birth?: string | null
    gender?: GenderType | null
    phone?: string | null
    address_first?: string | null
    address_second?: string | null
    profile_image_url?: string | null
    base: UserModelCreateNestedOneWithoutCustomerInput
    reviews?: ReviewModelCreateNestedManyWithoutReviewerInput
    focus_care_requests?: FocusCareRequestModelCreateNestedManyWithoutRequesterInput
  }

  export type CustomerModelUncheckedCreateWithoutOauth_accountsInput = {
    id: string
    birth?: string | null
    gender?: GenderType | null
    phone?: string | null
    address_first?: string | null
    address_second?: string | null
    profile_image_url?: string | null
    reviews?: ReviewModelUncheckedCreateNestedManyWithoutReviewerInput
    focus_care_requests?: FocusCareRequestModelUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type CustomerModelCreateOrConnectWithoutOauth_accountsInput = {
    where: CustomerModelWhereUniqueInput
    create: XOR<CustomerModelCreateWithoutOauth_accountsInput, CustomerModelUncheckedCreateWithoutOauth_accountsInput>
  }

  export type BusinessUserModelUpsertWithoutOauth_accountsInput = {
    update: XOR<BusinessUserModelUpdateWithoutOauth_accountsInput, BusinessUserModelUncheckedUpdateWithoutOauth_accountsInput>
    create: XOR<BusinessUserModelCreateWithoutOauth_accountsInput, BusinessUserModelUncheckedCreateWithoutOauth_accountsInput>
  }

  export type BusinessUserModelUpdateWithoutOauth_accountsInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    base?: UserModelUpdateOneRequiredWithoutBusiness_userNestedInput
    re_agent?: REAgentModelUpdateOneWithoutBaseNestedInput
    hs_provider?: HSProviderModelUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUpdateManyWithoutBusiness_userNestedInput
    sub_expertises?: SubExpertiseModelUpdateManyWithoutBusiness_userNestedInput
    reviews?: ReviewModelUpdateManyWithoutRevieweeNestedInput
  }

  export type BusinessUserModelUncheckedUpdateWithoutOauth_accountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    re_agent?: REAgentModelUncheckedUpdateOneWithoutBaseNestedInput
    hs_provider?: HSProviderModelUncheckedUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    sub_expertises?: SubExpertiseModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    reviews?: ReviewModelUncheckedUpdateManyWithoutRevieweeNestedInput
  }

  export type CustomerModelUpsertWithoutOauth_accountsInput = {
    update: XOR<CustomerModelUpdateWithoutOauth_accountsInput, CustomerModelUncheckedUpdateWithoutOauth_accountsInput>
    create: XOR<CustomerModelCreateWithoutOauth_accountsInput, CustomerModelUncheckedCreateWithoutOauth_accountsInput>
  }

  export type CustomerModelUpdateWithoutOauth_accountsInput = {
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    base?: UserModelUpdateOneRequiredWithoutCustomerNestedInput
    reviews?: ReviewModelUpdateManyWithoutReviewerNestedInput
    focus_care_requests?: FocusCareRequestModelUpdateManyWithoutRequesterNestedInput
  }

  export type CustomerModelUncheckedUpdateWithoutOauth_accountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    reviews?: ReviewModelUncheckedUpdateManyWithoutReviewerNestedInput
    focus_care_requests?: FocusCareRequestModelUncheckedUpdateManyWithoutRequesterNestedInput
  }

  export type REPropertyCategoryModelCreateManyRe_propertyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    sub_category_id: string
  }

  export type REPropertyCategoryModelUpdateWithoutRe_propertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_category?: REPropertySubCategoryModelUpdateOneRequiredWithoutProperty_categoriesNestedInput
  }

  export type REPropertyCategoryModelUncheckedUpdateWithoutRe_propertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertyCategoryModelUncheckedUpdateManyWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertyCategoryModelCreateManySub_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    re_property_id: string
  }

  export type REPropertyCategoryModelUpdateWithoutSub_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    re_property?: REProertyModelUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type REPropertyCategoryModelUncheckedUpdateWithoutSub_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    re_property_id?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertyCategoryModelUncheckedUpdateManyWithoutProperty_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    re_property_id?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertySubCategoryModelCreateManyMiddle_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
  }

  export type REPropertySubCategoryModelUpdateWithoutMiddle_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    property_categories?: REPropertyCategoryModelUpdateManyWithoutSub_categoryNestedInput
  }

  export type REPropertySubCategoryModelUncheckedUpdateWithoutMiddle_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    property_categories?: REPropertyCategoryModelUncheckedUpdateManyWithoutSub_categoryNestedInput
  }

  export type REPropertySubCategoryModelUncheckedUpdateManyWithoutSub_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertyMiddleCategoryModelCreateManySuper_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
  }

  export type REPropertyMiddleCategoryModelUpdateWithoutSuper_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    sub_categories?: REPropertySubCategoryModelUpdateManyWithoutMiddle_categoryNestedInput
  }

  export type REPropertyMiddleCategoryModelUncheckedUpdateWithoutSuper_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    sub_categories?: REPropertySubCategoryModelUncheckedUpdateManyWithoutMiddle_categoryNestedInput
  }

  export type REPropertyMiddleCategoryModelUncheckedUpdateManyWithoutMiddle_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RateModelCreateManyReviewInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    score: number
    category_id: string
  }

  export type RateModelUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
    category?: RateCategoryModelUpdateOneRequiredWithoutRatesNestedInput
  }

  export type RateModelUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
  }

  export type RateModelUncheckedUpdateManyWithoutRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
    category_id?: StringFieldUpdateOperationsInput | string
  }

  export type RateModelCreateManyCategoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    score: number
    review_id: string
  }

  export type RateModelUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
    review?: ReviewModelUpdateOneRequiredWithoutRatesNestedInput
  }

  export type RateModelUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
    review_id?: StringFieldUpdateOperationsInput | string
  }

  export type AgreementAcceptanceModelCreateManyAgreementInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    user_id: string
  }

  export type AgreementAcceptanceModelUpdateWithoutAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserModelUpdateOneRequiredWithoutAgreement_acceptancesNestedInput
  }

  export type AgreementAcceptanceModelUncheckedUpdateWithoutAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type AgreementAcceptanceModelUncheckedUpdateManyWithoutAcceptancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type FocusCareConsultationTimeCheckModelCreateManyConsultation_timeInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    request_id: string
  }

  export type FocusCareConsultationTimeCheckModelUpdateWithoutConsultation_timeInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    request?: FocusCareRequestModelUpdateOneRequiredWithoutConsultation_timesNestedInput
  }

  export type FocusCareConsultationTimeCheckModelUncheckedUpdateWithoutConsultation_timeInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    request_id?: StringFieldUpdateOperationsInput | string
  }

  export type FocusCareConsultationTimeCheckModelUncheckedUpdateManyWithoutFocus_care_checksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    request_id?: StringFieldUpdateOperationsInput | string
  }

  export type SubExpertiseModelCreateManySub_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    business_user_id: string
  }

  export type SubExpertiseModelUpdateWithoutSub_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business_user?: BusinessUserModelUpdateOneRequiredWithoutSub_expertisesNestedInput
  }

  export type SubExpertiseModelUncheckedUpdateWithoutSub_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business_user_id?: StringFieldUpdateOperationsInput | string
  }

  export type SubExpertiseModelUncheckedUpdateManyWithoutExpertisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business_user_id?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceSubCategoryModelCreateManySuper_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
  }

  export type FocusCareServiceCheckModelCreateManyService_super_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    request_id: string
  }

  export type ServiceSubCategoryModelUpdateWithoutSuper_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    expertises?: SubExpertiseModelUpdateManyWithoutSub_categoryNestedInput
  }

  export type ServiceSubCategoryModelUncheckedUpdateWithoutSuper_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    expertises?: SubExpertiseModelUncheckedUpdateManyWithoutSub_categoryNestedInput
  }

  export type ServiceSubCategoryModelUncheckedUpdateManyWithoutSub_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FocusCareServiceCheckModelUpdateWithoutService_super_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    request?: FocusCareRequestModelUpdateOneRequiredWithoutServicesNestedInput
  }

  export type FocusCareServiceCheckModelUncheckedUpdateWithoutService_super_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    request_id?: StringFieldUpdateOperationsInput | string
  }

  export type FocusCareServiceCheckModelUncheckedUpdateManyWithoutFocus_care_checksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    request_id?: StringFieldUpdateOperationsInput | string
  }

  export type FocusCareConsultationTimeCheckModelCreateManyRequestInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    consultation_time_id: string
  }

  export type FocusCareServiceCheckModelCreateManyRequestInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    service_super_category_id: string
  }

  export type FocusCareConsultationTimeCheckModelUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consultation_time?: ConsultationTimeModelUpdateOneRequiredWithoutFocus_care_checksNestedInput
  }

  export type FocusCareConsultationTimeCheckModelUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consultation_time_id?: StringFieldUpdateOperationsInput | string
  }

  export type FocusCareConsultationTimeCheckModelUncheckedUpdateManyWithoutConsultation_timesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consultation_time_id?: StringFieldUpdateOperationsInput | string
  }

  export type FocusCareServiceCheckModelUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_super_category?: ServiceSuperCategoryModelUpdateOneRequiredWithoutFocus_care_checksNestedInput
  }

  export type FocusCareServiceCheckModelUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_super_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type FocusCareServiceCheckModelUncheckedUpdateManyWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_super_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type AgreementAcceptanceModelCreateManyUserInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    agreement_id: string
  }

  export type AgreementAcceptanceModelUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agreement?: AgreementModelUpdateOneRequiredWithoutAcceptancesNestedInput
  }

  export type AgreementAcceptanceModelUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agreement_id?: StringFieldUpdateOperationsInput | string
  }

  export type AgreementAcceptanceModelUncheckedUpdateManyWithoutAgreement_acceptancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agreement_id?: StringFieldUpdateOperationsInput | string
  }

  export type OauthAccountModelCreateManyCustomerInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    oauth_type: OauthType
    oauth_sub: string
    business_user_id?: string | null
    name?: string | null
    email?: string | null
    phone?: string | null
    profile_image_url?: string | null
    birth?: string | null
    gender?: GenderType | null
    address_first?: string | null
    address_second?: string | null
  }

  export type ReviewModelCreateManyReviewerInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    reviewee_id: string
    content: string
  }

  export type FocusCareRequestModelCreateManyRequesterInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    care_start_date: Date | string
    care_end_date: Date | string
    detail: string
    status: FocusCareStatus
  }

  export type OauthAccountModelUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauth_type?: EnumOauthTypeFieldUpdateOperationsInput | OauthType
    oauth_sub?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    business_user?: BusinessUserModelUpdateOneWithoutOauth_accountsNestedInput
  }

  export type OauthAccountModelUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauth_type?: EnumOauthTypeFieldUpdateOperationsInput | OauthType
    oauth_sub?: StringFieldUpdateOperationsInput | string
    business_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OauthAccountModelUncheckedUpdateManyWithoutOauth_accountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauth_type?: EnumOauthTypeFieldUpdateOperationsInput | OauthType
    oauth_sub?: StringFieldUpdateOperationsInput | string
    business_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReviewModelUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    reviewee?: BusinessUserModelUpdateOneRequiredWithoutReviewsNestedInput
    rates?: RateModelUpdateManyWithoutReviewNestedInput
  }

  export type ReviewModelUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewee_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rates?: RateModelUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewModelUncheckedUpdateManyWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewee_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type FocusCareRequestModelUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    care_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    care_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: StringFieldUpdateOperationsInput | string
    status?: EnumFocusCareStatusFieldUpdateOperationsInput | FocusCareStatus
    consultation_times?: FocusCareConsultationTimeCheckModelUpdateManyWithoutRequestNestedInput
    services?: FocusCareServiceCheckModelUpdateManyWithoutRequestNestedInput
  }

  export type FocusCareRequestModelUncheckedUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    care_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    care_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: StringFieldUpdateOperationsInput | string
    status?: EnumFocusCareStatusFieldUpdateOperationsInput | FocusCareStatus
    consultation_times?: FocusCareConsultationTimeCheckModelUncheckedUpdateManyWithoutRequestNestedInput
    services?: FocusCareServiceCheckModelUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type FocusCareRequestModelUncheckedUpdateManyWithoutFocus_care_requestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    care_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    care_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: StringFieldUpdateOperationsInput | string
    status?: EnumFocusCareStatusFieldUpdateOperationsInput | FocusCareStatus
  }

  export type BusinessCertificationImageModelCreateManyBusiness_userInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    url: string
  }

  export type SubExpertiseModelCreateManyBusiness_userInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    sub_category_id: string
  }

  export type OauthAccountModelCreateManyBusiness_userInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    oauth_type: OauthType
    oauth_sub: string
    customer_id?: string | null
    name?: string | null
    email?: string | null
    phone?: string | null
    profile_image_url?: string | null
    birth?: string | null
    gender?: GenderType | null
    address_first?: string | null
    address_second?: string | null
  }

  export type ReviewModelCreateManyRevieweeInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    reviewer_id: string
    content: string
  }

  export type BusinessCertificationImageModelUpdateWithoutBusiness_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessCertificationImageModelUncheckedUpdateWithoutBusiness_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessCertificationImageModelUncheckedUpdateManyWithoutCertification_imagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SubExpertiseModelUpdateWithoutBusiness_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_category?: ServiceSubCategoryModelUpdateOneRequiredWithoutExpertisesNestedInput
  }

  export type SubExpertiseModelUncheckedUpdateWithoutBusiness_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type SubExpertiseModelUncheckedUpdateManyWithoutSub_expertisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type OauthAccountModelUpdateWithoutBusiness_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauth_type?: EnumOauthTypeFieldUpdateOperationsInput | OauthType
    oauth_sub?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerModelUpdateOneWithoutOauth_accountsNestedInput
  }

  export type OauthAccountModelUncheckedUpdateWithoutBusiness_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauth_type?: EnumOauthTypeFieldUpdateOperationsInput | OauthType
    oauth_sub?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReviewModelUpdateWithoutRevieweeInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    reviewer?: CustomerModelUpdateOneRequiredWithoutReviewsNestedInput
    rates?: RateModelUpdateManyWithoutReviewNestedInput
  }

  export type ReviewModelUncheckedUpdateWithoutRevieweeInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewer_id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rates?: RateModelUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type REProertyModelCreateManyRe_agentInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    main_image_url: string
  }

  export type REProertyModelUpdateWithoutRe_agentInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
    categories?: REPropertyCategoryModelUpdateManyWithoutRe_propertyNestedInput
  }

  export type REProertyModelUncheckedUpdateWithoutRe_agentInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
    categories?: REPropertyCategoryModelUncheckedUpdateManyWithoutRe_propertyNestedInput
  }

  export type REProertyModelUncheckedUpdateManyWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
  }

  export type HSIntroductionImageModelCreateManyHs_providerInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    url: string
  }

  export type HSIntroductionImageModelUpdateWithoutHs_providerInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: StringFieldUpdateOperationsInput | string
  }

  export type HSIntroductionImageModelUncheckedUpdateWithoutHs_providerInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: StringFieldUpdateOperationsInput | string
  }

  export type HSIntroductionImageModelUncheckedUpdateManyWithoutIntroduction_imagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}