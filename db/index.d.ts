
/**
 * Client
**/

import * as runtime from './runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model AuthenticationModel
 * 
 */
export type AuthenticationModel = {
  id: string
  oauth_sub: string
  oauth_type: string
  business_user_id: string | null
  customer_id: string | null
}

/**
 * Model UserModel
 * 
 */
export type UserModel = {
  id: string
  name: string
  email: string | null
  email_verified: boolean
  phone: string | null
  phone_verified: boolean
  address_first: string | null
  address_second: string | null
  profile_image: string | null
}

/**
 * Model CustomerModel
 * 
 */
export type CustomerModel = {
  id: string
  birth: string | null
  gender: string | null
}

/**
 * Model BusinessUserModel
 * 
 */
export type BusinessUserModel = {
  id: string
  is_verified: boolean
  introduction_title: string
  introduction_content: string
}

/**
 * Model RealEstateAgentModel
 * 
 */
export type RealEstateAgentModel = {
  id: string
  is_licensed: boolean
  real_estate_num: string
  real_estate_name: string
  real_estate_phone: string
  licensed_agent_name: string
  specialized_field_id: string | null
}

/**
 * Model HomeCareCompanyModel
 * 
 */
export type HomeCareCompanyModel = {
  id: string
  business_registration_num: string
  specialized_field_id: string | null
}

/**
 * Model HomeCareIntroductionImageModel
 * 
 */
export type HomeCareIntroductionImageModel = {
  id: string
  image_url: string
  company_id: string
}

/**
 * Model RealEstatePropertyModel
 * 
 */
export type RealEstatePropertyModel = {
  id: string
  name: string
  main_image_url: string
  agent_id: string
}

/**
 * Model HomeCareSpecializedSuperFieldModel
 * 
 */
export type HomeCareSpecializedSuperFieldModel = {
  id: string
  name: string
}

/**
 * Model HomeCareSpecializedSubFieldModel
 * 
 */
export type HomeCareSpecializedSubFieldModel = {
  id: string
  name: string
  super_id: string
}

/**
 * Model RealEstateSpecializedSuperFieldModel
 * 
 */
export type RealEstateSpecializedSuperFieldModel = {
  id: string
  name: string
}

/**
 * Model RealEstateSpecializedSubFieldModel
 * 
 */
export type RealEstateSpecializedSubFieldModel = {
  id: string
  name: string
  super_id: string
}

/**
 * Model BusinessRateModel
 * 
 */
export type BusinessRateModel = {
  id: string
  category_id: string
  ratee_id: string
  rater_id: string
  rate: number
}

/**
 * Model BusinessRateCategoryModel
 * 
 */
export type BusinessRateCategoryModel = {
  id: string
  name: string
}

/**
 * Model BusinessReviewModel
 * 
 */
export type BusinessReviewModel = {
  id: string
  reviewee_id: string
  reviewer_id: string
  review: string
}

/**
 * Model BoardModel
 * 
 */
export type BoardModel = {
  id: string
  name: string
}

/**
 * Model BoardArticleModel
 * 
 */
export type BoardArticleModel = {
  id: string
  title: string
  author_id: string
  board_id: string
}

/**
 * Model BoardArticleContentModel
 * 
 */
export type BoardArticleContentModel = {
  id: string
  text: string
  created_at: Date
  article_id: string
}

/**
 * Model BoardCommentModel
 * 
 */
export type BoardCommentModel = {
  id: string
  author_id: string
  article_id: string
}

/**
 * Model BoardCommentContentModel
 * 
 */
export type BoardCommentContentModel = {
  id: string
  text: string
  created_at: Date
  comment_id: string
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more AuthenticationModels
 * const authenticationModels = await prisma.authenticationModel.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more AuthenticationModels
   * const authenticationModels = await prisma.authenticationModel.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.authenticationModel`: Exposes CRUD operations for the **AuthenticationModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuthenticationModels
    * const authenticationModels = await prisma.authenticationModel.findMany()
    * ```
    */
  get authenticationModel(): Prisma.AuthenticationModelDelegate<GlobalReject>;

  /**
   * `prisma.userModel`: Exposes CRUD operations for the **UserModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserModels
    * const userModels = await prisma.userModel.findMany()
    * ```
    */
  get userModel(): Prisma.UserModelDelegate<GlobalReject>;

  /**
   * `prisma.customerModel`: Exposes CRUD operations for the **CustomerModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerModels
    * const customerModels = await prisma.customerModel.findMany()
    * ```
    */
  get customerModel(): Prisma.CustomerModelDelegate<GlobalReject>;

  /**
   * `prisma.businessUserModel`: Exposes CRUD operations for the **BusinessUserModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessUserModels
    * const businessUserModels = await prisma.businessUserModel.findMany()
    * ```
    */
  get businessUserModel(): Prisma.BusinessUserModelDelegate<GlobalReject>;

  /**
   * `prisma.realEstateAgentModel`: Exposes CRUD operations for the **RealEstateAgentModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RealEstateAgentModels
    * const realEstateAgentModels = await prisma.realEstateAgentModel.findMany()
    * ```
    */
  get realEstateAgentModel(): Prisma.RealEstateAgentModelDelegate<GlobalReject>;

  /**
   * `prisma.homeCareCompanyModel`: Exposes CRUD operations for the **HomeCareCompanyModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HomeCareCompanyModels
    * const homeCareCompanyModels = await prisma.homeCareCompanyModel.findMany()
    * ```
    */
  get homeCareCompanyModel(): Prisma.HomeCareCompanyModelDelegate<GlobalReject>;

  /**
   * `prisma.homeCareIntroductionImageModel`: Exposes CRUD operations for the **HomeCareIntroductionImageModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HomeCareIntroductionImageModels
    * const homeCareIntroductionImageModels = await prisma.homeCareIntroductionImageModel.findMany()
    * ```
    */
  get homeCareIntroductionImageModel(): Prisma.HomeCareIntroductionImageModelDelegate<GlobalReject>;

  /**
   * `prisma.realEstatePropertyModel`: Exposes CRUD operations for the **RealEstatePropertyModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RealEstatePropertyModels
    * const realEstatePropertyModels = await prisma.realEstatePropertyModel.findMany()
    * ```
    */
  get realEstatePropertyModel(): Prisma.RealEstatePropertyModelDelegate<GlobalReject>;

  /**
   * `prisma.homeCareSpecializedSuperFieldModel`: Exposes CRUD operations for the **HomeCareSpecializedSuperFieldModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HomeCareSpecializedSuperFieldModels
    * const homeCareSpecializedSuperFieldModels = await prisma.homeCareSpecializedSuperFieldModel.findMany()
    * ```
    */
  get homeCareSpecializedSuperFieldModel(): Prisma.HomeCareSpecializedSuperFieldModelDelegate<GlobalReject>;

  /**
   * `prisma.homeCareSpecializedSubFieldModel`: Exposes CRUD operations for the **HomeCareSpecializedSubFieldModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HomeCareSpecializedSubFieldModels
    * const homeCareSpecializedSubFieldModels = await prisma.homeCareSpecializedSubFieldModel.findMany()
    * ```
    */
  get homeCareSpecializedSubFieldModel(): Prisma.HomeCareSpecializedSubFieldModelDelegate<GlobalReject>;

  /**
   * `prisma.realEstateSpecializedSuperFieldModel`: Exposes CRUD operations for the **RealEstateSpecializedSuperFieldModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RealEstateSpecializedSuperFieldModels
    * const realEstateSpecializedSuperFieldModels = await prisma.realEstateSpecializedSuperFieldModel.findMany()
    * ```
    */
  get realEstateSpecializedSuperFieldModel(): Prisma.RealEstateSpecializedSuperFieldModelDelegate<GlobalReject>;

  /**
   * `prisma.realEstateSpecializedSubFieldModel`: Exposes CRUD operations for the **RealEstateSpecializedSubFieldModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RealEstateSpecializedSubFieldModels
    * const realEstateSpecializedSubFieldModels = await prisma.realEstateSpecializedSubFieldModel.findMany()
    * ```
    */
  get realEstateSpecializedSubFieldModel(): Prisma.RealEstateSpecializedSubFieldModelDelegate<GlobalReject>;

  /**
   * `prisma.businessRateModel`: Exposes CRUD operations for the **BusinessRateModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessRateModels
    * const businessRateModels = await prisma.businessRateModel.findMany()
    * ```
    */
  get businessRateModel(): Prisma.BusinessRateModelDelegate<GlobalReject>;

  /**
   * `prisma.businessRateCategoryModel`: Exposes CRUD operations for the **BusinessRateCategoryModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessRateCategoryModels
    * const businessRateCategoryModels = await prisma.businessRateCategoryModel.findMany()
    * ```
    */
  get businessRateCategoryModel(): Prisma.BusinessRateCategoryModelDelegate<GlobalReject>;

  /**
   * `prisma.businessReviewModel`: Exposes CRUD operations for the **BusinessReviewModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessReviewModels
    * const businessReviewModels = await prisma.businessReviewModel.findMany()
    * ```
    */
  get businessReviewModel(): Prisma.BusinessReviewModelDelegate<GlobalReject>;

  /**
   * `prisma.boardModel`: Exposes CRUD operations for the **BoardModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BoardModels
    * const boardModels = await prisma.boardModel.findMany()
    * ```
    */
  get boardModel(): Prisma.BoardModelDelegate<GlobalReject>;

  /**
   * `prisma.boardArticleModel`: Exposes CRUD operations for the **BoardArticleModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BoardArticleModels
    * const boardArticleModels = await prisma.boardArticleModel.findMany()
    * ```
    */
  get boardArticleModel(): Prisma.BoardArticleModelDelegate<GlobalReject>;

  /**
   * `prisma.boardArticleContentModel`: Exposes CRUD operations for the **BoardArticleContentModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BoardArticleContentModels
    * const boardArticleContentModels = await prisma.boardArticleContentModel.findMany()
    * ```
    */
  get boardArticleContentModel(): Prisma.BoardArticleContentModelDelegate<GlobalReject>;

  /**
   * `prisma.boardCommentModel`: Exposes CRUD operations for the **BoardCommentModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BoardCommentModels
    * const boardCommentModels = await prisma.boardCommentModel.findMany()
    * ```
    */
  get boardCommentModel(): Prisma.BoardCommentModelDelegate<GlobalReject>;

  /**
   * `prisma.boardCommentContentModel`: Exposes CRUD operations for the **BoardCommentContentModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BoardCommentContentModels
    * const boardCommentContentModels = await prisma.boardCommentContentModel.findMany()
    * ```
    */
  get boardCommentContentModel(): Prisma.BoardCommentContentModelDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.12.0
   * Query Engine version: 659ef412370fa3b41cd7bf6e94587c1dfb7f67e7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    AuthenticationModel: 'AuthenticationModel',
    UserModel: 'UserModel',
    CustomerModel: 'CustomerModel',
    BusinessUserModel: 'BusinessUserModel',
    RealEstateAgentModel: 'RealEstateAgentModel',
    HomeCareCompanyModel: 'HomeCareCompanyModel',
    HomeCareIntroductionImageModel: 'HomeCareIntroductionImageModel',
    RealEstatePropertyModel: 'RealEstatePropertyModel',
    HomeCareSpecializedSuperFieldModel: 'HomeCareSpecializedSuperFieldModel',
    HomeCareSpecializedSubFieldModel: 'HomeCareSpecializedSubFieldModel',
    RealEstateSpecializedSuperFieldModel: 'RealEstateSpecializedSuperFieldModel',
    RealEstateSpecializedSubFieldModel: 'RealEstateSpecializedSubFieldModel',
    BusinessRateModel: 'BusinessRateModel',
    BusinessRateCategoryModel: 'BusinessRateCategoryModel',
    BusinessReviewModel: 'BusinessReviewModel',
    BoardModel: 'BoardModel',
    BoardArticleModel: 'BoardArticleModel',
    BoardArticleContentModel: 'BoardArticleContentModel',
    BoardCommentModel: 'BoardCommentModel',
    BoardCommentContentModel: 'BoardCommentContentModel'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserModelCountOutputType
   */


  export type UserModelCountOutputType = {
    board_articles: number
    board_comments: number
  }

  export type UserModelCountOutputTypeSelect = {
    board_articles?: boolean
    board_comments?: boolean
  }

  export type UserModelCountOutputTypeGetPayload<S extends boolean | null | undefined | UserModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserModelCountOutputTypeArgs)
    ? UserModelCountOutputType 
    : S extends { select: any } & (UserModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserModelCountOutputType ? UserModelCountOutputType[P] : never
  } 
      : UserModelCountOutputType




  // Custom InputTypes

  /**
   * UserModelCountOutputType without action
   */
  export type UserModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserModelCountOutputType
     */
    select?: UserModelCountOutputTypeSelect | null
  }



  /**
   * Count Type CustomerModelCountOutputType
   */


  export type CustomerModelCountOutputType = {
    authentications: number
    rates: number
    reviews: number
  }

  export type CustomerModelCountOutputTypeSelect = {
    authentications?: boolean
    rates?: boolean
    reviews?: boolean
  }

  export type CustomerModelCountOutputTypeGetPayload<S extends boolean | null | undefined | CustomerModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CustomerModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CustomerModelCountOutputTypeArgs)
    ? CustomerModelCountOutputType 
    : S extends { select: any } & (CustomerModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CustomerModelCountOutputType ? CustomerModelCountOutputType[P] : never
  } 
      : CustomerModelCountOutputType




  // Custom InputTypes

  /**
   * CustomerModelCountOutputType without action
   */
  export type CustomerModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CustomerModelCountOutputType
     */
    select?: CustomerModelCountOutputTypeSelect | null
  }



  /**
   * Count Type BusinessUserModelCountOutputType
   */


  export type BusinessUserModelCountOutputType = {
    authentications: number
    rates: number
    reviews: number
  }

  export type BusinessUserModelCountOutputTypeSelect = {
    authentications?: boolean
    rates?: boolean
    reviews?: boolean
  }

  export type BusinessUserModelCountOutputTypeGetPayload<S extends boolean | null | undefined | BusinessUserModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BusinessUserModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BusinessUserModelCountOutputTypeArgs)
    ? BusinessUserModelCountOutputType 
    : S extends { select: any } & (BusinessUserModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BusinessUserModelCountOutputType ? BusinessUserModelCountOutputType[P] : never
  } 
      : BusinessUserModelCountOutputType




  // Custom InputTypes

  /**
   * BusinessUserModelCountOutputType without action
   */
  export type BusinessUserModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BusinessUserModelCountOutputType
     */
    select?: BusinessUserModelCountOutputTypeSelect | null
  }



  /**
   * Count Type RealEstateAgentModelCountOutputType
   */


  export type RealEstateAgentModelCountOutputType = {
    properties: number
  }

  export type RealEstateAgentModelCountOutputTypeSelect = {
    properties?: boolean
  }

  export type RealEstateAgentModelCountOutputTypeGetPayload<S extends boolean | null | undefined | RealEstateAgentModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RealEstateAgentModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RealEstateAgentModelCountOutputTypeArgs)
    ? RealEstateAgentModelCountOutputType 
    : S extends { select: any } & (RealEstateAgentModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RealEstateAgentModelCountOutputType ? RealEstateAgentModelCountOutputType[P] : never
  } 
      : RealEstateAgentModelCountOutputType




  // Custom InputTypes

  /**
   * RealEstateAgentModelCountOutputType without action
   */
  export type RealEstateAgentModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RealEstateAgentModelCountOutputType
     */
    select?: RealEstateAgentModelCountOutputTypeSelect | null
  }



  /**
   * Count Type HomeCareCompanyModelCountOutputType
   */


  export type HomeCareCompanyModelCountOutputType = {
    introduction_images: number
  }

  export type HomeCareCompanyModelCountOutputTypeSelect = {
    introduction_images?: boolean
  }

  export type HomeCareCompanyModelCountOutputTypeGetPayload<S extends boolean | null | undefined | HomeCareCompanyModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HomeCareCompanyModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (HomeCareCompanyModelCountOutputTypeArgs)
    ? HomeCareCompanyModelCountOutputType 
    : S extends { select: any } & (HomeCareCompanyModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof HomeCareCompanyModelCountOutputType ? HomeCareCompanyModelCountOutputType[P] : never
  } 
      : HomeCareCompanyModelCountOutputType




  // Custom InputTypes

  /**
   * HomeCareCompanyModelCountOutputType without action
   */
  export type HomeCareCompanyModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the HomeCareCompanyModelCountOutputType
     */
    select?: HomeCareCompanyModelCountOutputTypeSelect | null
  }



  /**
   * Count Type HomeCareSpecializedSuperFieldModelCountOutputType
   */


  export type HomeCareSpecializedSuperFieldModelCountOutputType = {
    sub: number
  }

  export type HomeCareSpecializedSuperFieldModelCountOutputTypeSelect = {
    sub?: boolean
  }

  export type HomeCareSpecializedSuperFieldModelCountOutputTypeGetPayload<S extends boolean | null | undefined | HomeCareSpecializedSuperFieldModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HomeCareSpecializedSuperFieldModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (HomeCareSpecializedSuperFieldModelCountOutputTypeArgs)
    ? HomeCareSpecializedSuperFieldModelCountOutputType 
    : S extends { select: any } & (HomeCareSpecializedSuperFieldModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof HomeCareSpecializedSuperFieldModelCountOutputType ? HomeCareSpecializedSuperFieldModelCountOutputType[P] : never
  } 
      : HomeCareSpecializedSuperFieldModelCountOutputType




  // Custom InputTypes

  /**
   * HomeCareSpecializedSuperFieldModelCountOutputType without action
   */
  export type HomeCareSpecializedSuperFieldModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the HomeCareSpecializedSuperFieldModelCountOutputType
     */
    select?: HomeCareSpecializedSuperFieldModelCountOutputTypeSelect | null
  }



  /**
   * Count Type HomeCareSpecializedSubFieldModelCountOutputType
   */


  export type HomeCareSpecializedSubFieldModelCountOutputType = {
    home_care_companies: number
  }

  export type HomeCareSpecializedSubFieldModelCountOutputTypeSelect = {
    home_care_companies?: boolean
  }

  export type HomeCareSpecializedSubFieldModelCountOutputTypeGetPayload<S extends boolean | null | undefined | HomeCareSpecializedSubFieldModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HomeCareSpecializedSubFieldModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (HomeCareSpecializedSubFieldModelCountOutputTypeArgs)
    ? HomeCareSpecializedSubFieldModelCountOutputType 
    : S extends { select: any } & (HomeCareSpecializedSubFieldModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof HomeCareSpecializedSubFieldModelCountOutputType ? HomeCareSpecializedSubFieldModelCountOutputType[P] : never
  } 
      : HomeCareSpecializedSubFieldModelCountOutputType




  // Custom InputTypes

  /**
   * HomeCareSpecializedSubFieldModelCountOutputType without action
   */
  export type HomeCareSpecializedSubFieldModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the HomeCareSpecializedSubFieldModelCountOutputType
     */
    select?: HomeCareSpecializedSubFieldModelCountOutputTypeSelect | null
  }



  /**
   * Count Type RealEstateSpecializedSuperFieldModelCountOutputType
   */


  export type RealEstateSpecializedSuperFieldModelCountOutputType = {
    sub: number
  }

  export type RealEstateSpecializedSuperFieldModelCountOutputTypeSelect = {
    sub?: boolean
  }

  export type RealEstateSpecializedSuperFieldModelCountOutputTypeGetPayload<S extends boolean | null | undefined | RealEstateSpecializedSuperFieldModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RealEstateSpecializedSuperFieldModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RealEstateSpecializedSuperFieldModelCountOutputTypeArgs)
    ? RealEstateSpecializedSuperFieldModelCountOutputType 
    : S extends { select: any } & (RealEstateSpecializedSuperFieldModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RealEstateSpecializedSuperFieldModelCountOutputType ? RealEstateSpecializedSuperFieldModelCountOutputType[P] : never
  } 
      : RealEstateSpecializedSuperFieldModelCountOutputType




  // Custom InputTypes

  /**
   * RealEstateSpecializedSuperFieldModelCountOutputType without action
   */
  export type RealEstateSpecializedSuperFieldModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RealEstateSpecializedSuperFieldModelCountOutputType
     */
    select?: RealEstateSpecializedSuperFieldModelCountOutputTypeSelect | null
  }



  /**
   * Count Type RealEstateSpecializedSubFieldModelCountOutputType
   */


  export type RealEstateSpecializedSubFieldModelCountOutputType = {
    real_estate_agents: number
  }

  export type RealEstateSpecializedSubFieldModelCountOutputTypeSelect = {
    real_estate_agents?: boolean
  }

  export type RealEstateSpecializedSubFieldModelCountOutputTypeGetPayload<S extends boolean | null | undefined | RealEstateSpecializedSubFieldModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RealEstateSpecializedSubFieldModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RealEstateSpecializedSubFieldModelCountOutputTypeArgs)
    ? RealEstateSpecializedSubFieldModelCountOutputType 
    : S extends { select: any } & (RealEstateSpecializedSubFieldModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RealEstateSpecializedSubFieldModelCountOutputType ? RealEstateSpecializedSubFieldModelCountOutputType[P] : never
  } 
      : RealEstateSpecializedSubFieldModelCountOutputType




  // Custom InputTypes

  /**
   * RealEstateSpecializedSubFieldModelCountOutputType without action
   */
  export type RealEstateSpecializedSubFieldModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RealEstateSpecializedSubFieldModelCountOutputType
     */
    select?: RealEstateSpecializedSubFieldModelCountOutputTypeSelect | null
  }



  /**
   * Count Type BusinessRateCategoryModelCountOutputType
   */


  export type BusinessRateCategoryModelCountOutputType = {
    rates: number
  }

  export type BusinessRateCategoryModelCountOutputTypeSelect = {
    rates?: boolean
  }

  export type BusinessRateCategoryModelCountOutputTypeGetPayload<S extends boolean | null | undefined | BusinessRateCategoryModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BusinessRateCategoryModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BusinessRateCategoryModelCountOutputTypeArgs)
    ? BusinessRateCategoryModelCountOutputType 
    : S extends { select: any } & (BusinessRateCategoryModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BusinessRateCategoryModelCountOutputType ? BusinessRateCategoryModelCountOutputType[P] : never
  } 
      : BusinessRateCategoryModelCountOutputType




  // Custom InputTypes

  /**
   * BusinessRateCategoryModelCountOutputType without action
   */
  export type BusinessRateCategoryModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BusinessRateCategoryModelCountOutputType
     */
    select?: BusinessRateCategoryModelCountOutputTypeSelect | null
  }



  /**
   * Count Type BoardModelCountOutputType
   */


  export type BoardModelCountOutputType = {
    articles: number
  }

  export type BoardModelCountOutputTypeSelect = {
    articles?: boolean
  }

  export type BoardModelCountOutputTypeGetPayload<S extends boolean | null | undefined | BoardModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BoardModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BoardModelCountOutputTypeArgs)
    ? BoardModelCountOutputType 
    : S extends { select: any } & (BoardModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BoardModelCountOutputType ? BoardModelCountOutputType[P] : never
  } 
      : BoardModelCountOutputType




  // Custom InputTypes

  /**
   * BoardModelCountOutputType without action
   */
  export type BoardModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BoardModelCountOutputType
     */
    select?: BoardModelCountOutputTypeSelect | null
  }



  /**
   * Count Type BoardArticleModelCountOutputType
   */


  export type BoardArticleModelCountOutputType = {
    contents: number
    comments: number
  }

  export type BoardArticleModelCountOutputTypeSelect = {
    contents?: boolean
    comments?: boolean
  }

  export type BoardArticleModelCountOutputTypeGetPayload<S extends boolean | null | undefined | BoardArticleModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BoardArticleModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BoardArticleModelCountOutputTypeArgs)
    ? BoardArticleModelCountOutputType 
    : S extends { select: any } & (BoardArticleModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BoardArticleModelCountOutputType ? BoardArticleModelCountOutputType[P] : never
  } 
      : BoardArticleModelCountOutputType




  // Custom InputTypes

  /**
   * BoardArticleModelCountOutputType without action
   */
  export type BoardArticleModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BoardArticleModelCountOutputType
     */
    select?: BoardArticleModelCountOutputTypeSelect | null
  }



  /**
   * Count Type BoardCommentModelCountOutputType
   */


  export type BoardCommentModelCountOutputType = {
    contents: number
  }

  export type BoardCommentModelCountOutputTypeSelect = {
    contents?: boolean
  }

  export type BoardCommentModelCountOutputTypeGetPayload<S extends boolean | null | undefined | BoardCommentModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BoardCommentModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BoardCommentModelCountOutputTypeArgs)
    ? BoardCommentModelCountOutputType 
    : S extends { select: any } & (BoardCommentModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BoardCommentModelCountOutputType ? BoardCommentModelCountOutputType[P] : never
  } 
      : BoardCommentModelCountOutputType




  // Custom InputTypes

  /**
   * BoardCommentModelCountOutputType without action
   */
  export type BoardCommentModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BoardCommentModelCountOutputType
     */
    select?: BoardCommentModelCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model AuthenticationModel
   */


  export type AggregateAuthenticationModel = {
    _count: AuthenticationModelCountAggregateOutputType | null
    _min: AuthenticationModelMinAggregateOutputType | null
    _max: AuthenticationModelMaxAggregateOutputType | null
  }

  export type AuthenticationModelMinAggregateOutputType = {
    id: string | null
    oauth_sub: string | null
    oauth_type: string | null
    business_user_id: string | null
    customer_id: string | null
  }

  export type AuthenticationModelMaxAggregateOutputType = {
    id: string | null
    oauth_sub: string | null
    oauth_type: string | null
    business_user_id: string | null
    customer_id: string | null
  }

  export type AuthenticationModelCountAggregateOutputType = {
    id: number
    oauth_sub: number
    oauth_type: number
    business_user_id: number
    customer_id: number
    _all: number
  }


  export type AuthenticationModelMinAggregateInputType = {
    id?: true
    oauth_sub?: true
    oauth_type?: true
    business_user_id?: true
    customer_id?: true
  }

  export type AuthenticationModelMaxAggregateInputType = {
    id?: true
    oauth_sub?: true
    oauth_type?: true
    business_user_id?: true
    customer_id?: true
  }

  export type AuthenticationModelCountAggregateInputType = {
    id?: true
    oauth_sub?: true
    oauth_type?: true
    business_user_id?: true
    customer_id?: true
    _all?: true
  }

  export type AuthenticationModelAggregateArgs = {
    /**
     * Filter which AuthenticationModel to aggregate.
     */
    where?: AuthenticationModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthenticationModels to fetch.
     */
    orderBy?: Enumerable<AuthenticationModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthenticationModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthenticationModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthenticationModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuthenticationModels
    **/
    _count?: true | AuthenticationModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthenticationModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthenticationModelMaxAggregateInputType
  }

  export type GetAuthenticationModelAggregateType<T extends AuthenticationModelAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthenticationModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthenticationModel[P]>
      : GetScalarType<T[P], AggregateAuthenticationModel[P]>
  }




  export type AuthenticationModelGroupByArgs = {
    where?: AuthenticationModelWhereInput
    orderBy?: Enumerable<AuthenticationModelOrderByWithAggregationInput>
    by: AuthenticationModelScalarFieldEnum[]
    having?: AuthenticationModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthenticationModelCountAggregateInputType | true
    _min?: AuthenticationModelMinAggregateInputType
    _max?: AuthenticationModelMaxAggregateInputType
  }


  export type AuthenticationModelGroupByOutputType = {
    id: string
    oauth_sub: string
    oauth_type: string
    business_user_id: string | null
    customer_id: string | null
    _count: AuthenticationModelCountAggregateOutputType | null
    _min: AuthenticationModelMinAggregateOutputType | null
    _max: AuthenticationModelMaxAggregateOutputType | null
  }

  type GetAuthenticationModelGroupByPayload<T extends AuthenticationModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AuthenticationModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthenticationModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthenticationModelGroupByOutputType[P]>
            : GetScalarType<T[P], AuthenticationModelGroupByOutputType[P]>
        }
      >
    >


  export type AuthenticationModelSelect = {
    id?: boolean
    oauth_sub?: boolean
    oauth_type?: boolean
    business_user_id?: boolean
    customer_id?: boolean
    business_user?: boolean | BusinessUserModelArgs
    customer?: boolean | CustomerModelArgs
  }


  export type AuthenticationModelInclude = {
    business_user?: boolean | BusinessUserModelArgs
    customer?: boolean | CustomerModelArgs
  }

  export type AuthenticationModelGetPayload<S extends boolean | null | undefined | AuthenticationModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AuthenticationModel :
    S extends undefined ? never :
    S extends { include: any } & (AuthenticationModelArgs | AuthenticationModelFindManyArgs)
    ? AuthenticationModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'business_user' ? BusinessUserModelGetPayload<S['include'][P]> | null :
        P extends 'customer' ? CustomerModelGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (AuthenticationModelArgs | AuthenticationModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'business_user' ? BusinessUserModelGetPayload<S['select'][P]> | null :
        P extends 'customer' ? CustomerModelGetPayload<S['select'][P]> | null :  P extends keyof AuthenticationModel ? AuthenticationModel[P] : never
  } 
      : AuthenticationModel


  type AuthenticationModelCountArgs = 
    Omit<AuthenticationModelFindManyArgs, 'select' | 'include'> & {
      select?: AuthenticationModelCountAggregateInputType | true
    }

  export interface AuthenticationModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one AuthenticationModel that matches the filter.
     * @param {AuthenticationModelFindUniqueArgs} args - Arguments to find a AuthenticationModel
     * @example
     * // Get one AuthenticationModel
     * const authenticationModel = await prisma.authenticationModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AuthenticationModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AuthenticationModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AuthenticationModel'> extends True ? Prisma__AuthenticationModelClient<AuthenticationModelGetPayload<T>> : Prisma__AuthenticationModelClient<AuthenticationModelGetPayload<T> | null, null>

    /**
     * Find one AuthenticationModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AuthenticationModelFindUniqueOrThrowArgs} args - Arguments to find a AuthenticationModel
     * @example
     * // Get one AuthenticationModel
     * const authenticationModel = await prisma.authenticationModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AuthenticationModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AuthenticationModelFindUniqueOrThrowArgs>
    ): Prisma__AuthenticationModelClient<AuthenticationModelGetPayload<T>>

    /**
     * Find the first AuthenticationModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticationModelFindFirstArgs} args - Arguments to find a AuthenticationModel
     * @example
     * // Get one AuthenticationModel
     * const authenticationModel = await prisma.authenticationModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AuthenticationModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AuthenticationModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AuthenticationModel'> extends True ? Prisma__AuthenticationModelClient<AuthenticationModelGetPayload<T>> : Prisma__AuthenticationModelClient<AuthenticationModelGetPayload<T> | null, null>

    /**
     * Find the first AuthenticationModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticationModelFindFirstOrThrowArgs} args - Arguments to find a AuthenticationModel
     * @example
     * // Get one AuthenticationModel
     * const authenticationModel = await prisma.authenticationModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AuthenticationModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AuthenticationModelFindFirstOrThrowArgs>
    ): Prisma__AuthenticationModelClient<AuthenticationModelGetPayload<T>>

    /**
     * Find zero or more AuthenticationModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticationModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuthenticationModels
     * const authenticationModels = await prisma.authenticationModel.findMany()
     * 
     * // Get first 10 AuthenticationModels
     * const authenticationModels = await prisma.authenticationModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authenticationModelWithIdOnly = await prisma.authenticationModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AuthenticationModelFindManyArgs>(
      args?: SelectSubset<T, AuthenticationModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<AuthenticationModelGetPayload<T>>>

    /**
     * Create a AuthenticationModel.
     * @param {AuthenticationModelCreateArgs} args - Arguments to create a AuthenticationModel.
     * @example
     * // Create one AuthenticationModel
     * const AuthenticationModel = await prisma.authenticationModel.create({
     *   data: {
     *     // ... data to create a AuthenticationModel
     *   }
     * })
     * 
    **/
    create<T extends AuthenticationModelCreateArgs>(
      args: SelectSubset<T, AuthenticationModelCreateArgs>
    ): Prisma__AuthenticationModelClient<AuthenticationModelGetPayload<T>>

    /**
     * Create many AuthenticationModels.
     *     @param {AuthenticationModelCreateManyArgs} args - Arguments to create many AuthenticationModels.
     *     @example
     *     // Create many AuthenticationModels
     *     const authenticationModel = await prisma.authenticationModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AuthenticationModelCreateManyArgs>(
      args?: SelectSubset<T, AuthenticationModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AuthenticationModel.
     * @param {AuthenticationModelDeleteArgs} args - Arguments to delete one AuthenticationModel.
     * @example
     * // Delete one AuthenticationModel
     * const AuthenticationModel = await prisma.authenticationModel.delete({
     *   where: {
     *     // ... filter to delete one AuthenticationModel
     *   }
     * })
     * 
    **/
    delete<T extends AuthenticationModelDeleteArgs>(
      args: SelectSubset<T, AuthenticationModelDeleteArgs>
    ): Prisma__AuthenticationModelClient<AuthenticationModelGetPayload<T>>

    /**
     * Update one AuthenticationModel.
     * @param {AuthenticationModelUpdateArgs} args - Arguments to update one AuthenticationModel.
     * @example
     * // Update one AuthenticationModel
     * const authenticationModel = await prisma.authenticationModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AuthenticationModelUpdateArgs>(
      args: SelectSubset<T, AuthenticationModelUpdateArgs>
    ): Prisma__AuthenticationModelClient<AuthenticationModelGetPayload<T>>

    /**
     * Delete zero or more AuthenticationModels.
     * @param {AuthenticationModelDeleteManyArgs} args - Arguments to filter AuthenticationModels to delete.
     * @example
     * // Delete a few AuthenticationModels
     * const { count } = await prisma.authenticationModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AuthenticationModelDeleteManyArgs>(
      args?: SelectSubset<T, AuthenticationModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthenticationModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticationModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuthenticationModels
     * const authenticationModel = await prisma.authenticationModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AuthenticationModelUpdateManyArgs>(
      args: SelectSubset<T, AuthenticationModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuthenticationModel.
     * @param {AuthenticationModelUpsertArgs} args - Arguments to update or create a AuthenticationModel.
     * @example
     * // Update or create a AuthenticationModel
     * const authenticationModel = await prisma.authenticationModel.upsert({
     *   create: {
     *     // ... data to create a AuthenticationModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuthenticationModel we want to update
     *   }
     * })
    **/
    upsert<T extends AuthenticationModelUpsertArgs>(
      args: SelectSubset<T, AuthenticationModelUpsertArgs>
    ): Prisma__AuthenticationModelClient<AuthenticationModelGetPayload<T>>

    /**
     * Count the number of AuthenticationModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticationModelCountArgs} args - Arguments to filter AuthenticationModels to count.
     * @example
     * // Count the number of AuthenticationModels
     * const count = await prisma.authenticationModel.count({
     *   where: {
     *     // ... the filter for the AuthenticationModels we want to count
     *   }
     * })
    **/
    count<T extends AuthenticationModelCountArgs>(
      args?: Subset<T, AuthenticationModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthenticationModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuthenticationModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticationModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthenticationModelAggregateArgs>(args: Subset<T, AuthenticationModelAggregateArgs>): Prisma.PrismaPromise<GetAuthenticationModelAggregateType<T>>

    /**
     * Group by AuthenticationModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthenticationModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthenticationModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthenticationModelGroupByArgs['orderBy'] }
        : { orderBy?: AuthenticationModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthenticationModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthenticationModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AuthenticationModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AuthenticationModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    business_user<T extends BusinessUserModelArgs= {}>(args?: Subset<T, BusinessUserModelArgs>): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T> | Null>;

    customer<T extends CustomerModelArgs= {}>(args?: Subset<T, CustomerModelArgs>): Prisma__CustomerModelClient<CustomerModelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AuthenticationModel base type for findUnique actions
   */
  export type AuthenticationModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AuthenticationModel
     */
    select?: AuthenticationModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthenticationModelInclude | null
    /**
     * Filter, which AuthenticationModel to fetch.
     */
    where: AuthenticationModelWhereUniqueInput
  }

  /**
   * AuthenticationModel findUnique
   */
  export interface AuthenticationModelFindUniqueArgs extends AuthenticationModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AuthenticationModel findUniqueOrThrow
   */
  export type AuthenticationModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AuthenticationModel
     */
    select?: AuthenticationModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthenticationModelInclude | null
    /**
     * Filter, which AuthenticationModel to fetch.
     */
    where: AuthenticationModelWhereUniqueInput
  }


  /**
   * AuthenticationModel base type for findFirst actions
   */
  export type AuthenticationModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AuthenticationModel
     */
    select?: AuthenticationModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthenticationModelInclude | null
    /**
     * Filter, which AuthenticationModel to fetch.
     */
    where?: AuthenticationModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthenticationModels to fetch.
     */
    orderBy?: Enumerable<AuthenticationModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthenticationModels.
     */
    cursor?: AuthenticationModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthenticationModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthenticationModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthenticationModels.
     */
    distinct?: Enumerable<AuthenticationModelScalarFieldEnum>
  }

  /**
   * AuthenticationModel findFirst
   */
  export interface AuthenticationModelFindFirstArgs extends AuthenticationModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AuthenticationModel findFirstOrThrow
   */
  export type AuthenticationModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AuthenticationModel
     */
    select?: AuthenticationModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthenticationModelInclude | null
    /**
     * Filter, which AuthenticationModel to fetch.
     */
    where?: AuthenticationModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthenticationModels to fetch.
     */
    orderBy?: Enumerable<AuthenticationModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthenticationModels.
     */
    cursor?: AuthenticationModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthenticationModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthenticationModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthenticationModels.
     */
    distinct?: Enumerable<AuthenticationModelScalarFieldEnum>
  }


  /**
   * AuthenticationModel findMany
   */
  export type AuthenticationModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the AuthenticationModel
     */
    select?: AuthenticationModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthenticationModelInclude | null
    /**
     * Filter, which AuthenticationModels to fetch.
     */
    where?: AuthenticationModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthenticationModels to fetch.
     */
    orderBy?: Enumerable<AuthenticationModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuthenticationModels.
     */
    cursor?: AuthenticationModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthenticationModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthenticationModels.
     */
    skip?: number
    distinct?: Enumerable<AuthenticationModelScalarFieldEnum>
  }


  /**
   * AuthenticationModel create
   */
  export type AuthenticationModelCreateArgs = {
    /**
     * Select specific fields to fetch from the AuthenticationModel
     */
    select?: AuthenticationModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthenticationModelInclude | null
    /**
     * The data needed to create a AuthenticationModel.
     */
    data: XOR<AuthenticationModelCreateInput, AuthenticationModelUncheckedCreateInput>
  }


  /**
   * AuthenticationModel createMany
   */
  export type AuthenticationModelCreateManyArgs = {
    /**
     * The data used to create many AuthenticationModels.
     */
    data: Enumerable<AuthenticationModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AuthenticationModel update
   */
  export type AuthenticationModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the AuthenticationModel
     */
    select?: AuthenticationModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthenticationModelInclude | null
    /**
     * The data needed to update a AuthenticationModel.
     */
    data: XOR<AuthenticationModelUpdateInput, AuthenticationModelUncheckedUpdateInput>
    /**
     * Choose, which AuthenticationModel to update.
     */
    where: AuthenticationModelWhereUniqueInput
  }


  /**
   * AuthenticationModel updateMany
   */
  export type AuthenticationModelUpdateManyArgs = {
    /**
     * The data used to update AuthenticationModels.
     */
    data: XOR<AuthenticationModelUpdateManyMutationInput, AuthenticationModelUncheckedUpdateManyInput>
    /**
     * Filter which AuthenticationModels to update
     */
    where?: AuthenticationModelWhereInput
  }


  /**
   * AuthenticationModel upsert
   */
  export type AuthenticationModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the AuthenticationModel
     */
    select?: AuthenticationModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthenticationModelInclude | null
    /**
     * The filter to search for the AuthenticationModel to update in case it exists.
     */
    where: AuthenticationModelWhereUniqueInput
    /**
     * In case the AuthenticationModel found by the `where` argument doesn't exist, create a new AuthenticationModel with this data.
     */
    create: XOR<AuthenticationModelCreateInput, AuthenticationModelUncheckedCreateInput>
    /**
     * In case the AuthenticationModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthenticationModelUpdateInput, AuthenticationModelUncheckedUpdateInput>
  }


  /**
   * AuthenticationModel delete
   */
  export type AuthenticationModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the AuthenticationModel
     */
    select?: AuthenticationModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthenticationModelInclude | null
    /**
     * Filter which AuthenticationModel to delete.
     */
    where: AuthenticationModelWhereUniqueInput
  }


  /**
   * AuthenticationModel deleteMany
   */
  export type AuthenticationModelDeleteManyArgs = {
    /**
     * Filter which AuthenticationModels to delete
     */
    where?: AuthenticationModelWhereInput
  }


  /**
   * AuthenticationModel without action
   */
  export type AuthenticationModelArgs = {
    /**
     * Select specific fields to fetch from the AuthenticationModel
     */
    select?: AuthenticationModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthenticationModelInclude | null
  }



  /**
   * Model UserModel
   */


  export type AggregateUserModel = {
    _count: UserModelCountAggregateOutputType | null
    _min: UserModelMinAggregateOutputType | null
    _max: UserModelMaxAggregateOutputType | null
  }

  export type UserModelMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    email_verified: boolean | null
    phone: string | null
    phone_verified: boolean | null
    address_first: string | null
    address_second: string | null
    profile_image: string | null
  }

  export type UserModelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    email_verified: boolean | null
    phone: string | null
    phone_verified: boolean | null
    address_first: string | null
    address_second: string | null
    profile_image: string | null
  }

  export type UserModelCountAggregateOutputType = {
    id: number
    name: number
    email: number
    email_verified: number
    phone: number
    phone_verified: number
    address_first: number
    address_second: number
    profile_image: number
    _all: number
  }


  export type UserModelMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    email_verified?: true
    phone?: true
    phone_verified?: true
    address_first?: true
    address_second?: true
    profile_image?: true
  }

  export type UserModelMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    email_verified?: true
    phone?: true
    phone_verified?: true
    address_first?: true
    address_second?: true
    profile_image?: true
  }

  export type UserModelCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    email_verified?: true
    phone?: true
    phone_verified?: true
    address_first?: true
    address_second?: true
    profile_image?: true
    _all?: true
  }

  export type UserModelAggregateArgs = {
    /**
     * Filter which UserModel to aggregate.
     */
    where?: UserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserModels to fetch.
     */
    orderBy?: Enumerable<UserModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserModels
    **/
    _count?: true | UserModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserModelMaxAggregateInputType
  }

  export type GetUserModelAggregateType<T extends UserModelAggregateArgs> = {
        [P in keyof T & keyof AggregateUserModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserModel[P]>
      : GetScalarType<T[P], AggregateUserModel[P]>
  }




  export type UserModelGroupByArgs = {
    where?: UserModelWhereInput
    orderBy?: Enumerable<UserModelOrderByWithAggregationInput>
    by: UserModelScalarFieldEnum[]
    having?: UserModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserModelCountAggregateInputType | true
    _min?: UserModelMinAggregateInputType
    _max?: UserModelMaxAggregateInputType
  }


  export type UserModelGroupByOutputType = {
    id: string
    name: string
    email: string | null
    email_verified: boolean
    phone: string | null
    phone_verified: boolean
    address_first: string | null
    address_second: string | null
    profile_image: string | null
    _count: UserModelCountAggregateOutputType | null
    _min: UserModelMinAggregateOutputType | null
    _max: UserModelMaxAggregateOutputType | null
  }

  type GetUserModelGroupByPayload<T extends UserModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserModelGroupByOutputType[P]>
            : GetScalarType<T[P], UserModelGroupByOutputType[P]>
        }
      >
    >


  export type UserModelSelect = {
    id?: boolean
    name?: boolean
    email?: boolean
    email_verified?: boolean
    phone?: boolean
    phone_verified?: boolean
    address_first?: boolean
    address_second?: boolean
    profile_image?: boolean
    customer?: boolean | CustomerModelArgs
    business_user?: boolean | BusinessUserModelArgs
    board_articles?: boolean | UserModel$board_articlesArgs
    board_comments?: boolean | UserModel$board_commentsArgs
    _count?: boolean | UserModelCountOutputTypeArgs
  }


  export type UserModelInclude = {
    customer?: boolean | CustomerModelArgs
    business_user?: boolean | BusinessUserModelArgs
    board_articles?: boolean | UserModel$board_articlesArgs
    board_comments?: boolean | UserModel$board_commentsArgs
    _count?: boolean | UserModelCountOutputTypeArgs
  }

  export type UserModelGetPayload<S extends boolean | null | undefined | UserModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserModel :
    S extends undefined ? never :
    S extends { include: any } & (UserModelArgs | UserModelFindManyArgs)
    ? UserModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'customer' ? CustomerModelGetPayload<S['include'][P]> | null :
        P extends 'business_user' ? BusinessUserModelGetPayload<S['include'][P]> | null :
        P extends 'board_articles' ? Array < BoardArticleModelGetPayload<S['include'][P]>>  :
        P extends 'board_comments' ? Array < BoardCommentModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserModelArgs | UserModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'customer' ? CustomerModelGetPayload<S['select'][P]> | null :
        P extends 'business_user' ? BusinessUserModelGetPayload<S['select'][P]> | null :
        P extends 'board_articles' ? Array < BoardArticleModelGetPayload<S['select'][P]>>  :
        P extends 'board_comments' ? Array < BoardCommentModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof UserModel ? UserModel[P] : never
  } 
      : UserModel


  type UserModelCountArgs = 
    Omit<UserModelFindManyArgs, 'select' | 'include'> & {
      select?: UserModelCountAggregateInputType | true
    }

  export interface UserModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserModel that matches the filter.
     * @param {UserModelFindUniqueArgs} args - Arguments to find a UserModel
     * @example
     * // Get one UserModel
     * const userModel = await prisma.userModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserModel'> extends True ? Prisma__UserModelClient<UserModelGetPayload<T>> : Prisma__UserModelClient<UserModelGetPayload<T> | null, null>

    /**
     * Find one UserModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserModelFindUniqueOrThrowArgs} args - Arguments to find a UserModel
     * @example
     * // Get one UserModel
     * const userModel = await prisma.userModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserModelFindUniqueOrThrowArgs>
    ): Prisma__UserModelClient<UserModelGetPayload<T>>

    /**
     * Find the first UserModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelFindFirstArgs} args - Arguments to find a UserModel
     * @example
     * // Get one UserModel
     * const userModel = await prisma.userModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserModel'> extends True ? Prisma__UserModelClient<UserModelGetPayload<T>> : Prisma__UserModelClient<UserModelGetPayload<T> | null, null>

    /**
     * Find the first UserModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelFindFirstOrThrowArgs} args - Arguments to find a UserModel
     * @example
     * // Get one UserModel
     * const userModel = await prisma.userModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserModelFindFirstOrThrowArgs>
    ): Prisma__UserModelClient<UserModelGetPayload<T>>

    /**
     * Find zero or more UserModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserModels
     * const userModels = await prisma.userModel.findMany()
     * 
     * // Get first 10 UserModels
     * const userModels = await prisma.userModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userModelWithIdOnly = await prisma.userModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserModelFindManyArgs>(
      args?: SelectSubset<T, UserModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserModelGetPayload<T>>>

    /**
     * Create a UserModel.
     * @param {UserModelCreateArgs} args - Arguments to create a UserModel.
     * @example
     * // Create one UserModel
     * const UserModel = await prisma.userModel.create({
     *   data: {
     *     // ... data to create a UserModel
     *   }
     * })
     * 
    **/
    create<T extends UserModelCreateArgs>(
      args: SelectSubset<T, UserModelCreateArgs>
    ): Prisma__UserModelClient<UserModelGetPayload<T>>

    /**
     * Create many UserModels.
     *     @param {UserModelCreateManyArgs} args - Arguments to create many UserModels.
     *     @example
     *     // Create many UserModels
     *     const userModel = await prisma.userModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserModelCreateManyArgs>(
      args?: SelectSubset<T, UserModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserModel.
     * @param {UserModelDeleteArgs} args - Arguments to delete one UserModel.
     * @example
     * // Delete one UserModel
     * const UserModel = await prisma.userModel.delete({
     *   where: {
     *     // ... filter to delete one UserModel
     *   }
     * })
     * 
    **/
    delete<T extends UserModelDeleteArgs>(
      args: SelectSubset<T, UserModelDeleteArgs>
    ): Prisma__UserModelClient<UserModelGetPayload<T>>

    /**
     * Update one UserModel.
     * @param {UserModelUpdateArgs} args - Arguments to update one UserModel.
     * @example
     * // Update one UserModel
     * const userModel = await prisma.userModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserModelUpdateArgs>(
      args: SelectSubset<T, UserModelUpdateArgs>
    ): Prisma__UserModelClient<UserModelGetPayload<T>>

    /**
     * Delete zero or more UserModels.
     * @param {UserModelDeleteManyArgs} args - Arguments to filter UserModels to delete.
     * @example
     * // Delete a few UserModels
     * const { count } = await prisma.userModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserModelDeleteManyArgs>(
      args?: SelectSubset<T, UserModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserModels
     * const userModel = await prisma.userModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserModelUpdateManyArgs>(
      args: SelectSubset<T, UserModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserModel.
     * @param {UserModelUpsertArgs} args - Arguments to update or create a UserModel.
     * @example
     * // Update or create a UserModel
     * const userModel = await prisma.userModel.upsert({
     *   create: {
     *     // ... data to create a UserModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserModel we want to update
     *   }
     * })
    **/
    upsert<T extends UserModelUpsertArgs>(
      args: SelectSubset<T, UserModelUpsertArgs>
    ): Prisma__UserModelClient<UserModelGetPayload<T>>

    /**
     * Count the number of UserModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelCountArgs} args - Arguments to filter UserModels to count.
     * @example
     * // Count the number of UserModels
     * const count = await prisma.userModel.count({
     *   where: {
     *     // ... the filter for the UserModels we want to count
     *   }
     * })
    **/
    count<T extends UserModelCountArgs>(
      args?: Subset<T, UserModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserModelAggregateArgs>(args: Subset<T, UserModelAggregateArgs>): Prisma.PrismaPromise<GetUserModelAggregateType<T>>

    /**
     * Group by UserModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserModelGroupByArgs['orderBy'] }
        : { orderBy?: UserModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    customer<T extends CustomerModelArgs= {}>(args?: Subset<T, CustomerModelArgs>): Prisma__CustomerModelClient<CustomerModelGetPayload<T> | Null>;

    business_user<T extends BusinessUserModelArgs= {}>(args?: Subset<T, BusinessUserModelArgs>): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T> | Null>;

    board_articles<T extends UserModel$board_articlesArgs= {}>(args?: Subset<T, UserModel$board_articlesArgs>): Prisma.PrismaPromise<Array<BoardArticleModelGetPayload<T>>| Null>;

    board_comments<T extends UserModel$board_commentsArgs= {}>(args?: Subset<T, UserModel$board_commentsArgs>): Prisma.PrismaPromise<Array<BoardCommentModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserModel base type for findUnique actions
   */
  export type UserModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude | null
    /**
     * Filter, which UserModel to fetch.
     */
    where: UserModelWhereUniqueInput
  }

  /**
   * UserModel findUnique
   */
  export interface UserModelFindUniqueArgs extends UserModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserModel findUniqueOrThrow
   */
  export type UserModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude | null
    /**
     * Filter, which UserModel to fetch.
     */
    where: UserModelWhereUniqueInput
  }


  /**
   * UserModel base type for findFirst actions
   */
  export type UserModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude | null
    /**
     * Filter, which UserModel to fetch.
     */
    where?: UserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserModels to fetch.
     */
    orderBy?: Enumerable<UserModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserModels.
     */
    cursor?: UserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserModels.
     */
    distinct?: Enumerable<UserModelScalarFieldEnum>
  }

  /**
   * UserModel findFirst
   */
  export interface UserModelFindFirstArgs extends UserModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserModel findFirstOrThrow
   */
  export type UserModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude | null
    /**
     * Filter, which UserModel to fetch.
     */
    where?: UserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserModels to fetch.
     */
    orderBy?: Enumerable<UserModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserModels.
     */
    cursor?: UserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserModels.
     */
    distinct?: Enumerable<UserModelScalarFieldEnum>
  }


  /**
   * UserModel findMany
   */
  export type UserModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude | null
    /**
     * Filter, which UserModels to fetch.
     */
    where?: UserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserModels to fetch.
     */
    orderBy?: Enumerable<UserModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserModels.
     */
    cursor?: UserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserModels.
     */
    skip?: number
    distinct?: Enumerable<UserModelScalarFieldEnum>
  }


  /**
   * UserModel create
   */
  export type UserModelCreateArgs = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude | null
    /**
     * The data needed to create a UserModel.
     */
    data: XOR<UserModelCreateInput, UserModelUncheckedCreateInput>
  }


  /**
   * UserModel createMany
   */
  export type UserModelCreateManyArgs = {
    /**
     * The data used to create many UserModels.
     */
    data: Enumerable<UserModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserModel update
   */
  export type UserModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude | null
    /**
     * The data needed to update a UserModel.
     */
    data: XOR<UserModelUpdateInput, UserModelUncheckedUpdateInput>
    /**
     * Choose, which UserModel to update.
     */
    where: UserModelWhereUniqueInput
  }


  /**
   * UserModel updateMany
   */
  export type UserModelUpdateManyArgs = {
    /**
     * The data used to update UserModels.
     */
    data: XOR<UserModelUpdateManyMutationInput, UserModelUncheckedUpdateManyInput>
    /**
     * Filter which UserModels to update
     */
    where?: UserModelWhereInput
  }


  /**
   * UserModel upsert
   */
  export type UserModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude | null
    /**
     * The filter to search for the UserModel to update in case it exists.
     */
    where: UserModelWhereUniqueInput
    /**
     * In case the UserModel found by the `where` argument doesn't exist, create a new UserModel with this data.
     */
    create: XOR<UserModelCreateInput, UserModelUncheckedCreateInput>
    /**
     * In case the UserModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserModelUpdateInput, UserModelUncheckedUpdateInput>
  }


  /**
   * UserModel delete
   */
  export type UserModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude | null
    /**
     * Filter which UserModel to delete.
     */
    where: UserModelWhereUniqueInput
  }


  /**
   * UserModel deleteMany
   */
  export type UserModelDeleteManyArgs = {
    /**
     * Filter which UserModels to delete
     */
    where?: UserModelWhereInput
  }


  /**
   * UserModel.board_articles
   */
  export type UserModel$board_articlesArgs = {
    /**
     * Select specific fields to fetch from the BoardArticleModel
     */
    select?: BoardArticleModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardArticleModelInclude | null
    where?: BoardArticleModelWhereInput
    orderBy?: Enumerable<BoardArticleModelOrderByWithRelationInput>
    cursor?: BoardArticleModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BoardArticleModelScalarFieldEnum>
  }


  /**
   * UserModel.board_comments
   */
  export type UserModel$board_commentsArgs = {
    /**
     * Select specific fields to fetch from the BoardCommentModel
     */
    select?: BoardCommentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardCommentModelInclude | null
    where?: BoardCommentModelWhereInput
    orderBy?: Enumerable<BoardCommentModelOrderByWithRelationInput>
    cursor?: BoardCommentModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BoardCommentModelScalarFieldEnum>
  }


  /**
   * UserModel without action
   */
  export type UserModelArgs = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude | null
  }



  /**
   * Model CustomerModel
   */


  export type AggregateCustomerModel = {
    _count: CustomerModelCountAggregateOutputType | null
    _min: CustomerModelMinAggregateOutputType | null
    _max: CustomerModelMaxAggregateOutputType | null
  }

  export type CustomerModelMinAggregateOutputType = {
    id: string | null
    birth: string | null
    gender: string | null
  }

  export type CustomerModelMaxAggregateOutputType = {
    id: string | null
    birth: string | null
    gender: string | null
  }

  export type CustomerModelCountAggregateOutputType = {
    id: number
    birth: number
    gender: number
    _all: number
  }


  export type CustomerModelMinAggregateInputType = {
    id?: true
    birth?: true
    gender?: true
  }

  export type CustomerModelMaxAggregateInputType = {
    id?: true
    birth?: true
    gender?: true
  }

  export type CustomerModelCountAggregateInputType = {
    id?: true
    birth?: true
    gender?: true
    _all?: true
  }

  export type CustomerModelAggregateArgs = {
    /**
     * Filter which CustomerModel to aggregate.
     */
    where?: CustomerModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerModels to fetch.
     */
    orderBy?: Enumerable<CustomerModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerModels
    **/
    _count?: true | CustomerModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerModelMaxAggregateInputType
  }

  export type GetCustomerModelAggregateType<T extends CustomerModelAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerModel[P]>
      : GetScalarType<T[P], AggregateCustomerModel[P]>
  }




  export type CustomerModelGroupByArgs = {
    where?: CustomerModelWhereInput
    orderBy?: Enumerable<CustomerModelOrderByWithAggregationInput>
    by: CustomerModelScalarFieldEnum[]
    having?: CustomerModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerModelCountAggregateInputType | true
    _min?: CustomerModelMinAggregateInputType
    _max?: CustomerModelMaxAggregateInputType
  }


  export type CustomerModelGroupByOutputType = {
    id: string
    birth: string | null
    gender: string | null
    _count: CustomerModelCountAggregateOutputType | null
    _min: CustomerModelMinAggregateOutputType | null
    _max: CustomerModelMaxAggregateOutputType | null
  }

  type GetCustomerModelGroupByPayload<T extends CustomerModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CustomerModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerModelGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerModelGroupByOutputType[P]>
        }
      >
    >


  export type CustomerModelSelect = {
    id?: boolean
    birth?: boolean
    gender?: boolean
    user?: boolean | UserModelArgs
    authentications?: boolean | CustomerModel$authenticationsArgs
    rates?: boolean | CustomerModel$ratesArgs
    reviews?: boolean | CustomerModel$reviewsArgs
    _count?: boolean | CustomerModelCountOutputTypeArgs
  }


  export type CustomerModelInclude = {
    user?: boolean | UserModelArgs
    authentications?: boolean | CustomerModel$authenticationsArgs
    rates?: boolean | CustomerModel$ratesArgs
    reviews?: boolean | CustomerModel$reviewsArgs
    _count?: boolean | CustomerModelCountOutputTypeArgs
  }

  export type CustomerModelGetPayload<S extends boolean | null | undefined | CustomerModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CustomerModel :
    S extends undefined ? never :
    S extends { include: any } & (CustomerModelArgs | CustomerModelFindManyArgs)
    ? CustomerModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserModelGetPayload<S['include'][P]> :
        P extends 'authentications' ? Array < AuthenticationModelGetPayload<S['include'][P]>>  :
        P extends 'rates' ? Array < BusinessRateModelGetPayload<S['include'][P]>>  :
        P extends 'reviews' ? Array < BusinessReviewModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? CustomerModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CustomerModelArgs | CustomerModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserModelGetPayload<S['select'][P]> :
        P extends 'authentications' ? Array < AuthenticationModelGetPayload<S['select'][P]>>  :
        P extends 'rates' ? Array < BusinessRateModelGetPayload<S['select'][P]>>  :
        P extends 'reviews' ? Array < BusinessReviewModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? CustomerModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof CustomerModel ? CustomerModel[P] : never
  } 
      : CustomerModel


  type CustomerModelCountArgs = 
    Omit<CustomerModelFindManyArgs, 'select' | 'include'> & {
      select?: CustomerModelCountAggregateInputType | true
    }

  export interface CustomerModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one CustomerModel that matches the filter.
     * @param {CustomerModelFindUniqueArgs} args - Arguments to find a CustomerModel
     * @example
     * // Get one CustomerModel
     * const customerModel = await prisma.customerModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CustomerModel'> extends True ? Prisma__CustomerModelClient<CustomerModelGetPayload<T>> : Prisma__CustomerModelClient<CustomerModelGetPayload<T> | null, null>

    /**
     * Find one CustomerModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CustomerModelFindUniqueOrThrowArgs} args - Arguments to find a CustomerModel
     * @example
     * // Get one CustomerModel
     * const customerModel = await prisma.customerModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CustomerModelFindUniqueOrThrowArgs>
    ): Prisma__CustomerModelClient<CustomerModelGetPayload<T>>

    /**
     * Find the first CustomerModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerModelFindFirstArgs} args - Arguments to find a CustomerModel
     * @example
     * // Get one CustomerModel
     * const customerModel = await prisma.customerModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CustomerModel'> extends True ? Prisma__CustomerModelClient<CustomerModelGetPayload<T>> : Prisma__CustomerModelClient<CustomerModelGetPayload<T> | null, null>

    /**
     * Find the first CustomerModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerModelFindFirstOrThrowArgs} args - Arguments to find a CustomerModel
     * @example
     * // Get one CustomerModel
     * const customerModel = await prisma.customerModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CustomerModelFindFirstOrThrowArgs>
    ): Prisma__CustomerModelClient<CustomerModelGetPayload<T>>

    /**
     * Find zero or more CustomerModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerModels
     * const customerModels = await prisma.customerModel.findMany()
     * 
     * // Get first 10 CustomerModels
     * const customerModels = await prisma.customerModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerModelWithIdOnly = await prisma.customerModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomerModelFindManyArgs>(
      args?: SelectSubset<T, CustomerModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<CustomerModelGetPayload<T>>>

    /**
     * Create a CustomerModel.
     * @param {CustomerModelCreateArgs} args - Arguments to create a CustomerModel.
     * @example
     * // Create one CustomerModel
     * const CustomerModel = await prisma.customerModel.create({
     *   data: {
     *     // ... data to create a CustomerModel
     *   }
     * })
     * 
    **/
    create<T extends CustomerModelCreateArgs>(
      args: SelectSubset<T, CustomerModelCreateArgs>
    ): Prisma__CustomerModelClient<CustomerModelGetPayload<T>>

    /**
     * Create many CustomerModels.
     *     @param {CustomerModelCreateManyArgs} args - Arguments to create many CustomerModels.
     *     @example
     *     // Create many CustomerModels
     *     const customerModel = await prisma.customerModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerModelCreateManyArgs>(
      args?: SelectSubset<T, CustomerModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerModel.
     * @param {CustomerModelDeleteArgs} args - Arguments to delete one CustomerModel.
     * @example
     * // Delete one CustomerModel
     * const CustomerModel = await prisma.customerModel.delete({
     *   where: {
     *     // ... filter to delete one CustomerModel
     *   }
     * })
     * 
    **/
    delete<T extends CustomerModelDeleteArgs>(
      args: SelectSubset<T, CustomerModelDeleteArgs>
    ): Prisma__CustomerModelClient<CustomerModelGetPayload<T>>

    /**
     * Update one CustomerModel.
     * @param {CustomerModelUpdateArgs} args - Arguments to update one CustomerModel.
     * @example
     * // Update one CustomerModel
     * const customerModel = await prisma.customerModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerModelUpdateArgs>(
      args: SelectSubset<T, CustomerModelUpdateArgs>
    ): Prisma__CustomerModelClient<CustomerModelGetPayload<T>>

    /**
     * Delete zero or more CustomerModels.
     * @param {CustomerModelDeleteManyArgs} args - Arguments to filter CustomerModels to delete.
     * @example
     * // Delete a few CustomerModels
     * const { count } = await prisma.customerModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerModelDeleteManyArgs>(
      args?: SelectSubset<T, CustomerModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerModels
     * const customerModel = await prisma.customerModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerModelUpdateManyArgs>(
      args: SelectSubset<T, CustomerModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerModel.
     * @param {CustomerModelUpsertArgs} args - Arguments to update or create a CustomerModel.
     * @example
     * // Update or create a CustomerModel
     * const customerModel = await prisma.customerModel.upsert({
     *   create: {
     *     // ... data to create a CustomerModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerModel we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerModelUpsertArgs>(
      args: SelectSubset<T, CustomerModelUpsertArgs>
    ): Prisma__CustomerModelClient<CustomerModelGetPayload<T>>

    /**
     * Count the number of CustomerModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerModelCountArgs} args - Arguments to filter CustomerModels to count.
     * @example
     * // Count the number of CustomerModels
     * const count = await prisma.customerModel.count({
     *   where: {
     *     // ... the filter for the CustomerModels we want to count
     *   }
     * })
    **/
    count<T extends CustomerModelCountArgs>(
      args?: Subset<T, CustomerModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerModelAggregateArgs>(args: Subset<T, CustomerModelAggregateArgs>): Prisma.PrismaPromise<GetCustomerModelAggregateType<T>>

    /**
     * Group by CustomerModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerModelGroupByArgs['orderBy'] }
        : { orderBy?: CustomerModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserModelArgs= {}>(args?: Subset<T, UserModelArgs>): Prisma__UserModelClient<UserModelGetPayload<T> | Null>;

    authentications<T extends CustomerModel$authenticationsArgs= {}>(args?: Subset<T, CustomerModel$authenticationsArgs>): Prisma.PrismaPromise<Array<AuthenticationModelGetPayload<T>>| Null>;

    rates<T extends CustomerModel$ratesArgs= {}>(args?: Subset<T, CustomerModel$ratesArgs>): Prisma.PrismaPromise<Array<BusinessRateModelGetPayload<T>>| Null>;

    reviews<T extends CustomerModel$reviewsArgs= {}>(args?: Subset<T, CustomerModel$reviewsArgs>): Prisma.PrismaPromise<Array<BusinessReviewModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CustomerModel base type for findUnique actions
   */
  export type CustomerModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude | null
    /**
     * Filter, which CustomerModel to fetch.
     */
    where: CustomerModelWhereUniqueInput
  }

  /**
   * CustomerModel findUnique
   */
  export interface CustomerModelFindUniqueArgs extends CustomerModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerModel findUniqueOrThrow
   */
  export type CustomerModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude | null
    /**
     * Filter, which CustomerModel to fetch.
     */
    where: CustomerModelWhereUniqueInput
  }


  /**
   * CustomerModel base type for findFirst actions
   */
  export type CustomerModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude | null
    /**
     * Filter, which CustomerModel to fetch.
     */
    where?: CustomerModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerModels to fetch.
     */
    orderBy?: Enumerable<CustomerModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerModels.
     */
    cursor?: CustomerModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerModels.
     */
    distinct?: Enumerable<CustomerModelScalarFieldEnum>
  }

  /**
   * CustomerModel findFirst
   */
  export interface CustomerModelFindFirstArgs extends CustomerModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerModel findFirstOrThrow
   */
  export type CustomerModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude | null
    /**
     * Filter, which CustomerModel to fetch.
     */
    where?: CustomerModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerModels to fetch.
     */
    orderBy?: Enumerable<CustomerModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerModels.
     */
    cursor?: CustomerModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerModels.
     */
    distinct?: Enumerable<CustomerModelScalarFieldEnum>
  }


  /**
   * CustomerModel findMany
   */
  export type CustomerModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude | null
    /**
     * Filter, which CustomerModels to fetch.
     */
    where?: CustomerModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerModels to fetch.
     */
    orderBy?: Enumerable<CustomerModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerModels.
     */
    cursor?: CustomerModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerModels.
     */
    skip?: number
    distinct?: Enumerable<CustomerModelScalarFieldEnum>
  }


  /**
   * CustomerModel create
   */
  export type CustomerModelCreateArgs = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude | null
    /**
     * The data needed to create a CustomerModel.
     */
    data: XOR<CustomerModelCreateInput, CustomerModelUncheckedCreateInput>
  }


  /**
   * CustomerModel createMany
   */
  export type CustomerModelCreateManyArgs = {
    /**
     * The data used to create many CustomerModels.
     */
    data: Enumerable<CustomerModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CustomerModel update
   */
  export type CustomerModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude | null
    /**
     * The data needed to update a CustomerModel.
     */
    data: XOR<CustomerModelUpdateInput, CustomerModelUncheckedUpdateInput>
    /**
     * Choose, which CustomerModel to update.
     */
    where: CustomerModelWhereUniqueInput
  }


  /**
   * CustomerModel updateMany
   */
  export type CustomerModelUpdateManyArgs = {
    /**
     * The data used to update CustomerModels.
     */
    data: XOR<CustomerModelUpdateManyMutationInput, CustomerModelUncheckedUpdateManyInput>
    /**
     * Filter which CustomerModels to update
     */
    where?: CustomerModelWhereInput
  }


  /**
   * CustomerModel upsert
   */
  export type CustomerModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude | null
    /**
     * The filter to search for the CustomerModel to update in case it exists.
     */
    where: CustomerModelWhereUniqueInput
    /**
     * In case the CustomerModel found by the `where` argument doesn't exist, create a new CustomerModel with this data.
     */
    create: XOR<CustomerModelCreateInput, CustomerModelUncheckedCreateInput>
    /**
     * In case the CustomerModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerModelUpdateInput, CustomerModelUncheckedUpdateInput>
  }


  /**
   * CustomerModel delete
   */
  export type CustomerModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude | null
    /**
     * Filter which CustomerModel to delete.
     */
    where: CustomerModelWhereUniqueInput
  }


  /**
   * CustomerModel deleteMany
   */
  export type CustomerModelDeleteManyArgs = {
    /**
     * Filter which CustomerModels to delete
     */
    where?: CustomerModelWhereInput
  }


  /**
   * CustomerModel.authentications
   */
  export type CustomerModel$authenticationsArgs = {
    /**
     * Select specific fields to fetch from the AuthenticationModel
     */
    select?: AuthenticationModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthenticationModelInclude | null
    where?: AuthenticationModelWhereInput
    orderBy?: Enumerable<AuthenticationModelOrderByWithRelationInput>
    cursor?: AuthenticationModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AuthenticationModelScalarFieldEnum>
  }


  /**
   * CustomerModel.rates
   */
  export type CustomerModel$ratesArgs = {
    /**
     * Select specific fields to fetch from the BusinessRateModel
     */
    select?: BusinessRateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessRateModelInclude | null
    where?: BusinessRateModelWhereInput
    orderBy?: Enumerable<BusinessRateModelOrderByWithRelationInput>
    cursor?: BusinessRateModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BusinessRateModelScalarFieldEnum>
  }


  /**
   * CustomerModel.reviews
   */
  export type CustomerModel$reviewsArgs = {
    /**
     * Select specific fields to fetch from the BusinessReviewModel
     */
    select?: BusinessReviewModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessReviewModelInclude | null
    where?: BusinessReviewModelWhereInput
    orderBy?: Enumerable<BusinessReviewModelOrderByWithRelationInput>
    cursor?: BusinessReviewModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BusinessReviewModelScalarFieldEnum>
  }


  /**
   * CustomerModel without action
   */
  export type CustomerModelArgs = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude | null
  }



  /**
   * Model BusinessUserModel
   */


  export type AggregateBusinessUserModel = {
    _count: BusinessUserModelCountAggregateOutputType | null
    _min: BusinessUserModelMinAggregateOutputType | null
    _max: BusinessUserModelMaxAggregateOutputType | null
  }

  export type BusinessUserModelMinAggregateOutputType = {
    id: string | null
    is_verified: boolean | null
    introduction_title: string | null
    introduction_content: string | null
  }

  export type BusinessUserModelMaxAggregateOutputType = {
    id: string | null
    is_verified: boolean | null
    introduction_title: string | null
    introduction_content: string | null
  }

  export type BusinessUserModelCountAggregateOutputType = {
    id: number
    is_verified: number
    introduction_title: number
    introduction_content: number
    _all: number
  }


  export type BusinessUserModelMinAggregateInputType = {
    id?: true
    is_verified?: true
    introduction_title?: true
    introduction_content?: true
  }

  export type BusinessUserModelMaxAggregateInputType = {
    id?: true
    is_verified?: true
    introduction_title?: true
    introduction_content?: true
  }

  export type BusinessUserModelCountAggregateInputType = {
    id?: true
    is_verified?: true
    introduction_title?: true
    introduction_content?: true
    _all?: true
  }

  export type BusinessUserModelAggregateArgs = {
    /**
     * Filter which BusinessUserModel to aggregate.
     */
    where?: BusinessUserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUserModels to fetch.
     */
    orderBy?: Enumerable<BusinessUserModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessUserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUserModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessUserModels
    **/
    _count?: true | BusinessUserModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessUserModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessUserModelMaxAggregateInputType
  }

  export type GetBusinessUserModelAggregateType<T extends BusinessUserModelAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessUserModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessUserModel[P]>
      : GetScalarType<T[P], AggregateBusinessUserModel[P]>
  }




  export type BusinessUserModelGroupByArgs = {
    where?: BusinessUserModelWhereInput
    orderBy?: Enumerable<BusinessUserModelOrderByWithAggregationInput>
    by: BusinessUserModelScalarFieldEnum[]
    having?: BusinessUserModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessUserModelCountAggregateInputType | true
    _min?: BusinessUserModelMinAggregateInputType
    _max?: BusinessUserModelMaxAggregateInputType
  }


  export type BusinessUserModelGroupByOutputType = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    _count: BusinessUserModelCountAggregateOutputType | null
    _min: BusinessUserModelMinAggregateOutputType | null
    _max: BusinessUserModelMaxAggregateOutputType | null
  }

  type GetBusinessUserModelGroupByPayload<T extends BusinessUserModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BusinessUserModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessUserModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessUserModelGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessUserModelGroupByOutputType[P]>
        }
      >
    >


  export type BusinessUserModelSelect = {
    id?: boolean
    is_verified?: boolean
    introduction_title?: boolean
    introduction_content?: boolean
    user?: boolean | UserModelArgs
    authentications?: boolean | BusinessUserModel$authenticationsArgs
    real_estate_agent?: boolean | RealEstateAgentModelArgs
    home_care_company?: boolean | HomeCareCompanyModelArgs
    rates?: boolean | BusinessUserModel$ratesArgs
    reviews?: boolean | BusinessUserModel$reviewsArgs
    _count?: boolean | BusinessUserModelCountOutputTypeArgs
  }


  export type BusinessUserModelInclude = {
    user?: boolean | UserModelArgs
    authentications?: boolean | BusinessUserModel$authenticationsArgs
    real_estate_agent?: boolean | RealEstateAgentModelArgs
    home_care_company?: boolean | HomeCareCompanyModelArgs
    rates?: boolean | BusinessUserModel$ratesArgs
    reviews?: boolean | BusinessUserModel$reviewsArgs
    _count?: boolean | BusinessUserModelCountOutputTypeArgs
  }

  export type BusinessUserModelGetPayload<S extends boolean | null | undefined | BusinessUserModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BusinessUserModel :
    S extends undefined ? never :
    S extends { include: any } & (BusinessUserModelArgs | BusinessUserModelFindManyArgs)
    ? BusinessUserModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserModelGetPayload<S['include'][P]> :
        P extends 'authentications' ? Array < AuthenticationModelGetPayload<S['include'][P]>>  :
        P extends 'real_estate_agent' ? RealEstateAgentModelGetPayload<S['include'][P]> | null :
        P extends 'home_care_company' ? HomeCareCompanyModelGetPayload<S['include'][P]> | null :
        P extends 'rates' ? Array < BusinessRateModelGetPayload<S['include'][P]>>  :
        P extends 'reviews' ? Array < BusinessReviewModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? BusinessUserModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BusinessUserModelArgs | BusinessUserModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserModelGetPayload<S['select'][P]> :
        P extends 'authentications' ? Array < AuthenticationModelGetPayload<S['select'][P]>>  :
        P extends 'real_estate_agent' ? RealEstateAgentModelGetPayload<S['select'][P]> | null :
        P extends 'home_care_company' ? HomeCareCompanyModelGetPayload<S['select'][P]> | null :
        P extends 'rates' ? Array < BusinessRateModelGetPayload<S['select'][P]>>  :
        P extends 'reviews' ? Array < BusinessReviewModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? BusinessUserModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BusinessUserModel ? BusinessUserModel[P] : never
  } 
      : BusinessUserModel


  type BusinessUserModelCountArgs = 
    Omit<BusinessUserModelFindManyArgs, 'select' | 'include'> & {
      select?: BusinessUserModelCountAggregateInputType | true
    }

  export interface BusinessUserModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BusinessUserModel that matches the filter.
     * @param {BusinessUserModelFindUniqueArgs} args - Arguments to find a BusinessUserModel
     * @example
     * // Get one BusinessUserModel
     * const businessUserModel = await prisma.businessUserModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BusinessUserModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BusinessUserModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BusinessUserModel'> extends True ? Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T>> : Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T> | null, null>

    /**
     * Find one BusinessUserModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BusinessUserModelFindUniqueOrThrowArgs} args - Arguments to find a BusinessUserModel
     * @example
     * // Get one BusinessUserModel
     * const businessUserModel = await prisma.businessUserModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BusinessUserModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BusinessUserModelFindUniqueOrThrowArgs>
    ): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T>>

    /**
     * Find the first BusinessUserModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUserModelFindFirstArgs} args - Arguments to find a BusinessUserModel
     * @example
     * // Get one BusinessUserModel
     * const businessUserModel = await prisma.businessUserModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BusinessUserModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BusinessUserModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BusinessUserModel'> extends True ? Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T>> : Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T> | null, null>

    /**
     * Find the first BusinessUserModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUserModelFindFirstOrThrowArgs} args - Arguments to find a BusinessUserModel
     * @example
     * // Get one BusinessUserModel
     * const businessUserModel = await prisma.businessUserModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BusinessUserModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BusinessUserModelFindFirstOrThrowArgs>
    ): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T>>

    /**
     * Find zero or more BusinessUserModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUserModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessUserModels
     * const businessUserModels = await prisma.businessUserModel.findMany()
     * 
     * // Get first 10 BusinessUserModels
     * const businessUserModels = await prisma.businessUserModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessUserModelWithIdOnly = await prisma.businessUserModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BusinessUserModelFindManyArgs>(
      args?: SelectSubset<T, BusinessUserModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<BusinessUserModelGetPayload<T>>>

    /**
     * Create a BusinessUserModel.
     * @param {BusinessUserModelCreateArgs} args - Arguments to create a BusinessUserModel.
     * @example
     * // Create one BusinessUserModel
     * const BusinessUserModel = await prisma.businessUserModel.create({
     *   data: {
     *     // ... data to create a BusinessUserModel
     *   }
     * })
     * 
    **/
    create<T extends BusinessUserModelCreateArgs>(
      args: SelectSubset<T, BusinessUserModelCreateArgs>
    ): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T>>

    /**
     * Create many BusinessUserModels.
     *     @param {BusinessUserModelCreateManyArgs} args - Arguments to create many BusinessUserModels.
     *     @example
     *     // Create many BusinessUserModels
     *     const businessUserModel = await prisma.businessUserModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BusinessUserModelCreateManyArgs>(
      args?: SelectSubset<T, BusinessUserModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BusinessUserModel.
     * @param {BusinessUserModelDeleteArgs} args - Arguments to delete one BusinessUserModel.
     * @example
     * // Delete one BusinessUserModel
     * const BusinessUserModel = await prisma.businessUserModel.delete({
     *   where: {
     *     // ... filter to delete one BusinessUserModel
     *   }
     * })
     * 
    **/
    delete<T extends BusinessUserModelDeleteArgs>(
      args: SelectSubset<T, BusinessUserModelDeleteArgs>
    ): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T>>

    /**
     * Update one BusinessUserModel.
     * @param {BusinessUserModelUpdateArgs} args - Arguments to update one BusinessUserModel.
     * @example
     * // Update one BusinessUserModel
     * const businessUserModel = await prisma.businessUserModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BusinessUserModelUpdateArgs>(
      args: SelectSubset<T, BusinessUserModelUpdateArgs>
    ): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T>>

    /**
     * Delete zero or more BusinessUserModels.
     * @param {BusinessUserModelDeleteManyArgs} args - Arguments to filter BusinessUserModels to delete.
     * @example
     * // Delete a few BusinessUserModels
     * const { count } = await prisma.businessUserModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BusinessUserModelDeleteManyArgs>(
      args?: SelectSubset<T, BusinessUserModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessUserModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUserModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessUserModels
     * const businessUserModel = await prisma.businessUserModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BusinessUserModelUpdateManyArgs>(
      args: SelectSubset<T, BusinessUserModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessUserModel.
     * @param {BusinessUserModelUpsertArgs} args - Arguments to update or create a BusinessUserModel.
     * @example
     * // Update or create a BusinessUserModel
     * const businessUserModel = await prisma.businessUserModel.upsert({
     *   create: {
     *     // ... data to create a BusinessUserModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessUserModel we want to update
     *   }
     * })
    **/
    upsert<T extends BusinessUserModelUpsertArgs>(
      args: SelectSubset<T, BusinessUserModelUpsertArgs>
    ): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T>>

    /**
     * Count the number of BusinessUserModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUserModelCountArgs} args - Arguments to filter BusinessUserModels to count.
     * @example
     * // Count the number of BusinessUserModels
     * const count = await prisma.businessUserModel.count({
     *   where: {
     *     // ... the filter for the BusinessUserModels we want to count
     *   }
     * })
    **/
    count<T extends BusinessUserModelCountArgs>(
      args?: Subset<T, BusinessUserModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessUserModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessUserModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUserModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessUserModelAggregateArgs>(args: Subset<T, BusinessUserModelAggregateArgs>): Prisma.PrismaPromise<GetBusinessUserModelAggregateType<T>>

    /**
     * Group by BusinessUserModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUserModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessUserModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessUserModelGroupByArgs['orderBy'] }
        : { orderBy?: BusinessUserModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessUserModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessUserModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessUserModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BusinessUserModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserModelArgs= {}>(args?: Subset<T, UserModelArgs>): Prisma__UserModelClient<UserModelGetPayload<T> | Null>;

    authentications<T extends BusinessUserModel$authenticationsArgs= {}>(args?: Subset<T, BusinessUserModel$authenticationsArgs>): Prisma.PrismaPromise<Array<AuthenticationModelGetPayload<T>>| Null>;

    real_estate_agent<T extends RealEstateAgentModelArgs= {}>(args?: Subset<T, RealEstateAgentModelArgs>): Prisma__RealEstateAgentModelClient<RealEstateAgentModelGetPayload<T> | Null>;

    home_care_company<T extends HomeCareCompanyModelArgs= {}>(args?: Subset<T, HomeCareCompanyModelArgs>): Prisma__HomeCareCompanyModelClient<HomeCareCompanyModelGetPayload<T> | Null>;

    rates<T extends BusinessUserModel$ratesArgs= {}>(args?: Subset<T, BusinessUserModel$ratesArgs>): Prisma.PrismaPromise<Array<BusinessRateModelGetPayload<T>>| Null>;

    reviews<T extends BusinessUserModel$reviewsArgs= {}>(args?: Subset<T, BusinessUserModel$reviewsArgs>): Prisma.PrismaPromise<Array<BusinessReviewModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BusinessUserModel base type for findUnique actions
   */
  export type BusinessUserModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude | null
    /**
     * Filter, which BusinessUserModel to fetch.
     */
    where: BusinessUserModelWhereUniqueInput
  }

  /**
   * BusinessUserModel findUnique
   */
  export interface BusinessUserModelFindUniqueArgs extends BusinessUserModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusinessUserModel findUniqueOrThrow
   */
  export type BusinessUserModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude | null
    /**
     * Filter, which BusinessUserModel to fetch.
     */
    where: BusinessUserModelWhereUniqueInput
  }


  /**
   * BusinessUserModel base type for findFirst actions
   */
  export type BusinessUserModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude | null
    /**
     * Filter, which BusinessUserModel to fetch.
     */
    where?: BusinessUserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUserModels to fetch.
     */
    orderBy?: Enumerable<BusinessUserModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessUserModels.
     */
    cursor?: BusinessUserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUserModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessUserModels.
     */
    distinct?: Enumerable<BusinessUserModelScalarFieldEnum>
  }

  /**
   * BusinessUserModel findFirst
   */
  export interface BusinessUserModelFindFirstArgs extends BusinessUserModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusinessUserModel findFirstOrThrow
   */
  export type BusinessUserModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude | null
    /**
     * Filter, which BusinessUserModel to fetch.
     */
    where?: BusinessUserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUserModels to fetch.
     */
    orderBy?: Enumerable<BusinessUserModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessUserModels.
     */
    cursor?: BusinessUserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUserModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessUserModels.
     */
    distinct?: Enumerable<BusinessUserModelScalarFieldEnum>
  }


  /**
   * BusinessUserModel findMany
   */
  export type BusinessUserModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude | null
    /**
     * Filter, which BusinessUserModels to fetch.
     */
    where?: BusinessUserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUserModels to fetch.
     */
    orderBy?: Enumerable<BusinessUserModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessUserModels.
     */
    cursor?: BusinessUserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUserModels.
     */
    skip?: number
    distinct?: Enumerable<BusinessUserModelScalarFieldEnum>
  }


  /**
   * BusinessUserModel create
   */
  export type BusinessUserModelCreateArgs = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude | null
    /**
     * The data needed to create a BusinessUserModel.
     */
    data: XOR<BusinessUserModelCreateInput, BusinessUserModelUncheckedCreateInput>
  }


  /**
   * BusinessUserModel createMany
   */
  export type BusinessUserModelCreateManyArgs = {
    /**
     * The data used to create many BusinessUserModels.
     */
    data: Enumerable<BusinessUserModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BusinessUserModel update
   */
  export type BusinessUserModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude | null
    /**
     * The data needed to update a BusinessUserModel.
     */
    data: XOR<BusinessUserModelUpdateInput, BusinessUserModelUncheckedUpdateInput>
    /**
     * Choose, which BusinessUserModel to update.
     */
    where: BusinessUserModelWhereUniqueInput
  }


  /**
   * BusinessUserModel updateMany
   */
  export type BusinessUserModelUpdateManyArgs = {
    /**
     * The data used to update BusinessUserModels.
     */
    data: XOR<BusinessUserModelUpdateManyMutationInput, BusinessUserModelUncheckedUpdateManyInput>
    /**
     * Filter which BusinessUserModels to update
     */
    where?: BusinessUserModelWhereInput
  }


  /**
   * BusinessUserModel upsert
   */
  export type BusinessUserModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude | null
    /**
     * The filter to search for the BusinessUserModel to update in case it exists.
     */
    where: BusinessUserModelWhereUniqueInput
    /**
     * In case the BusinessUserModel found by the `where` argument doesn't exist, create a new BusinessUserModel with this data.
     */
    create: XOR<BusinessUserModelCreateInput, BusinessUserModelUncheckedCreateInput>
    /**
     * In case the BusinessUserModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessUserModelUpdateInput, BusinessUserModelUncheckedUpdateInput>
  }


  /**
   * BusinessUserModel delete
   */
  export type BusinessUserModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude | null
    /**
     * Filter which BusinessUserModel to delete.
     */
    where: BusinessUserModelWhereUniqueInput
  }


  /**
   * BusinessUserModel deleteMany
   */
  export type BusinessUserModelDeleteManyArgs = {
    /**
     * Filter which BusinessUserModels to delete
     */
    where?: BusinessUserModelWhereInput
  }


  /**
   * BusinessUserModel.authentications
   */
  export type BusinessUserModel$authenticationsArgs = {
    /**
     * Select specific fields to fetch from the AuthenticationModel
     */
    select?: AuthenticationModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuthenticationModelInclude | null
    where?: AuthenticationModelWhereInput
    orderBy?: Enumerable<AuthenticationModelOrderByWithRelationInput>
    cursor?: AuthenticationModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AuthenticationModelScalarFieldEnum>
  }


  /**
   * BusinessUserModel.rates
   */
  export type BusinessUserModel$ratesArgs = {
    /**
     * Select specific fields to fetch from the BusinessRateModel
     */
    select?: BusinessRateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessRateModelInclude | null
    where?: BusinessRateModelWhereInput
    orderBy?: Enumerable<BusinessRateModelOrderByWithRelationInput>
    cursor?: BusinessRateModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BusinessRateModelScalarFieldEnum>
  }


  /**
   * BusinessUserModel.reviews
   */
  export type BusinessUserModel$reviewsArgs = {
    /**
     * Select specific fields to fetch from the BusinessReviewModel
     */
    select?: BusinessReviewModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessReviewModelInclude | null
    where?: BusinessReviewModelWhereInput
    orderBy?: Enumerable<BusinessReviewModelOrderByWithRelationInput>
    cursor?: BusinessReviewModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BusinessReviewModelScalarFieldEnum>
  }


  /**
   * BusinessUserModel without action
   */
  export type BusinessUserModelArgs = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude | null
  }



  /**
   * Model RealEstateAgentModel
   */


  export type AggregateRealEstateAgentModel = {
    _count: RealEstateAgentModelCountAggregateOutputType | null
    _min: RealEstateAgentModelMinAggregateOutputType | null
    _max: RealEstateAgentModelMaxAggregateOutputType | null
  }

  export type RealEstateAgentModelMinAggregateOutputType = {
    id: string | null
    is_licensed: boolean | null
    real_estate_num: string | null
    real_estate_name: string | null
    real_estate_phone: string | null
    licensed_agent_name: string | null
    specialized_field_id: string | null
  }

  export type RealEstateAgentModelMaxAggregateOutputType = {
    id: string | null
    is_licensed: boolean | null
    real_estate_num: string | null
    real_estate_name: string | null
    real_estate_phone: string | null
    licensed_agent_name: string | null
    specialized_field_id: string | null
  }

  export type RealEstateAgentModelCountAggregateOutputType = {
    id: number
    is_licensed: number
    real_estate_num: number
    real_estate_name: number
    real_estate_phone: number
    licensed_agent_name: number
    specialized_field_id: number
    _all: number
  }


  export type RealEstateAgentModelMinAggregateInputType = {
    id?: true
    is_licensed?: true
    real_estate_num?: true
    real_estate_name?: true
    real_estate_phone?: true
    licensed_agent_name?: true
    specialized_field_id?: true
  }

  export type RealEstateAgentModelMaxAggregateInputType = {
    id?: true
    is_licensed?: true
    real_estate_num?: true
    real_estate_name?: true
    real_estate_phone?: true
    licensed_agent_name?: true
    specialized_field_id?: true
  }

  export type RealEstateAgentModelCountAggregateInputType = {
    id?: true
    is_licensed?: true
    real_estate_num?: true
    real_estate_name?: true
    real_estate_phone?: true
    licensed_agent_name?: true
    specialized_field_id?: true
    _all?: true
  }

  export type RealEstateAgentModelAggregateArgs = {
    /**
     * Filter which RealEstateAgentModel to aggregate.
     */
    where?: RealEstateAgentModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateAgentModels to fetch.
     */
    orderBy?: Enumerable<RealEstateAgentModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RealEstateAgentModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateAgentModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateAgentModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RealEstateAgentModels
    **/
    _count?: true | RealEstateAgentModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RealEstateAgentModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RealEstateAgentModelMaxAggregateInputType
  }

  export type GetRealEstateAgentModelAggregateType<T extends RealEstateAgentModelAggregateArgs> = {
        [P in keyof T & keyof AggregateRealEstateAgentModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRealEstateAgentModel[P]>
      : GetScalarType<T[P], AggregateRealEstateAgentModel[P]>
  }




  export type RealEstateAgentModelGroupByArgs = {
    where?: RealEstateAgentModelWhereInput
    orderBy?: Enumerable<RealEstateAgentModelOrderByWithAggregationInput>
    by: RealEstateAgentModelScalarFieldEnum[]
    having?: RealEstateAgentModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RealEstateAgentModelCountAggregateInputType | true
    _min?: RealEstateAgentModelMinAggregateInputType
    _max?: RealEstateAgentModelMaxAggregateInputType
  }


  export type RealEstateAgentModelGroupByOutputType = {
    id: string
    is_licensed: boolean
    real_estate_num: string
    real_estate_name: string
    real_estate_phone: string
    licensed_agent_name: string
    specialized_field_id: string | null
    _count: RealEstateAgentModelCountAggregateOutputType | null
    _min: RealEstateAgentModelMinAggregateOutputType | null
    _max: RealEstateAgentModelMaxAggregateOutputType | null
  }

  type GetRealEstateAgentModelGroupByPayload<T extends RealEstateAgentModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RealEstateAgentModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RealEstateAgentModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RealEstateAgentModelGroupByOutputType[P]>
            : GetScalarType<T[P], RealEstateAgentModelGroupByOutputType[P]>
        }
      >
    >


  export type RealEstateAgentModelSelect = {
    id?: boolean
    is_licensed?: boolean
    real_estate_num?: boolean
    real_estate_name?: boolean
    real_estate_phone?: boolean
    licensed_agent_name?: boolean
    specialized_field_id?: boolean
    business?: boolean | BusinessUserModelArgs
    specialized_field?: boolean | RealEstateSpecializedSubFieldModelArgs
    properties?: boolean | RealEstateAgentModel$propertiesArgs
    _count?: boolean | RealEstateAgentModelCountOutputTypeArgs
  }


  export type RealEstateAgentModelInclude = {
    business?: boolean | BusinessUserModelArgs
    specialized_field?: boolean | RealEstateSpecializedSubFieldModelArgs
    properties?: boolean | RealEstateAgentModel$propertiesArgs
    _count?: boolean | RealEstateAgentModelCountOutputTypeArgs
  }

  export type RealEstateAgentModelGetPayload<S extends boolean | null | undefined | RealEstateAgentModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RealEstateAgentModel :
    S extends undefined ? never :
    S extends { include: any } & (RealEstateAgentModelArgs | RealEstateAgentModelFindManyArgs)
    ? RealEstateAgentModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'business' ? BusinessUserModelGetPayload<S['include'][P]> :
        P extends 'specialized_field' ? RealEstateSpecializedSubFieldModelGetPayload<S['include'][P]> | null :
        P extends 'properties' ? Array < RealEstatePropertyModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? RealEstateAgentModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RealEstateAgentModelArgs | RealEstateAgentModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'business' ? BusinessUserModelGetPayload<S['select'][P]> :
        P extends 'specialized_field' ? RealEstateSpecializedSubFieldModelGetPayload<S['select'][P]> | null :
        P extends 'properties' ? Array < RealEstatePropertyModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? RealEstateAgentModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof RealEstateAgentModel ? RealEstateAgentModel[P] : never
  } 
      : RealEstateAgentModel


  type RealEstateAgentModelCountArgs = 
    Omit<RealEstateAgentModelFindManyArgs, 'select' | 'include'> & {
      select?: RealEstateAgentModelCountAggregateInputType | true
    }

  export interface RealEstateAgentModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one RealEstateAgentModel that matches the filter.
     * @param {RealEstateAgentModelFindUniqueArgs} args - Arguments to find a RealEstateAgentModel
     * @example
     * // Get one RealEstateAgentModel
     * const realEstateAgentModel = await prisma.realEstateAgentModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RealEstateAgentModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RealEstateAgentModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RealEstateAgentModel'> extends True ? Prisma__RealEstateAgentModelClient<RealEstateAgentModelGetPayload<T>> : Prisma__RealEstateAgentModelClient<RealEstateAgentModelGetPayload<T> | null, null>

    /**
     * Find one RealEstateAgentModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RealEstateAgentModelFindUniqueOrThrowArgs} args - Arguments to find a RealEstateAgentModel
     * @example
     * // Get one RealEstateAgentModel
     * const realEstateAgentModel = await prisma.realEstateAgentModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RealEstateAgentModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RealEstateAgentModelFindUniqueOrThrowArgs>
    ): Prisma__RealEstateAgentModelClient<RealEstateAgentModelGetPayload<T>>

    /**
     * Find the first RealEstateAgentModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgentModelFindFirstArgs} args - Arguments to find a RealEstateAgentModel
     * @example
     * // Get one RealEstateAgentModel
     * const realEstateAgentModel = await prisma.realEstateAgentModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RealEstateAgentModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RealEstateAgentModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RealEstateAgentModel'> extends True ? Prisma__RealEstateAgentModelClient<RealEstateAgentModelGetPayload<T>> : Prisma__RealEstateAgentModelClient<RealEstateAgentModelGetPayload<T> | null, null>

    /**
     * Find the first RealEstateAgentModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgentModelFindFirstOrThrowArgs} args - Arguments to find a RealEstateAgentModel
     * @example
     * // Get one RealEstateAgentModel
     * const realEstateAgentModel = await prisma.realEstateAgentModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RealEstateAgentModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RealEstateAgentModelFindFirstOrThrowArgs>
    ): Prisma__RealEstateAgentModelClient<RealEstateAgentModelGetPayload<T>>

    /**
     * Find zero or more RealEstateAgentModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgentModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RealEstateAgentModels
     * const realEstateAgentModels = await prisma.realEstateAgentModel.findMany()
     * 
     * // Get first 10 RealEstateAgentModels
     * const realEstateAgentModels = await prisma.realEstateAgentModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const realEstateAgentModelWithIdOnly = await prisma.realEstateAgentModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RealEstateAgentModelFindManyArgs>(
      args?: SelectSubset<T, RealEstateAgentModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<RealEstateAgentModelGetPayload<T>>>

    /**
     * Create a RealEstateAgentModel.
     * @param {RealEstateAgentModelCreateArgs} args - Arguments to create a RealEstateAgentModel.
     * @example
     * // Create one RealEstateAgentModel
     * const RealEstateAgentModel = await prisma.realEstateAgentModel.create({
     *   data: {
     *     // ... data to create a RealEstateAgentModel
     *   }
     * })
     * 
    **/
    create<T extends RealEstateAgentModelCreateArgs>(
      args: SelectSubset<T, RealEstateAgentModelCreateArgs>
    ): Prisma__RealEstateAgentModelClient<RealEstateAgentModelGetPayload<T>>

    /**
     * Create many RealEstateAgentModels.
     *     @param {RealEstateAgentModelCreateManyArgs} args - Arguments to create many RealEstateAgentModels.
     *     @example
     *     // Create many RealEstateAgentModels
     *     const realEstateAgentModel = await prisma.realEstateAgentModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RealEstateAgentModelCreateManyArgs>(
      args?: SelectSubset<T, RealEstateAgentModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RealEstateAgentModel.
     * @param {RealEstateAgentModelDeleteArgs} args - Arguments to delete one RealEstateAgentModel.
     * @example
     * // Delete one RealEstateAgentModel
     * const RealEstateAgentModel = await prisma.realEstateAgentModel.delete({
     *   where: {
     *     // ... filter to delete one RealEstateAgentModel
     *   }
     * })
     * 
    **/
    delete<T extends RealEstateAgentModelDeleteArgs>(
      args: SelectSubset<T, RealEstateAgentModelDeleteArgs>
    ): Prisma__RealEstateAgentModelClient<RealEstateAgentModelGetPayload<T>>

    /**
     * Update one RealEstateAgentModel.
     * @param {RealEstateAgentModelUpdateArgs} args - Arguments to update one RealEstateAgentModel.
     * @example
     * // Update one RealEstateAgentModel
     * const realEstateAgentModel = await prisma.realEstateAgentModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RealEstateAgentModelUpdateArgs>(
      args: SelectSubset<T, RealEstateAgentModelUpdateArgs>
    ): Prisma__RealEstateAgentModelClient<RealEstateAgentModelGetPayload<T>>

    /**
     * Delete zero or more RealEstateAgentModels.
     * @param {RealEstateAgentModelDeleteManyArgs} args - Arguments to filter RealEstateAgentModels to delete.
     * @example
     * // Delete a few RealEstateAgentModels
     * const { count } = await prisma.realEstateAgentModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RealEstateAgentModelDeleteManyArgs>(
      args?: SelectSubset<T, RealEstateAgentModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RealEstateAgentModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgentModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RealEstateAgentModels
     * const realEstateAgentModel = await prisma.realEstateAgentModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RealEstateAgentModelUpdateManyArgs>(
      args: SelectSubset<T, RealEstateAgentModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RealEstateAgentModel.
     * @param {RealEstateAgentModelUpsertArgs} args - Arguments to update or create a RealEstateAgentModel.
     * @example
     * // Update or create a RealEstateAgentModel
     * const realEstateAgentModel = await prisma.realEstateAgentModel.upsert({
     *   create: {
     *     // ... data to create a RealEstateAgentModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RealEstateAgentModel we want to update
     *   }
     * })
    **/
    upsert<T extends RealEstateAgentModelUpsertArgs>(
      args: SelectSubset<T, RealEstateAgentModelUpsertArgs>
    ): Prisma__RealEstateAgentModelClient<RealEstateAgentModelGetPayload<T>>

    /**
     * Count the number of RealEstateAgentModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgentModelCountArgs} args - Arguments to filter RealEstateAgentModels to count.
     * @example
     * // Count the number of RealEstateAgentModels
     * const count = await prisma.realEstateAgentModel.count({
     *   where: {
     *     // ... the filter for the RealEstateAgentModels we want to count
     *   }
     * })
    **/
    count<T extends RealEstateAgentModelCountArgs>(
      args?: Subset<T, RealEstateAgentModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RealEstateAgentModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RealEstateAgentModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgentModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RealEstateAgentModelAggregateArgs>(args: Subset<T, RealEstateAgentModelAggregateArgs>): Prisma.PrismaPromise<GetRealEstateAgentModelAggregateType<T>>

    /**
     * Group by RealEstateAgentModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateAgentModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RealEstateAgentModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RealEstateAgentModelGroupByArgs['orderBy'] }
        : { orderBy?: RealEstateAgentModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RealEstateAgentModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRealEstateAgentModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RealEstateAgentModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RealEstateAgentModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    business<T extends BusinessUserModelArgs= {}>(args?: Subset<T, BusinessUserModelArgs>): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T> | Null>;

    specialized_field<T extends RealEstateSpecializedSubFieldModelArgs= {}>(args?: Subset<T, RealEstateSpecializedSubFieldModelArgs>): Prisma__RealEstateSpecializedSubFieldModelClient<RealEstateSpecializedSubFieldModelGetPayload<T> | Null>;

    properties<T extends RealEstateAgentModel$propertiesArgs= {}>(args?: Subset<T, RealEstateAgentModel$propertiesArgs>): Prisma.PrismaPromise<Array<RealEstatePropertyModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RealEstateAgentModel base type for findUnique actions
   */
  export type RealEstateAgentModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RealEstateAgentModel
     */
    select?: RealEstateAgentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateAgentModelInclude | null
    /**
     * Filter, which RealEstateAgentModel to fetch.
     */
    where: RealEstateAgentModelWhereUniqueInput
  }

  /**
   * RealEstateAgentModel findUnique
   */
  export interface RealEstateAgentModelFindUniqueArgs extends RealEstateAgentModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RealEstateAgentModel findUniqueOrThrow
   */
  export type RealEstateAgentModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RealEstateAgentModel
     */
    select?: RealEstateAgentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateAgentModelInclude | null
    /**
     * Filter, which RealEstateAgentModel to fetch.
     */
    where: RealEstateAgentModelWhereUniqueInput
  }


  /**
   * RealEstateAgentModel base type for findFirst actions
   */
  export type RealEstateAgentModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RealEstateAgentModel
     */
    select?: RealEstateAgentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateAgentModelInclude | null
    /**
     * Filter, which RealEstateAgentModel to fetch.
     */
    where?: RealEstateAgentModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateAgentModels to fetch.
     */
    orderBy?: Enumerable<RealEstateAgentModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RealEstateAgentModels.
     */
    cursor?: RealEstateAgentModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateAgentModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateAgentModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RealEstateAgentModels.
     */
    distinct?: Enumerable<RealEstateAgentModelScalarFieldEnum>
  }

  /**
   * RealEstateAgentModel findFirst
   */
  export interface RealEstateAgentModelFindFirstArgs extends RealEstateAgentModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RealEstateAgentModel findFirstOrThrow
   */
  export type RealEstateAgentModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RealEstateAgentModel
     */
    select?: RealEstateAgentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateAgentModelInclude | null
    /**
     * Filter, which RealEstateAgentModel to fetch.
     */
    where?: RealEstateAgentModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateAgentModels to fetch.
     */
    orderBy?: Enumerable<RealEstateAgentModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RealEstateAgentModels.
     */
    cursor?: RealEstateAgentModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateAgentModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateAgentModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RealEstateAgentModels.
     */
    distinct?: Enumerable<RealEstateAgentModelScalarFieldEnum>
  }


  /**
   * RealEstateAgentModel findMany
   */
  export type RealEstateAgentModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the RealEstateAgentModel
     */
    select?: RealEstateAgentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateAgentModelInclude | null
    /**
     * Filter, which RealEstateAgentModels to fetch.
     */
    where?: RealEstateAgentModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateAgentModels to fetch.
     */
    orderBy?: Enumerable<RealEstateAgentModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RealEstateAgentModels.
     */
    cursor?: RealEstateAgentModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateAgentModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateAgentModels.
     */
    skip?: number
    distinct?: Enumerable<RealEstateAgentModelScalarFieldEnum>
  }


  /**
   * RealEstateAgentModel create
   */
  export type RealEstateAgentModelCreateArgs = {
    /**
     * Select specific fields to fetch from the RealEstateAgentModel
     */
    select?: RealEstateAgentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateAgentModelInclude | null
    /**
     * The data needed to create a RealEstateAgentModel.
     */
    data: XOR<RealEstateAgentModelCreateInput, RealEstateAgentModelUncheckedCreateInput>
  }


  /**
   * RealEstateAgentModel createMany
   */
  export type RealEstateAgentModelCreateManyArgs = {
    /**
     * The data used to create many RealEstateAgentModels.
     */
    data: Enumerable<RealEstateAgentModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RealEstateAgentModel update
   */
  export type RealEstateAgentModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the RealEstateAgentModel
     */
    select?: RealEstateAgentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateAgentModelInclude | null
    /**
     * The data needed to update a RealEstateAgentModel.
     */
    data: XOR<RealEstateAgentModelUpdateInput, RealEstateAgentModelUncheckedUpdateInput>
    /**
     * Choose, which RealEstateAgentModel to update.
     */
    where: RealEstateAgentModelWhereUniqueInput
  }


  /**
   * RealEstateAgentModel updateMany
   */
  export type RealEstateAgentModelUpdateManyArgs = {
    /**
     * The data used to update RealEstateAgentModels.
     */
    data: XOR<RealEstateAgentModelUpdateManyMutationInput, RealEstateAgentModelUncheckedUpdateManyInput>
    /**
     * Filter which RealEstateAgentModels to update
     */
    where?: RealEstateAgentModelWhereInput
  }


  /**
   * RealEstateAgentModel upsert
   */
  export type RealEstateAgentModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the RealEstateAgentModel
     */
    select?: RealEstateAgentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateAgentModelInclude | null
    /**
     * The filter to search for the RealEstateAgentModel to update in case it exists.
     */
    where: RealEstateAgentModelWhereUniqueInput
    /**
     * In case the RealEstateAgentModel found by the `where` argument doesn't exist, create a new RealEstateAgentModel with this data.
     */
    create: XOR<RealEstateAgentModelCreateInput, RealEstateAgentModelUncheckedCreateInput>
    /**
     * In case the RealEstateAgentModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RealEstateAgentModelUpdateInput, RealEstateAgentModelUncheckedUpdateInput>
  }


  /**
   * RealEstateAgentModel delete
   */
  export type RealEstateAgentModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the RealEstateAgentModel
     */
    select?: RealEstateAgentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateAgentModelInclude | null
    /**
     * Filter which RealEstateAgentModel to delete.
     */
    where: RealEstateAgentModelWhereUniqueInput
  }


  /**
   * RealEstateAgentModel deleteMany
   */
  export type RealEstateAgentModelDeleteManyArgs = {
    /**
     * Filter which RealEstateAgentModels to delete
     */
    where?: RealEstateAgentModelWhereInput
  }


  /**
   * RealEstateAgentModel.properties
   */
  export type RealEstateAgentModel$propertiesArgs = {
    /**
     * Select specific fields to fetch from the RealEstatePropertyModel
     */
    select?: RealEstatePropertyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstatePropertyModelInclude | null
    where?: RealEstatePropertyModelWhereInput
    orderBy?: Enumerable<RealEstatePropertyModelOrderByWithRelationInput>
    cursor?: RealEstatePropertyModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RealEstatePropertyModelScalarFieldEnum>
  }


  /**
   * RealEstateAgentModel without action
   */
  export type RealEstateAgentModelArgs = {
    /**
     * Select specific fields to fetch from the RealEstateAgentModel
     */
    select?: RealEstateAgentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateAgentModelInclude | null
  }



  /**
   * Model HomeCareCompanyModel
   */


  export type AggregateHomeCareCompanyModel = {
    _count: HomeCareCompanyModelCountAggregateOutputType | null
    _min: HomeCareCompanyModelMinAggregateOutputType | null
    _max: HomeCareCompanyModelMaxAggregateOutputType | null
  }

  export type HomeCareCompanyModelMinAggregateOutputType = {
    id: string | null
    business_registration_num: string | null
    specialized_field_id: string | null
  }

  export type HomeCareCompanyModelMaxAggregateOutputType = {
    id: string | null
    business_registration_num: string | null
    specialized_field_id: string | null
  }

  export type HomeCareCompanyModelCountAggregateOutputType = {
    id: number
    business_registration_num: number
    specialized_field_id: number
    _all: number
  }


  export type HomeCareCompanyModelMinAggregateInputType = {
    id?: true
    business_registration_num?: true
    specialized_field_id?: true
  }

  export type HomeCareCompanyModelMaxAggregateInputType = {
    id?: true
    business_registration_num?: true
    specialized_field_id?: true
  }

  export type HomeCareCompanyModelCountAggregateInputType = {
    id?: true
    business_registration_num?: true
    specialized_field_id?: true
    _all?: true
  }

  export type HomeCareCompanyModelAggregateArgs = {
    /**
     * Filter which HomeCareCompanyModel to aggregate.
     */
    where?: HomeCareCompanyModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeCareCompanyModels to fetch.
     */
    orderBy?: Enumerable<HomeCareCompanyModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HomeCareCompanyModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeCareCompanyModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeCareCompanyModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HomeCareCompanyModels
    **/
    _count?: true | HomeCareCompanyModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HomeCareCompanyModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HomeCareCompanyModelMaxAggregateInputType
  }

  export type GetHomeCareCompanyModelAggregateType<T extends HomeCareCompanyModelAggregateArgs> = {
        [P in keyof T & keyof AggregateHomeCareCompanyModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHomeCareCompanyModel[P]>
      : GetScalarType<T[P], AggregateHomeCareCompanyModel[P]>
  }




  export type HomeCareCompanyModelGroupByArgs = {
    where?: HomeCareCompanyModelWhereInput
    orderBy?: Enumerable<HomeCareCompanyModelOrderByWithAggregationInput>
    by: HomeCareCompanyModelScalarFieldEnum[]
    having?: HomeCareCompanyModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HomeCareCompanyModelCountAggregateInputType | true
    _min?: HomeCareCompanyModelMinAggregateInputType
    _max?: HomeCareCompanyModelMaxAggregateInputType
  }


  export type HomeCareCompanyModelGroupByOutputType = {
    id: string
    business_registration_num: string
    specialized_field_id: string | null
    _count: HomeCareCompanyModelCountAggregateOutputType | null
    _min: HomeCareCompanyModelMinAggregateOutputType | null
    _max: HomeCareCompanyModelMaxAggregateOutputType | null
  }

  type GetHomeCareCompanyModelGroupByPayload<T extends HomeCareCompanyModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HomeCareCompanyModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HomeCareCompanyModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HomeCareCompanyModelGroupByOutputType[P]>
            : GetScalarType<T[P], HomeCareCompanyModelGroupByOutputType[P]>
        }
      >
    >


  export type HomeCareCompanyModelSelect = {
    id?: boolean
    business_registration_num?: boolean
    specialized_field_id?: boolean
    business?: boolean | BusinessUserModelArgs
    specialized_field?: boolean | HomeCareSpecializedSubFieldModelArgs
    introduction_images?: boolean | HomeCareCompanyModel$introduction_imagesArgs
    _count?: boolean | HomeCareCompanyModelCountOutputTypeArgs
  }


  export type HomeCareCompanyModelInclude = {
    business?: boolean | BusinessUserModelArgs
    specialized_field?: boolean | HomeCareSpecializedSubFieldModelArgs
    introduction_images?: boolean | HomeCareCompanyModel$introduction_imagesArgs
    _count?: boolean | HomeCareCompanyModelCountOutputTypeArgs
  }

  export type HomeCareCompanyModelGetPayload<S extends boolean | null | undefined | HomeCareCompanyModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HomeCareCompanyModel :
    S extends undefined ? never :
    S extends { include: any } & (HomeCareCompanyModelArgs | HomeCareCompanyModelFindManyArgs)
    ? HomeCareCompanyModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'business' ? BusinessUserModelGetPayload<S['include'][P]> :
        P extends 'specialized_field' ? HomeCareSpecializedSubFieldModelGetPayload<S['include'][P]> | null :
        P extends 'introduction_images' ? Array < HomeCareIntroductionImageModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? HomeCareCompanyModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (HomeCareCompanyModelArgs | HomeCareCompanyModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'business' ? BusinessUserModelGetPayload<S['select'][P]> :
        P extends 'specialized_field' ? HomeCareSpecializedSubFieldModelGetPayload<S['select'][P]> | null :
        P extends 'introduction_images' ? Array < HomeCareIntroductionImageModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? HomeCareCompanyModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof HomeCareCompanyModel ? HomeCareCompanyModel[P] : never
  } 
      : HomeCareCompanyModel


  type HomeCareCompanyModelCountArgs = 
    Omit<HomeCareCompanyModelFindManyArgs, 'select' | 'include'> & {
      select?: HomeCareCompanyModelCountAggregateInputType | true
    }

  export interface HomeCareCompanyModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one HomeCareCompanyModel that matches the filter.
     * @param {HomeCareCompanyModelFindUniqueArgs} args - Arguments to find a HomeCareCompanyModel
     * @example
     * // Get one HomeCareCompanyModel
     * const homeCareCompanyModel = await prisma.homeCareCompanyModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HomeCareCompanyModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HomeCareCompanyModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'HomeCareCompanyModel'> extends True ? Prisma__HomeCareCompanyModelClient<HomeCareCompanyModelGetPayload<T>> : Prisma__HomeCareCompanyModelClient<HomeCareCompanyModelGetPayload<T> | null, null>

    /**
     * Find one HomeCareCompanyModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HomeCareCompanyModelFindUniqueOrThrowArgs} args - Arguments to find a HomeCareCompanyModel
     * @example
     * // Get one HomeCareCompanyModel
     * const homeCareCompanyModel = await prisma.homeCareCompanyModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HomeCareCompanyModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, HomeCareCompanyModelFindUniqueOrThrowArgs>
    ): Prisma__HomeCareCompanyModelClient<HomeCareCompanyModelGetPayload<T>>

    /**
     * Find the first HomeCareCompanyModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareCompanyModelFindFirstArgs} args - Arguments to find a HomeCareCompanyModel
     * @example
     * // Get one HomeCareCompanyModel
     * const homeCareCompanyModel = await prisma.homeCareCompanyModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HomeCareCompanyModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HomeCareCompanyModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'HomeCareCompanyModel'> extends True ? Prisma__HomeCareCompanyModelClient<HomeCareCompanyModelGetPayload<T>> : Prisma__HomeCareCompanyModelClient<HomeCareCompanyModelGetPayload<T> | null, null>

    /**
     * Find the first HomeCareCompanyModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareCompanyModelFindFirstOrThrowArgs} args - Arguments to find a HomeCareCompanyModel
     * @example
     * // Get one HomeCareCompanyModel
     * const homeCareCompanyModel = await prisma.homeCareCompanyModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HomeCareCompanyModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HomeCareCompanyModelFindFirstOrThrowArgs>
    ): Prisma__HomeCareCompanyModelClient<HomeCareCompanyModelGetPayload<T>>

    /**
     * Find zero or more HomeCareCompanyModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareCompanyModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HomeCareCompanyModels
     * const homeCareCompanyModels = await prisma.homeCareCompanyModel.findMany()
     * 
     * // Get first 10 HomeCareCompanyModels
     * const homeCareCompanyModels = await prisma.homeCareCompanyModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const homeCareCompanyModelWithIdOnly = await prisma.homeCareCompanyModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HomeCareCompanyModelFindManyArgs>(
      args?: SelectSubset<T, HomeCareCompanyModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<HomeCareCompanyModelGetPayload<T>>>

    /**
     * Create a HomeCareCompanyModel.
     * @param {HomeCareCompanyModelCreateArgs} args - Arguments to create a HomeCareCompanyModel.
     * @example
     * // Create one HomeCareCompanyModel
     * const HomeCareCompanyModel = await prisma.homeCareCompanyModel.create({
     *   data: {
     *     // ... data to create a HomeCareCompanyModel
     *   }
     * })
     * 
    **/
    create<T extends HomeCareCompanyModelCreateArgs>(
      args: SelectSubset<T, HomeCareCompanyModelCreateArgs>
    ): Prisma__HomeCareCompanyModelClient<HomeCareCompanyModelGetPayload<T>>

    /**
     * Create many HomeCareCompanyModels.
     *     @param {HomeCareCompanyModelCreateManyArgs} args - Arguments to create many HomeCareCompanyModels.
     *     @example
     *     // Create many HomeCareCompanyModels
     *     const homeCareCompanyModel = await prisma.homeCareCompanyModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HomeCareCompanyModelCreateManyArgs>(
      args?: SelectSubset<T, HomeCareCompanyModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HomeCareCompanyModel.
     * @param {HomeCareCompanyModelDeleteArgs} args - Arguments to delete one HomeCareCompanyModel.
     * @example
     * // Delete one HomeCareCompanyModel
     * const HomeCareCompanyModel = await prisma.homeCareCompanyModel.delete({
     *   where: {
     *     // ... filter to delete one HomeCareCompanyModel
     *   }
     * })
     * 
    **/
    delete<T extends HomeCareCompanyModelDeleteArgs>(
      args: SelectSubset<T, HomeCareCompanyModelDeleteArgs>
    ): Prisma__HomeCareCompanyModelClient<HomeCareCompanyModelGetPayload<T>>

    /**
     * Update one HomeCareCompanyModel.
     * @param {HomeCareCompanyModelUpdateArgs} args - Arguments to update one HomeCareCompanyModel.
     * @example
     * // Update one HomeCareCompanyModel
     * const homeCareCompanyModel = await prisma.homeCareCompanyModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HomeCareCompanyModelUpdateArgs>(
      args: SelectSubset<T, HomeCareCompanyModelUpdateArgs>
    ): Prisma__HomeCareCompanyModelClient<HomeCareCompanyModelGetPayload<T>>

    /**
     * Delete zero or more HomeCareCompanyModels.
     * @param {HomeCareCompanyModelDeleteManyArgs} args - Arguments to filter HomeCareCompanyModels to delete.
     * @example
     * // Delete a few HomeCareCompanyModels
     * const { count } = await prisma.homeCareCompanyModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HomeCareCompanyModelDeleteManyArgs>(
      args?: SelectSubset<T, HomeCareCompanyModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HomeCareCompanyModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareCompanyModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HomeCareCompanyModels
     * const homeCareCompanyModel = await prisma.homeCareCompanyModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HomeCareCompanyModelUpdateManyArgs>(
      args: SelectSubset<T, HomeCareCompanyModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HomeCareCompanyModel.
     * @param {HomeCareCompanyModelUpsertArgs} args - Arguments to update or create a HomeCareCompanyModel.
     * @example
     * // Update or create a HomeCareCompanyModel
     * const homeCareCompanyModel = await prisma.homeCareCompanyModel.upsert({
     *   create: {
     *     // ... data to create a HomeCareCompanyModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HomeCareCompanyModel we want to update
     *   }
     * })
    **/
    upsert<T extends HomeCareCompanyModelUpsertArgs>(
      args: SelectSubset<T, HomeCareCompanyModelUpsertArgs>
    ): Prisma__HomeCareCompanyModelClient<HomeCareCompanyModelGetPayload<T>>

    /**
     * Count the number of HomeCareCompanyModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareCompanyModelCountArgs} args - Arguments to filter HomeCareCompanyModels to count.
     * @example
     * // Count the number of HomeCareCompanyModels
     * const count = await prisma.homeCareCompanyModel.count({
     *   where: {
     *     // ... the filter for the HomeCareCompanyModels we want to count
     *   }
     * })
    **/
    count<T extends HomeCareCompanyModelCountArgs>(
      args?: Subset<T, HomeCareCompanyModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HomeCareCompanyModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HomeCareCompanyModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareCompanyModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HomeCareCompanyModelAggregateArgs>(args: Subset<T, HomeCareCompanyModelAggregateArgs>): Prisma.PrismaPromise<GetHomeCareCompanyModelAggregateType<T>>

    /**
     * Group by HomeCareCompanyModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareCompanyModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HomeCareCompanyModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HomeCareCompanyModelGroupByArgs['orderBy'] }
        : { orderBy?: HomeCareCompanyModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HomeCareCompanyModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHomeCareCompanyModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for HomeCareCompanyModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HomeCareCompanyModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    business<T extends BusinessUserModelArgs= {}>(args?: Subset<T, BusinessUserModelArgs>): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T> | Null>;

    specialized_field<T extends HomeCareSpecializedSubFieldModelArgs= {}>(args?: Subset<T, HomeCareSpecializedSubFieldModelArgs>): Prisma__HomeCareSpecializedSubFieldModelClient<HomeCareSpecializedSubFieldModelGetPayload<T> | Null>;

    introduction_images<T extends HomeCareCompanyModel$introduction_imagesArgs= {}>(args?: Subset<T, HomeCareCompanyModel$introduction_imagesArgs>): Prisma.PrismaPromise<Array<HomeCareIntroductionImageModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * HomeCareCompanyModel base type for findUnique actions
   */
  export type HomeCareCompanyModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the HomeCareCompanyModel
     */
    select?: HomeCareCompanyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareCompanyModelInclude | null
    /**
     * Filter, which HomeCareCompanyModel to fetch.
     */
    where: HomeCareCompanyModelWhereUniqueInput
  }

  /**
   * HomeCareCompanyModel findUnique
   */
  export interface HomeCareCompanyModelFindUniqueArgs extends HomeCareCompanyModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HomeCareCompanyModel findUniqueOrThrow
   */
  export type HomeCareCompanyModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HomeCareCompanyModel
     */
    select?: HomeCareCompanyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareCompanyModelInclude | null
    /**
     * Filter, which HomeCareCompanyModel to fetch.
     */
    where: HomeCareCompanyModelWhereUniqueInput
  }


  /**
   * HomeCareCompanyModel base type for findFirst actions
   */
  export type HomeCareCompanyModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the HomeCareCompanyModel
     */
    select?: HomeCareCompanyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareCompanyModelInclude | null
    /**
     * Filter, which HomeCareCompanyModel to fetch.
     */
    where?: HomeCareCompanyModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeCareCompanyModels to fetch.
     */
    orderBy?: Enumerable<HomeCareCompanyModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomeCareCompanyModels.
     */
    cursor?: HomeCareCompanyModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeCareCompanyModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeCareCompanyModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomeCareCompanyModels.
     */
    distinct?: Enumerable<HomeCareCompanyModelScalarFieldEnum>
  }

  /**
   * HomeCareCompanyModel findFirst
   */
  export interface HomeCareCompanyModelFindFirstArgs extends HomeCareCompanyModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HomeCareCompanyModel findFirstOrThrow
   */
  export type HomeCareCompanyModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HomeCareCompanyModel
     */
    select?: HomeCareCompanyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareCompanyModelInclude | null
    /**
     * Filter, which HomeCareCompanyModel to fetch.
     */
    where?: HomeCareCompanyModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeCareCompanyModels to fetch.
     */
    orderBy?: Enumerable<HomeCareCompanyModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomeCareCompanyModels.
     */
    cursor?: HomeCareCompanyModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeCareCompanyModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeCareCompanyModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomeCareCompanyModels.
     */
    distinct?: Enumerable<HomeCareCompanyModelScalarFieldEnum>
  }


  /**
   * HomeCareCompanyModel findMany
   */
  export type HomeCareCompanyModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the HomeCareCompanyModel
     */
    select?: HomeCareCompanyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareCompanyModelInclude | null
    /**
     * Filter, which HomeCareCompanyModels to fetch.
     */
    where?: HomeCareCompanyModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeCareCompanyModels to fetch.
     */
    orderBy?: Enumerable<HomeCareCompanyModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HomeCareCompanyModels.
     */
    cursor?: HomeCareCompanyModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeCareCompanyModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeCareCompanyModels.
     */
    skip?: number
    distinct?: Enumerable<HomeCareCompanyModelScalarFieldEnum>
  }


  /**
   * HomeCareCompanyModel create
   */
  export type HomeCareCompanyModelCreateArgs = {
    /**
     * Select specific fields to fetch from the HomeCareCompanyModel
     */
    select?: HomeCareCompanyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareCompanyModelInclude | null
    /**
     * The data needed to create a HomeCareCompanyModel.
     */
    data: XOR<HomeCareCompanyModelCreateInput, HomeCareCompanyModelUncheckedCreateInput>
  }


  /**
   * HomeCareCompanyModel createMany
   */
  export type HomeCareCompanyModelCreateManyArgs = {
    /**
     * The data used to create many HomeCareCompanyModels.
     */
    data: Enumerable<HomeCareCompanyModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * HomeCareCompanyModel update
   */
  export type HomeCareCompanyModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the HomeCareCompanyModel
     */
    select?: HomeCareCompanyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareCompanyModelInclude | null
    /**
     * The data needed to update a HomeCareCompanyModel.
     */
    data: XOR<HomeCareCompanyModelUpdateInput, HomeCareCompanyModelUncheckedUpdateInput>
    /**
     * Choose, which HomeCareCompanyModel to update.
     */
    where: HomeCareCompanyModelWhereUniqueInput
  }


  /**
   * HomeCareCompanyModel updateMany
   */
  export type HomeCareCompanyModelUpdateManyArgs = {
    /**
     * The data used to update HomeCareCompanyModels.
     */
    data: XOR<HomeCareCompanyModelUpdateManyMutationInput, HomeCareCompanyModelUncheckedUpdateManyInput>
    /**
     * Filter which HomeCareCompanyModels to update
     */
    where?: HomeCareCompanyModelWhereInput
  }


  /**
   * HomeCareCompanyModel upsert
   */
  export type HomeCareCompanyModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the HomeCareCompanyModel
     */
    select?: HomeCareCompanyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareCompanyModelInclude | null
    /**
     * The filter to search for the HomeCareCompanyModel to update in case it exists.
     */
    where: HomeCareCompanyModelWhereUniqueInput
    /**
     * In case the HomeCareCompanyModel found by the `where` argument doesn't exist, create a new HomeCareCompanyModel with this data.
     */
    create: XOR<HomeCareCompanyModelCreateInput, HomeCareCompanyModelUncheckedCreateInput>
    /**
     * In case the HomeCareCompanyModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HomeCareCompanyModelUpdateInput, HomeCareCompanyModelUncheckedUpdateInput>
  }


  /**
   * HomeCareCompanyModel delete
   */
  export type HomeCareCompanyModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the HomeCareCompanyModel
     */
    select?: HomeCareCompanyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareCompanyModelInclude | null
    /**
     * Filter which HomeCareCompanyModel to delete.
     */
    where: HomeCareCompanyModelWhereUniqueInput
  }


  /**
   * HomeCareCompanyModel deleteMany
   */
  export type HomeCareCompanyModelDeleteManyArgs = {
    /**
     * Filter which HomeCareCompanyModels to delete
     */
    where?: HomeCareCompanyModelWhereInput
  }


  /**
   * HomeCareCompanyModel.introduction_images
   */
  export type HomeCareCompanyModel$introduction_imagesArgs = {
    /**
     * Select specific fields to fetch from the HomeCareIntroductionImageModel
     */
    select?: HomeCareIntroductionImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareIntroductionImageModelInclude | null
    where?: HomeCareIntroductionImageModelWhereInput
    orderBy?: Enumerable<HomeCareIntroductionImageModelOrderByWithRelationInput>
    cursor?: HomeCareIntroductionImageModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HomeCareIntroductionImageModelScalarFieldEnum>
  }


  /**
   * HomeCareCompanyModel without action
   */
  export type HomeCareCompanyModelArgs = {
    /**
     * Select specific fields to fetch from the HomeCareCompanyModel
     */
    select?: HomeCareCompanyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareCompanyModelInclude | null
  }



  /**
   * Model HomeCareIntroductionImageModel
   */


  export type AggregateHomeCareIntroductionImageModel = {
    _count: HomeCareIntroductionImageModelCountAggregateOutputType | null
    _min: HomeCareIntroductionImageModelMinAggregateOutputType | null
    _max: HomeCareIntroductionImageModelMaxAggregateOutputType | null
  }

  export type HomeCareIntroductionImageModelMinAggregateOutputType = {
    id: string | null
    image_url: string | null
    company_id: string | null
  }

  export type HomeCareIntroductionImageModelMaxAggregateOutputType = {
    id: string | null
    image_url: string | null
    company_id: string | null
  }

  export type HomeCareIntroductionImageModelCountAggregateOutputType = {
    id: number
    image_url: number
    company_id: number
    _all: number
  }


  export type HomeCareIntroductionImageModelMinAggregateInputType = {
    id?: true
    image_url?: true
    company_id?: true
  }

  export type HomeCareIntroductionImageModelMaxAggregateInputType = {
    id?: true
    image_url?: true
    company_id?: true
  }

  export type HomeCareIntroductionImageModelCountAggregateInputType = {
    id?: true
    image_url?: true
    company_id?: true
    _all?: true
  }

  export type HomeCareIntroductionImageModelAggregateArgs = {
    /**
     * Filter which HomeCareIntroductionImageModel to aggregate.
     */
    where?: HomeCareIntroductionImageModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeCareIntroductionImageModels to fetch.
     */
    orderBy?: Enumerable<HomeCareIntroductionImageModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HomeCareIntroductionImageModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeCareIntroductionImageModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeCareIntroductionImageModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HomeCareIntroductionImageModels
    **/
    _count?: true | HomeCareIntroductionImageModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HomeCareIntroductionImageModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HomeCareIntroductionImageModelMaxAggregateInputType
  }

  export type GetHomeCareIntroductionImageModelAggregateType<T extends HomeCareIntroductionImageModelAggregateArgs> = {
        [P in keyof T & keyof AggregateHomeCareIntroductionImageModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHomeCareIntroductionImageModel[P]>
      : GetScalarType<T[P], AggregateHomeCareIntroductionImageModel[P]>
  }




  export type HomeCareIntroductionImageModelGroupByArgs = {
    where?: HomeCareIntroductionImageModelWhereInput
    orderBy?: Enumerable<HomeCareIntroductionImageModelOrderByWithAggregationInput>
    by: HomeCareIntroductionImageModelScalarFieldEnum[]
    having?: HomeCareIntroductionImageModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HomeCareIntroductionImageModelCountAggregateInputType | true
    _min?: HomeCareIntroductionImageModelMinAggregateInputType
    _max?: HomeCareIntroductionImageModelMaxAggregateInputType
  }


  export type HomeCareIntroductionImageModelGroupByOutputType = {
    id: string
    image_url: string
    company_id: string
    _count: HomeCareIntroductionImageModelCountAggregateOutputType | null
    _min: HomeCareIntroductionImageModelMinAggregateOutputType | null
    _max: HomeCareIntroductionImageModelMaxAggregateOutputType | null
  }

  type GetHomeCareIntroductionImageModelGroupByPayload<T extends HomeCareIntroductionImageModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HomeCareIntroductionImageModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HomeCareIntroductionImageModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HomeCareIntroductionImageModelGroupByOutputType[P]>
            : GetScalarType<T[P], HomeCareIntroductionImageModelGroupByOutputType[P]>
        }
      >
    >


  export type HomeCareIntroductionImageModelSelect = {
    id?: boolean
    image_url?: boolean
    company_id?: boolean
    company?: boolean | HomeCareCompanyModelArgs
  }


  export type HomeCareIntroductionImageModelInclude = {
    company?: boolean | HomeCareCompanyModelArgs
  }

  export type HomeCareIntroductionImageModelGetPayload<S extends boolean | null | undefined | HomeCareIntroductionImageModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HomeCareIntroductionImageModel :
    S extends undefined ? never :
    S extends { include: any } & (HomeCareIntroductionImageModelArgs | HomeCareIntroductionImageModelFindManyArgs)
    ? HomeCareIntroductionImageModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'company' ? HomeCareCompanyModelGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (HomeCareIntroductionImageModelArgs | HomeCareIntroductionImageModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'company' ? HomeCareCompanyModelGetPayload<S['select'][P]> :  P extends keyof HomeCareIntroductionImageModel ? HomeCareIntroductionImageModel[P] : never
  } 
      : HomeCareIntroductionImageModel


  type HomeCareIntroductionImageModelCountArgs = 
    Omit<HomeCareIntroductionImageModelFindManyArgs, 'select' | 'include'> & {
      select?: HomeCareIntroductionImageModelCountAggregateInputType | true
    }

  export interface HomeCareIntroductionImageModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one HomeCareIntroductionImageModel that matches the filter.
     * @param {HomeCareIntroductionImageModelFindUniqueArgs} args - Arguments to find a HomeCareIntroductionImageModel
     * @example
     * // Get one HomeCareIntroductionImageModel
     * const homeCareIntroductionImageModel = await prisma.homeCareIntroductionImageModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HomeCareIntroductionImageModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HomeCareIntroductionImageModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'HomeCareIntroductionImageModel'> extends True ? Prisma__HomeCareIntroductionImageModelClient<HomeCareIntroductionImageModelGetPayload<T>> : Prisma__HomeCareIntroductionImageModelClient<HomeCareIntroductionImageModelGetPayload<T> | null, null>

    /**
     * Find one HomeCareIntroductionImageModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HomeCareIntroductionImageModelFindUniqueOrThrowArgs} args - Arguments to find a HomeCareIntroductionImageModel
     * @example
     * // Get one HomeCareIntroductionImageModel
     * const homeCareIntroductionImageModel = await prisma.homeCareIntroductionImageModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HomeCareIntroductionImageModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, HomeCareIntroductionImageModelFindUniqueOrThrowArgs>
    ): Prisma__HomeCareIntroductionImageModelClient<HomeCareIntroductionImageModelGetPayload<T>>

    /**
     * Find the first HomeCareIntroductionImageModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareIntroductionImageModelFindFirstArgs} args - Arguments to find a HomeCareIntroductionImageModel
     * @example
     * // Get one HomeCareIntroductionImageModel
     * const homeCareIntroductionImageModel = await prisma.homeCareIntroductionImageModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HomeCareIntroductionImageModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HomeCareIntroductionImageModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'HomeCareIntroductionImageModel'> extends True ? Prisma__HomeCareIntroductionImageModelClient<HomeCareIntroductionImageModelGetPayload<T>> : Prisma__HomeCareIntroductionImageModelClient<HomeCareIntroductionImageModelGetPayload<T> | null, null>

    /**
     * Find the first HomeCareIntroductionImageModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareIntroductionImageModelFindFirstOrThrowArgs} args - Arguments to find a HomeCareIntroductionImageModel
     * @example
     * // Get one HomeCareIntroductionImageModel
     * const homeCareIntroductionImageModel = await prisma.homeCareIntroductionImageModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HomeCareIntroductionImageModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HomeCareIntroductionImageModelFindFirstOrThrowArgs>
    ): Prisma__HomeCareIntroductionImageModelClient<HomeCareIntroductionImageModelGetPayload<T>>

    /**
     * Find zero or more HomeCareIntroductionImageModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareIntroductionImageModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HomeCareIntroductionImageModels
     * const homeCareIntroductionImageModels = await prisma.homeCareIntroductionImageModel.findMany()
     * 
     * // Get first 10 HomeCareIntroductionImageModels
     * const homeCareIntroductionImageModels = await prisma.homeCareIntroductionImageModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const homeCareIntroductionImageModelWithIdOnly = await prisma.homeCareIntroductionImageModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HomeCareIntroductionImageModelFindManyArgs>(
      args?: SelectSubset<T, HomeCareIntroductionImageModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<HomeCareIntroductionImageModelGetPayload<T>>>

    /**
     * Create a HomeCareIntroductionImageModel.
     * @param {HomeCareIntroductionImageModelCreateArgs} args - Arguments to create a HomeCareIntroductionImageModel.
     * @example
     * // Create one HomeCareIntroductionImageModel
     * const HomeCareIntroductionImageModel = await prisma.homeCareIntroductionImageModel.create({
     *   data: {
     *     // ... data to create a HomeCareIntroductionImageModel
     *   }
     * })
     * 
    **/
    create<T extends HomeCareIntroductionImageModelCreateArgs>(
      args: SelectSubset<T, HomeCareIntroductionImageModelCreateArgs>
    ): Prisma__HomeCareIntroductionImageModelClient<HomeCareIntroductionImageModelGetPayload<T>>

    /**
     * Create many HomeCareIntroductionImageModels.
     *     @param {HomeCareIntroductionImageModelCreateManyArgs} args - Arguments to create many HomeCareIntroductionImageModels.
     *     @example
     *     // Create many HomeCareIntroductionImageModels
     *     const homeCareIntroductionImageModel = await prisma.homeCareIntroductionImageModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HomeCareIntroductionImageModelCreateManyArgs>(
      args?: SelectSubset<T, HomeCareIntroductionImageModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HomeCareIntroductionImageModel.
     * @param {HomeCareIntroductionImageModelDeleteArgs} args - Arguments to delete one HomeCareIntroductionImageModel.
     * @example
     * // Delete one HomeCareIntroductionImageModel
     * const HomeCareIntroductionImageModel = await prisma.homeCareIntroductionImageModel.delete({
     *   where: {
     *     // ... filter to delete one HomeCareIntroductionImageModel
     *   }
     * })
     * 
    **/
    delete<T extends HomeCareIntroductionImageModelDeleteArgs>(
      args: SelectSubset<T, HomeCareIntroductionImageModelDeleteArgs>
    ): Prisma__HomeCareIntroductionImageModelClient<HomeCareIntroductionImageModelGetPayload<T>>

    /**
     * Update one HomeCareIntroductionImageModel.
     * @param {HomeCareIntroductionImageModelUpdateArgs} args - Arguments to update one HomeCareIntroductionImageModel.
     * @example
     * // Update one HomeCareIntroductionImageModel
     * const homeCareIntroductionImageModel = await prisma.homeCareIntroductionImageModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HomeCareIntroductionImageModelUpdateArgs>(
      args: SelectSubset<T, HomeCareIntroductionImageModelUpdateArgs>
    ): Prisma__HomeCareIntroductionImageModelClient<HomeCareIntroductionImageModelGetPayload<T>>

    /**
     * Delete zero or more HomeCareIntroductionImageModels.
     * @param {HomeCareIntroductionImageModelDeleteManyArgs} args - Arguments to filter HomeCareIntroductionImageModels to delete.
     * @example
     * // Delete a few HomeCareIntroductionImageModels
     * const { count } = await prisma.homeCareIntroductionImageModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HomeCareIntroductionImageModelDeleteManyArgs>(
      args?: SelectSubset<T, HomeCareIntroductionImageModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HomeCareIntroductionImageModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareIntroductionImageModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HomeCareIntroductionImageModels
     * const homeCareIntroductionImageModel = await prisma.homeCareIntroductionImageModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HomeCareIntroductionImageModelUpdateManyArgs>(
      args: SelectSubset<T, HomeCareIntroductionImageModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HomeCareIntroductionImageModel.
     * @param {HomeCareIntroductionImageModelUpsertArgs} args - Arguments to update or create a HomeCareIntroductionImageModel.
     * @example
     * // Update or create a HomeCareIntroductionImageModel
     * const homeCareIntroductionImageModel = await prisma.homeCareIntroductionImageModel.upsert({
     *   create: {
     *     // ... data to create a HomeCareIntroductionImageModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HomeCareIntroductionImageModel we want to update
     *   }
     * })
    **/
    upsert<T extends HomeCareIntroductionImageModelUpsertArgs>(
      args: SelectSubset<T, HomeCareIntroductionImageModelUpsertArgs>
    ): Prisma__HomeCareIntroductionImageModelClient<HomeCareIntroductionImageModelGetPayload<T>>

    /**
     * Count the number of HomeCareIntroductionImageModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareIntroductionImageModelCountArgs} args - Arguments to filter HomeCareIntroductionImageModels to count.
     * @example
     * // Count the number of HomeCareIntroductionImageModels
     * const count = await prisma.homeCareIntroductionImageModel.count({
     *   where: {
     *     // ... the filter for the HomeCareIntroductionImageModels we want to count
     *   }
     * })
    **/
    count<T extends HomeCareIntroductionImageModelCountArgs>(
      args?: Subset<T, HomeCareIntroductionImageModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HomeCareIntroductionImageModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HomeCareIntroductionImageModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareIntroductionImageModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HomeCareIntroductionImageModelAggregateArgs>(args: Subset<T, HomeCareIntroductionImageModelAggregateArgs>): Prisma.PrismaPromise<GetHomeCareIntroductionImageModelAggregateType<T>>

    /**
     * Group by HomeCareIntroductionImageModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareIntroductionImageModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HomeCareIntroductionImageModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HomeCareIntroductionImageModelGroupByArgs['orderBy'] }
        : { orderBy?: HomeCareIntroductionImageModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HomeCareIntroductionImageModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHomeCareIntroductionImageModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for HomeCareIntroductionImageModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HomeCareIntroductionImageModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    company<T extends HomeCareCompanyModelArgs= {}>(args?: Subset<T, HomeCareCompanyModelArgs>): Prisma__HomeCareCompanyModelClient<HomeCareCompanyModelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * HomeCareIntroductionImageModel base type for findUnique actions
   */
  export type HomeCareIntroductionImageModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the HomeCareIntroductionImageModel
     */
    select?: HomeCareIntroductionImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareIntroductionImageModelInclude | null
    /**
     * Filter, which HomeCareIntroductionImageModel to fetch.
     */
    where: HomeCareIntroductionImageModelWhereUniqueInput
  }

  /**
   * HomeCareIntroductionImageModel findUnique
   */
  export interface HomeCareIntroductionImageModelFindUniqueArgs extends HomeCareIntroductionImageModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HomeCareIntroductionImageModel findUniqueOrThrow
   */
  export type HomeCareIntroductionImageModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HomeCareIntroductionImageModel
     */
    select?: HomeCareIntroductionImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareIntroductionImageModelInclude | null
    /**
     * Filter, which HomeCareIntroductionImageModel to fetch.
     */
    where: HomeCareIntroductionImageModelWhereUniqueInput
  }


  /**
   * HomeCareIntroductionImageModel base type for findFirst actions
   */
  export type HomeCareIntroductionImageModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the HomeCareIntroductionImageModel
     */
    select?: HomeCareIntroductionImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareIntroductionImageModelInclude | null
    /**
     * Filter, which HomeCareIntroductionImageModel to fetch.
     */
    where?: HomeCareIntroductionImageModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeCareIntroductionImageModels to fetch.
     */
    orderBy?: Enumerable<HomeCareIntroductionImageModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomeCareIntroductionImageModels.
     */
    cursor?: HomeCareIntroductionImageModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeCareIntroductionImageModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeCareIntroductionImageModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomeCareIntroductionImageModels.
     */
    distinct?: Enumerable<HomeCareIntroductionImageModelScalarFieldEnum>
  }

  /**
   * HomeCareIntroductionImageModel findFirst
   */
  export interface HomeCareIntroductionImageModelFindFirstArgs extends HomeCareIntroductionImageModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HomeCareIntroductionImageModel findFirstOrThrow
   */
  export type HomeCareIntroductionImageModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HomeCareIntroductionImageModel
     */
    select?: HomeCareIntroductionImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareIntroductionImageModelInclude | null
    /**
     * Filter, which HomeCareIntroductionImageModel to fetch.
     */
    where?: HomeCareIntroductionImageModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeCareIntroductionImageModels to fetch.
     */
    orderBy?: Enumerable<HomeCareIntroductionImageModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomeCareIntroductionImageModels.
     */
    cursor?: HomeCareIntroductionImageModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeCareIntroductionImageModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeCareIntroductionImageModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomeCareIntroductionImageModels.
     */
    distinct?: Enumerable<HomeCareIntroductionImageModelScalarFieldEnum>
  }


  /**
   * HomeCareIntroductionImageModel findMany
   */
  export type HomeCareIntroductionImageModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the HomeCareIntroductionImageModel
     */
    select?: HomeCareIntroductionImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareIntroductionImageModelInclude | null
    /**
     * Filter, which HomeCareIntroductionImageModels to fetch.
     */
    where?: HomeCareIntroductionImageModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeCareIntroductionImageModels to fetch.
     */
    orderBy?: Enumerable<HomeCareIntroductionImageModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HomeCareIntroductionImageModels.
     */
    cursor?: HomeCareIntroductionImageModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeCareIntroductionImageModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeCareIntroductionImageModels.
     */
    skip?: number
    distinct?: Enumerable<HomeCareIntroductionImageModelScalarFieldEnum>
  }


  /**
   * HomeCareIntroductionImageModel create
   */
  export type HomeCareIntroductionImageModelCreateArgs = {
    /**
     * Select specific fields to fetch from the HomeCareIntroductionImageModel
     */
    select?: HomeCareIntroductionImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareIntroductionImageModelInclude | null
    /**
     * The data needed to create a HomeCareIntroductionImageModel.
     */
    data: XOR<HomeCareIntroductionImageModelCreateInput, HomeCareIntroductionImageModelUncheckedCreateInput>
  }


  /**
   * HomeCareIntroductionImageModel createMany
   */
  export type HomeCareIntroductionImageModelCreateManyArgs = {
    /**
     * The data used to create many HomeCareIntroductionImageModels.
     */
    data: Enumerable<HomeCareIntroductionImageModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * HomeCareIntroductionImageModel update
   */
  export type HomeCareIntroductionImageModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the HomeCareIntroductionImageModel
     */
    select?: HomeCareIntroductionImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareIntroductionImageModelInclude | null
    /**
     * The data needed to update a HomeCareIntroductionImageModel.
     */
    data: XOR<HomeCareIntroductionImageModelUpdateInput, HomeCareIntroductionImageModelUncheckedUpdateInput>
    /**
     * Choose, which HomeCareIntroductionImageModel to update.
     */
    where: HomeCareIntroductionImageModelWhereUniqueInput
  }


  /**
   * HomeCareIntroductionImageModel updateMany
   */
  export type HomeCareIntroductionImageModelUpdateManyArgs = {
    /**
     * The data used to update HomeCareIntroductionImageModels.
     */
    data: XOR<HomeCareIntroductionImageModelUpdateManyMutationInput, HomeCareIntroductionImageModelUncheckedUpdateManyInput>
    /**
     * Filter which HomeCareIntroductionImageModels to update
     */
    where?: HomeCareIntroductionImageModelWhereInput
  }


  /**
   * HomeCareIntroductionImageModel upsert
   */
  export type HomeCareIntroductionImageModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the HomeCareIntroductionImageModel
     */
    select?: HomeCareIntroductionImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareIntroductionImageModelInclude | null
    /**
     * The filter to search for the HomeCareIntroductionImageModel to update in case it exists.
     */
    where: HomeCareIntroductionImageModelWhereUniqueInput
    /**
     * In case the HomeCareIntroductionImageModel found by the `where` argument doesn't exist, create a new HomeCareIntroductionImageModel with this data.
     */
    create: XOR<HomeCareIntroductionImageModelCreateInput, HomeCareIntroductionImageModelUncheckedCreateInput>
    /**
     * In case the HomeCareIntroductionImageModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HomeCareIntroductionImageModelUpdateInput, HomeCareIntroductionImageModelUncheckedUpdateInput>
  }


  /**
   * HomeCareIntroductionImageModel delete
   */
  export type HomeCareIntroductionImageModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the HomeCareIntroductionImageModel
     */
    select?: HomeCareIntroductionImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareIntroductionImageModelInclude | null
    /**
     * Filter which HomeCareIntroductionImageModel to delete.
     */
    where: HomeCareIntroductionImageModelWhereUniqueInput
  }


  /**
   * HomeCareIntroductionImageModel deleteMany
   */
  export type HomeCareIntroductionImageModelDeleteManyArgs = {
    /**
     * Filter which HomeCareIntroductionImageModels to delete
     */
    where?: HomeCareIntroductionImageModelWhereInput
  }


  /**
   * HomeCareIntroductionImageModel without action
   */
  export type HomeCareIntroductionImageModelArgs = {
    /**
     * Select specific fields to fetch from the HomeCareIntroductionImageModel
     */
    select?: HomeCareIntroductionImageModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareIntroductionImageModelInclude | null
  }



  /**
   * Model RealEstatePropertyModel
   */


  export type AggregateRealEstatePropertyModel = {
    _count: RealEstatePropertyModelCountAggregateOutputType | null
    _min: RealEstatePropertyModelMinAggregateOutputType | null
    _max: RealEstatePropertyModelMaxAggregateOutputType | null
  }

  export type RealEstatePropertyModelMinAggregateOutputType = {
    id: string | null
    name: string | null
    main_image_url: string | null
    agent_id: string | null
  }

  export type RealEstatePropertyModelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    main_image_url: string | null
    agent_id: string | null
  }

  export type RealEstatePropertyModelCountAggregateOutputType = {
    id: number
    name: number
    main_image_url: number
    agent_id: number
    _all: number
  }


  export type RealEstatePropertyModelMinAggregateInputType = {
    id?: true
    name?: true
    main_image_url?: true
    agent_id?: true
  }

  export type RealEstatePropertyModelMaxAggregateInputType = {
    id?: true
    name?: true
    main_image_url?: true
    agent_id?: true
  }

  export type RealEstatePropertyModelCountAggregateInputType = {
    id?: true
    name?: true
    main_image_url?: true
    agent_id?: true
    _all?: true
  }

  export type RealEstatePropertyModelAggregateArgs = {
    /**
     * Filter which RealEstatePropertyModel to aggregate.
     */
    where?: RealEstatePropertyModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstatePropertyModels to fetch.
     */
    orderBy?: Enumerable<RealEstatePropertyModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RealEstatePropertyModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstatePropertyModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstatePropertyModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RealEstatePropertyModels
    **/
    _count?: true | RealEstatePropertyModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RealEstatePropertyModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RealEstatePropertyModelMaxAggregateInputType
  }

  export type GetRealEstatePropertyModelAggregateType<T extends RealEstatePropertyModelAggregateArgs> = {
        [P in keyof T & keyof AggregateRealEstatePropertyModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRealEstatePropertyModel[P]>
      : GetScalarType<T[P], AggregateRealEstatePropertyModel[P]>
  }




  export type RealEstatePropertyModelGroupByArgs = {
    where?: RealEstatePropertyModelWhereInput
    orderBy?: Enumerable<RealEstatePropertyModelOrderByWithAggregationInput>
    by: RealEstatePropertyModelScalarFieldEnum[]
    having?: RealEstatePropertyModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RealEstatePropertyModelCountAggregateInputType | true
    _min?: RealEstatePropertyModelMinAggregateInputType
    _max?: RealEstatePropertyModelMaxAggregateInputType
  }


  export type RealEstatePropertyModelGroupByOutputType = {
    id: string
    name: string
    main_image_url: string
    agent_id: string
    _count: RealEstatePropertyModelCountAggregateOutputType | null
    _min: RealEstatePropertyModelMinAggregateOutputType | null
    _max: RealEstatePropertyModelMaxAggregateOutputType | null
  }

  type GetRealEstatePropertyModelGroupByPayload<T extends RealEstatePropertyModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RealEstatePropertyModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RealEstatePropertyModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RealEstatePropertyModelGroupByOutputType[P]>
            : GetScalarType<T[P], RealEstatePropertyModelGroupByOutputType[P]>
        }
      >
    >


  export type RealEstatePropertyModelSelect = {
    id?: boolean
    name?: boolean
    main_image_url?: boolean
    agent_id?: boolean
    agent?: boolean | RealEstateAgentModelArgs
  }


  export type RealEstatePropertyModelInclude = {
    agent?: boolean | RealEstateAgentModelArgs
  }

  export type RealEstatePropertyModelGetPayload<S extends boolean | null | undefined | RealEstatePropertyModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RealEstatePropertyModel :
    S extends undefined ? never :
    S extends { include: any } & (RealEstatePropertyModelArgs | RealEstatePropertyModelFindManyArgs)
    ? RealEstatePropertyModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'agent' ? RealEstateAgentModelGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RealEstatePropertyModelArgs | RealEstatePropertyModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'agent' ? RealEstateAgentModelGetPayload<S['select'][P]> :  P extends keyof RealEstatePropertyModel ? RealEstatePropertyModel[P] : never
  } 
      : RealEstatePropertyModel


  type RealEstatePropertyModelCountArgs = 
    Omit<RealEstatePropertyModelFindManyArgs, 'select' | 'include'> & {
      select?: RealEstatePropertyModelCountAggregateInputType | true
    }

  export interface RealEstatePropertyModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one RealEstatePropertyModel that matches the filter.
     * @param {RealEstatePropertyModelFindUniqueArgs} args - Arguments to find a RealEstatePropertyModel
     * @example
     * // Get one RealEstatePropertyModel
     * const realEstatePropertyModel = await prisma.realEstatePropertyModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RealEstatePropertyModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RealEstatePropertyModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RealEstatePropertyModel'> extends True ? Prisma__RealEstatePropertyModelClient<RealEstatePropertyModelGetPayload<T>> : Prisma__RealEstatePropertyModelClient<RealEstatePropertyModelGetPayload<T> | null, null>

    /**
     * Find one RealEstatePropertyModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RealEstatePropertyModelFindUniqueOrThrowArgs} args - Arguments to find a RealEstatePropertyModel
     * @example
     * // Get one RealEstatePropertyModel
     * const realEstatePropertyModel = await prisma.realEstatePropertyModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RealEstatePropertyModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RealEstatePropertyModelFindUniqueOrThrowArgs>
    ): Prisma__RealEstatePropertyModelClient<RealEstatePropertyModelGetPayload<T>>

    /**
     * Find the first RealEstatePropertyModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstatePropertyModelFindFirstArgs} args - Arguments to find a RealEstatePropertyModel
     * @example
     * // Get one RealEstatePropertyModel
     * const realEstatePropertyModel = await prisma.realEstatePropertyModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RealEstatePropertyModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RealEstatePropertyModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RealEstatePropertyModel'> extends True ? Prisma__RealEstatePropertyModelClient<RealEstatePropertyModelGetPayload<T>> : Prisma__RealEstatePropertyModelClient<RealEstatePropertyModelGetPayload<T> | null, null>

    /**
     * Find the first RealEstatePropertyModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstatePropertyModelFindFirstOrThrowArgs} args - Arguments to find a RealEstatePropertyModel
     * @example
     * // Get one RealEstatePropertyModel
     * const realEstatePropertyModel = await prisma.realEstatePropertyModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RealEstatePropertyModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RealEstatePropertyModelFindFirstOrThrowArgs>
    ): Prisma__RealEstatePropertyModelClient<RealEstatePropertyModelGetPayload<T>>

    /**
     * Find zero or more RealEstatePropertyModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstatePropertyModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RealEstatePropertyModels
     * const realEstatePropertyModels = await prisma.realEstatePropertyModel.findMany()
     * 
     * // Get first 10 RealEstatePropertyModels
     * const realEstatePropertyModels = await prisma.realEstatePropertyModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const realEstatePropertyModelWithIdOnly = await prisma.realEstatePropertyModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RealEstatePropertyModelFindManyArgs>(
      args?: SelectSubset<T, RealEstatePropertyModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<RealEstatePropertyModelGetPayload<T>>>

    /**
     * Create a RealEstatePropertyModel.
     * @param {RealEstatePropertyModelCreateArgs} args - Arguments to create a RealEstatePropertyModel.
     * @example
     * // Create one RealEstatePropertyModel
     * const RealEstatePropertyModel = await prisma.realEstatePropertyModel.create({
     *   data: {
     *     // ... data to create a RealEstatePropertyModel
     *   }
     * })
     * 
    **/
    create<T extends RealEstatePropertyModelCreateArgs>(
      args: SelectSubset<T, RealEstatePropertyModelCreateArgs>
    ): Prisma__RealEstatePropertyModelClient<RealEstatePropertyModelGetPayload<T>>

    /**
     * Create many RealEstatePropertyModels.
     *     @param {RealEstatePropertyModelCreateManyArgs} args - Arguments to create many RealEstatePropertyModels.
     *     @example
     *     // Create many RealEstatePropertyModels
     *     const realEstatePropertyModel = await prisma.realEstatePropertyModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RealEstatePropertyModelCreateManyArgs>(
      args?: SelectSubset<T, RealEstatePropertyModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RealEstatePropertyModel.
     * @param {RealEstatePropertyModelDeleteArgs} args - Arguments to delete one RealEstatePropertyModel.
     * @example
     * // Delete one RealEstatePropertyModel
     * const RealEstatePropertyModel = await prisma.realEstatePropertyModel.delete({
     *   where: {
     *     // ... filter to delete one RealEstatePropertyModel
     *   }
     * })
     * 
    **/
    delete<T extends RealEstatePropertyModelDeleteArgs>(
      args: SelectSubset<T, RealEstatePropertyModelDeleteArgs>
    ): Prisma__RealEstatePropertyModelClient<RealEstatePropertyModelGetPayload<T>>

    /**
     * Update one RealEstatePropertyModel.
     * @param {RealEstatePropertyModelUpdateArgs} args - Arguments to update one RealEstatePropertyModel.
     * @example
     * // Update one RealEstatePropertyModel
     * const realEstatePropertyModel = await prisma.realEstatePropertyModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RealEstatePropertyModelUpdateArgs>(
      args: SelectSubset<T, RealEstatePropertyModelUpdateArgs>
    ): Prisma__RealEstatePropertyModelClient<RealEstatePropertyModelGetPayload<T>>

    /**
     * Delete zero or more RealEstatePropertyModels.
     * @param {RealEstatePropertyModelDeleteManyArgs} args - Arguments to filter RealEstatePropertyModels to delete.
     * @example
     * // Delete a few RealEstatePropertyModels
     * const { count } = await prisma.realEstatePropertyModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RealEstatePropertyModelDeleteManyArgs>(
      args?: SelectSubset<T, RealEstatePropertyModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RealEstatePropertyModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstatePropertyModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RealEstatePropertyModels
     * const realEstatePropertyModel = await prisma.realEstatePropertyModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RealEstatePropertyModelUpdateManyArgs>(
      args: SelectSubset<T, RealEstatePropertyModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RealEstatePropertyModel.
     * @param {RealEstatePropertyModelUpsertArgs} args - Arguments to update or create a RealEstatePropertyModel.
     * @example
     * // Update or create a RealEstatePropertyModel
     * const realEstatePropertyModel = await prisma.realEstatePropertyModel.upsert({
     *   create: {
     *     // ... data to create a RealEstatePropertyModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RealEstatePropertyModel we want to update
     *   }
     * })
    **/
    upsert<T extends RealEstatePropertyModelUpsertArgs>(
      args: SelectSubset<T, RealEstatePropertyModelUpsertArgs>
    ): Prisma__RealEstatePropertyModelClient<RealEstatePropertyModelGetPayload<T>>

    /**
     * Count the number of RealEstatePropertyModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstatePropertyModelCountArgs} args - Arguments to filter RealEstatePropertyModels to count.
     * @example
     * // Count the number of RealEstatePropertyModels
     * const count = await prisma.realEstatePropertyModel.count({
     *   where: {
     *     // ... the filter for the RealEstatePropertyModels we want to count
     *   }
     * })
    **/
    count<T extends RealEstatePropertyModelCountArgs>(
      args?: Subset<T, RealEstatePropertyModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RealEstatePropertyModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RealEstatePropertyModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstatePropertyModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RealEstatePropertyModelAggregateArgs>(args: Subset<T, RealEstatePropertyModelAggregateArgs>): Prisma.PrismaPromise<GetRealEstatePropertyModelAggregateType<T>>

    /**
     * Group by RealEstatePropertyModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstatePropertyModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RealEstatePropertyModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RealEstatePropertyModelGroupByArgs['orderBy'] }
        : { orderBy?: RealEstatePropertyModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RealEstatePropertyModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRealEstatePropertyModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RealEstatePropertyModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RealEstatePropertyModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    agent<T extends RealEstateAgentModelArgs= {}>(args?: Subset<T, RealEstateAgentModelArgs>): Prisma__RealEstateAgentModelClient<RealEstateAgentModelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RealEstatePropertyModel base type for findUnique actions
   */
  export type RealEstatePropertyModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RealEstatePropertyModel
     */
    select?: RealEstatePropertyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstatePropertyModelInclude | null
    /**
     * Filter, which RealEstatePropertyModel to fetch.
     */
    where: RealEstatePropertyModelWhereUniqueInput
  }

  /**
   * RealEstatePropertyModel findUnique
   */
  export interface RealEstatePropertyModelFindUniqueArgs extends RealEstatePropertyModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RealEstatePropertyModel findUniqueOrThrow
   */
  export type RealEstatePropertyModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RealEstatePropertyModel
     */
    select?: RealEstatePropertyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstatePropertyModelInclude | null
    /**
     * Filter, which RealEstatePropertyModel to fetch.
     */
    where: RealEstatePropertyModelWhereUniqueInput
  }


  /**
   * RealEstatePropertyModel base type for findFirst actions
   */
  export type RealEstatePropertyModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RealEstatePropertyModel
     */
    select?: RealEstatePropertyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstatePropertyModelInclude | null
    /**
     * Filter, which RealEstatePropertyModel to fetch.
     */
    where?: RealEstatePropertyModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstatePropertyModels to fetch.
     */
    orderBy?: Enumerable<RealEstatePropertyModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RealEstatePropertyModels.
     */
    cursor?: RealEstatePropertyModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstatePropertyModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstatePropertyModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RealEstatePropertyModels.
     */
    distinct?: Enumerable<RealEstatePropertyModelScalarFieldEnum>
  }

  /**
   * RealEstatePropertyModel findFirst
   */
  export interface RealEstatePropertyModelFindFirstArgs extends RealEstatePropertyModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RealEstatePropertyModel findFirstOrThrow
   */
  export type RealEstatePropertyModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RealEstatePropertyModel
     */
    select?: RealEstatePropertyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstatePropertyModelInclude | null
    /**
     * Filter, which RealEstatePropertyModel to fetch.
     */
    where?: RealEstatePropertyModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstatePropertyModels to fetch.
     */
    orderBy?: Enumerable<RealEstatePropertyModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RealEstatePropertyModels.
     */
    cursor?: RealEstatePropertyModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstatePropertyModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstatePropertyModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RealEstatePropertyModels.
     */
    distinct?: Enumerable<RealEstatePropertyModelScalarFieldEnum>
  }


  /**
   * RealEstatePropertyModel findMany
   */
  export type RealEstatePropertyModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the RealEstatePropertyModel
     */
    select?: RealEstatePropertyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstatePropertyModelInclude | null
    /**
     * Filter, which RealEstatePropertyModels to fetch.
     */
    where?: RealEstatePropertyModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstatePropertyModels to fetch.
     */
    orderBy?: Enumerable<RealEstatePropertyModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RealEstatePropertyModels.
     */
    cursor?: RealEstatePropertyModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstatePropertyModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstatePropertyModels.
     */
    skip?: number
    distinct?: Enumerable<RealEstatePropertyModelScalarFieldEnum>
  }


  /**
   * RealEstatePropertyModel create
   */
  export type RealEstatePropertyModelCreateArgs = {
    /**
     * Select specific fields to fetch from the RealEstatePropertyModel
     */
    select?: RealEstatePropertyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstatePropertyModelInclude | null
    /**
     * The data needed to create a RealEstatePropertyModel.
     */
    data: XOR<RealEstatePropertyModelCreateInput, RealEstatePropertyModelUncheckedCreateInput>
  }


  /**
   * RealEstatePropertyModel createMany
   */
  export type RealEstatePropertyModelCreateManyArgs = {
    /**
     * The data used to create many RealEstatePropertyModels.
     */
    data: Enumerable<RealEstatePropertyModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RealEstatePropertyModel update
   */
  export type RealEstatePropertyModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the RealEstatePropertyModel
     */
    select?: RealEstatePropertyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstatePropertyModelInclude | null
    /**
     * The data needed to update a RealEstatePropertyModel.
     */
    data: XOR<RealEstatePropertyModelUpdateInput, RealEstatePropertyModelUncheckedUpdateInput>
    /**
     * Choose, which RealEstatePropertyModel to update.
     */
    where: RealEstatePropertyModelWhereUniqueInput
  }


  /**
   * RealEstatePropertyModel updateMany
   */
  export type RealEstatePropertyModelUpdateManyArgs = {
    /**
     * The data used to update RealEstatePropertyModels.
     */
    data: XOR<RealEstatePropertyModelUpdateManyMutationInput, RealEstatePropertyModelUncheckedUpdateManyInput>
    /**
     * Filter which RealEstatePropertyModels to update
     */
    where?: RealEstatePropertyModelWhereInput
  }


  /**
   * RealEstatePropertyModel upsert
   */
  export type RealEstatePropertyModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the RealEstatePropertyModel
     */
    select?: RealEstatePropertyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstatePropertyModelInclude | null
    /**
     * The filter to search for the RealEstatePropertyModel to update in case it exists.
     */
    where: RealEstatePropertyModelWhereUniqueInput
    /**
     * In case the RealEstatePropertyModel found by the `where` argument doesn't exist, create a new RealEstatePropertyModel with this data.
     */
    create: XOR<RealEstatePropertyModelCreateInput, RealEstatePropertyModelUncheckedCreateInput>
    /**
     * In case the RealEstatePropertyModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RealEstatePropertyModelUpdateInput, RealEstatePropertyModelUncheckedUpdateInput>
  }


  /**
   * RealEstatePropertyModel delete
   */
  export type RealEstatePropertyModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the RealEstatePropertyModel
     */
    select?: RealEstatePropertyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstatePropertyModelInclude | null
    /**
     * Filter which RealEstatePropertyModel to delete.
     */
    where: RealEstatePropertyModelWhereUniqueInput
  }


  /**
   * RealEstatePropertyModel deleteMany
   */
  export type RealEstatePropertyModelDeleteManyArgs = {
    /**
     * Filter which RealEstatePropertyModels to delete
     */
    where?: RealEstatePropertyModelWhereInput
  }


  /**
   * RealEstatePropertyModel without action
   */
  export type RealEstatePropertyModelArgs = {
    /**
     * Select specific fields to fetch from the RealEstatePropertyModel
     */
    select?: RealEstatePropertyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstatePropertyModelInclude | null
  }



  /**
   * Model HomeCareSpecializedSuperFieldModel
   */


  export type AggregateHomeCareSpecializedSuperFieldModel = {
    _count: HomeCareSpecializedSuperFieldModelCountAggregateOutputType | null
    _min: HomeCareSpecializedSuperFieldModelMinAggregateOutputType | null
    _max: HomeCareSpecializedSuperFieldModelMaxAggregateOutputType | null
  }

  export type HomeCareSpecializedSuperFieldModelMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type HomeCareSpecializedSuperFieldModelMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type HomeCareSpecializedSuperFieldModelCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type HomeCareSpecializedSuperFieldModelMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type HomeCareSpecializedSuperFieldModelMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type HomeCareSpecializedSuperFieldModelCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type HomeCareSpecializedSuperFieldModelAggregateArgs = {
    /**
     * Filter which HomeCareSpecializedSuperFieldModel to aggregate.
     */
    where?: HomeCareSpecializedSuperFieldModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeCareSpecializedSuperFieldModels to fetch.
     */
    orderBy?: Enumerable<HomeCareSpecializedSuperFieldModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HomeCareSpecializedSuperFieldModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeCareSpecializedSuperFieldModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeCareSpecializedSuperFieldModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HomeCareSpecializedSuperFieldModels
    **/
    _count?: true | HomeCareSpecializedSuperFieldModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HomeCareSpecializedSuperFieldModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HomeCareSpecializedSuperFieldModelMaxAggregateInputType
  }

  export type GetHomeCareSpecializedSuperFieldModelAggregateType<T extends HomeCareSpecializedSuperFieldModelAggregateArgs> = {
        [P in keyof T & keyof AggregateHomeCareSpecializedSuperFieldModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHomeCareSpecializedSuperFieldModel[P]>
      : GetScalarType<T[P], AggregateHomeCareSpecializedSuperFieldModel[P]>
  }




  export type HomeCareSpecializedSuperFieldModelGroupByArgs = {
    where?: HomeCareSpecializedSuperFieldModelWhereInput
    orderBy?: Enumerable<HomeCareSpecializedSuperFieldModelOrderByWithAggregationInput>
    by: HomeCareSpecializedSuperFieldModelScalarFieldEnum[]
    having?: HomeCareSpecializedSuperFieldModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HomeCareSpecializedSuperFieldModelCountAggregateInputType | true
    _min?: HomeCareSpecializedSuperFieldModelMinAggregateInputType
    _max?: HomeCareSpecializedSuperFieldModelMaxAggregateInputType
  }


  export type HomeCareSpecializedSuperFieldModelGroupByOutputType = {
    id: string
    name: string
    _count: HomeCareSpecializedSuperFieldModelCountAggregateOutputType | null
    _min: HomeCareSpecializedSuperFieldModelMinAggregateOutputType | null
    _max: HomeCareSpecializedSuperFieldModelMaxAggregateOutputType | null
  }

  type GetHomeCareSpecializedSuperFieldModelGroupByPayload<T extends HomeCareSpecializedSuperFieldModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HomeCareSpecializedSuperFieldModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HomeCareSpecializedSuperFieldModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HomeCareSpecializedSuperFieldModelGroupByOutputType[P]>
            : GetScalarType<T[P], HomeCareSpecializedSuperFieldModelGroupByOutputType[P]>
        }
      >
    >


  export type HomeCareSpecializedSuperFieldModelSelect = {
    id?: boolean
    name?: boolean
    sub?: boolean | HomeCareSpecializedSuperFieldModel$subArgs
    _count?: boolean | HomeCareSpecializedSuperFieldModelCountOutputTypeArgs
  }


  export type HomeCareSpecializedSuperFieldModelInclude = {
    sub?: boolean | HomeCareSpecializedSuperFieldModel$subArgs
    _count?: boolean | HomeCareSpecializedSuperFieldModelCountOutputTypeArgs
  }

  export type HomeCareSpecializedSuperFieldModelGetPayload<S extends boolean | null | undefined | HomeCareSpecializedSuperFieldModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HomeCareSpecializedSuperFieldModel :
    S extends undefined ? never :
    S extends { include: any } & (HomeCareSpecializedSuperFieldModelArgs | HomeCareSpecializedSuperFieldModelFindManyArgs)
    ? HomeCareSpecializedSuperFieldModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'sub' ? Array < HomeCareSpecializedSubFieldModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? HomeCareSpecializedSuperFieldModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (HomeCareSpecializedSuperFieldModelArgs | HomeCareSpecializedSuperFieldModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'sub' ? Array < HomeCareSpecializedSubFieldModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? HomeCareSpecializedSuperFieldModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof HomeCareSpecializedSuperFieldModel ? HomeCareSpecializedSuperFieldModel[P] : never
  } 
      : HomeCareSpecializedSuperFieldModel


  type HomeCareSpecializedSuperFieldModelCountArgs = 
    Omit<HomeCareSpecializedSuperFieldModelFindManyArgs, 'select' | 'include'> & {
      select?: HomeCareSpecializedSuperFieldModelCountAggregateInputType | true
    }

  export interface HomeCareSpecializedSuperFieldModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one HomeCareSpecializedSuperFieldModel that matches the filter.
     * @param {HomeCareSpecializedSuperFieldModelFindUniqueArgs} args - Arguments to find a HomeCareSpecializedSuperFieldModel
     * @example
     * // Get one HomeCareSpecializedSuperFieldModel
     * const homeCareSpecializedSuperFieldModel = await prisma.homeCareSpecializedSuperFieldModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HomeCareSpecializedSuperFieldModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HomeCareSpecializedSuperFieldModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'HomeCareSpecializedSuperFieldModel'> extends True ? Prisma__HomeCareSpecializedSuperFieldModelClient<HomeCareSpecializedSuperFieldModelGetPayload<T>> : Prisma__HomeCareSpecializedSuperFieldModelClient<HomeCareSpecializedSuperFieldModelGetPayload<T> | null, null>

    /**
     * Find one HomeCareSpecializedSuperFieldModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HomeCareSpecializedSuperFieldModelFindUniqueOrThrowArgs} args - Arguments to find a HomeCareSpecializedSuperFieldModel
     * @example
     * // Get one HomeCareSpecializedSuperFieldModel
     * const homeCareSpecializedSuperFieldModel = await prisma.homeCareSpecializedSuperFieldModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HomeCareSpecializedSuperFieldModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, HomeCareSpecializedSuperFieldModelFindUniqueOrThrowArgs>
    ): Prisma__HomeCareSpecializedSuperFieldModelClient<HomeCareSpecializedSuperFieldModelGetPayload<T>>

    /**
     * Find the first HomeCareSpecializedSuperFieldModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareSpecializedSuperFieldModelFindFirstArgs} args - Arguments to find a HomeCareSpecializedSuperFieldModel
     * @example
     * // Get one HomeCareSpecializedSuperFieldModel
     * const homeCareSpecializedSuperFieldModel = await prisma.homeCareSpecializedSuperFieldModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HomeCareSpecializedSuperFieldModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HomeCareSpecializedSuperFieldModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'HomeCareSpecializedSuperFieldModel'> extends True ? Prisma__HomeCareSpecializedSuperFieldModelClient<HomeCareSpecializedSuperFieldModelGetPayload<T>> : Prisma__HomeCareSpecializedSuperFieldModelClient<HomeCareSpecializedSuperFieldModelGetPayload<T> | null, null>

    /**
     * Find the first HomeCareSpecializedSuperFieldModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareSpecializedSuperFieldModelFindFirstOrThrowArgs} args - Arguments to find a HomeCareSpecializedSuperFieldModel
     * @example
     * // Get one HomeCareSpecializedSuperFieldModel
     * const homeCareSpecializedSuperFieldModel = await prisma.homeCareSpecializedSuperFieldModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HomeCareSpecializedSuperFieldModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HomeCareSpecializedSuperFieldModelFindFirstOrThrowArgs>
    ): Prisma__HomeCareSpecializedSuperFieldModelClient<HomeCareSpecializedSuperFieldModelGetPayload<T>>

    /**
     * Find zero or more HomeCareSpecializedSuperFieldModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareSpecializedSuperFieldModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HomeCareSpecializedSuperFieldModels
     * const homeCareSpecializedSuperFieldModels = await prisma.homeCareSpecializedSuperFieldModel.findMany()
     * 
     * // Get first 10 HomeCareSpecializedSuperFieldModels
     * const homeCareSpecializedSuperFieldModels = await prisma.homeCareSpecializedSuperFieldModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const homeCareSpecializedSuperFieldModelWithIdOnly = await prisma.homeCareSpecializedSuperFieldModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HomeCareSpecializedSuperFieldModelFindManyArgs>(
      args?: SelectSubset<T, HomeCareSpecializedSuperFieldModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<HomeCareSpecializedSuperFieldModelGetPayload<T>>>

    /**
     * Create a HomeCareSpecializedSuperFieldModel.
     * @param {HomeCareSpecializedSuperFieldModelCreateArgs} args - Arguments to create a HomeCareSpecializedSuperFieldModel.
     * @example
     * // Create one HomeCareSpecializedSuperFieldModel
     * const HomeCareSpecializedSuperFieldModel = await prisma.homeCareSpecializedSuperFieldModel.create({
     *   data: {
     *     // ... data to create a HomeCareSpecializedSuperFieldModel
     *   }
     * })
     * 
    **/
    create<T extends HomeCareSpecializedSuperFieldModelCreateArgs>(
      args: SelectSubset<T, HomeCareSpecializedSuperFieldModelCreateArgs>
    ): Prisma__HomeCareSpecializedSuperFieldModelClient<HomeCareSpecializedSuperFieldModelGetPayload<T>>

    /**
     * Create many HomeCareSpecializedSuperFieldModels.
     *     @param {HomeCareSpecializedSuperFieldModelCreateManyArgs} args - Arguments to create many HomeCareSpecializedSuperFieldModels.
     *     @example
     *     // Create many HomeCareSpecializedSuperFieldModels
     *     const homeCareSpecializedSuperFieldModel = await prisma.homeCareSpecializedSuperFieldModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HomeCareSpecializedSuperFieldModelCreateManyArgs>(
      args?: SelectSubset<T, HomeCareSpecializedSuperFieldModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HomeCareSpecializedSuperFieldModel.
     * @param {HomeCareSpecializedSuperFieldModelDeleteArgs} args - Arguments to delete one HomeCareSpecializedSuperFieldModel.
     * @example
     * // Delete one HomeCareSpecializedSuperFieldModel
     * const HomeCareSpecializedSuperFieldModel = await prisma.homeCareSpecializedSuperFieldModel.delete({
     *   where: {
     *     // ... filter to delete one HomeCareSpecializedSuperFieldModel
     *   }
     * })
     * 
    **/
    delete<T extends HomeCareSpecializedSuperFieldModelDeleteArgs>(
      args: SelectSubset<T, HomeCareSpecializedSuperFieldModelDeleteArgs>
    ): Prisma__HomeCareSpecializedSuperFieldModelClient<HomeCareSpecializedSuperFieldModelGetPayload<T>>

    /**
     * Update one HomeCareSpecializedSuperFieldModel.
     * @param {HomeCareSpecializedSuperFieldModelUpdateArgs} args - Arguments to update one HomeCareSpecializedSuperFieldModel.
     * @example
     * // Update one HomeCareSpecializedSuperFieldModel
     * const homeCareSpecializedSuperFieldModel = await prisma.homeCareSpecializedSuperFieldModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HomeCareSpecializedSuperFieldModelUpdateArgs>(
      args: SelectSubset<T, HomeCareSpecializedSuperFieldModelUpdateArgs>
    ): Prisma__HomeCareSpecializedSuperFieldModelClient<HomeCareSpecializedSuperFieldModelGetPayload<T>>

    /**
     * Delete zero or more HomeCareSpecializedSuperFieldModels.
     * @param {HomeCareSpecializedSuperFieldModelDeleteManyArgs} args - Arguments to filter HomeCareSpecializedSuperFieldModels to delete.
     * @example
     * // Delete a few HomeCareSpecializedSuperFieldModels
     * const { count } = await prisma.homeCareSpecializedSuperFieldModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HomeCareSpecializedSuperFieldModelDeleteManyArgs>(
      args?: SelectSubset<T, HomeCareSpecializedSuperFieldModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HomeCareSpecializedSuperFieldModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareSpecializedSuperFieldModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HomeCareSpecializedSuperFieldModels
     * const homeCareSpecializedSuperFieldModel = await prisma.homeCareSpecializedSuperFieldModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HomeCareSpecializedSuperFieldModelUpdateManyArgs>(
      args: SelectSubset<T, HomeCareSpecializedSuperFieldModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HomeCareSpecializedSuperFieldModel.
     * @param {HomeCareSpecializedSuperFieldModelUpsertArgs} args - Arguments to update or create a HomeCareSpecializedSuperFieldModel.
     * @example
     * // Update or create a HomeCareSpecializedSuperFieldModel
     * const homeCareSpecializedSuperFieldModel = await prisma.homeCareSpecializedSuperFieldModel.upsert({
     *   create: {
     *     // ... data to create a HomeCareSpecializedSuperFieldModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HomeCareSpecializedSuperFieldModel we want to update
     *   }
     * })
    **/
    upsert<T extends HomeCareSpecializedSuperFieldModelUpsertArgs>(
      args: SelectSubset<T, HomeCareSpecializedSuperFieldModelUpsertArgs>
    ): Prisma__HomeCareSpecializedSuperFieldModelClient<HomeCareSpecializedSuperFieldModelGetPayload<T>>

    /**
     * Count the number of HomeCareSpecializedSuperFieldModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareSpecializedSuperFieldModelCountArgs} args - Arguments to filter HomeCareSpecializedSuperFieldModels to count.
     * @example
     * // Count the number of HomeCareSpecializedSuperFieldModels
     * const count = await prisma.homeCareSpecializedSuperFieldModel.count({
     *   where: {
     *     // ... the filter for the HomeCareSpecializedSuperFieldModels we want to count
     *   }
     * })
    **/
    count<T extends HomeCareSpecializedSuperFieldModelCountArgs>(
      args?: Subset<T, HomeCareSpecializedSuperFieldModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HomeCareSpecializedSuperFieldModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HomeCareSpecializedSuperFieldModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareSpecializedSuperFieldModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HomeCareSpecializedSuperFieldModelAggregateArgs>(args: Subset<T, HomeCareSpecializedSuperFieldModelAggregateArgs>): Prisma.PrismaPromise<GetHomeCareSpecializedSuperFieldModelAggregateType<T>>

    /**
     * Group by HomeCareSpecializedSuperFieldModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareSpecializedSuperFieldModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HomeCareSpecializedSuperFieldModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HomeCareSpecializedSuperFieldModelGroupByArgs['orderBy'] }
        : { orderBy?: HomeCareSpecializedSuperFieldModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HomeCareSpecializedSuperFieldModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHomeCareSpecializedSuperFieldModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for HomeCareSpecializedSuperFieldModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HomeCareSpecializedSuperFieldModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    sub<T extends HomeCareSpecializedSuperFieldModel$subArgs= {}>(args?: Subset<T, HomeCareSpecializedSuperFieldModel$subArgs>): Prisma.PrismaPromise<Array<HomeCareSpecializedSubFieldModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * HomeCareSpecializedSuperFieldModel base type for findUnique actions
   */
  export type HomeCareSpecializedSuperFieldModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the HomeCareSpecializedSuperFieldModel
     */
    select?: HomeCareSpecializedSuperFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareSpecializedSuperFieldModelInclude | null
    /**
     * Filter, which HomeCareSpecializedSuperFieldModel to fetch.
     */
    where: HomeCareSpecializedSuperFieldModelWhereUniqueInput
  }

  /**
   * HomeCareSpecializedSuperFieldModel findUnique
   */
  export interface HomeCareSpecializedSuperFieldModelFindUniqueArgs extends HomeCareSpecializedSuperFieldModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HomeCareSpecializedSuperFieldModel findUniqueOrThrow
   */
  export type HomeCareSpecializedSuperFieldModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HomeCareSpecializedSuperFieldModel
     */
    select?: HomeCareSpecializedSuperFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareSpecializedSuperFieldModelInclude | null
    /**
     * Filter, which HomeCareSpecializedSuperFieldModel to fetch.
     */
    where: HomeCareSpecializedSuperFieldModelWhereUniqueInput
  }


  /**
   * HomeCareSpecializedSuperFieldModel base type for findFirst actions
   */
  export type HomeCareSpecializedSuperFieldModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the HomeCareSpecializedSuperFieldModel
     */
    select?: HomeCareSpecializedSuperFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareSpecializedSuperFieldModelInclude | null
    /**
     * Filter, which HomeCareSpecializedSuperFieldModel to fetch.
     */
    where?: HomeCareSpecializedSuperFieldModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeCareSpecializedSuperFieldModels to fetch.
     */
    orderBy?: Enumerable<HomeCareSpecializedSuperFieldModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomeCareSpecializedSuperFieldModels.
     */
    cursor?: HomeCareSpecializedSuperFieldModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeCareSpecializedSuperFieldModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeCareSpecializedSuperFieldModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomeCareSpecializedSuperFieldModels.
     */
    distinct?: Enumerable<HomeCareSpecializedSuperFieldModelScalarFieldEnum>
  }

  /**
   * HomeCareSpecializedSuperFieldModel findFirst
   */
  export interface HomeCareSpecializedSuperFieldModelFindFirstArgs extends HomeCareSpecializedSuperFieldModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HomeCareSpecializedSuperFieldModel findFirstOrThrow
   */
  export type HomeCareSpecializedSuperFieldModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HomeCareSpecializedSuperFieldModel
     */
    select?: HomeCareSpecializedSuperFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareSpecializedSuperFieldModelInclude | null
    /**
     * Filter, which HomeCareSpecializedSuperFieldModel to fetch.
     */
    where?: HomeCareSpecializedSuperFieldModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeCareSpecializedSuperFieldModels to fetch.
     */
    orderBy?: Enumerable<HomeCareSpecializedSuperFieldModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomeCareSpecializedSuperFieldModels.
     */
    cursor?: HomeCareSpecializedSuperFieldModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeCareSpecializedSuperFieldModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeCareSpecializedSuperFieldModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomeCareSpecializedSuperFieldModels.
     */
    distinct?: Enumerable<HomeCareSpecializedSuperFieldModelScalarFieldEnum>
  }


  /**
   * HomeCareSpecializedSuperFieldModel findMany
   */
  export type HomeCareSpecializedSuperFieldModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the HomeCareSpecializedSuperFieldModel
     */
    select?: HomeCareSpecializedSuperFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareSpecializedSuperFieldModelInclude | null
    /**
     * Filter, which HomeCareSpecializedSuperFieldModels to fetch.
     */
    where?: HomeCareSpecializedSuperFieldModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeCareSpecializedSuperFieldModels to fetch.
     */
    orderBy?: Enumerable<HomeCareSpecializedSuperFieldModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HomeCareSpecializedSuperFieldModels.
     */
    cursor?: HomeCareSpecializedSuperFieldModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeCareSpecializedSuperFieldModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeCareSpecializedSuperFieldModels.
     */
    skip?: number
    distinct?: Enumerable<HomeCareSpecializedSuperFieldModelScalarFieldEnum>
  }


  /**
   * HomeCareSpecializedSuperFieldModel create
   */
  export type HomeCareSpecializedSuperFieldModelCreateArgs = {
    /**
     * Select specific fields to fetch from the HomeCareSpecializedSuperFieldModel
     */
    select?: HomeCareSpecializedSuperFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareSpecializedSuperFieldModelInclude | null
    /**
     * The data needed to create a HomeCareSpecializedSuperFieldModel.
     */
    data: XOR<HomeCareSpecializedSuperFieldModelCreateInput, HomeCareSpecializedSuperFieldModelUncheckedCreateInput>
  }


  /**
   * HomeCareSpecializedSuperFieldModel createMany
   */
  export type HomeCareSpecializedSuperFieldModelCreateManyArgs = {
    /**
     * The data used to create many HomeCareSpecializedSuperFieldModels.
     */
    data: Enumerable<HomeCareSpecializedSuperFieldModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * HomeCareSpecializedSuperFieldModel update
   */
  export type HomeCareSpecializedSuperFieldModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the HomeCareSpecializedSuperFieldModel
     */
    select?: HomeCareSpecializedSuperFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareSpecializedSuperFieldModelInclude | null
    /**
     * The data needed to update a HomeCareSpecializedSuperFieldModel.
     */
    data: XOR<HomeCareSpecializedSuperFieldModelUpdateInput, HomeCareSpecializedSuperFieldModelUncheckedUpdateInput>
    /**
     * Choose, which HomeCareSpecializedSuperFieldModel to update.
     */
    where: HomeCareSpecializedSuperFieldModelWhereUniqueInput
  }


  /**
   * HomeCareSpecializedSuperFieldModel updateMany
   */
  export type HomeCareSpecializedSuperFieldModelUpdateManyArgs = {
    /**
     * The data used to update HomeCareSpecializedSuperFieldModels.
     */
    data: XOR<HomeCareSpecializedSuperFieldModelUpdateManyMutationInput, HomeCareSpecializedSuperFieldModelUncheckedUpdateManyInput>
    /**
     * Filter which HomeCareSpecializedSuperFieldModels to update
     */
    where?: HomeCareSpecializedSuperFieldModelWhereInput
  }


  /**
   * HomeCareSpecializedSuperFieldModel upsert
   */
  export type HomeCareSpecializedSuperFieldModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the HomeCareSpecializedSuperFieldModel
     */
    select?: HomeCareSpecializedSuperFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareSpecializedSuperFieldModelInclude | null
    /**
     * The filter to search for the HomeCareSpecializedSuperFieldModel to update in case it exists.
     */
    where: HomeCareSpecializedSuperFieldModelWhereUniqueInput
    /**
     * In case the HomeCareSpecializedSuperFieldModel found by the `where` argument doesn't exist, create a new HomeCareSpecializedSuperFieldModel with this data.
     */
    create: XOR<HomeCareSpecializedSuperFieldModelCreateInput, HomeCareSpecializedSuperFieldModelUncheckedCreateInput>
    /**
     * In case the HomeCareSpecializedSuperFieldModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HomeCareSpecializedSuperFieldModelUpdateInput, HomeCareSpecializedSuperFieldModelUncheckedUpdateInput>
  }


  /**
   * HomeCareSpecializedSuperFieldModel delete
   */
  export type HomeCareSpecializedSuperFieldModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the HomeCareSpecializedSuperFieldModel
     */
    select?: HomeCareSpecializedSuperFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareSpecializedSuperFieldModelInclude | null
    /**
     * Filter which HomeCareSpecializedSuperFieldModel to delete.
     */
    where: HomeCareSpecializedSuperFieldModelWhereUniqueInput
  }


  /**
   * HomeCareSpecializedSuperFieldModel deleteMany
   */
  export type HomeCareSpecializedSuperFieldModelDeleteManyArgs = {
    /**
     * Filter which HomeCareSpecializedSuperFieldModels to delete
     */
    where?: HomeCareSpecializedSuperFieldModelWhereInput
  }


  /**
   * HomeCareSpecializedSuperFieldModel.sub
   */
  export type HomeCareSpecializedSuperFieldModel$subArgs = {
    /**
     * Select specific fields to fetch from the HomeCareSpecializedSubFieldModel
     */
    select?: HomeCareSpecializedSubFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareSpecializedSubFieldModelInclude | null
    where?: HomeCareSpecializedSubFieldModelWhereInput
    orderBy?: Enumerable<HomeCareSpecializedSubFieldModelOrderByWithRelationInput>
    cursor?: HomeCareSpecializedSubFieldModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HomeCareSpecializedSubFieldModelScalarFieldEnum>
  }


  /**
   * HomeCareSpecializedSuperFieldModel without action
   */
  export type HomeCareSpecializedSuperFieldModelArgs = {
    /**
     * Select specific fields to fetch from the HomeCareSpecializedSuperFieldModel
     */
    select?: HomeCareSpecializedSuperFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareSpecializedSuperFieldModelInclude | null
  }



  /**
   * Model HomeCareSpecializedSubFieldModel
   */


  export type AggregateHomeCareSpecializedSubFieldModel = {
    _count: HomeCareSpecializedSubFieldModelCountAggregateOutputType | null
    _min: HomeCareSpecializedSubFieldModelMinAggregateOutputType | null
    _max: HomeCareSpecializedSubFieldModelMaxAggregateOutputType | null
  }

  export type HomeCareSpecializedSubFieldModelMinAggregateOutputType = {
    id: string | null
    name: string | null
    super_id: string | null
  }

  export type HomeCareSpecializedSubFieldModelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    super_id: string | null
  }

  export type HomeCareSpecializedSubFieldModelCountAggregateOutputType = {
    id: number
    name: number
    super_id: number
    _all: number
  }


  export type HomeCareSpecializedSubFieldModelMinAggregateInputType = {
    id?: true
    name?: true
    super_id?: true
  }

  export type HomeCareSpecializedSubFieldModelMaxAggregateInputType = {
    id?: true
    name?: true
    super_id?: true
  }

  export type HomeCareSpecializedSubFieldModelCountAggregateInputType = {
    id?: true
    name?: true
    super_id?: true
    _all?: true
  }

  export type HomeCareSpecializedSubFieldModelAggregateArgs = {
    /**
     * Filter which HomeCareSpecializedSubFieldModel to aggregate.
     */
    where?: HomeCareSpecializedSubFieldModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeCareSpecializedSubFieldModels to fetch.
     */
    orderBy?: Enumerable<HomeCareSpecializedSubFieldModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HomeCareSpecializedSubFieldModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeCareSpecializedSubFieldModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeCareSpecializedSubFieldModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HomeCareSpecializedSubFieldModels
    **/
    _count?: true | HomeCareSpecializedSubFieldModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HomeCareSpecializedSubFieldModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HomeCareSpecializedSubFieldModelMaxAggregateInputType
  }

  export type GetHomeCareSpecializedSubFieldModelAggregateType<T extends HomeCareSpecializedSubFieldModelAggregateArgs> = {
        [P in keyof T & keyof AggregateHomeCareSpecializedSubFieldModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHomeCareSpecializedSubFieldModel[P]>
      : GetScalarType<T[P], AggregateHomeCareSpecializedSubFieldModel[P]>
  }




  export type HomeCareSpecializedSubFieldModelGroupByArgs = {
    where?: HomeCareSpecializedSubFieldModelWhereInput
    orderBy?: Enumerable<HomeCareSpecializedSubFieldModelOrderByWithAggregationInput>
    by: HomeCareSpecializedSubFieldModelScalarFieldEnum[]
    having?: HomeCareSpecializedSubFieldModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HomeCareSpecializedSubFieldModelCountAggregateInputType | true
    _min?: HomeCareSpecializedSubFieldModelMinAggregateInputType
    _max?: HomeCareSpecializedSubFieldModelMaxAggregateInputType
  }


  export type HomeCareSpecializedSubFieldModelGroupByOutputType = {
    id: string
    name: string
    super_id: string
    _count: HomeCareSpecializedSubFieldModelCountAggregateOutputType | null
    _min: HomeCareSpecializedSubFieldModelMinAggregateOutputType | null
    _max: HomeCareSpecializedSubFieldModelMaxAggregateOutputType | null
  }

  type GetHomeCareSpecializedSubFieldModelGroupByPayload<T extends HomeCareSpecializedSubFieldModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HomeCareSpecializedSubFieldModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HomeCareSpecializedSubFieldModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HomeCareSpecializedSubFieldModelGroupByOutputType[P]>
            : GetScalarType<T[P], HomeCareSpecializedSubFieldModelGroupByOutputType[P]>
        }
      >
    >


  export type HomeCareSpecializedSubFieldModelSelect = {
    id?: boolean
    name?: boolean
    super_id?: boolean
    super?: boolean | HomeCareSpecializedSuperFieldModelArgs
    home_care_companies?: boolean | HomeCareSpecializedSubFieldModel$home_care_companiesArgs
    _count?: boolean | HomeCareSpecializedSubFieldModelCountOutputTypeArgs
  }


  export type HomeCareSpecializedSubFieldModelInclude = {
    super?: boolean | HomeCareSpecializedSuperFieldModelArgs
    home_care_companies?: boolean | HomeCareSpecializedSubFieldModel$home_care_companiesArgs
    _count?: boolean | HomeCareSpecializedSubFieldModelCountOutputTypeArgs
  }

  export type HomeCareSpecializedSubFieldModelGetPayload<S extends boolean | null | undefined | HomeCareSpecializedSubFieldModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HomeCareSpecializedSubFieldModel :
    S extends undefined ? never :
    S extends { include: any } & (HomeCareSpecializedSubFieldModelArgs | HomeCareSpecializedSubFieldModelFindManyArgs)
    ? HomeCareSpecializedSubFieldModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'super' ? HomeCareSpecializedSuperFieldModelGetPayload<S['include'][P]> :
        P extends 'home_care_companies' ? Array < HomeCareCompanyModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? HomeCareSpecializedSubFieldModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (HomeCareSpecializedSubFieldModelArgs | HomeCareSpecializedSubFieldModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'super' ? HomeCareSpecializedSuperFieldModelGetPayload<S['select'][P]> :
        P extends 'home_care_companies' ? Array < HomeCareCompanyModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? HomeCareSpecializedSubFieldModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof HomeCareSpecializedSubFieldModel ? HomeCareSpecializedSubFieldModel[P] : never
  } 
      : HomeCareSpecializedSubFieldModel


  type HomeCareSpecializedSubFieldModelCountArgs = 
    Omit<HomeCareSpecializedSubFieldModelFindManyArgs, 'select' | 'include'> & {
      select?: HomeCareSpecializedSubFieldModelCountAggregateInputType | true
    }

  export interface HomeCareSpecializedSubFieldModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one HomeCareSpecializedSubFieldModel that matches the filter.
     * @param {HomeCareSpecializedSubFieldModelFindUniqueArgs} args - Arguments to find a HomeCareSpecializedSubFieldModel
     * @example
     * // Get one HomeCareSpecializedSubFieldModel
     * const homeCareSpecializedSubFieldModel = await prisma.homeCareSpecializedSubFieldModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HomeCareSpecializedSubFieldModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HomeCareSpecializedSubFieldModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'HomeCareSpecializedSubFieldModel'> extends True ? Prisma__HomeCareSpecializedSubFieldModelClient<HomeCareSpecializedSubFieldModelGetPayload<T>> : Prisma__HomeCareSpecializedSubFieldModelClient<HomeCareSpecializedSubFieldModelGetPayload<T> | null, null>

    /**
     * Find one HomeCareSpecializedSubFieldModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HomeCareSpecializedSubFieldModelFindUniqueOrThrowArgs} args - Arguments to find a HomeCareSpecializedSubFieldModel
     * @example
     * // Get one HomeCareSpecializedSubFieldModel
     * const homeCareSpecializedSubFieldModel = await prisma.homeCareSpecializedSubFieldModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HomeCareSpecializedSubFieldModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, HomeCareSpecializedSubFieldModelFindUniqueOrThrowArgs>
    ): Prisma__HomeCareSpecializedSubFieldModelClient<HomeCareSpecializedSubFieldModelGetPayload<T>>

    /**
     * Find the first HomeCareSpecializedSubFieldModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareSpecializedSubFieldModelFindFirstArgs} args - Arguments to find a HomeCareSpecializedSubFieldModel
     * @example
     * // Get one HomeCareSpecializedSubFieldModel
     * const homeCareSpecializedSubFieldModel = await prisma.homeCareSpecializedSubFieldModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HomeCareSpecializedSubFieldModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HomeCareSpecializedSubFieldModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'HomeCareSpecializedSubFieldModel'> extends True ? Prisma__HomeCareSpecializedSubFieldModelClient<HomeCareSpecializedSubFieldModelGetPayload<T>> : Prisma__HomeCareSpecializedSubFieldModelClient<HomeCareSpecializedSubFieldModelGetPayload<T> | null, null>

    /**
     * Find the first HomeCareSpecializedSubFieldModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareSpecializedSubFieldModelFindFirstOrThrowArgs} args - Arguments to find a HomeCareSpecializedSubFieldModel
     * @example
     * // Get one HomeCareSpecializedSubFieldModel
     * const homeCareSpecializedSubFieldModel = await prisma.homeCareSpecializedSubFieldModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HomeCareSpecializedSubFieldModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HomeCareSpecializedSubFieldModelFindFirstOrThrowArgs>
    ): Prisma__HomeCareSpecializedSubFieldModelClient<HomeCareSpecializedSubFieldModelGetPayload<T>>

    /**
     * Find zero or more HomeCareSpecializedSubFieldModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareSpecializedSubFieldModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HomeCareSpecializedSubFieldModels
     * const homeCareSpecializedSubFieldModels = await prisma.homeCareSpecializedSubFieldModel.findMany()
     * 
     * // Get first 10 HomeCareSpecializedSubFieldModels
     * const homeCareSpecializedSubFieldModels = await prisma.homeCareSpecializedSubFieldModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const homeCareSpecializedSubFieldModelWithIdOnly = await prisma.homeCareSpecializedSubFieldModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HomeCareSpecializedSubFieldModelFindManyArgs>(
      args?: SelectSubset<T, HomeCareSpecializedSubFieldModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<HomeCareSpecializedSubFieldModelGetPayload<T>>>

    /**
     * Create a HomeCareSpecializedSubFieldModel.
     * @param {HomeCareSpecializedSubFieldModelCreateArgs} args - Arguments to create a HomeCareSpecializedSubFieldModel.
     * @example
     * // Create one HomeCareSpecializedSubFieldModel
     * const HomeCareSpecializedSubFieldModel = await prisma.homeCareSpecializedSubFieldModel.create({
     *   data: {
     *     // ... data to create a HomeCareSpecializedSubFieldModel
     *   }
     * })
     * 
    **/
    create<T extends HomeCareSpecializedSubFieldModelCreateArgs>(
      args: SelectSubset<T, HomeCareSpecializedSubFieldModelCreateArgs>
    ): Prisma__HomeCareSpecializedSubFieldModelClient<HomeCareSpecializedSubFieldModelGetPayload<T>>

    /**
     * Create many HomeCareSpecializedSubFieldModels.
     *     @param {HomeCareSpecializedSubFieldModelCreateManyArgs} args - Arguments to create many HomeCareSpecializedSubFieldModels.
     *     @example
     *     // Create many HomeCareSpecializedSubFieldModels
     *     const homeCareSpecializedSubFieldModel = await prisma.homeCareSpecializedSubFieldModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HomeCareSpecializedSubFieldModelCreateManyArgs>(
      args?: SelectSubset<T, HomeCareSpecializedSubFieldModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HomeCareSpecializedSubFieldModel.
     * @param {HomeCareSpecializedSubFieldModelDeleteArgs} args - Arguments to delete one HomeCareSpecializedSubFieldModel.
     * @example
     * // Delete one HomeCareSpecializedSubFieldModel
     * const HomeCareSpecializedSubFieldModel = await prisma.homeCareSpecializedSubFieldModel.delete({
     *   where: {
     *     // ... filter to delete one HomeCareSpecializedSubFieldModel
     *   }
     * })
     * 
    **/
    delete<T extends HomeCareSpecializedSubFieldModelDeleteArgs>(
      args: SelectSubset<T, HomeCareSpecializedSubFieldModelDeleteArgs>
    ): Prisma__HomeCareSpecializedSubFieldModelClient<HomeCareSpecializedSubFieldModelGetPayload<T>>

    /**
     * Update one HomeCareSpecializedSubFieldModel.
     * @param {HomeCareSpecializedSubFieldModelUpdateArgs} args - Arguments to update one HomeCareSpecializedSubFieldModel.
     * @example
     * // Update one HomeCareSpecializedSubFieldModel
     * const homeCareSpecializedSubFieldModel = await prisma.homeCareSpecializedSubFieldModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HomeCareSpecializedSubFieldModelUpdateArgs>(
      args: SelectSubset<T, HomeCareSpecializedSubFieldModelUpdateArgs>
    ): Prisma__HomeCareSpecializedSubFieldModelClient<HomeCareSpecializedSubFieldModelGetPayload<T>>

    /**
     * Delete zero or more HomeCareSpecializedSubFieldModels.
     * @param {HomeCareSpecializedSubFieldModelDeleteManyArgs} args - Arguments to filter HomeCareSpecializedSubFieldModels to delete.
     * @example
     * // Delete a few HomeCareSpecializedSubFieldModels
     * const { count } = await prisma.homeCareSpecializedSubFieldModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HomeCareSpecializedSubFieldModelDeleteManyArgs>(
      args?: SelectSubset<T, HomeCareSpecializedSubFieldModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HomeCareSpecializedSubFieldModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareSpecializedSubFieldModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HomeCareSpecializedSubFieldModels
     * const homeCareSpecializedSubFieldModel = await prisma.homeCareSpecializedSubFieldModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HomeCareSpecializedSubFieldModelUpdateManyArgs>(
      args: SelectSubset<T, HomeCareSpecializedSubFieldModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HomeCareSpecializedSubFieldModel.
     * @param {HomeCareSpecializedSubFieldModelUpsertArgs} args - Arguments to update or create a HomeCareSpecializedSubFieldModel.
     * @example
     * // Update or create a HomeCareSpecializedSubFieldModel
     * const homeCareSpecializedSubFieldModel = await prisma.homeCareSpecializedSubFieldModel.upsert({
     *   create: {
     *     // ... data to create a HomeCareSpecializedSubFieldModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HomeCareSpecializedSubFieldModel we want to update
     *   }
     * })
    **/
    upsert<T extends HomeCareSpecializedSubFieldModelUpsertArgs>(
      args: SelectSubset<T, HomeCareSpecializedSubFieldModelUpsertArgs>
    ): Prisma__HomeCareSpecializedSubFieldModelClient<HomeCareSpecializedSubFieldModelGetPayload<T>>

    /**
     * Count the number of HomeCareSpecializedSubFieldModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareSpecializedSubFieldModelCountArgs} args - Arguments to filter HomeCareSpecializedSubFieldModels to count.
     * @example
     * // Count the number of HomeCareSpecializedSubFieldModels
     * const count = await prisma.homeCareSpecializedSubFieldModel.count({
     *   where: {
     *     // ... the filter for the HomeCareSpecializedSubFieldModels we want to count
     *   }
     * })
    **/
    count<T extends HomeCareSpecializedSubFieldModelCountArgs>(
      args?: Subset<T, HomeCareSpecializedSubFieldModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HomeCareSpecializedSubFieldModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HomeCareSpecializedSubFieldModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareSpecializedSubFieldModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HomeCareSpecializedSubFieldModelAggregateArgs>(args: Subset<T, HomeCareSpecializedSubFieldModelAggregateArgs>): Prisma.PrismaPromise<GetHomeCareSpecializedSubFieldModelAggregateType<T>>

    /**
     * Group by HomeCareSpecializedSubFieldModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeCareSpecializedSubFieldModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HomeCareSpecializedSubFieldModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HomeCareSpecializedSubFieldModelGroupByArgs['orderBy'] }
        : { orderBy?: HomeCareSpecializedSubFieldModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HomeCareSpecializedSubFieldModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHomeCareSpecializedSubFieldModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for HomeCareSpecializedSubFieldModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HomeCareSpecializedSubFieldModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    super<T extends HomeCareSpecializedSuperFieldModelArgs= {}>(args?: Subset<T, HomeCareSpecializedSuperFieldModelArgs>): Prisma__HomeCareSpecializedSuperFieldModelClient<HomeCareSpecializedSuperFieldModelGetPayload<T> | Null>;

    home_care_companies<T extends HomeCareSpecializedSubFieldModel$home_care_companiesArgs= {}>(args?: Subset<T, HomeCareSpecializedSubFieldModel$home_care_companiesArgs>): Prisma.PrismaPromise<Array<HomeCareCompanyModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * HomeCareSpecializedSubFieldModel base type for findUnique actions
   */
  export type HomeCareSpecializedSubFieldModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the HomeCareSpecializedSubFieldModel
     */
    select?: HomeCareSpecializedSubFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareSpecializedSubFieldModelInclude | null
    /**
     * Filter, which HomeCareSpecializedSubFieldModel to fetch.
     */
    where: HomeCareSpecializedSubFieldModelWhereUniqueInput
  }

  /**
   * HomeCareSpecializedSubFieldModel findUnique
   */
  export interface HomeCareSpecializedSubFieldModelFindUniqueArgs extends HomeCareSpecializedSubFieldModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HomeCareSpecializedSubFieldModel findUniqueOrThrow
   */
  export type HomeCareSpecializedSubFieldModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HomeCareSpecializedSubFieldModel
     */
    select?: HomeCareSpecializedSubFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareSpecializedSubFieldModelInclude | null
    /**
     * Filter, which HomeCareSpecializedSubFieldModel to fetch.
     */
    where: HomeCareSpecializedSubFieldModelWhereUniqueInput
  }


  /**
   * HomeCareSpecializedSubFieldModel base type for findFirst actions
   */
  export type HomeCareSpecializedSubFieldModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the HomeCareSpecializedSubFieldModel
     */
    select?: HomeCareSpecializedSubFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareSpecializedSubFieldModelInclude | null
    /**
     * Filter, which HomeCareSpecializedSubFieldModel to fetch.
     */
    where?: HomeCareSpecializedSubFieldModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeCareSpecializedSubFieldModels to fetch.
     */
    orderBy?: Enumerable<HomeCareSpecializedSubFieldModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomeCareSpecializedSubFieldModels.
     */
    cursor?: HomeCareSpecializedSubFieldModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeCareSpecializedSubFieldModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeCareSpecializedSubFieldModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomeCareSpecializedSubFieldModels.
     */
    distinct?: Enumerable<HomeCareSpecializedSubFieldModelScalarFieldEnum>
  }

  /**
   * HomeCareSpecializedSubFieldModel findFirst
   */
  export interface HomeCareSpecializedSubFieldModelFindFirstArgs extends HomeCareSpecializedSubFieldModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HomeCareSpecializedSubFieldModel findFirstOrThrow
   */
  export type HomeCareSpecializedSubFieldModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HomeCareSpecializedSubFieldModel
     */
    select?: HomeCareSpecializedSubFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareSpecializedSubFieldModelInclude | null
    /**
     * Filter, which HomeCareSpecializedSubFieldModel to fetch.
     */
    where?: HomeCareSpecializedSubFieldModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeCareSpecializedSubFieldModels to fetch.
     */
    orderBy?: Enumerable<HomeCareSpecializedSubFieldModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomeCareSpecializedSubFieldModels.
     */
    cursor?: HomeCareSpecializedSubFieldModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeCareSpecializedSubFieldModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeCareSpecializedSubFieldModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomeCareSpecializedSubFieldModels.
     */
    distinct?: Enumerable<HomeCareSpecializedSubFieldModelScalarFieldEnum>
  }


  /**
   * HomeCareSpecializedSubFieldModel findMany
   */
  export type HomeCareSpecializedSubFieldModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the HomeCareSpecializedSubFieldModel
     */
    select?: HomeCareSpecializedSubFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareSpecializedSubFieldModelInclude | null
    /**
     * Filter, which HomeCareSpecializedSubFieldModels to fetch.
     */
    where?: HomeCareSpecializedSubFieldModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeCareSpecializedSubFieldModels to fetch.
     */
    orderBy?: Enumerable<HomeCareSpecializedSubFieldModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HomeCareSpecializedSubFieldModels.
     */
    cursor?: HomeCareSpecializedSubFieldModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HomeCareSpecializedSubFieldModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeCareSpecializedSubFieldModels.
     */
    skip?: number
    distinct?: Enumerable<HomeCareSpecializedSubFieldModelScalarFieldEnum>
  }


  /**
   * HomeCareSpecializedSubFieldModel create
   */
  export type HomeCareSpecializedSubFieldModelCreateArgs = {
    /**
     * Select specific fields to fetch from the HomeCareSpecializedSubFieldModel
     */
    select?: HomeCareSpecializedSubFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareSpecializedSubFieldModelInclude | null
    /**
     * The data needed to create a HomeCareSpecializedSubFieldModel.
     */
    data: XOR<HomeCareSpecializedSubFieldModelCreateInput, HomeCareSpecializedSubFieldModelUncheckedCreateInput>
  }


  /**
   * HomeCareSpecializedSubFieldModel createMany
   */
  export type HomeCareSpecializedSubFieldModelCreateManyArgs = {
    /**
     * The data used to create many HomeCareSpecializedSubFieldModels.
     */
    data: Enumerable<HomeCareSpecializedSubFieldModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * HomeCareSpecializedSubFieldModel update
   */
  export type HomeCareSpecializedSubFieldModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the HomeCareSpecializedSubFieldModel
     */
    select?: HomeCareSpecializedSubFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareSpecializedSubFieldModelInclude | null
    /**
     * The data needed to update a HomeCareSpecializedSubFieldModel.
     */
    data: XOR<HomeCareSpecializedSubFieldModelUpdateInput, HomeCareSpecializedSubFieldModelUncheckedUpdateInput>
    /**
     * Choose, which HomeCareSpecializedSubFieldModel to update.
     */
    where: HomeCareSpecializedSubFieldModelWhereUniqueInput
  }


  /**
   * HomeCareSpecializedSubFieldModel updateMany
   */
  export type HomeCareSpecializedSubFieldModelUpdateManyArgs = {
    /**
     * The data used to update HomeCareSpecializedSubFieldModels.
     */
    data: XOR<HomeCareSpecializedSubFieldModelUpdateManyMutationInput, HomeCareSpecializedSubFieldModelUncheckedUpdateManyInput>
    /**
     * Filter which HomeCareSpecializedSubFieldModels to update
     */
    where?: HomeCareSpecializedSubFieldModelWhereInput
  }


  /**
   * HomeCareSpecializedSubFieldModel upsert
   */
  export type HomeCareSpecializedSubFieldModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the HomeCareSpecializedSubFieldModel
     */
    select?: HomeCareSpecializedSubFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareSpecializedSubFieldModelInclude | null
    /**
     * The filter to search for the HomeCareSpecializedSubFieldModel to update in case it exists.
     */
    where: HomeCareSpecializedSubFieldModelWhereUniqueInput
    /**
     * In case the HomeCareSpecializedSubFieldModel found by the `where` argument doesn't exist, create a new HomeCareSpecializedSubFieldModel with this data.
     */
    create: XOR<HomeCareSpecializedSubFieldModelCreateInput, HomeCareSpecializedSubFieldModelUncheckedCreateInput>
    /**
     * In case the HomeCareSpecializedSubFieldModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HomeCareSpecializedSubFieldModelUpdateInput, HomeCareSpecializedSubFieldModelUncheckedUpdateInput>
  }


  /**
   * HomeCareSpecializedSubFieldModel delete
   */
  export type HomeCareSpecializedSubFieldModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the HomeCareSpecializedSubFieldModel
     */
    select?: HomeCareSpecializedSubFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareSpecializedSubFieldModelInclude | null
    /**
     * Filter which HomeCareSpecializedSubFieldModel to delete.
     */
    where: HomeCareSpecializedSubFieldModelWhereUniqueInput
  }


  /**
   * HomeCareSpecializedSubFieldModel deleteMany
   */
  export type HomeCareSpecializedSubFieldModelDeleteManyArgs = {
    /**
     * Filter which HomeCareSpecializedSubFieldModels to delete
     */
    where?: HomeCareSpecializedSubFieldModelWhereInput
  }


  /**
   * HomeCareSpecializedSubFieldModel.home_care_companies
   */
  export type HomeCareSpecializedSubFieldModel$home_care_companiesArgs = {
    /**
     * Select specific fields to fetch from the HomeCareCompanyModel
     */
    select?: HomeCareCompanyModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareCompanyModelInclude | null
    where?: HomeCareCompanyModelWhereInput
    orderBy?: Enumerable<HomeCareCompanyModelOrderByWithRelationInput>
    cursor?: HomeCareCompanyModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HomeCareCompanyModelScalarFieldEnum>
  }


  /**
   * HomeCareSpecializedSubFieldModel without action
   */
  export type HomeCareSpecializedSubFieldModelArgs = {
    /**
     * Select specific fields to fetch from the HomeCareSpecializedSubFieldModel
     */
    select?: HomeCareSpecializedSubFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HomeCareSpecializedSubFieldModelInclude | null
  }



  /**
   * Model RealEstateSpecializedSuperFieldModel
   */


  export type AggregateRealEstateSpecializedSuperFieldModel = {
    _count: RealEstateSpecializedSuperFieldModelCountAggregateOutputType | null
    _min: RealEstateSpecializedSuperFieldModelMinAggregateOutputType | null
    _max: RealEstateSpecializedSuperFieldModelMaxAggregateOutputType | null
  }

  export type RealEstateSpecializedSuperFieldModelMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type RealEstateSpecializedSuperFieldModelMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type RealEstateSpecializedSuperFieldModelCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RealEstateSpecializedSuperFieldModelMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RealEstateSpecializedSuperFieldModelMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RealEstateSpecializedSuperFieldModelCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RealEstateSpecializedSuperFieldModelAggregateArgs = {
    /**
     * Filter which RealEstateSpecializedSuperFieldModel to aggregate.
     */
    where?: RealEstateSpecializedSuperFieldModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateSpecializedSuperFieldModels to fetch.
     */
    orderBy?: Enumerable<RealEstateSpecializedSuperFieldModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RealEstateSpecializedSuperFieldModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateSpecializedSuperFieldModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateSpecializedSuperFieldModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RealEstateSpecializedSuperFieldModels
    **/
    _count?: true | RealEstateSpecializedSuperFieldModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RealEstateSpecializedSuperFieldModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RealEstateSpecializedSuperFieldModelMaxAggregateInputType
  }

  export type GetRealEstateSpecializedSuperFieldModelAggregateType<T extends RealEstateSpecializedSuperFieldModelAggregateArgs> = {
        [P in keyof T & keyof AggregateRealEstateSpecializedSuperFieldModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRealEstateSpecializedSuperFieldModel[P]>
      : GetScalarType<T[P], AggregateRealEstateSpecializedSuperFieldModel[P]>
  }




  export type RealEstateSpecializedSuperFieldModelGroupByArgs = {
    where?: RealEstateSpecializedSuperFieldModelWhereInput
    orderBy?: Enumerable<RealEstateSpecializedSuperFieldModelOrderByWithAggregationInput>
    by: RealEstateSpecializedSuperFieldModelScalarFieldEnum[]
    having?: RealEstateSpecializedSuperFieldModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RealEstateSpecializedSuperFieldModelCountAggregateInputType | true
    _min?: RealEstateSpecializedSuperFieldModelMinAggregateInputType
    _max?: RealEstateSpecializedSuperFieldModelMaxAggregateInputType
  }


  export type RealEstateSpecializedSuperFieldModelGroupByOutputType = {
    id: string
    name: string
    _count: RealEstateSpecializedSuperFieldModelCountAggregateOutputType | null
    _min: RealEstateSpecializedSuperFieldModelMinAggregateOutputType | null
    _max: RealEstateSpecializedSuperFieldModelMaxAggregateOutputType | null
  }

  type GetRealEstateSpecializedSuperFieldModelGroupByPayload<T extends RealEstateSpecializedSuperFieldModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RealEstateSpecializedSuperFieldModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RealEstateSpecializedSuperFieldModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RealEstateSpecializedSuperFieldModelGroupByOutputType[P]>
            : GetScalarType<T[P], RealEstateSpecializedSuperFieldModelGroupByOutputType[P]>
        }
      >
    >


  export type RealEstateSpecializedSuperFieldModelSelect = {
    id?: boolean
    name?: boolean
    sub?: boolean | RealEstateSpecializedSuperFieldModel$subArgs
    _count?: boolean | RealEstateSpecializedSuperFieldModelCountOutputTypeArgs
  }


  export type RealEstateSpecializedSuperFieldModelInclude = {
    sub?: boolean | RealEstateSpecializedSuperFieldModel$subArgs
    _count?: boolean | RealEstateSpecializedSuperFieldModelCountOutputTypeArgs
  }

  export type RealEstateSpecializedSuperFieldModelGetPayload<S extends boolean | null | undefined | RealEstateSpecializedSuperFieldModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RealEstateSpecializedSuperFieldModel :
    S extends undefined ? never :
    S extends { include: any } & (RealEstateSpecializedSuperFieldModelArgs | RealEstateSpecializedSuperFieldModelFindManyArgs)
    ? RealEstateSpecializedSuperFieldModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'sub' ? Array < RealEstateSpecializedSubFieldModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? RealEstateSpecializedSuperFieldModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RealEstateSpecializedSuperFieldModelArgs | RealEstateSpecializedSuperFieldModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'sub' ? Array < RealEstateSpecializedSubFieldModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? RealEstateSpecializedSuperFieldModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof RealEstateSpecializedSuperFieldModel ? RealEstateSpecializedSuperFieldModel[P] : never
  } 
      : RealEstateSpecializedSuperFieldModel


  type RealEstateSpecializedSuperFieldModelCountArgs = 
    Omit<RealEstateSpecializedSuperFieldModelFindManyArgs, 'select' | 'include'> & {
      select?: RealEstateSpecializedSuperFieldModelCountAggregateInputType | true
    }

  export interface RealEstateSpecializedSuperFieldModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one RealEstateSpecializedSuperFieldModel that matches the filter.
     * @param {RealEstateSpecializedSuperFieldModelFindUniqueArgs} args - Arguments to find a RealEstateSpecializedSuperFieldModel
     * @example
     * // Get one RealEstateSpecializedSuperFieldModel
     * const realEstateSpecializedSuperFieldModel = await prisma.realEstateSpecializedSuperFieldModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RealEstateSpecializedSuperFieldModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RealEstateSpecializedSuperFieldModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RealEstateSpecializedSuperFieldModel'> extends True ? Prisma__RealEstateSpecializedSuperFieldModelClient<RealEstateSpecializedSuperFieldModelGetPayload<T>> : Prisma__RealEstateSpecializedSuperFieldModelClient<RealEstateSpecializedSuperFieldModelGetPayload<T> | null, null>

    /**
     * Find one RealEstateSpecializedSuperFieldModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RealEstateSpecializedSuperFieldModelFindUniqueOrThrowArgs} args - Arguments to find a RealEstateSpecializedSuperFieldModel
     * @example
     * // Get one RealEstateSpecializedSuperFieldModel
     * const realEstateSpecializedSuperFieldModel = await prisma.realEstateSpecializedSuperFieldModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RealEstateSpecializedSuperFieldModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RealEstateSpecializedSuperFieldModelFindUniqueOrThrowArgs>
    ): Prisma__RealEstateSpecializedSuperFieldModelClient<RealEstateSpecializedSuperFieldModelGetPayload<T>>

    /**
     * Find the first RealEstateSpecializedSuperFieldModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateSpecializedSuperFieldModelFindFirstArgs} args - Arguments to find a RealEstateSpecializedSuperFieldModel
     * @example
     * // Get one RealEstateSpecializedSuperFieldModel
     * const realEstateSpecializedSuperFieldModel = await prisma.realEstateSpecializedSuperFieldModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RealEstateSpecializedSuperFieldModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RealEstateSpecializedSuperFieldModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RealEstateSpecializedSuperFieldModel'> extends True ? Prisma__RealEstateSpecializedSuperFieldModelClient<RealEstateSpecializedSuperFieldModelGetPayload<T>> : Prisma__RealEstateSpecializedSuperFieldModelClient<RealEstateSpecializedSuperFieldModelGetPayload<T> | null, null>

    /**
     * Find the first RealEstateSpecializedSuperFieldModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateSpecializedSuperFieldModelFindFirstOrThrowArgs} args - Arguments to find a RealEstateSpecializedSuperFieldModel
     * @example
     * // Get one RealEstateSpecializedSuperFieldModel
     * const realEstateSpecializedSuperFieldModel = await prisma.realEstateSpecializedSuperFieldModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RealEstateSpecializedSuperFieldModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RealEstateSpecializedSuperFieldModelFindFirstOrThrowArgs>
    ): Prisma__RealEstateSpecializedSuperFieldModelClient<RealEstateSpecializedSuperFieldModelGetPayload<T>>

    /**
     * Find zero or more RealEstateSpecializedSuperFieldModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateSpecializedSuperFieldModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RealEstateSpecializedSuperFieldModels
     * const realEstateSpecializedSuperFieldModels = await prisma.realEstateSpecializedSuperFieldModel.findMany()
     * 
     * // Get first 10 RealEstateSpecializedSuperFieldModels
     * const realEstateSpecializedSuperFieldModels = await prisma.realEstateSpecializedSuperFieldModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const realEstateSpecializedSuperFieldModelWithIdOnly = await prisma.realEstateSpecializedSuperFieldModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RealEstateSpecializedSuperFieldModelFindManyArgs>(
      args?: SelectSubset<T, RealEstateSpecializedSuperFieldModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<RealEstateSpecializedSuperFieldModelGetPayload<T>>>

    /**
     * Create a RealEstateSpecializedSuperFieldModel.
     * @param {RealEstateSpecializedSuperFieldModelCreateArgs} args - Arguments to create a RealEstateSpecializedSuperFieldModel.
     * @example
     * // Create one RealEstateSpecializedSuperFieldModel
     * const RealEstateSpecializedSuperFieldModel = await prisma.realEstateSpecializedSuperFieldModel.create({
     *   data: {
     *     // ... data to create a RealEstateSpecializedSuperFieldModel
     *   }
     * })
     * 
    **/
    create<T extends RealEstateSpecializedSuperFieldModelCreateArgs>(
      args: SelectSubset<T, RealEstateSpecializedSuperFieldModelCreateArgs>
    ): Prisma__RealEstateSpecializedSuperFieldModelClient<RealEstateSpecializedSuperFieldModelGetPayload<T>>

    /**
     * Create many RealEstateSpecializedSuperFieldModels.
     *     @param {RealEstateSpecializedSuperFieldModelCreateManyArgs} args - Arguments to create many RealEstateSpecializedSuperFieldModels.
     *     @example
     *     // Create many RealEstateSpecializedSuperFieldModels
     *     const realEstateSpecializedSuperFieldModel = await prisma.realEstateSpecializedSuperFieldModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RealEstateSpecializedSuperFieldModelCreateManyArgs>(
      args?: SelectSubset<T, RealEstateSpecializedSuperFieldModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RealEstateSpecializedSuperFieldModel.
     * @param {RealEstateSpecializedSuperFieldModelDeleteArgs} args - Arguments to delete one RealEstateSpecializedSuperFieldModel.
     * @example
     * // Delete one RealEstateSpecializedSuperFieldModel
     * const RealEstateSpecializedSuperFieldModel = await prisma.realEstateSpecializedSuperFieldModel.delete({
     *   where: {
     *     // ... filter to delete one RealEstateSpecializedSuperFieldModel
     *   }
     * })
     * 
    **/
    delete<T extends RealEstateSpecializedSuperFieldModelDeleteArgs>(
      args: SelectSubset<T, RealEstateSpecializedSuperFieldModelDeleteArgs>
    ): Prisma__RealEstateSpecializedSuperFieldModelClient<RealEstateSpecializedSuperFieldModelGetPayload<T>>

    /**
     * Update one RealEstateSpecializedSuperFieldModel.
     * @param {RealEstateSpecializedSuperFieldModelUpdateArgs} args - Arguments to update one RealEstateSpecializedSuperFieldModel.
     * @example
     * // Update one RealEstateSpecializedSuperFieldModel
     * const realEstateSpecializedSuperFieldModel = await prisma.realEstateSpecializedSuperFieldModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RealEstateSpecializedSuperFieldModelUpdateArgs>(
      args: SelectSubset<T, RealEstateSpecializedSuperFieldModelUpdateArgs>
    ): Prisma__RealEstateSpecializedSuperFieldModelClient<RealEstateSpecializedSuperFieldModelGetPayload<T>>

    /**
     * Delete zero or more RealEstateSpecializedSuperFieldModels.
     * @param {RealEstateSpecializedSuperFieldModelDeleteManyArgs} args - Arguments to filter RealEstateSpecializedSuperFieldModels to delete.
     * @example
     * // Delete a few RealEstateSpecializedSuperFieldModels
     * const { count } = await prisma.realEstateSpecializedSuperFieldModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RealEstateSpecializedSuperFieldModelDeleteManyArgs>(
      args?: SelectSubset<T, RealEstateSpecializedSuperFieldModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RealEstateSpecializedSuperFieldModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateSpecializedSuperFieldModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RealEstateSpecializedSuperFieldModels
     * const realEstateSpecializedSuperFieldModel = await prisma.realEstateSpecializedSuperFieldModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RealEstateSpecializedSuperFieldModelUpdateManyArgs>(
      args: SelectSubset<T, RealEstateSpecializedSuperFieldModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RealEstateSpecializedSuperFieldModel.
     * @param {RealEstateSpecializedSuperFieldModelUpsertArgs} args - Arguments to update or create a RealEstateSpecializedSuperFieldModel.
     * @example
     * // Update or create a RealEstateSpecializedSuperFieldModel
     * const realEstateSpecializedSuperFieldModel = await prisma.realEstateSpecializedSuperFieldModel.upsert({
     *   create: {
     *     // ... data to create a RealEstateSpecializedSuperFieldModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RealEstateSpecializedSuperFieldModel we want to update
     *   }
     * })
    **/
    upsert<T extends RealEstateSpecializedSuperFieldModelUpsertArgs>(
      args: SelectSubset<T, RealEstateSpecializedSuperFieldModelUpsertArgs>
    ): Prisma__RealEstateSpecializedSuperFieldModelClient<RealEstateSpecializedSuperFieldModelGetPayload<T>>

    /**
     * Count the number of RealEstateSpecializedSuperFieldModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateSpecializedSuperFieldModelCountArgs} args - Arguments to filter RealEstateSpecializedSuperFieldModels to count.
     * @example
     * // Count the number of RealEstateSpecializedSuperFieldModels
     * const count = await prisma.realEstateSpecializedSuperFieldModel.count({
     *   where: {
     *     // ... the filter for the RealEstateSpecializedSuperFieldModels we want to count
     *   }
     * })
    **/
    count<T extends RealEstateSpecializedSuperFieldModelCountArgs>(
      args?: Subset<T, RealEstateSpecializedSuperFieldModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RealEstateSpecializedSuperFieldModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RealEstateSpecializedSuperFieldModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateSpecializedSuperFieldModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RealEstateSpecializedSuperFieldModelAggregateArgs>(args: Subset<T, RealEstateSpecializedSuperFieldModelAggregateArgs>): Prisma.PrismaPromise<GetRealEstateSpecializedSuperFieldModelAggregateType<T>>

    /**
     * Group by RealEstateSpecializedSuperFieldModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateSpecializedSuperFieldModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RealEstateSpecializedSuperFieldModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RealEstateSpecializedSuperFieldModelGroupByArgs['orderBy'] }
        : { orderBy?: RealEstateSpecializedSuperFieldModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RealEstateSpecializedSuperFieldModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRealEstateSpecializedSuperFieldModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RealEstateSpecializedSuperFieldModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RealEstateSpecializedSuperFieldModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    sub<T extends RealEstateSpecializedSuperFieldModel$subArgs= {}>(args?: Subset<T, RealEstateSpecializedSuperFieldModel$subArgs>): Prisma.PrismaPromise<Array<RealEstateSpecializedSubFieldModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RealEstateSpecializedSuperFieldModel base type for findUnique actions
   */
  export type RealEstateSpecializedSuperFieldModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RealEstateSpecializedSuperFieldModel
     */
    select?: RealEstateSpecializedSuperFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateSpecializedSuperFieldModelInclude | null
    /**
     * Filter, which RealEstateSpecializedSuperFieldModel to fetch.
     */
    where: RealEstateSpecializedSuperFieldModelWhereUniqueInput
  }

  /**
   * RealEstateSpecializedSuperFieldModel findUnique
   */
  export interface RealEstateSpecializedSuperFieldModelFindUniqueArgs extends RealEstateSpecializedSuperFieldModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RealEstateSpecializedSuperFieldModel findUniqueOrThrow
   */
  export type RealEstateSpecializedSuperFieldModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RealEstateSpecializedSuperFieldModel
     */
    select?: RealEstateSpecializedSuperFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateSpecializedSuperFieldModelInclude | null
    /**
     * Filter, which RealEstateSpecializedSuperFieldModel to fetch.
     */
    where: RealEstateSpecializedSuperFieldModelWhereUniqueInput
  }


  /**
   * RealEstateSpecializedSuperFieldModel base type for findFirst actions
   */
  export type RealEstateSpecializedSuperFieldModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RealEstateSpecializedSuperFieldModel
     */
    select?: RealEstateSpecializedSuperFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateSpecializedSuperFieldModelInclude | null
    /**
     * Filter, which RealEstateSpecializedSuperFieldModel to fetch.
     */
    where?: RealEstateSpecializedSuperFieldModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateSpecializedSuperFieldModels to fetch.
     */
    orderBy?: Enumerable<RealEstateSpecializedSuperFieldModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RealEstateSpecializedSuperFieldModels.
     */
    cursor?: RealEstateSpecializedSuperFieldModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateSpecializedSuperFieldModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateSpecializedSuperFieldModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RealEstateSpecializedSuperFieldModels.
     */
    distinct?: Enumerable<RealEstateSpecializedSuperFieldModelScalarFieldEnum>
  }

  /**
   * RealEstateSpecializedSuperFieldModel findFirst
   */
  export interface RealEstateSpecializedSuperFieldModelFindFirstArgs extends RealEstateSpecializedSuperFieldModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RealEstateSpecializedSuperFieldModel findFirstOrThrow
   */
  export type RealEstateSpecializedSuperFieldModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RealEstateSpecializedSuperFieldModel
     */
    select?: RealEstateSpecializedSuperFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateSpecializedSuperFieldModelInclude | null
    /**
     * Filter, which RealEstateSpecializedSuperFieldModel to fetch.
     */
    where?: RealEstateSpecializedSuperFieldModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateSpecializedSuperFieldModels to fetch.
     */
    orderBy?: Enumerable<RealEstateSpecializedSuperFieldModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RealEstateSpecializedSuperFieldModels.
     */
    cursor?: RealEstateSpecializedSuperFieldModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateSpecializedSuperFieldModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateSpecializedSuperFieldModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RealEstateSpecializedSuperFieldModels.
     */
    distinct?: Enumerable<RealEstateSpecializedSuperFieldModelScalarFieldEnum>
  }


  /**
   * RealEstateSpecializedSuperFieldModel findMany
   */
  export type RealEstateSpecializedSuperFieldModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the RealEstateSpecializedSuperFieldModel
     */
    select?: RealEstateSpecializedSuperFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateSpecializedSuperFieldModelInclude | null
    /**
     * Filter, which RealEstateSpecializedSuperFieldModels to fetch.
     */
    where?: RealEstateSpecializedSuperFieldModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateSpecializedSuperFieldModels to fetch.
     */
    orderBy?: Enumerable<RealEstateSpecializedSuperFieldModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RealEstateSpecializedSuperFieldModels.
     */
    cursor?: RealEstateSpecializedSuperFieldModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateSpecializedSuperFieldModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateSpecializedSuperFieldModels.
     */
    skip?: number
    distinct?: Enumerable<RealEstateSpecializedSuperFieldModelScalarFieldEnum>
  }


  /**
   * RealEstateSpecializedSuperFieldModel create
   */
  export type RealEstateSpecializedSuperFieldModelCreateArgs = {
    /**
     * Select specific fields to fetch from the RealEstateSpecializedSuperFieldModel
     */
    select?: RealEstateSpecializedSuperFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateSpecializedSuperFieldModelInclude | null
    /**
     * The data needed to create a RealEstateSpecializedSuperFieldModel.
     */
    data: XOR<RealEstateSpecializedSuperFieldModelCreateInput, RealEstateSpecializedSuperFieldModelUncheckedCreateInput>
  }


  /**
   * RealEstateSpecializedSuperFieldModel createMany
   */
  export type RealEstateSpecializedSuperFieldModelCreateManyArgs = {
    /**
     * The data used to create many RealEstateSpecializedSuperFieldModels.
     */
    data: Enumerable<RealEstateSpecializedSuperFieldModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RealEstateSpecializedSuperFieldModel update
   */
  export type RealEstateSpecializedSuperFieldModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the RealEstateSpecializedSuperFieldModel
     */
    select?: RealEstateSpecializedSuperFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateSpecializedSuperFieldModelInclude | null
    /**
     * The data needed to update a RealEstateSpecializedSuperFieldModel.
     */
    data: XOR<RealEstateSpecializedSuperFieldModelUpdateInput, RealEstateSpecializedSuperFieldModelUncheckedUpdateInput>
    /**
     * Choose, which RealEstateSpecializedSuperFieldModel to update.
     */
    where: RealEstateSpecializedSuperFieldModelWhereUniqueInput
  }


  /**
   * RealEstateSpecializedSuperFieldModel updateMany
   */
  export type RealEstateSpecializedSuperFieldModelUpdateManyArgs = {
    /**
     * The data used to update RealEstateSpecializedSuperFieldModels.
     */
    data: XOR<RealEstateSpecializedSuperFieldModelUpdateManyMutationInput, RealEstateSpecializedSuperFieldModelUncheckedUpdateManyInput>
    /**
     * Filter which RealEstateSpecializedSuperFieldModels to update
     */
    where?: RealEstateSpecializedSuperFieldModelWhereInput
  }


  /**
   * RealEstateSpecializedSuperFieldModel upsert
   */
  export type RealEstateSpecializedSuperFieldModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the RealEstateSpecializedSuperFieldModel
     */
    select?: RealEstateSpecializedSuperFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateSpecializedSuperFieldModelInclude | null
    /**
     * The filter to search for the RealEstateSpecializedSuperFieldModel to update in case it exists.
     */
    where: RealEstateSpecializedSuperFieldModelWhereUniqueInput
    /**
     * In case the RealEstateSpecializedSuperFieldModel found by the `where` argument doesn't exist, create a new RealEstateSpecializedSuperFieldModel with this data.
     */
    create: XOR<RealEstateSpecializedSuperFieldModelCreateInput, RealEstateSpecializedSuperFieldModelUncheckedCreateInput>
    /**
     * In case the RealEstateSpecializedSuperFieldModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RealEstateSpecializedSuperFieldModelUpdateInput, RealEstateSpecializedSuperFieldModelUncheckedUpdateInput>
  }


  /**
   * RealEstateSpecializedSuperFieldModel delete
   */
  export type RealEstateSpecializedSuperFieldModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the RealEstateSpecializedSuperFieldModel
     */
    select?: RealEstateSpecializedSuperFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateSpecializedSuperFieldModelInclude | null
    /**
     * Filter which RealEstateSpecializedSuperFieldModel to delete.
     */
    where: RealEstateSpecializedSuperFieldModelWhereUniqueInput
  }


  /**
   * RealEstateSpecializedSuperFieldModel deleteMany
   */
  export type RealEstateSpecializedSuperFieldModelDeleteManyArgs = {
    /**
     * Filter which RealEstateSpecializedSuperFieldModels to delete
     */
    where?: RealEstateSpecializedSuperFieldModelWhereInput
  }


  /**
   * RealEstateSpecializedSuperFieldModel.sub
   */
  export type RealEstateSpecializedSuperFieldModel$subArgs = {
    /**
     * Select specific fields to fetch from the RealEstateSpecializedSubFieldModel
     */
    select?: RealEstateSpecializedSubFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateSpecializedSubFieldModelInclude | null
    where?: RealEstateSpecializedSubFieldModelWhereInput
    orderBy?: Enumerable<RealEstateSpecializedSubFieldModelOrderByWithRelationInput>
    cursor?: RealEstateSpecializedSubFieldModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RealEstateSpecializedSubFieldModelScalarFieldEnum>
  }


  /**
   * RealEstateSpecializedSuperFieldModel without action
   */
  export type RealEstateSpecializedSuperFieldModelArgs = {
    /**
     * Select specific fields to fetch from the RealEstateSpecializedSuperFieldModel
     */
    select?: RealEstateSpecializedSuperFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateSpecializedSuperFieldModelInclude | null
  }



  /**
   * Model RealEstateSpecializedSubFieldModel
   */


  export type AggregateRealEstateSpecializedSubFieldModel = {
    _count: RealEstateSpecializedSubFieldModelCountAggregateOutputType | null
    _min: RealEstateSpecializedSubFieldModelMinAggregateOutputType | null
    _max: RealEstateSpecializedSubFieldModelMaxAggregateOutputType | null
  }

  export type RealEstateSpecializedSubFieldModelMinAggregateOutputType = {
    id: string | null
    name: string | null
    super_id: string | null
  }

  export type RealEstateSpecializedSubFieldModelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    super_id: string | null
  }

  export type RealEstateSpecializedSubFieldModelCountAggregateOutputType = {
    id: number
    name: number
    super_id: number
    _all: number
  }


  export type RealEstateSpecializedSubFieldModelMinAggregateInputType = {
    id?: true
    name?: true
    super_id?: true
  }

  export type RealEstateSpecializedSubFieldModelMaxAggregateInputType = {
    id?: true
    name?: true
    super_id?: true
  }

  export type RealEstateSpecializedSubFieldModelCountAggregateInputType = {
    id?: true
    name?: true
    super_id?: true
    _all?: true
  }

  export type RealEstateSpecializedSubFieldModelAggregateArgs = {
    /**
     * Filter which RealEstateSpecializedSubFieldModel to aggregate.
     */
    where?: RealEstateSpecializedSubFieldModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateSpecializedSubFieldModels to fetch.
     */
    orderBy?: Enumerable<RealEstateSpecializedSubFieldModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RealEstateSpecializedSubFieldModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateSpecializedSubFieldModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateSpecializedSubFieldModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RealEstateSpecializedSubFieldModels
    **/
    _count?: true | RealEstateSpecializedSubFieldModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RealEstateSpecializedSubFieldModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RealEstateSpecializedSubFieldModelMaxAggregateInputType
  }

  export type GetRealEstateSpecializedSubFieldModelAggregateType<T extends RealEstateSpecializedSubFieldModelAggregateArgs> = {
        [P in keyof T & keyof AggregateRealEstateSpecializedSubFieldModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRealEstateSpecializedSubFieldModel[P]>
      : GetScalarType<T[P], AggregateRealEstateSpecializedSubFieldModel[P]>
  }




  export type RealEstateSpecializedSubFieldModelGroupByArgs = {
    where?: RealEstateSpecializedSubFieldModelWhereInput
    orderBy?: Enumerable<RealEstateSpecializedSubFieldModelOrderByWithAggregationInput>
    by: RealEstateSpecializedSubFieldModelScalarFieldEnum[]
    having?: RealEstateSpecializedSubFieldModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RealEstateSpecializedSubFieldModelCountAggregateInputType | true
    _min?: RealEstateSpecializedSubFieldModelMinAggregateInputType
    _max?: RealEstateSpecializedSubFieldModelMaxAggregateInputType
  }


  export type RealEstateSpecializedSubFieldModelGroupByOutputType = {
    id: string
    name: string
    super_id: string
    _count: RealEstateSpecializedSubFieldModelCountAggregateOutputType | null
    _min: RealEstateSpecializedSubFieldModelMinAggregateOutputType | null
    _max: RealEstateSpecializedSubFieldModelMaxAggregateOutputType | null
  }

  type GetRealEstateSpecializedSubFieldModelGroupByPayload<T extends RealEstateSpecializedSubFieldModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RealEstateSpecializedSubFieldModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RealEstateSpecializedSubFieldModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RealEstateSpecializedSubFieldModelGroupByOutputType[P]>
            : GetScalarType<T[P], RealEstateSpecializedSubFieldModelGroupByOutputType[P]>
        }
      >
    >


  export type RealEstateSpecializedSubFieldModelSelect = {
    id?: boolean
    name?: boolean
    super_id?: boolean
    super?: boolean | RealEstateSpecializedSuperFieldModelArgs
    real_estate_agents?: boolean | RealEstateSpecializedSubFieldModel$real_estate_agentsArgs
    _count?: boolean | RealEstateSpecializedSubFieldModelCountOutputTypeArgs
  }


  export type RealEstateSpecializedSubFieldModelInclude = {
    super?: boolean | RealEstateSpecializedSuperFieldModelArgs
    real_estate_agents?: boolean | RealEstateSpecializedSubFieldModel$real_estate_agentsArgs
    _count?: boolean | RealEstateSpecializedSubFieldModelCountOutputTypeArgs
  }

  export type RealEstateSpecializedSubFieldModelGetPayload<S extends boolean | null | undefined | RealEstateSpecializedSubFieldModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RealEstateSpecializedSubFieldModel :
    S extends undefined ? never :
    S extends { include: any } & (RealEstateSpecializedSubFieldModelArgs | RealEstateSpecializedSubFieldModelFindManyArgs)
    ? RealEstateSpecializedSubFieldModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'super' ? RealEstateSpecializedSuperFieldModelGetPayload<S['include'][P]> :
        P extends 'real_estate_agents' ? Array < RealEstateAgentModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? RealEstateSpecializedSubFieldModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RealEstateSpecializedSubFieldModelArgs | RealEstateSpecializedSubFieldModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'super' ? RealEstateSpecializedSuperFieldModelGetPayload<S['select'][P]> :
        P extends 'real_estate_agents' ? Array < RealEstateAgentModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? RealEstateSpecializedSubFieldModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof RealEstateSpecializedSubFieldModel ? RealEstateSpecializedSubFieldModel[P] : never
  } 
      : RealEstateSpecializedSubFieldModel


  type RealEstateSpecializedSubFieldModelCountArgs = 
    Omit<RealEstateSpecializedSubFieldModelFindManyArgs, 'select' | 'include'> & {
      select?: RealEstateSpecializedSubFieldModelCountAggregateInputType | true
    }

  export interface RealEstateSpecializedSubFieldModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one RealEstateSpecializedSubFieldModel that matches the filter.
     * @param {RealEstateSpecializedSubFieldModelFindUniqueArgs} args - Arguments to find a RealEstateSpecializedSubFieldModel
     * @example
     * // Get one RealEstateSpecializedSubFieldModel
     * const realEstateSpecializedSubFieldModel = await prisma.realEstateSpecializedSubFieldModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RealEstateSpecializedSubFieldModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RealEstateSpecializedSubFieldModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RealEstateSpecializedSubFieldModel'> extends True ? Prisma__RealEstateSpecializedSubFieldModelClient<RealEstateSpecializedSubFieldModelGetPayload<T>> : Prisma__RealEstateSpecializedSubFieldModelClient<RealEstateSpecializedSubFieldModelGetPayload<T> | null, null>

    /**
     * Find one RealEstateSpecializedSubFieldModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RealEstateSpecializedSubFieldModelFindUniqueOrThrowArgs} args - Arguments to find a RealEstateSpecializedSubFieldModel
     * @example
     * // Get one RealEstateSpecializedSubFieldModel
     * const realEstateSpecializedSubFieldModel = await prisma.realEstateSpecializedSubFieldModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RealEstateSpecializedSubFieldModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RealEstateSpecializedSubFieldModelFindUniqueOrThrowArgs>
    ): Prisma__RealEstateSpecializedSubFieldModelClient<RealEstateSpecializedSubFieldModelGetPayload<T>>

    /**
     * Find the first RealEstateSpecializedSubFieldModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateSpecializedSubFieldModelFindFirstArgs} args - Arguments to find a RealEstateSpecializedSubFieldModel
     * @example
     * // Get one RealEstateSpecializedSubFieldModel
     * const realEstateSpecializedSubFieldModel = await prisma.realEstateSpecializedSubFieldModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RealEstateSpecializedSubFieldModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RealEstateSpecializedSubFieldModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RealEstateSpecializedSubFieldModel'> extends True ? Prisma__RealEstateSpecializedSubFieldModelClient<RealEstateSpecializedSubFieldModelGetPayload<T>> : Prisma__RealEstateSpecializedSubFieldModelClient<RealEstateSpecializedSubFieldModelGetPayload<T> | null, null>

    /**
     * Find the first RealEstateSpecializedSubFieldModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateSpecializedSubFieldModelFindFirstOrThrowArgs} args - Arguments to find a RealEstateSpecializedSubFieldModel
     * @example
     * // Get one RealEstateSpecializedSubFieldModel
     * const realEstateSpecializedSubFieldModel = await prisma.realEstateSpecializedSubFieldModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RealEstateSpecializedSubFieldModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RealEstateSpecializedSubFieldModelFindFirstOrThrowArgs>
    ): Prisma__RealEstateSpecializedSubFieldModelClient<RealEstateSpecializedSubFieldModelGetPayload<T>>

    /**
     * Find zero or more RealEstateSpecializedSubFieldModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateSpecializedSubFieldModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RealEstateSpecializedSubFieldModels
     * const realEstateSpecializedSubFieldModels = await prisma.realEstateSpecializedSubFieldModel.findMany()
     * 
     * // Get first 10 RealEstateSpecializedSubFieldModels
     * const realEstateSpecializedSubFieldModels = await prisma.realEstateSpecializedSubFieldModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const realEstateSpecializedSubFieldModelWithIdOnly = await prisma.realEstateSpecializedSubFieldModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RealEstateSpecializedSubFieldModelFindManyArgs>(
      args?: SelectSubset<T, RealEstateSpecializedSubFieldModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<RealEstateSpecializedSubFieldModelGetPayload<T>>>

    /**
     * Create a RealEstateSpecializedSubFieldModel.
     * @param {RealEstateSpecializedSubFieldModelCreateArgs} args - Arguments to create a RealEstateSpecializedSubFieldModel.
     * @example
     * // Create one RealEstateSpecializedSubFieldModel
     * const RealEstateSpecializedSubFieldModel = await prisma.realEstateSpecializedSubFieldModel.create({
     *   data: {
     *     // ... data to create a RealEstateSpecializedSubFieldModel
     *   }
     * })
     * 
    **/
    create<T extends RealEstateSpecializedSubFieldModelCreateArgs>(
      args: SelectSubset<T, RealEstateSpecializedSubFieldModelCreateArgs>
    ): Prisma__RealEstateSpecializedSubFieldModelClient<RealEstateSpecializedSubFieldModelGetPayload<T>>

    /**
     * Create many RealEstateSpecializedSubFieldModels.
     *     @param {RealEstateSpecializedSubFieldModelCreateManyArgs} args - Arguments to create many RealEstateSpecializedSubFieldModels.
     *     @example
     *     // Create many RealEstateSpecializedSubFieldModels
     *     const realEstateSpecializedSubFieldModel = await prisma.realEstateSpecializedSubFieldModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RealEstateSpecializedSubFieldModelCreateManyArgs>(
      args?: SelectSubset<T, RealEstateSpecializedSubFieldModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RealEstateSpecializedSubFieldModel.
     * @param {RealEstateSpecializedSubFieldModelDeleteArgs} args - Arguments to delete one RealEstateSpecializedSubFieldModel.
     * @example
     * // Delete one RealEstateSpecializedSubFieldModel
     * const RealEstateSpecializedSubFieldModel = await prisma.realEstateSpecializedSubFieldModel.delete({
     *   where: {
     *     // ... filter to delete one RealEstateSpecializedSubFieldModel
     *   }
     * })
     * 
    **/
    delete<T extends RealEstateSpecializedSubFieldModelDeleteArgs>(
      args: SelectSubset<T, RealEstateSpecializedSubFieldModelDeleteArgs>
    ): Prisma__RealEstateSpecializedSubFieldModelClient<RealEstateSpecializedSubFieldModelGetPayload<T>>

    /**
     * Update one RealEstateSpecializedSubFieldModel.
     * @param {RealEstateSpecializedSubFieldModelUpdateArgs} args - Arguments to update one RealEstateSpecializedSubFieldModel.
     * @example
     * // Update one RealEstateSpecializedSubFieldModel
     * const realEstateSpecializedSubFieldModel = await prisma.realEstateSpecializedSubFieldModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RealEstateSpecializedSubFieldModelUpdateArgs>(
      args: SelectSubset<T, RealEstateSpecializedSubFieldModelUpdateArgs>
    ): Prisma__RealEstateSpecializedSubFieldModelClient<RealEstateSpecializedSubFieldModelGetPayload<T>>

    /**
     * Delete zero or more RealEstateSpecializedSubFieldModels.
     * @param {RealEstateSpecializedSubFieldModelDeleteManyArgs} args - Arguments to filter RealEstateSpecializedSubFieldModels to delete.
     * @example
     * // Delete a few RealEstateSpecializedSubFieldModels
     * const { count } = await prisma.realEstateSpecializedSubFieldModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RealEstateSpecializedSubFieldModelDeleteManyArgs>(
      args?: SelectSubset<T, RealEstateSpecializedSubFieldModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RealEstateSpecializedSubFieldModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateSpecializedSubFieldModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RealEstateSpecializedSubFieldModels
     * const realEstateSpecializedSubFieldModel = await prisma.realEstateSpecializedSubFieldModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RealEstateSpecializedSubFieldModelUpdateManyArgs>(
      args: SelectSubset<T, RealEstateSpecializedSubFieldModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RealEstateSpecializedSubFieldModel.
     * @param {RealEstateSpecializedSubFieldModelUpsertArgs} args - Arguments to update or create a RealEstateSpecializedSubFieldModel.
     * @example
     * // Update or create a RealEstateSpecializedSubFieldModel
     * const realEstateSpecializedSubFieldModel = await prisma.realEstateSpecializedSubFieldModel.upsert({
     *   create: {
     *     // ... data to create a RealEstateSpecializedSubFieldModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RealEstateSpecializedSubFieldModel we want to update
     *   }
     * })
    **/
    upsert<T extends RealEstateSpecializedSubFieldModelUpsertArgs>(
      args: SelectSubset<T, RealEstateSpecializedSubFieldModelUpsertArgs>
    ): Prisma__RealEstateSpecializedSubFieldModelClient<RealEstateSpecializedSubFieldModelGetPayload<T>>

    /**
     * Count the number of RealEstateSpecializedSubFieldModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateSpecializedSubFieldModelCountArgs} args - Arguments to filter RealEstateSpecializedSubFieldModels to count.
     * @example
     * // Count the number of RealEstateSpecializedSubFieldModels
     * const count = await prisma.realEstateSpecializedSubFieldModel.count({
     *   where: {
     *     // ... the filter for the RealEstateSpecializedSubFieldModels we want to count
     *   }
     * })
    **/
    count<T extends RealEstateSpecializedSubFieldModelCountArgs>(
      args?: Subset<T, RealEstateSpecializedSubFieldModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RealEstateSpecializedSubFieldModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RealEstateSpecializedSubFieldModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateSpecializedSubFieldModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RealEstateSpecializedSubFieldModelAggregateArgs>(args: Subset<T, RealEstateSpecializedSubFieldModelAggregateArgs>): Prisma.PrismaPromise<GetRealEstateSpecializedSubFieldModelAggregateType<T>>

    /**
     * Group by RealEstateSpecializedSubFieldModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealEstateSpecializedSubFieldModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RealEstateSpecializedSubFieldModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RealEstateSpecializedSubFieldModelGroupByArgs['orderBy'] }
        : { orderBy?: RealEstateSpecializedSubFieldModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RealEstateSpecializedSubFieldModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRealEstateSpecializedSubFieldModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RealEstateSpecializedSubFieldModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RealEstateSpecializedSubFieldModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    super<T extends RealEstateSpecializedSuperFieldModelArgs= {}>(args?: Subset<T, RealEstateSpecializedSuperFieldModelArgs>): Prisma__RealEstateSpecializedSuperFieldModelClient<RealEstateSpecializedSuperFieldModelGetPayload<T> | Null>;

    real_estate_agents<T extends RealEstateSpecializedSubFieldModel$real_estate_agentsArgs= {}>(args?: Subset<T, RealEstateSpecializedSubFieldModel$real_estate_agentsArgs>): Prisma.PrismaPromise<Array<RealEstateAgentModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RealEstateSpecializedSubFieldModel base type for findUnique actions
   */
  export type RealEstateSpecializedSubFieldModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RealEstateSpecializedSubFieldModel
     */
    select?: RealEstateSpecializedSubFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateSpecializedSubFieldModelInclude | null
    /**
     * Filter, which RealEstateSpecializedSubFieldModel to fetch.
     */
    where: RealEstateSpecializedSubFieldModelWhereUniqueInput
  }

  /**
   * RealEstateSpecializedSubFieldModel findUnique
   */
  export interface RealEstateSpecializedSubFieldModelFindUniqueArgs extends RealEstateSpecializedSubFieldModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RealEstateSpecializedSubFieldModel findUniqueOrThrow
   */
  export type RealEstateSpecializedSubFieldModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RealEstateSpecializedSubFieldModel
     */
    select?: RealEstateSpecializedSubFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateSpecializedSubFieldModelInclude | null
    /**
     * Filter, which RealEstateSpecializedSubFieldModel to fetch.
     */
    where: RealEstateSpecializedSubFieldModelWhereUniqueInput
  }


  /**
   * RealEstateSpecializedSubFieldModel base type for findFirst actions
   */
  export type RealEstateSpecializedSubFieldModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RealEstateSpecializedSubFieldModel
     */
    select?: RealEstateSpecializedSubFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateSpecializedSubFieldModelInclude | null
    /**
     * Filter, which RealEstateSpecializedSubFieldModel to fetch.
     */
    where?: RealEstateSpecializedSubFieldModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateSpecializedSubFieldModels to fetch.
     */
    orderBy?: Enumerable<RealEstateSpecializedSubFieldModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RealEstateSpecializedSubFieldModels.
     */
    cursor?: RealEstateSpecializedSubFieldModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateSpecializedSubFieldModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateSpecializedSubFieldModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RealEstateSpecializedSubFieldModels.
     */
    distinct?: Enumerable<RealEstateSpecializedSubFieldModelScalarFieldEnum>
  }

  /**
   * RealEstateSpecializedSubFieldModel findFirst
   */
  export interface RealEstateSpecializedSubFieldModelFindFirstArgs extends RealEstateSpecializedSubFieldModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RealEstateSpecializedSubFieldModel findFirstOrThrow
   */
  export type RealEstateSpecializedSubFieldModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RealEstateSpecializedSubFieldModel
     */
    select?: RealEstateSpecializedSubFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateSpecializedSubFieldModelInclude | null
    /**
     * Filter, which RealEstateSpecializedSubFieldModel to fetch.
     */
    where?: RealEstateSpecializedSubFieldModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateSpecializedSubFieldModels to fetch.
     */
    orderBy?: Enumerable<RealEstateSpecializedSubFieldModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RealEstateSpecializedSubFieldModels.
     */
    cursor?: RealEstateSpecializedSubFieldModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateSpecializedSubFieldModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateSpecializedSubFieldModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RealEstateSpecializedSubFieldModels.
     */
    distinct?: Enumerable<RealEstateSpecializedSubFieldModelScalarFieldEnum>
  }


  /**
   * RealEstateSpecializedSubFieldModel findMany
   */
  export type RealEstateSpecializedSubFieldModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the RealEstateSpecializedSubFieldModel
     */
    select?: RealEstateSpecializedSubFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateSpecializedSubFieldModelInclude | null
    /**
     * Filter, which RealEstateSpecializedSubFieldModels to fetch.
     */
    where?: RealEstateSpecializedSubFieldModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealEstateSpecializedSubFieldModels to fetch.
     */
    orderBy?: Enumerable<RealEstateSpecializedSubFieldModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RealEstateSpecializedSubFieldModels.
     */
    cursor?: RealEstateSpecializedSubFieldModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealEstateSpecializedSubFieldModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealEstateSpecializedSubFieldModels.
     */
    skip?: number
    distinct?: Enumerable<RealEstateSpecializedSubFieldModelScalarFieldEnum>
  }


  /**
   * RealEstateSpecializedSubFieldModel create
   */
  export type RealEstateSpecializedSubFieldModelCreateArgs = {
    /**
     * Select specific fields to fetch from the RealEstateSpecializedSubFieldModel
     */
    select?: RealEstateSpecializedSubFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateSpecializedSubFieldModelInclude | null
    /**
     * The data needed to create a RealEstateSpecializedSubFieldModel.
     */
    data: XOR<RealEstateSpecializedSubFieldModelCreateInput, RealEstateSpecializedSubFieldModelUncheckedCreateInput>
  }


  /**
   * RealEstateSpecializedSubFieldModel createMany
   */
  export type RealEstateSpecializedSubFieldModelCreateManyArgs = {
    /**
     * The data used to create many RealEstateSpecializedSubFieldModels.
     */
    data: Enumerable<RealEstateSpecializedSubFieldModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RealEstateSpecializedSubFieldModel update
   */
  export type RealEstateSpecializedSubFieldModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the RealEstateSpecializedSubFieldModel
     */
    select?: RealEstateSpecializedSubFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateSpecializedSubFieldModelInclude | null
    /**
     * The data needed to update a RealEstateSpecializedSubFieldModel.
     */
    data: XOR<RealEstateSpecializedSubFieldModelUpdateInput, RealEstateSpecializedSubFieldModelUncheckedUpdateInput>
    /**
     * Choose, which RealEstateSpecializedSubFieldModel to update.
     */
    where: RealEstateSpecializedSubFieldModelWhereUniqueInput
  }


  /**
   * RealEstateSpecializedSubFieldModel updateMany
   */
  export type RealEstateSpecializedSubFieldModelUpdateManyArgs = {
    /**
     * The data used to update RealEstateSpecializedSubFieldModels.
     */
    data: XOR<RealEstateSpecializedSubFieldModelUpdateManyMutationInput, RealEstateSpecializedSubFieldModelUncheckedUpdateManyInput>
    /**
     * Filter which RealEstateSpecializedSubFieldModels to update
     */
    where?: RealEstateSpecializedSubFieldModelWhereInput
  }


  /**
   * RealEstateSpecializedSubFieldModel upsert
   */
  export type RealEstateSpecializedSubFieldModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the RealEstateSpecializedSubFieldModel
     */
    select?: RealEstateSpecializedSubFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateSpecializedSubFieldModelInclude | null
    /**
     * The filter to search for the RealEstateSpecializedSubFieldModel to update in case it exists.
     */
    where: RealEstateSpecializedSubFieldModelWhereUniqueInput
    /**
     * In case the RealEstateSpecializedSubFieldModel found by the `where` argument doesn't exist, create a new RealEstateSpecializedSubFieldModel with this data.
     */
    create: XOR<RealEstateSpecializedSubFieldModelCreateInput, RealEstateSpecializedSubFieldModelUncheckedCreateInput>
    /**
     * In case the RealEstateSpecializedSubFieldModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RealEstateSpecializedSubFieldModelUpdateInput, RealEstateSpecializedSubFieldModelUncheckedUpdateInput>
  }


  /**
   * RealEstateSpecializedSubFieldModel delete
   */
  export type RealEstateSpecializedSubFieldModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the RealEstateSpecializedSubFieldModel
     */
    select?: RealEstateSpecializedSubFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateSpecializedSubFieldModelInclude | null
    /**
     * Filter which RealEstateSpecializedSubFieldModel to delete.
     */
    where: RealEstateSpecializedSubFieldModelWhereUniqueInput
  }


  /**
   * RealEstateSpecializedSubFieldModel deleteMany
   */
  export type RealEstateSpecializedSubFieldModelDeleteManyArgs = {
    /**
     * Filter which RealEstateSpecializedSubFieldModels to delete
     */
    where?: RealEstateSpecializedSubFieldModelWhereInput
  }


  /**
   * RealEstateSpecializedSubFieldModel.real_estate_agents
   */
  export type RealEstateSpecializedSubFieldModel$real_estate_agentsArgs = {
    /**
     * Select specific fields to fetch from the RealEstateAgentModel
     */
    select?: RealEstateAgentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateAgentModelInclude | null
    where?: RealEstateAgentModelWhereInput
    orderBy?: Enumerable<RealEstateAgentModelOrderByWithRelationInput>
    cursor?: RealEstateAgentModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RealEstateAgentModelScalarFieldEnum>
  }


  /**
   * RealEstateSpecializedSubFieldModel without action
   */
  export type RealEstateSpecializedSubFieldModelArgs = {
    /**
     * Select specific fields to fetch from the RealEstateSpecializedSubFieldModel
     */
    select?: RealEstateSpecializedSubFieldModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RealEstateSpecializedSubFieldModelInclude | null
  }



  /**
   * Model BusinessRateModel
   */


  export type AggregateBusinessRateModel = {
    _count: BusinessRateModelCountAggregateOutputType | null
    _avg: BusinessRateModelAvgAggregateOutputType | null
    _sum: BusinessRateModelSumAggregateOutputType | null
    _min: BusinessRateModelMinAggregateOutputType | null
    _max: BusinessRateModelMaxAggregateOutputType | null
  }

  export type BusinessRateModelAvgAggregateOutputType = {
    rate: number | null
  }

  export type BusinessRateModelSumAggregateOutputType = {
    rate: number | null
  }

  export type BusinessRateModelMinAggregateOutputType = {
    id: string | null
    category_id: string | null
    ratee_id: string | null
    rater_id: string | null
    rate: number | null
  }

  export type BusinessRateModelMaxAggregateOutputType = {
    id: string | null
    category_id: string | null
    ratee_id: string | null
    rater_id: string | null
    rate: number | null
  }

  export type BusinessRateModelCountAggregateOutputType = {
    id: number
    category_id: number
    ratee_id: number
    rater_id: number
    rate: number
    _all: number
  }


  export type BusinessRateModelAvgAggregateInputType = {
    rate?: true
  }

  export type BusinessRateModelSumAggregateInputType = {
    rate?: true
  }

  export type BusinessRateModelMinAggregateInputType = {
    id?: true
    category_id?: true
    ratee_id?: true
    rater_id?: true
    rate?: true
  }

  export type BusinessRateModelMaxAggregateInputType = {
    id?: true
    category_id?: true
    ratee_id?: true
    rater_id?: true
    rate?: true
  }

  export type BusinessRateModelCountAggregateInputType = {
    id?: true
    category_id?: true
    ratee_id?: true
    rater_id?: true
    rate?: true
    _all?: true
  }

  export type BusinessRateModelAggregateArgs = {
    /**
     * Filter which BusinessRateModel to aggregate.
     */
    where?: BusinessRateModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessRateModels to fetch.
     */
    orderBy?: Enumerable<BusinessRateModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessRateModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessRateModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessRateModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessRateModels
    **/
    _count?: true | BusinessRateModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessRateModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessRateModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessRateModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessRateModelMaxAggregateInputType
  }

  export type GetBusinessRateModelAggregateType<T extends BusinessRateModelAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessRateModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessRateModel[P]>
      : GetScalarType<T[P], AggregateBusinessRateModel[P]>
  }




  export type BusinessRateModelGroupByArgs = {
    where?: BusinessRateModelWhereInput
    orderBy?: Enumerable<BusinessRateModelOrderByWithAggregationInput>
    by: BusinessRateModelScalarFieldEnum[]
    having?: BusinessRateModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessRateModelCountAggregateInputType | true
    _avg?: BusinessRateModelAvgAggregateInputType
    _sum?: BusinessRateModelSumAggregateInputType
    _min?: BusinessRateModelMinAggregateInputType
    _max?: BusinessRateModelMaxAggregateInputType
  }


  export type BusinessRateModelGroupByOutputType = {
    id: string
    category_id: string
    ratee_id: string
    rater_id: string
    rate: number
    _count: BusinessRateModelCountAggregateOutputType | null
    _avg: BusinessRateModelAvgAggregateOutputType | null
    _sum: BusinessRateModelSumAggregateOutputType | null
    _min: BusinessRateModelMinAggregateOutputType | null
    _max: BusinessRateModelMaxAggregateOutputType | null
  }

  type GetBusinessRateModelGroupByPayload<T extends BusinessRateModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BusinessRateModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessRateModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessRateModelGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessRateModelGroupByOutputType[P]>
        }
      >
    >


  export type BusinessRateModelSelect = {
    id?: boolean
    category_id?: boolean
    ratee_id?: boolean
    rater_id?: boolean
    rate?: boolean
    ratee?: boolean | BusinessUserModelArgs
    rater?: boolean | CustomerModelArgs
    category?: boolean | BusinessRateCategoryModelArgs
  }


  export type BusinessRateModelInclude = {
    ratee?: boolean | BusinessUserModelArgs
    rater?: boolean | CustomerModelArgs
    category?: boolean | BusinessRateCategoryModelArgs
  }

  export type BusinessRateModelGetPayload<S extends boolean | null | undefined | BusinessRateModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BusinessRateModel :
    S extends undefined ? never :
    S extends { include: any } & (BusinessRateModelArgs | BusinessRateModelFindManyArgs)
    ? BusinessRateModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ratee' ? BusinessUserModelGetPayload<S['include'][P]> :
        P extends 'rater' ? CustomerModelGetPayload<S['include'][P]> :
        P extends 'category' ? BusinessRateCategoryModelGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BusinessRateModelArgs | BusinessRateModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ratee' ? BusinessUserModelGetPayload<S['select'][P]> :
        P extends 'rater' ? CustomerModelGetPayload<S['select'][P]> :
        P extends 'category' ? BusinessRateCategoryModelGetPayload<S['select'][P]> :  P extends keyof BusinessRateModel ? BusinessRateModel[P] : never
  } 
      : BusinessRateModel


  type BusinessRateModelCountArgs = 
    Omit<BusinessRateModelFindManyArgs, 'select' | 'include'> & {
      select?: BusinessRateModelCountAggregateInputType | true
    }

  export interface BusinessRateModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BusinessRateModel that matches the filter.
     * @param {BusinessRateModelFindUniqueArgs} args - Arguments to find a BusinessRateModel
     * @example
     * // Get one BusinessRateModel
     * const businessRateModel = await prisma.businessRateModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BusinessRateModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BusinessRateModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BusinessRateModel'> extends True ? Prisma__BusinessRateModelClient<BusinessRateModelGetPayload<T>> : Prisma__BusinessRateModelClient<BusinessRateModelGetPayload<T> | null, null>

    /**
     * Find one BusinessRateModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BusinessRateModelFindUniqueOrThrowArgs} args - Arguments to find a BusinessRateModel
     * @example
     * // Get one BusinessRateModel
     * const businessRateModel = await prisma.businessRateModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BusinessRateModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BusinessRateModelFindUniqueOrThrowArgs>
    ): Prisma__BusinessRateModelClient<BusinessRateModelGetPayload<T>>

    /**
     * Find the first BusinessRateModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRateModelFindFirstArgs} args - Arguments to find a BusinessRateModel
     * @example
     * // Get one BusinessRateModel
     * const businessRateModel = await prisma.businessRateModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BusinessRateModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BusinessRateModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BusinessRateModel'> extends True ? Prisma__BusinessRateModelClient<BusinessRateModelGetPayload<T>> : Prisma__BusinessRateModelClient<BusinessRateModelGetPayload<T> | null, null>

    /**
     * Find the first BusinessRateModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRateModelFindFirstOrThrowArgs} args - Arguments to find a BusinessRateModel
     * @example
     * // Get one BusinessRateModel
     * const businessRateModel = await prisma.businessRateModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BusinessRateModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BusinessRateModelFindFirstOrThrowArgs>
    ): Prisma__BusinessRateModelClient<BusinessRateModelGetPayload<T>>

    /**
     * Find zero or more BusinessRateModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRateModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessRateModels
     * const businessRateModels = await prisma.businessRateModel.findMany()
     * 
     * // Get first 10 BusinessRateModels
     * const businessRateModels = await prisma.businessRateModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessRateModelWithIdOnly = await prisma.businessRateModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BusinessRateModelFindManyArgs>(
      args?: SelectSubset<T, BusinessRateModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<BusinessRateModelGetPayload<T>>>

    /**
     * Create a BusinessRateModel.
     * @param {BusinessRateModelCreateArgs} args - Arguments to create a BusinessRateModel.
     * @example
     * // Create one BusinessRateModel
     * const BusinessRateModel = await prisma.businessRateModel.create({
     *   data: {
     *     // ... data to create a BusinessRateModel
     *   }
     * })
     * 
    **/
    create<T extends BusinessRateModelCreateArgs>(
      args: SelectSubset<T, BusinessRateModelCreateArgs>
    ): Prisma__BusinessRateModelClient<BusinessRateModelGetPayload<T>>

    /**
     * Create many BusinessRateModels.
     *     @param {BusinessRateModelCreateManyArgs} args - Arguments to create many BusinessRateModels.
     *     @example
     *     // Create many BusinessRateModels
     *     const businessRateModel = await prisma.businessRateModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BusinessRateModelCreateManyArgs>(
      args?: SelectSubset<T, BusinessRateModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BusinessRateModel.
     * @param {BusinessRateModelDeleteArgs} args - Arguments to delete one BusinessRateModel.
     * @example
     * // Delete one BusinessRateModel
     * const BusinessRateModel = await prisma.businessRateModel.delete({
     *   where: {
     *     // ... filter to delete one BusinessRateModel
     *   }
     * })
     * 
    **/
    delete<T extends BusinessRateModelDeleteArgs>(
      args: SelectSubset<T, BusinessRateModelDeleteArgs>
    ): Prisma__BusinessRateModelClient<BusinessRateModelGetPayload<T>>

    /**
     * Update one BusinessRateModel.
     * @param {BusinessRateModelUpdateArgs} args - Arguments to update one BusinessRateModel.
     * @example
     * // Update one BusinessRateModel
     * const businessRateModel = await prisma.businessRateModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BusinessRateModelUpdateArgs>(
      args: SelectSubset<T, BusinessRateModelUpdateArgs>
    ): Prisma__BusinessRateModelClient<BusinessRateModelGetPayload<T>>

    /**
     * Delete zero or more BusinessRateModels.
     * @param {BusinessRateModelDeleteManyArgs} args - Arguments to filter BusinessRateModels to delete.
     * @example
     * // Delete a few BusinessRateModels
     * const { count } = await prisma.businessRateModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BusinessRateModelDeleteManyArgs>(
      args?: SelectSubset<T, BusinessRateModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessRateModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRateModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessRateModels
     * const businessRateModel = await prisma.businessRateModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BusinessRateModelUpdateManyArgs>(
      args: SelectSubset<T, BusinessRateModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessRateModel.
     * @param {BusinessRateModelUpsertArgs} args - Arguments to update or create a BusinessRateModel.
     * @example
     * // Update or create a BusinessRateModel
     * const businessRateModel = await prisma.businessRateModel.upsert({
     *   create: {
     *     // ... data to create a BusinessRateModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessRateModel we want to update
     *   }
     * })
    **/
    upsert<T extends BusinessRateModelUpsertArgs>(
      args: SelectSubset<T, BusinessRateModelUpsertArgs>
    ): Prisma__BusinessRateModelClient<BusinessRateModelGetPayload<T>>

    /**
     * Count the number of BusinessRateModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRateModelCountArgs} args - Arguments to filter BusinessRateModels to count.
     * @example
     * // Count the number of BusinessRateModels
     * const count = await prisma.businessRateModel.count({
     *   where: {
     *     // ... the filter for the BusinessRateModels we want to count
     *   }
     * })
    **/
    count<T extends BusinessRateModelCountArgs>(
      args?: Subset<T, BusinessRateModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessRateModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessRateModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRateModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessRateModelAggregateArgs>(args: Subset<T, BusinessRateModelAggregateArgs>): Prisma.PrismaPromise<GetBusinessRateModelAggregateType<T>>

    /**
     * Group by BusinessRateModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRateModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessRateModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessRateModelGroupByArgs['orderBy'] }
        : { orderBy?: BusinessRateModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessRateModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessRateModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessRateModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BusinessRateModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ratee<T extends BusinessUserModelArgs= {}>(args?: Subset<T, BusinessUserModelArgs>): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T> | Null>;

    rater<T extends CustomerModelArgs= {}>(args?: Subset<T, CustomerModelArgs>): Prisma__CustomerModelClient<CustomerModelGetPayload<T> | Null>;

    category<T extends BusinessRateCategoryModelArgs= {}>(args?: Subset<T, BusinessRateCategoryModelArgs>): Prisma__BusinessRateCategoryModelClient<BusinessRateCategoryModelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BusinessRateModel base type for findUnique actions
   */
  export type BusinessRateModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BusinessRateModel
     */
    select?: BusinessRateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessRateModelInclude | null
    /**
     * Filter, which BusinessRateModel to fetch.
     */
    where: BusinessRateModelWhereUniqueInput
  }

  /**
   * BusinessRateModel findUnique
   */
  export interface BusinessRateModelFindUniqueArgs extends BusinessRateModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusinessRateModel findUniqueOrThrow
   */
  export type BusinessRateModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BusinessRateModel
     */
    select?: BusinessRateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessRateModelInclude | null
    /**
     * Filter, which BusinessRateModel to fetch.
     */
    where: BusinessRateModelWhereUniqueInput
  }


  /**
   * BusinessRateModel base type for findFirst actions
   */
  export type BusinessRateModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BusinessRateModel
     */
    select?: BusinessRateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessRateModelInclude | null
    /**
     * Filter, which BusinessRateModel to fetch.
     */
    where?: BusinessRateModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessRateModels to fetch.
     */
    orderBy?: Enumerable<BusinessRateModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessRateModels.
     */
    cursor?: BusinessRateModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessRateModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessRateModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessRateModels.
     */
    distinct?: Enumerable<BusinessRateModelScalarFieldEnum>
  }

  /**
   * BusinessRateModel findFirst
   */
  export interface BusinessRateModelFindFirstArgs extends BusinessRateModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusinessRateModel findFirstOrThrow
   */
  export type BusinessRateModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BusinessRateModel
     */
    select?: BusinessRateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessRateModelInclude | null
    /**
     * Filter, which BusinessRateModel to fetch.
     */
    where?: BusinessRateModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessRateModels to fetch.
     */
    orderBy?: Enumerable<BusinessRateModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessRateModels.
     */
    cursor?: BusinessRateModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessRateModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessRateModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessRateModels.
     */
    distinct?: Enumerable<BusinessRateModelScalarFieldEnum>
  }


  /**
   * BusinessRateModel findMany
   */
  export type BusinessRateModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the BusinessRateModel
     */
    select?: BusinessRateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessRateModelInclude | null
    /**
     * Filter, which BusinessRateModels to fetch.
     */
    where?: BusinessRateModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessRateModels to fetch.
     */
    orderBy?: Enumerable<BusinessRateModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessRateModels.
     */
    cursor?: BusinessRateModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessRateModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessRateModels.
     */
    skip?: number
    distinct?: Enumerable<BusinessRateModelScalarFieldEnum>
  }


  /**
   * BusinessRateModel create
   */
  export type BusinessRateModelCreateArgs = {
    /**
     * Select specific fields to fetch from the BusinessRateModel
     */
    select?: BusinessRateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessRateModelInclude | null
    /**
     * The data needed to create a BusinessRateModel.
     */
    data: XOR<BusinessRateModelCreateInput, BusinessRateModelUncheckedCreateInput>
  }


  /**
   * BusinessRateModel createMany
   */
  export type BusinessRateModelCreateManyArgs = {
    /**
     * The data used to create many BusinessRateModels.
     */
    data: Enumerable<BusinessRateModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BusinessRateModel update
   */
  export type BusinessRateModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the BusinessRateModel
     */
    select?: BusinessRateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessRateModelInclude | null
    /**
     * The data needed to update a BusinessRateModel.
     */
    data: XOR<BusinessRateModelUpdateInput, BusinessRateModelUncheckedUpdateInput>
    /**
     * Choose, which BusinessRateModel to update.
     */
    where: BusinessRateModelWhereUniqueInput
  }


  /**
   * BusinessRateModel updateMany
   */
  export type BusinessRateModelUpdateManyArgs = {
    /**
     * The data used to update BusinessRateModels.
     */
    data: XOR<BusinessRateModelUpdateManyMutationInput, BusinessRateModelUncheckedUpdateManyInput>
    /**
     * Filter which BusinessRateModels to update
     */
    where?: BusinessRateModelWhereInput
  }


  /**
   * BusinessRateModel upsert
   */
  export type BusinessRateModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the BusinessRateModel
     */
    select?: BusinessRateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessRateModelInclude | null
    /**
     * The filter to search for the BusinessRateModel to update in case it exists.
     */
    where: BusinessRateModelWhereUniqueInput
    /**
     * In case the BusinessRateModel found by the `where` argument doesn't exist, create a new BusinessRateModel with this data.
     */
    create: XOR<BusinessRateModelCreateInput, BusinessRateModelUncheckedCreateInput>
    /**
     * In case the BusinessRateModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessRateModelUpdateInput, BusinessRateModelUncheckedUpdateInput>
  }


  /**
   * BusinessRateModel delete
   */
  export type BusinessRateModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the BusinessRateModel
     */
    select?: BusinessRateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessRateModelInclude | null
    /**
     * Filter which BusinessRateModel to delete.
     */
    where: BusinessRateModelWhereUniqueInput
  }


  /**
   * BusinessRateModel deleteMany
   */
  export type BusinessRateModelDeleteManyArgs = {
    /**
     * Filter which BusinessRateModels to delete
     */
    where?: BusinessRateModelWhereInput
  }


  /**
   * BusinessRateModel without action
   */
  export type BusinessRateModelArgs = {
    /**
     * Select specific fields to fetch from the BusinessRateModel
     */
    select?: BusinessRateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessRateModelInclude | null
  }



  /**
   * Model BusinessRateCategoryModel
   */


  export type AggregateBusinessRateCategoryModel = {
    _count: BusinessRateCategoryModelCountAggregateOutputType | null
    _min: BusinessRateCategoryModelMinAggregateOutputType | null
    _max: BusinessRateCategoryModelMaxAggregateOutputType | null
  }

  export type BusinessRateCategoryModelMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type BusinessRateCategoryModelMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type BusinessRateCategoryModelCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type BusinessRateCategoryModelMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type BusinessRateCategoryModelMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type BusinessRateCategoryModelCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type BusinessRateCategoryModelAggregateArgs = {
    /**
     * Filter which BusinessRateCategoryModel to aggregate.
     */
    where?: BusinessRateCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessRateCategoryModels to fetch.
     */
    orderBy?: Enumerable<BusinessRateCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessRateCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessRateCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessRateCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessRateCategoryModels
    **/
    _count?: true | BusinessRateCategoryModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessRateCategoryModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessRateCategoryModelMaxAggregateInputType
  }

  export type GetBusinessRateCategoryModelAggregateType<T extends BusinessRateCategoryModelAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessRateCategoryModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessRateCategoryModel[P]>
      : GetScalarType<T[P], AggregateBusinessRateCategoryModel[P]>
  }




  export type BusinessRateCategoryModelGroupByArgs = {
    where?: BusinessRateCategoryModelWhereInput
    orderBy?: Enumerable<BusinessRateCategoryModelOrderByWithAggregationInput>
    by: BusinessRateCategoryModelScalarFieldEnum[]
    having?: BusinessRateCategoryModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessRateCategoryModelCountAggregateInputType | true
    _min?: BusinessRateCategoryModelMinAggregateInputType
    _max?: BusinessRateCategoryModelMaxAggregateInputType
  }


  export type BusinessRateCategoryModelGroupByOutputType = {
    id: string
    name: string
    _count: BusinessRateCategoryModelCountAggregateOutputType | null
    _min: BusinessRateCategoryModelMinAggregateOutputType | null
    _max: BusinessRateCategoryModelMaxAggregateOutputType | null
  }

  type GetBusinessRateCategoryModelGroupByPayload<T extends BusinessRateCategoryModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BusinessRateCategoryModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessRateCategoryModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessRateCategoryModelGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessRateCategoryModelGroupByOutputType[P]>
        }
      >
    >


  export type BusinessRateCategoryModelSelect = {
    id?: boolean
    name?: boolean
    rates?: boolean | BusinessRateCategoryModel$ratesArgs
    _count?: boolean | BusinessRateCategoryModelCountOutputTypeArgs
  }


  export type BusinessRateCategoryModelInclude = {
    rates?: boolean | BusinessRateCategoryModel$ratesArgs
    _count?: boolean | BusinessRateCategoryModelCountOutputTypeArgs
  }

  export type BusinessRateCategoryModelGetPayload<S extends boolean | null | undefined | BusinessRateCategoryModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BusinessRateCategoryModel :
    S extends undefined ? never :
    S extends { include: any } & (BusinessRateCategoryModelArgs | BusinessRateCategoryModelFindManyArgs)
    ? BusinessRateCategoryModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'rates' ? Array < BusinessRateModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? BusinessRateCategoryModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BusinessRateCategoryModelArgs | BusinessRateCategoryModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'rates' ? Array < BusinessRateModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? BusinessRateCategoryModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BusinessRateCategoryModel ? BusinessRateCategoryModel[P] : never
  } 
      : BusinessRateCategoryModel


  type BusinessRateCategoryModelCountArgs = 
    Omit<BusinessRateCategoryModelFindManyArgs, 'select' | 'include'> & {
      select?: BusinessRateCategoryModelCountAggregateInputType | true
    }

  export interface BusinessRateCategoryModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BusinessRateCategoryModel that matches the filter.
     * @param {BusinessRateCategoryModelFindUniqueArgs} args - Arguments to find a BusinessRateCategoryModel
     * @example
     * // Get one BusinessRateCategoryModel
     * const businessRateCategoryModel = await prisma.businessRateCategoryModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BusinessRateCategoryModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BusinessRateCategoryModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BusinessRateCategoryModel'> extends True ? Prisma__BusinessRateCategoryModelClient<BusinessRateCategoryModelGetPayload<T>> : Prisma__BusinessRateCategoryModelClient<BusinessRateCategoryModelGetPayload<T> | null, null>

    /**
     * Find one BusinessRateCategoryModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BusinessRateCategoryModelFindUniqueOrThrowArgs} args - Arguments to find a BusinessRateCategoryModel
     * @example
     * // Get one BusinessRateCategoryModel
     * const businessRateCategoryModel = await prisma.businessRateCategoryModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BusinessRateCategoryModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BusinessRateCategoryModelFindUniqueOrThrowArgs>
    ): Prisma__BusinessRateCategoryModelClient<BusinessRateCategoryModelGetPayload<T>>

    /**
     * Find the first BusinessRateCategoryModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRateCategoryModelFindFirstArgs} args - Arguments to find a BusinessRateCategoryModel
     * @example
     * // Get one BusinessRateCategoryModel
     * const businessRateCategoryModel = await prisma.businessRateCategoryModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BusinessRateCategoryModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BusinessRateCategoryModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BusinessRateCategoryModel'> extends True ? Prisma__BusinessRateCategoryModelClient<BusinessRateCategoryModelGetPayload<T>> : Prisma__BusinessRateCategoryModelClient<BusinessRateCategoryModelGetPayload<T> | null, null>

    /**
     * Find the first BusinessRateCategoryModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRateCategoryModelFindFirstOrThrowArgs} args - Arguments to find a BusinessRateCategoryModel
     * @example
     * // Get one BusinessRateCategoryModel
     * const businessRateCategoryModel = await prisma.businessRateCategoryModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BusinessRateCategoryModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BusinessRateCategoryModelFindFirstOrThrowArgs>
    ): Prisma__BusinessRateCategoryModelClient<BusinessRateCategoryModelGetPayload<T>>

    /**
     * Find zero or more BusinessRateCategoryModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRateCategoryModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessRateCategoryModels
     * const businessRateCategoryModels = await prisma.businessRateCategoryModel.findMany()
     * 
     * // Get first 10 BusinessRateCategoryModels
     * const businessRateCategoryModels = await prisma.businessRateCategoryModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessRateCategoryModelWithIdOnly = await prisma.businessRateCategoryModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BusinessRateCategoryModelFindManyArgs>(
      args?: SelectSubset<T, BusinessRateCategoryModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<BusinessRateCategoryModelGetPayload<T>>>

    /**
     * Create a BusinessRateCategoryModel.
     * @param {BusinessRateCategoryModelCreateArgs} args - Arguments to create a BusinessRateCategoryModel.
     * @example
     * // Create one BusinessRateCategoryModel
     * const BusinessRateCategoryModel = await prisma.businessRateCategoryModel.create({
     *   data: {
     *     // ... data to create a BusinessRateCategoryModel
     *   }
     * })
     * 
    **/
    create<T extends BusinessRateCategoryModelCreateArgs>(
      args: SelectSubset<T, BusinessRateCategoryModelCreateArgs>
    ): Prisma__BusinessRateCategoryModelClient<BusinessRateCategoryModelGetPayload<T>>

    /**
     * Create many BusinessRateCategoryModels.
     *     @param {BusinessRateCategoryModelCreateManyArgs} args - Arguments to create many BusinessRateCategoryModels.
     *     @example
     *     // Create many BusinessRateCategoryModels
     *     const businessRateCategoryModel = await prisma.businessRateCategoryModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BusinessRateCategoryModelCreateManyArgs>(
      args?: SelectSubset<T, BusinessRateCategoryModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BusinessRateCategoryModel.
     * @param {BusinessRateCategoryModelDeleteArgs} args - Arguments to delete one BusinessRateCategoryModel.
     * @example
     * // Delete one BusinessRateCategoryModel
     * const BusinessRateCategoryModel = await prisma.businessRateCategoryModel.delete({
     *   where: {
     *     // ... filter to delete one BusinessRateCategoryModel
     *   }
     * })
     * 
    **/
    delete<T extends BusinessRateCategoryModelDeleteArgs>(
      args: SelectSubset<T, BusinessRateCategoryModelDeleteArgs>
    ): Prisma__BusinessRateCategoryModelClient<BusinessRateCategoryModelGetPayload<T>>

    /**
     * Update one BusinessRateCategoryModel.
     * @param {BusinessRateCategoryModelUpdateArgs} args - Arguments to update one BusinessRateCategoryModel.
     * @example
     * // Update one BusinessRateCategoryModel
     * const businessRateCategoryModel = await prisma.businessRateCategoryModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BusinessRateCategoryModelUpdateArgs>(
      args: SelectSubset<T, BusinessRateCategoryModelUpdateArgs>
    ): Prisma__BusinessRateCategoryModelClient<BusinessRateCategoryModelGetPayload<T>>

    /**
     * Delete zero or more BusinessRateCategoryModels.
     * @param {BusinessRateCategoryModelDeleteManyArgs} args - Arguments to filter BusinessRateCategoryModels to delete.
     * @example
     * // Delete a few BusinessRateCategoryModels
     * const { count } = await prisma.businessRateCategoryModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BusinessRateCategoryModelDeleteManyArgs>(
      args?: SelectSubset<T, BusinessRateCategoryModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessRateCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRateCategoryModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessRateCategoryModels
     * const businessRateCategoryModel = await prisma.businessRateCategoryModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BusinessRateCategoryModelUpdateManyArgs>(
      args: SelectSubset<T, BusinessRateCategoryModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessRateCategoryModel.
     * @param {BusinessRateCategoryModelUpsertArgs} args - Arguments to update or create a BusinessRateCategoryModel.
     * @example
     * // Update or create a BusinessRateCategoryModel
     * const businessRateCategoryModel = await prisma.businessRateCategoryModel.upsert({
     *   create: {
     *     // ... data to create a BusinessRateCategoryModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessRateCategoryModel we want to update
     *   }
     * })
    **/
    upsert<T extends BusinessRateCategoryModelUpsertArgs>(
      args: SelectSubset<T, BusinessRateCategoryModelUpsertArgs>
    ): Prisma__BusinessRateCategoryModelClient<BusinessRateCategoryModelGetPayload<T>>

    /**
     * Count the number of BusinessRateCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRateCategoryModelCountArgs} args - Arguments to filter BusinessRateCategoryModels to count.
     * @example
     * // Count the number of BusinessRateCategoryModels
     * const count = await prisma.businessRateCategoryModel.count({
     *   where: {
     *     // ... the filter for the BusinessRateCategoryModels we want to count
     *   }
     * })
    **/
    count<T extends BusinessRateCategoryModelCountArgs>(
      args?: Subset<T, BusinessRateCategoryModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessRateCategoryModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessRateCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRateCategoryModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessRateCategoryModelAggregateArgs>(args: Subset<T, BusinessRateCategoryModelAggregateArgs>): Prisma.PrismaPromise<GetBusinessRateCategoryModelAggregateType<T>>

    /**
     * Group by BusinessRateCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessRateCategoryModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessRateCategoryModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessRateCategoryModelGroupByArgs['orderBy'] }
        : { orderBy?: BusinessRateCategoryModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessRateCategoryModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessRateCategoryModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessRateCategoryModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BusinessRateCategoryModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    rates<T extends BusinessRateCategoryModel$ratesArgs= {}>(args?: Subset<T, BusinessRateCategoryModel$ratesArgs>): Prisma.PrismaPromise<Array<BusinessRateModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BusinessRateCategoryModel base type for findUnique actions
   */
  export type BusinessRateCategoryModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BusinessRateCategoryModel
     */
    select?: BusinessRateCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessRateCategoryModelInclude | null
    /**
     * Filter, which BusinessRateCategoryModel to fetch.
     */
    where: BusinessRateCategoryModelWhereUniqueInput
  }

  /**
   * BusinessRateCategoryModel findUnique
   */
  export interface BusinessRateCategoryModelFindUniqueArgs extends BusinessRateCategoryModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusinessRateCategoryModel findUniqueOrThrow
   */
  export type BusinessRateCategoryModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BusinessRateCategoryModel
     */
    select?: BusinessRateCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessRateCategoryModelInclude | null
    /**
     * Filter, which BusinessRateCategoryModel to fetch.
     */
    where: BusinessRateCategoryModelWhereUniqueInput
  }


  /**
   * BusinessRateCategoryModel base type for findFirst actions
   */
  export type BusinessRateCategoryModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BusinessRateCategoryModel
     */
    select?: BusinessRateCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessRateCategoryModelInclude | null
    /**
     * Filter, which BusinessRateCategoryModel to fetch.
     */
    where?: BusinessRateCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessRateCategoryModels to fetch.
     */
    orderBy?: Enumerable<BusinessRateCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessRateCategoryModels.
     */
    cursor?: BusinessRateCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessRateCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessRateCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessRateCategoryModels.
     */
    distinct?: Enumerable<BusinessRateCategoryModelScalarFieldEnum>
  }

  /**
   * BusinessRateCategoryModel findFirst
   */
  export interface BusinessRateCategoryModelFindFirstArgs extends BusinessRateCategoryModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusinessRateCategoryModel findFirstOrThrow
   */
  export type BusinessRateCategoryModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BusinessRateCategoryModel
     */
    select?: BusinessRateCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessRateCategoryModelInclude | null
    /**
     * Filter, which BusinessRateCategoryModel to fetch.
     */
    where?: BusinessRateCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessRateCategoryModels to fetch.
     */
    orderBy?: Enumerable<BusinessRateCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessRateCategoryModels.
     */
    cursor?: BusinessRateCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessRateCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessRateCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessRateCategoryModels.
     */
    distinct?: Enumerable<BusinessRateCategoryModelScalarFieldEnum>
  }


  /**
   * BusinessRateCategoryModel findMany
   */
  export type BusinessRateCategoryModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the BusinessRateCategoryModel
     */
    select?: BusinessRateCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessRateCategoryModelInclude | null
    /**
     * Filter, which BusinessRateCategoryModels to fetch.
     */
    where?: BusinessRateCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessRateCategoryModels to fetch.
     */
    orderBy?: Enumerable<BusinessRateCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessRateCategoryModels.
     */
    cursor?: BusinessRateCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessRateCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessRateCategoryModels.
     */
    skip?: number
    distinct?: Enumerable<BusinessRateCategoryModelScalarFieldEnum>
  }


  /**
   * BusinessRateCategoryModel create
   */
  export type BusinessRateCategoryModelCreateArgs = {
    /**
     * Select specific fields to fetch from the BusinessRateCategoryModel
     */
    select?: BusinessRateCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessRateCategoryModelInclude | null
    /**
     * The data needed to create a BusinessRateCategoryModel.
     */
    data: XOR<BusinessRateCategoryModelCreateInput, BusinessRateCategoryModelUncheckedCreateInput>
  }


  /**
   * BusinessRateCategoryModel createMany
   */
  export type BusinessRateCategoryModelCreateManyArgs = {
    /**
     * The data used to create many BusinessRateCategoryModels.
     */
    data: Enumerable<BusinessRateCategoryModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BusinessRateCategoryModel update
   */
  export type BusinessRateCategoryModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the BusinessRateCategoryModel
     */
    select?: BusinessRateCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessRateCategoryModelInclude | null
    /**
     * The data needed to update a BusinessRateCategoryModel.
     */
    data: XOR<BusinessRateCategoryModelUpdateInput, BusinessRateCategoryModelUncheckedUpdateInput>
    /**
     * Choose, which BusinessRateCategoryModel to update.
     */
    where: BusinessRateCategoryModelWhereUniqueInput
  }


  /**
   * BusinessRateCategoryModel updateMany
   */
  export type BusinessRateCategoryModelUpdateManyArgs = {
    /**
     * The data used to update BusinessRateCategoryModels.
     */
    data: XOR<BusinessRateCategoryModelUpdateManyMutationInput, BusinessRateCategoryModelUncheckedUpdateManyInput>
    /**
     * Filter which BusinessRateCategoryModels to update
     */
    where?: BusinessRateCategoryModelWhereInput
  }


  /**
   * BusinessRateCategoryModel upsert
   */
  export type BusinessRateCategoryModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the BusinessRateCategoryModel
     */
    select?: BusinessRateCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessRateCategoryModelInclude | null
    /**
     * The filter to search for the BusinessRateCategoryModel to update in case it exists.
     */
    where: BusinessRateCategoryModelWhereUniqueInput
    /**
     * In case the BusinessRateCategoryModel found by the `where` argument doesn't exist, create a new BusinessRateCategoryModel with this data.
     */
    create: XOR<BusinessRateCategoryModelCreateInput, BusinessRateCategoryModelUncheckedCreateInput>
    /**
     * In case the BusinessRateCategoryModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessRateCategoryModelUpdateInput, BusinessRateCategoryModelUncheckedUpdateInput>
  }


  /**
   * BusinessRateCategoryModel delete
   */
  export type BusinessRateCategoryModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the BusinessRateCategoryModel
     */
    select?: BusinessRateCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessRateCategoryModelInclude | null
    /**
     * Filter which BusinessRateCategoryModel to delete.
     */
    where: BusinessRateCategoryModelWhereUniqueInput
  }


  /**
   * BusinessRateCategoryModel deleteMany
   */
  export type BusinessRateCategoryModelDeleteManyArgs = {
    /**
     * Filter which BusinessRateCategoryModels to delete
     */
    where?: BusinessRateCategoryModelWhereInput
  }


  /**
   * BusinessRateCategoryModel.rates
   */
  export type BusinessRateCategoryModel$ratesArgs = {
    /**
     * Select specific fields to fetch from the BusinessRateModel
     */
    select?: BusinessRateModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessRateModelInclude | null
    where?: BusinessRateModelWhereInput
    orderBy?: Enumerable<BusinessRateModelOrderByWithRelationInput>
    cursor?: BusinessRateModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BusinessRateModelScalarFieldEnum>
  }


  /**
   * BusinessRateCategoryModel without action
   */
  export type BusinessRateCategoryModelArgs = {
    /**
     * Select specific fields to fetch from the BusinessRateCategoryModel
     */
    select?: BusinessRateCategoryModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessRateCategoryModelInclude | null
  }



  /**
   * Model BusinessReviewModel
   */


  export type AggregateBusinessReviewModel = {
    _count: BusinessReviewModelCountAggregateOutputType | null
    _min: BusinessReviewModelMinAggregateOutputType | null
    _max: BusinessReviewModelMaxAggregateOutputType | null
  }

  export type BusinessReviewModelMinAggregateOutputType = {
    id: string | null
    reviewee_id: string | null
    reviewer_id: string | null
    review: string | null
  }

  export type BusinessReviewModelMaxAggregateOutputType = {
    id: string | null
    reviewee_id: string | null
    reviewer_id: string | null
    review: string | null
  }

  export type BusinessReviewModelCountAggregateOutputType = {
    id: number
    reviewee_id: number
    reviewer_id: number
    review: number
    _all: number
  }


  export type BusinessReviewModelMinAggregateInputType = {
    id?: true
    reviewee_id?: true
    reviewer_id?: true
    review?: true
  }

  export type BusinessReviewModelMaxAggregateInputType = {
    id?: true
    reviewee_id?: true
    reviewer_id?: true
    review?: true
  }

  export type BusinessReviewModelCountAggregateInputType = {
    id?: true
    reviewee_id?: true
    reviewer_id?: true
    review?: true
    _all?: true
  }

  export type BusinessReviewModelAggregateArgs = {
    /**
     * Filter which BusinessReviewModel to aggregate.
     */
    where?: BusinessReviewModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessReviewModels to fetch.
     */
    orderBy?: Enumerable<BusinessReviewModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessReviewModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessReviewModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessReviewModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessReviewModels
    **/
    _count?: true | BusinessReviewModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessReviewModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessReviewModelMaxAggregateInputType
  }

  export type GetBusinessReviewModelAggregateType<T extends BusinessReviewModelAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessReviewModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessReviewModel[P]>
      : GetScalarType<T[P], AggregateBusinessReviewModel[P]>
  }




  export type BusinessReviewModelGroupByArgs = {
    where?: BusinessReviewModelWhereInput
    orderBy?: Enumerable<BusinessReviewModelOrderByWithAggregationInput>
    by: BusinessReviewModelScalarFieldEnum[]
    having?: BusinessReviewModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessReviewModelCountAggregateInputType | true
    _min?: BusinessReviewModelMinAggregateInputType
    _max?: BusinessReviewModelMaxAggregateInputType
  }


  export type BusinessReviewModelGroupByOutputType = {
    id: string
    reviewee_id: string
    reviewer_id: string
    review: string
    _count: BusinessReviewModelCountAggregateOutputType | null
    _min: BusinessReviewModelMinAggregateOutputType | null
    _max: BusinessReviewModelMaxAggregateOutputType | null
  }

  type GetBusinessReviewModelGroupByPayload<T extends BusinessReviewModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BusinessReviewModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessReviewModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessReviewModelGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessReviewModelGroupByOutputType[P]>
        }
      >
    >


  export type BusinessReviewModelSelect = {
    id?: boolean
    reviewee_id?: boolean
    reviewer_id?: boolean
    review?: boolean
    reviewee?: boolean | BusinessUserModelArgs
    reviewer?: boolean | CustomerModelArgs
  }


  export type BusinessReviewModelInclude = {
    reviewee?: boolean | BusinessUserModelArgs
    reviewer?: boolean | CustomerModelArgs
  }

  export type BusinessReviewModelGetPayload<S extends boolean | null | undefined | BusinessReviewModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BusinessReviewModel :
    S extends undefined ? never :
    S extends { include: any } & (BusinessReviewModelArgs | BusinessReviewModelFindManyArgs)
    ? BusinessReviewModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'reviewee' ? BusinessUserModelGetPayload<S['include'][P]> :
        P extends 'reviewer' ? CustomerModelGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BusinessReviewModelArgs | BusinessReviewModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'reviewee' ? BusinessUserModelGetPayload<S['select'][P]> :
        P extends 'reviewer' ? CustomerModelGetPayload<S['select'][P]> :  P extends keyof BusinessReviewModel ? BusinessReviewModel[P] : never
  } 
      : BusinessReviewModel


  type BusinessReviewModelCountArgs = 
    Omit<BusinessReviewModelFindManyArgs, 'select' | 'include'> & {
      select?: BusinessReviewModelCountAggregateInputType | true
    }

  export interface BusinessReviewModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BusinessReviewModel that matches the filter.
     * @param {BusinessReviewModelFindUniqueArgs} args - Arguments to find a BusinessReviewModel
     * @example
     * // Get one BusinessReviewModel
     * const businessReviewModel = await prisma.businessReviewModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BusinessReviewModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BusinessReviewModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BusinessReviewModel'> extends True ? Prisma__BusinessReviewModelClient<BusinessReviewModelGetPayload<T>> : Prisma__BusinessReviewModelClient<BusinessReviewModelGetPayload<T> | null, null>

    /**
     * Find one BusinessReviewModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BusinessReviewModelFindUniqueOrThrowArgs} args - Arguments to find a BusinessReviewModel
     * @example
     * // Get one BusinessReviewModel
     * const businessReviewModel = await prisma.businessReviewModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BusinessReviewModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BusinessReviewModelFindUniqueOrThrowArgs>
    ): Prisma__BusinessReviewModelClient<BusinessReviewModelGetPayload<T>>

    /**
     * Find the first BusinessReviewModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessReviewModelFindFirstArgs} args - Arguments to find a BusinessReviewModel
     * @example
     * // Get one BusinessReviewModel
     * const businessReviewModel = await prisma.businessReviewModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BusinessReviewModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BusinessReviewModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BusinessReviewModel'> extends True ? Prisma__BusinessReviewModelClient<BusinessReviewModelGetPayload<T>> : Prisma__BusinessReviewModelClient<BusinessReviewModelGetPayload<T> | null, null>

    /**
     * Find the first BusinessReviewModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessReviewModelFindFirstOrThrowArgs} args - Arguments to find a BusinessReviewModel
     * @example
     * // Get one BusinessReviewModel
     * const businessReviewModel = await prisma.businessReviewModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BusinessReviewModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BusinessReviewModelFindFirstOrThrowArgs>
    ): Prisma__BusinessReviewModelClient<BusinessReviewModelGetPayload<T>>

    /**
     * Find zero or more BusinessReviewModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessReviewModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessReviewModels
     * const businessReviewModels = await prisma.businessReviewModel.findMany()
     * 
     * // Get first 10 BusinessReviewModels
     * const businessReviewModels = await prisma.businessReviewModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessReviewModelWithIdOnly = await prisma.businessReviewModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BusinessReviewModelFindManyArgs>(
      args?: SelectSubset<T, BusinessReviewModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<BusinessReviewModelGetPayload<T>>>

    /**
     * Create a BusinessReviewModel.
     * @param {BusinessReviewModelCreateArgs} args - Arguments to create a BusinessReviewModel.
     * @example
     * // Create one BusinessReviewModel
     * const BusinessReviewModel = await prisma.businessReviewModel.create({
     *   data: {
     *     // ... data to create a BusinessReviewModel
     *   }
     * })
     * 
    **/
    create<T extends BusinessReviewModelCreateArgs>(
      args: SelectSubset<T, BusinessReviewModelCreateArgs>
    ): Prisma__BusinessReviewModelClient<BusinessReviewModelGetPayload<T>>

    /**
     * Create many BusinessReviewModels.
     *     @param {BusinessReviewModelCreateManyArgs} args - Arguments to create many BusinessReviewModels.
     *     @example
     *     // Create many BusinessReviewModels
     *     const businessReviewModel = await prisma.businessReviewModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BusinessReviewModelCreateManyArgs>(
      args?: SelectSubset<T, BusinessReviewModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BusinessReviewModel.
     * @param {BusinessReviewModelDeleteArgs} args - Arguments to delete one BusinessReviewModel.
     * @example
     * // Delete one BusinessReviewModel
     * const BusinessReviewModel = await prisma.businessReviewModel.delete({
     *   where: {
     *     // ... filter to delete one BusinessReviewModel
     *   }
     * })
     * 
    **/
    delete<T extends BusinessReviewModelDeleteArgs>(
      args: SelectSubset<T, BusinessReviewModelDeleteArgs>
    ): Prisma__BusinessReviewModelClient<BusinessReviewModelGetPayload<T>>

    /**
     * Update one BusinessReviewModel.
     * @param {BusinessReviewModelUpdateArgs} args - Arguments to update one BusinessReviewModel.
     * @example
     * // Update one BusinessReviewModel
     * const businessReviewModel = await prisma.businessReviewModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BusinessReviewModelUpdateArgs>(
      args: SelectSubset<T, BusinessReviewModelUpdateArgs>
    ): Prisma__BusinessReviewModelClient<BusinessReviewModelGetPayload<T>>

    /**
     * Delete zero or more BusinessReviewModels.
     * @param {BusinessReviewModelDeleteManyArgs} args - Arguments to filter BusinessReviewModels to delete.
     * @example
     * // Delete a few BusinessReviewModels
     * const { count } = await prisma.businessReviewModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BusinessReviewModelDeleteManyArgs>(
      args?: SelectSubset<T, BusinessReviewModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessReviewModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessReviewModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessReviewModels
     * const businessReviewModel = await prisma.businessReviewModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BusinessReviewModelUpdateManyArgs>(
      args: SelectSubset<T, BusinessReviewModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessReviewModel.
     * @param {BusinessReviewModelUpsertArgs} args - Arguments to update or create a BusinessReviewModel.
     * @example
     * // Update or create a BusinessReviewModel
     * const businessReviewModel = await prisma.businessReviewModel.upsert({
     *   create: {
     *     // ... data to create a BusinessReviewModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessReviewModel we want to update
     *   }
     * })
    **/
    upsert<T extends BusinessReviewModelUpsertArgs>(
      args: SelectSubset<T, BusinessReviewModelUpsertArgs>
    ): Prisma__BusinessReviewModelClient<BusinessReviewModelGetPayload<T>>

    /**
     * Count the number of BusinessReviewModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessReviewModelCountArgs} args - Arguments to filter BusinessReviewModels to count.
     * @example
     * // Count the number of BusinessReviewModels
     * const count = await prisma.businessReviewModel.count({
     *   where: {
     *     // ... the filter for the BusinessReviewModels we want to count
     *   }
     * })
    **/
    count<T extends BusinessReviewModelCountArgs>(
      args?: Subset<T, BusinessReviewModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessReviewModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessReviewModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessReviewModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessReviewModelAggregateArgs>(args: Subset<T, BusinessReviewModelAggregateArgs>): Prisma.PrismaPromise<GetBusinessReviewModelAggregateType<T>>

    /**
     * Group by BusinessReviewModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessReviewModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessReviewModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessReviewModelGroupByArgs['orderBy'] }
        : { orderBy?: BusinessReviewModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessReviewModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessReviewModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessReviewModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BusinessReviewModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    reviewee<T extends BusinessUserModelArgs= {}>(args?: Subset<T, BusinessUserModelArgs>): Prisma__BusinessUserModelClient<BusinessUserModelGetPayload<T> | Null>;

    reviewer<T extends CustomerModelArgs= {}>(args?: Subset<T, CustomerModelArgs>): Prisma__CustomerModelClient<CustomerModelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BusinessReviewModel base type for findUnique actions
   */
  export type BusinessReviewModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BusinessReviewModel
     */
    select?: BusinessReviewModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessReviewModelInclude | null
    /**
     * Filter, which BusinessReviewModel to fetch.
     */
    where: BusinessReviewModelWhereUniqueInput
  }

  /**
   * BusinessReviewModel findUnique
   */
  export interface BusinessReviewModelFindUniqueArgs extends BusinessReviewModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusinessReviewModel findUniqueOrThrow
   */
  export type BusinessReviewModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BusinessReviewModel
     */
    select?: BusinessReviewModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessReviewModelInclude | null
    /**
     * Filter, which BusinessReviewModel to fetch.
     */
    where: BusinessReviewModelWhereUniqueInput
  }


  /**
   * BusinessReviewModel base type for findFirst actions
   */
  export type BusinessReviewModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BusinessReviewModel
     */
    select?: BusinessReviewModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessReviewModelInclude | null
    /**
     * Filter, which BusinessReviewModel to fetch.
     */
    where?: BusinessReviewModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessReviewModels to fetch.
     */
    orderBy?: Enumerable<BusinessReviewModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessReviewModels.
     */
    cursor?: BusinessReviewModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessReviewModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessReviewModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessReviewModels.
     */
    distinct?: Enumerable<BusinessReviewModelScalarFieldEnum>
  }

  /**
   * BusinessReviewModel findFirst
   */
  export interface BusinessReviewModelFindFirstArgs extends BusinessReviewModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusinessReviewModel findFirstOrThrow
   */
  export type BusinessReviewModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BusinessReviewModel
     */
    select?: BusinessReviewModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessReviewModelInclude | null
    /**
     * Filter, which BusinessReviewModel to fetch.
     */
    where?: BusinessReviewModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessReviewModels to fetch.
     */
    orderBy?: Enumerable<BusinessReviewModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessReviewModels.
     */
    cursor?: BusinessReviewModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessReviewModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessReviewModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessReviewModels.
     */
    distinct?: Enumerable<BusinessReviewModelScalarFieldEnum>
  }


  /**
   * BusinessReviewModel findMany
   */
  export type BusinessReviewModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the BusinessReviewModel
     */
    select?: BusinessReviewModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessReviewModelInclude | null
    /**
     * Filter, which BusinessReviewModels to fetch.
     */
    where?: BusinessReviewModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessReviewModels to fetch.
     */
    orderBy?: Enumerable<BusinessReviewModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessReviewModels.
     */
    cursor?: BusinessReviewModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessReviewModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessReviewModels.
     */
    skip?: number
    distinct?: Enumerable<BusinessReviewModelScalarFieldEnum>
  }


  /**
   * BusinessReviewModel create
   */
  export type BusinessReviewModelCreateArgs = {
    /**
     * Select specific fields to fetch from the BusinessReviewModel
     */
    select?: BusinessReviewModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessReviewModelInclude | null
    /**
     * The data needed to create a BusinessReviewModel.
     */
    data: XOR<BusinessReviewModelCreateInput, BusinessReviewModelUncheckedCreateInput>
  }


  /**
   * BusinessReviewModel createMany
   */
  export type BusinessReviewModelCreateManyArgs = {
    /**
     * The data used to create many BusinessReviewModels.
     */
    data: Enumerable<BusinessReviewModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BusinessReviewModel update
   */
  export type BusinessReviewModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the BusinessReviewModel
     */
    select?: BusinessReviewModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessReviewModelInclude | null
    /**
     * The data needed to update a BusinessReviewModel.
     */
    data: XOR<BusinessReviewModelUpdateInput, BusinessReviewModelUncheckedUpdateInput>
    /**
     * Choose, which BusinessReviewModel to update.
     */
    where: BusinessReviewModelWhereUniqueInput
  }


  /**
   * BusinessReviewModel updateMany
   */
  export type BusinessReviewModelUpdateManyArgs = {
    /**
     * The data used to update BusinessReviewModels.
     */
    data: XOR<BusinessReviewModelUpdateManyMutationInput, BusinessReviewModelUncheckedUpdateManyInput>
    /**
     * Filter which BusinessReviewModels to update
     */
    where?: BusinessReviewModelWhereInput
  }


  /**
   * BusinessReviewModel upsert
   */
  export type BusinessReviewModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the BusinessReviewModel
     */
    select?: BusinessReviewModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessReviewModelInclude | null
    /**
     * The filter to search for the BusinessReviewModel to update in case it exists.
     */
    where: BusinessReviewModelWhereUniqueInput
    /**
     * In case the BusinessReviewModel found by the `where` argument doesn't exist, create a new BusinessReviewModel with this data.
     */
    create: XOR<BusinessReviewModelCreateInput, BusinessReviewModelUncheckedCreateInput>
    /**
     * In case the BusinessReviewModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessReviewModelUpdateInput, BusinessReviewModelUncheckedUpdateInput>
  }


  /**
   * BusinessReviewModel delete
   */
  export type BusinessReviewModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the BusinessReviewModel
     */
    select?: BusinessReviewModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessReviewModelInclude | null
    /**
     * Filter which BusinessReviewModel to delete.
     */
    where: BusinessReviewModelWhereUniqueInput
  }


  /**
   * BusinessReviewModel deleteMany
   */
  export type BusinessReviewModelDeleteManyArgs = {
    /**
     * Filter which BusinessReviewModels to delete
     */
    where?: BusinessReviewModelWhereInput
  }


  /**
   * BusinessReviewModel without action
   */
  export type BusinessReviewModelArgs = {
    /**
     * Select specific fields to fetch from the BusinessReviewModel
     */
    select?: BusinessReviewModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessReviewModelInclude | null
  }



  /**
   * Model BoardModel
   */


  export type AggregateBoardModel = {
    _count: BoardModelCountAggregateOutputType | null
    _min: BoardModelMinAggregateOutputType | null
    _max: BoardModelMaxAggregateOutputType | null
  }

  export type BoardModelMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type BoardModelMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type BoardModelCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type BoardModelMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type BoardModelMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type BoardModelCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type BoardModelAggregateArgs = {
    /**
     * Filter which BoardModel to aggregate.
     */
    where?: BoardModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardModels to fetch.
     */
    orderBy?: Enumerable<BoardModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoardModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BoardModels
    **/
    _count?: true | BoardModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoardModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoardModelMaxAggregateInputType
  }

  export type GetBoardModelAggregateType<T extends BoardModelAggregateArgs> = {
        [P in keyof T & keyof AggregateBoardModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoardModel[P]>
      : GetScalarType<T[P], AggregateBoardModel[P]>
  }




  export type BoardModelGroupByArgs = {
    where?: BoardModelWhereInput
    orderBy?: Enumerable<BoardModelOrderByWithAggregationInput>
    by: BoardModelScalarFieldEnum[]
    having?: BoardModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoardModelCountAggregateInputType | true
    _min?: BoardModelMinAggregateInputType
    _max?: BoardModelMaxAggregateInputType
  }


  export type BoardModelGroupByOutputType = {
    id: string
    name: string
    _count: BoardModelCountAggregateOutputType | null
    _min: BoardModelMinAggregateOutputType | null
    _max: BoardModelMaxAggregateOutputType | null
  }

  type GetBoardModelGroupByPayload<T extends BoardModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BoardModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoardModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoardModelGroupByOutputType[P]>
            : GetScalarType<T[P], BoardModelGroupByOutputType[P]>
        }
      >
    >


  export type BoardModelSelect = {
    id?: boolean
    name?: boolean
    articles?: boolean | BoardModel$articlesArgs
    _count?: boolean | BoardModelCountOutputTypeArgs
  }


  export type BoardModelInclude = {
    articles?: boolean | BoardModel$articlesArgs
    _count?: boolean | BoardModelCountOutputTypeArgs
  }

  export type BoardModelGetPayload<S extends boolean | null | undefined | BoardModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BoardModel :
    S extends undefined ? never :
    S extends { include: any } & (BoardModelArgs | BoardModelFindManyArgs)
    ? BoardModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'articles' ? Array < BoardArticleModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? BoardModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BoardModelArgs | BoardModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'articles' ? Array < BoardArticleModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? BoardModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BoardModel ? BoardModel[P] : never
  } 
      : BoardModel


  type BoardModelCountArgs = 
    Omit<BoardModelFindManyArgs, 'select' | 'include'> & {
      select?: BoardModelCountAggregateInputType | true
    }

  export interface BoardModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BoardModel that matches the filter.
     * @param {BoardModelFindUniqueArgs} args - Arguments to find a BoardModel
     * @example
     * // Get one BoardModel
     * const boardModel = await prisma.boardModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BoardModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BoardModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BoardModel'> extends True ? Prisma__BoardModelClient<BoardModelGetPayload<T>> : Prisma__BoardModelClient<BoardModelGetPayload<T> | null, null>

    /**
     * Find one BoardModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BoardModelFindUniqueOrThrowArgs} args - Arguments to find a BoardModel
     * @example
     * // Get one BoardModel
     * const boardModel = await prisma.boardModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BoardModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BoardModelFindUniqueOrThrowArgs>
    ): Prisma__BoardModelClient<BoardModelGetPayload<T>>

    /**
     * Find the first BoardModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardModelFindFirstArgs} args - Arguments to find a BoardModel
     * @example
     * // Get one BoardModel
     * const boardModel = await prisma.boardModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BoardModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BoardModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BoardModel'> extends True ? Prisma__BoardModelClient<BoardModelGetPayload<T>> : Prisma__BoardModelClient<BoardModelGetPayload<T> | null, null>

    /**
     * Find the first BoardModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardModelFindFirstOrThrowArgs} args - Arguments to find a BoardModel
     * @example
     * // Get one BoardModel
     * const boardModel = await prisma.boardModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BoardModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BoardModelFindFirstOrThrowArgs>
    ): Prisma__BoardModelClient<BoardModelGetPayload<T>>

    /**
     * Find zero or more BoardModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BoardModels
     * const boardModels = await prisma.boardModel.findMany()
     * 
     * // Get first 10 BoardModels
     * const boardModels = await prisma.boardModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boardModelWithIdOnly = await prisma.boardModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BoardModelFindManyArgs>(
      args?: SelectSubset<T, BoardModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<BoardModelGetPayload<T>>>

    /**
     * Create a BoardModel.
     * @param {BoardModelCreateArgs} args - Arguments to create a BoardModel.
     * @example
     * // Create one BoardModel
     * const BoardModel = await prisma.boardModel.create({
     *   data: {
     *     // ... data to create a BoardModel
     *   }
     * })
     * 
    **/
    create<T extends BoardModelCreateArgs>(
      args: SelectSubset<T, BoardModelCreateArgs>
    ): Prisma__BoardModelClient<BoardModelGetPayload<T>>

    /**
     * Create many BoardModels.
     *     @param {BoardModelCreateManyArgs} args - Arguments to create many BoardModels.
     *     @example
     *     // Create many BoardModels
     *     const boardModel = await prisma.boardModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BoardModelCreateManyArgs>(
      args?: SelectSubset<T, BoardModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BoardModel.
     * @param {BoardModelDeleteArgs} args - Arguments to delete one BoardModel.
     * @example
     * // Delete one BoardModel
     * const BoardModel = await prisma.boardModel.delete({
     *   where: {
     *     // ... filter to delete one BoardModel
     *   }
     * })
     * 
    **/
    delete<T extends BoardModelDeleteArgs>(
      args: SelectSubset<T, BoardModelDeleteArgs>
    ): Prisma__BoardModelClient<BoardModelGetPayload<T>>

    /**
     * Update one BoardModel.
     * @param {BoardModelUpdateArgs} args - Arguments to update one BoardModel.
     * @example
     * // Update one BoardModel
     * const boardModel = await prisma.boardModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BoardModelUpdateArgs>(
      args: SelectSubset<T, BoardModelUpdateArgs>
    ): Prisma__BoardModelClient<BoardModelGetPayload<T>>

    /**
     * Delete zero or more BoardModels.
     * @param {BoardModelDeleteManyArgs} args - Arguments to filter BoardModels to delete.
     * @example
     * // Delete a few BoardModels
     * const { count } = await prisma.boardModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BoardModelDeleteManyArgs>(
      args?: SelectSubset<T, BoardModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoardModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BoardModels
     * const boardModel = await prisma.boardModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BoardModelUpdateManyArgs>(
      args: SelectSubset<T, BoardModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BoardModel.
     * @param {BoardModelUpsertArgs} args - Arguments to update or create a BoardModel.
     * @example
     * // Update or create a BoardModel
     * const boardModel = await prisma.boardModel.upsert({
     *   create: {
     *     // ... data to create a BoardModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BoardModel we want to update
     *   }
     * })
    **/
    upsert<T extends BoardModelUpsertArgs>(
      args: SelectSubset<T, BoardModelUpsertArgs>
    ): Prisma__BoardModelClient<BoardModelGetPayload<T>>

    /**
     * Count the number of BoardModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardModelCountArgs} args - Arguments to filter BoardModels to count.
     * @example
     * // Count the number of BoardModels
     * const count = await prisma.boardModel.count({
     *   where: {
     *     // ... the filter for the BoardModels we want to count
     *   }
     * })
    **/
    count<T extends BoardModelCountArgs>(
      args?: Subset<T, BoardModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoardModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BoardModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoardModelAggregateArgs>(args: Subset<T, BoardModelAggregateArgs>): Prisma.PrismaPromise<GetBoardModelAggregateType<T>>

    /**
     * Group by BoardModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoardModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoardModelGroupByArgs['orderBy'] }
        : { orderBy?: BoardModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoardModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoardModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BoardModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BoardModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    articles<T extends BoardModel$articlesArgs= {}>(args?: Subset<T, BoardModel$articlesArgs>): Prisma.PrismaPromise<Array<BoardArticleModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BoardModel base type for findUnique actions
   */
  export type BoardModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BoardModel
     */
    select?: BoardModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardModelInclude | null
    /**
     * Filter, which BoardModel to fetch.
     */
    where: BoardModelWhereUniqueInput
  }

  /**
   * BoardModel findUnique
   */
  export interface BoardModelFindUniqueArgs extends BoardModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoardModel findUniqueOrThrow
   */
  export type BoardModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BoardModel
     */
    select?: BoardModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardModelInclude | null
    /**
     * Filter, which BoardModel to fetch.
     */
    where: BoardModelWhereUniqueInput
  }


  /**
   * BoardModel base type for findFirst actions
   */
  export type BoardModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BoardModel
     */
    select?: BoardModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardModelInclude | null
    /**
     * Filter, which BoardModel to fetch.
     */
    where?: BoardModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardModels to fetch.
     */
    orderBy?: Enumerable<BoardModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardModels.
     */
    cursor?: BoardModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardModels.
     */
    distinct?: Enumerable<BoardModelScalarFieldEnum>
  }

  /**
   * BoardModel findFirst
   */
  export interface BoardModelFindFirstArgs extends BoardModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoardModel findFirstOrThrow
   */
  export type BoardModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BoardModel
     */
    select?: BoardModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardModelInclude | null
    /**
     * Filter, which BoardModel to fetch.
     */
    where?: BoardModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardModels to fetch.
     */
    orderBy?: Enumerable<BoardModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardModels.
     */
    cursor?: BoardModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardModels.
     */
    distinct?: Enumerable<BoardModelScalarFieldEnum>
  }


  /**
   * BoardModel findMany
   */
  export type BoardModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the BoardModel
     */
    select?: BoardModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardModelInclude | null
    /**
     * Filter, which BoardModels to fetch.
     */
    where?: BoardModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardModels to fetch.
     */
    orderBy?: Enumerable<BoardModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BoardModels.
     */
    cursor?: BoardModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardModels.
     */
    skip?: number
    distinct?: Enumerable<BoardModelScalarFieldEnum>
  }


  /**
   * BoardModel create
   */
  export type BoardModelCreateArgs = {
    /**
     * Select specific fields to fetch from the BoardModel
     */
    select?: BoardModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardModelInclude | null
    /**
     * The data needed to create a BoardModel.
     */
    data: XOR<BoardModelCreateInput, BoardModelUncheckedCreateInput>
  }


  /**
   * BoardModel createMany
   */
  export type BoardModelCreateManyArgs = {
    /**
     * The data used to create many BoardModels.
     */
    data: Enumerable<BoardModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BoardModel update
   */
  export type BoardModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the BoardModel
     */
    select?: BoardModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardModelInclude | null
    /**
     * The data needed to update a BoardModel.
     */
    data: XOR<BoardModelUpdateInput, BoardModelUncheckedUpdateInput>
    /**
     * Choose, which BoardModel to update.
     */
    where: BoardModelWhereUniqueInput
  }


  /**
   * BoardModel updateMany
   */
  export type BoardModelUpdateManyArgs = {
    /**
     * The data used to update BoardModels.
     */
    data: XOR<BoardModelUpdateManyMutationInput, BoardModelUncheckedUpdateManyInput>
    /**
     * Filter which BoardModels to update
     */
    where?: BoardModelWhereInput
  }


  /**
   * BoardModel upsert
   */
  export type BoardModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the BoardModel
     */
    select?: BoardModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardModelInclude | null
    /**
     * The filter to search for the BoardModel to update in case it exists.
     */
    where: BoardModelWhereUniqueInput
    /**
     * In case the BoardModel found by the `where` argument doesn't exist, create a new BoardModel with this data.
     */
    create: XOR<BoardModelCreateInput, BoardModelUncheckedCreateInput>
    /**
     * In case the BoardModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoardModelUpdateInput, BoardModelUncheckedUpdateInput>
  }


  /**
   * BoardModel delete
   */
  export type BoardModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the BoardModel
     */
    select?: BoardModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardModelInclude | null
    /**
     * Filter which BoardModel to delete.
     */
    where: BoardModelWhereUniqueInput
  }


  /**
   * BoardModel deleteMany
   */
  export type BoardModelDeleteManyArgs = {
    /**
     * Filter which BoardModels to delete
     */
    where?: BoardModelWhereInput
  }


  /**
   * BoardModel.articles
   */
  export type BoardModel$articlesArgs = {
    /**
     * Select specific fields to fetch from the BoardArticleModel
     */
    select?: BoardArticleModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardArticleModelInclude | null
    where?: BoardArticleModelWhereInput
    orderBy?: Enumerable<BoardArticleModelOrderByWithRelationInput>
    cursor?: BoardArticleModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BoardArticleModelScalarFieldEnum>
  }


  /**
   * BoardModel without action
   */
  export type BoardModelArgs = {
    /**
     * Select specific fields to fetch from the BoardModel
     */
    select?: BoardModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardModelInclude | null
  }



  /**
   * Model BoardArticleModel
   */


  export type AggregateBoardArticleModel = {
    _count: BoardArticleModelCountAggregateOutputType | null
    _min: BoardArticleModelMinAggregateOutputType | null
    _max: BoardArticleModelMaxAggregateOutputType | null
  }

  export type BoardArticleModelMinAggregateOutputType = {
    id: string | null
    title: string | null
    author_id: string | null
    board_id: string | null
  }

  export type BoardArticleModelMaxAggregateOutputType = {
    id: string | null
    title: string | null
    author_id: string | null
    board_id: string | null
  }

  export type BoardArticleModelCountAggregateOutputType = {
    id: number
    title: number
    author_id: number
    board_id: number
    _all: number
  }


  export type BoardArticleModelMinAggregateInputType = {
    id?: true
    title?: true
    author_id?: true
    board_id?: true
  }

  export type BoardArticleModelMaxAggregateInputType = {
    id?: true
    title?: true
    author_id?: true
    board_id?: true
  }

  export type BoardArticleModelCountAggregateInputType = {
    id?: true
    title?: true
    author_id?: true
    board_id?: true
    _all?: true
  }

  export type BoardArticleModelAggregateArgs = {
    /**
     * Filter which BoardArticleModel to aggregate.
     */
    where?: BoardArticleModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardArticleModels to fetch.
     */
    orderBy?: Enumerable<BoardArticleModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoardArticleModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardArticleModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardArticleModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BoardArticleModels
    **/
    _count?: true | BoardArticleModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoardArticleModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoardArticleModelMaxAggregateInputType
  }

  export type GetBoardArticleModelAggregateType<T extends BoardArticleModelAggregateArgs> = {
        [P in keyof T & keyof AggregateBoardArticleModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoardArticleModel[P]>
      : GetScalarType<T[P], AggregateBoardArticleModel[P]>
  }




  export type BoardArticleModelGroupByArgs = {
    where?: BoardArticleModelWhereInput
    orderBy?: Enumerable<BoardArticleModelOrderByWithAggregationInput>
    by: BoardArticleModelScalarFieldEnum[]
    having?: BoardArticleModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoardArticleModelCountAggregateInputType | true
    _min?: BoardArticleModelMinAggregateInputType
    _max?: BoardArticleModelMaxAggregateInputType
  }


  export type BoardArticleModelGroupByOutputType = {
    id: string
    title: string
    author_id: string
    board_id: string
    _count: BoardArticleModelCountAggregateOutputType | null
    _min: BoardArticleModelMinAggregateOutputType | null
    _max: BoardArticleModelMaxAggregateOutputType | null
  }

  type GetBoardArticleModelGroupByPayload<T extends BoardArticleModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BoardArticleModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoardArticleModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoardArticleModelGroupByOutputType[P]>
            : GetScalarType<T[P], BoardArticleModelGroupByOutputType[P]>
        }
      >
    >


  export type BoardArticleModelSelect = {
    id?: boolean
    title?: boolean
    author_id?: boolean
    board_id?: boolean
    author?: boolean | UserModelArgs
    board?: boolean | BoardModelArgs
    contents?: boolean | BoardArticleModel$contentsArgs
    comments?: boolean | BoardArticleModel$commentsArgs
    _count?: boolean | BoardArticleModelCountOutputTypeArgs
  }


  export type BoardArticleModelInclude = {
    author?: boolean | UserModelArgs
    board?: boolean | BoardModelArgs
    contents?: boolean | BoardArticleModel$contentsArgs
    comments?: boolean | BoardArticleModel$commentsArgs
    _count?: boolean | BoardArticleModelCountOutputTypeArgs
  }

  export type BoardArticleModelGetPayload<S extends boolean | null | undefined | BoardArticleModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BoardArticleModel :
    S extends undefined ? never :
    S extends { include: any } & (BoardArticleModelArgs | BoardArticleModelFindManyArgs)
    ? BoardArticleModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'author' ? UserModelGetPayload<S['include'][P]> :
        P extends 'board' ? BoardModelGetPayload<S['include'][P]> :
        P extends 'contents' ? Array < BoardArticleContentModelGetPayload<S['include'][P]>>  :
        P extends 'comments' ? Array < BoardCommentModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? BoardArticleModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BoardArticleModelArgs | BoardArticleModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'author' ? UserModelGetPayload<S['select'][P]> :
        P extends 'board' ? BoardModelGetPayload<S['select'][P]> :
        P extends 'contents' ? Array < BoardArticleContentModelGetPayload<S['select'][P]>>  :
        P extends 'comments' ? Array < BoardCommentModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? BoardArticleModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BoardArticleModel ? BoardArticleModel[P] : never
  } 
      : BoardArticleModel


  type BoardArticleModelCountArgs = 
    Omit<BoardArticleModelFindManyArgs, 'select' | 'include'> & {
      select?: BoardArticleModelCountAggregateInputType | true
    }

  export interface BoardArticleModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BoardArticleModel that matches the filter.
     * @param {BoardArticleModelFindUniqueArgs} args - Arguments to find a BoardArticleModel
     * @example
     * // Get one BoardArticleModel
     * const boardArticleModel = await prisma.boardArticleModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BoardArticleModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BoardArticleModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BoardArticleModel'> extends True ? Prisma__BoardArticleModelClient<BoardArticleModelGetPayload<T>> : Prisma__BoardArticleModelClient<BoardArticleModelGetPayload<T> | null, null>

    /**
     * Find one BoardArticleModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BoardArticleModelFindUniqueOrThrowArgs} args - Arguments to find a BoardArticleModel
     * @example
     * // Get one BoardArticleModel
     * const boardArticleModel = await prisma.boardArticleModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BoardArticleModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BoardArticleModelFindUniqueOrThrowArgs>
    ): Prisma__BoardArticleModelClient<BoardArticleModelGetPayload<T>>

    /**
     * Find the first BoardArticleModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardArticleModelFindFirstArgs} args - Arguments to find a BoardArticleModel
     * @example
     * // Get one BoardArticleModel
     * const boardArticleModel = await prisma.boardArticleModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BoardArticleModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BoardArticleModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BoardArticleModel'> extends True ? Prisma__BoardArticleModelClient<BoardArticleModelGetPayload<T>> : Prisma__BoardArticleModelClient<BoardArticleModelGetPayload<T> | null, null>

    /**
     * Find the first BoardArticleModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardArticleModelFindFirstOrThrowArgs} args - Arguments to find a BoardArticleModel
     * @example
     * // Get one BoardArticleModel
     * const boardArticleModel = await prisma.boardArticleModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BoardArticleModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BoardArticleModelFindFirstOrThrowArgs>
    ): Prisma__BoardArticleModelClient<BoardArticleModelGetPayload<T>>

    /**
     * Find zero or more BoardArticleModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardArticleModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BoardArticleModels
     * const boardArticleModels = await prisma.boardArticleModel.findMany()
     * 
     * // Get first 10 BoardArticleModels
     * const boardArticleModels = await prisma.boardArticleModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boardArticleModelWithIdOnly = await prisma.boardArticleModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BoardArticleModelFindManyArgs>(
      args?: SelectSubset<T, BoardArticleModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<BoardArticleModelGetPayload<T>>>

    /**
     * Create a BoardArticleModel.
     * @param {BoardArticleModelCreateArgs} args - Arguments to create a BoardArticleModel.
     * @example
     * // Create one BoardArticleModel
     * const BoardArticleModel = await prisma.boardArticleModel.create({
     *   data: {
     *     // ... data to create a BoardArticleModel
     *   }
     * })
     * 
    **/
    create<T extends BoardArticleModelCreateArgs>(
      args: SelectSubset<T, BoardArticleModelCreateArgs>
    ): Prisma__BoardArticleModelClient<BoardArticleModelGetPayload<T>>

    /**
     * Create many BoardArticleModels.
     *     @param {BoardArticleModelCreateManyArgs} args - Arguments to create many BoardArticleModels.
     *     @example
     *     // Create many BoardArticleModels
     *     const boardArticleModel = await prisma.boardArticleModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BoardArticleModelCreateManyArgs>(
      args?: SelectSubset<T, BoardArticleModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BoardArticleModel.
     * @param {BoardArticleModelDeleteArgs} args - Arguments to delete one BoardArticleModel.
     * @example
     * // Delete one BoardArticleModel
     * const BoardArticleModel = await prisma.boardArticleModel.delete({
     *   where: {
     *     // ... filter to delete one BoardArticleModel
     *   }
     * })
     * 
    **/
    delete<T extends BoardArticleModelDeleteArgs>(
      args: SelectSubset<T, BoardArticleModelDeleteArgs>
    ): Prisma__BoardArticleModelClient<BoardArticleModelGetPayload<T>>

    /**
     * Update one BoardArticleModel.
     * @param {BoardArticleModelUpdateArgs} args - Arguments to update one BoardArticleModel.
     * @example
     * // Update one BoardArticleModel
     * const boardArticleModel = await prisma.boardArticleModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BoardArticleModelUpdateArgs>(
      args: SelectSubset<T, BoardArticleModelUpdateArgs>
    ): Prisma__BoardArticleModelClient<BoardArticleModelGetPayload<T>>

    /**
     * Delete zero or more BoardArticleModels.
     * @param {BoardArticleModelDeleteManyArgs} args - Arguments to filter BoardArticleModels to delete.
     * @example
     * // Delete a few BoardArticleModels
     * const { count } = await prisma.boardArticleModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BoardArticleModelDeleteManyArgs>(
      args?: SelectSubset<T, BoardArticleModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoardArticleModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardArticleModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BoardArticleModels
     * const boardArticleModel = await prisma.boardArticleModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BoardArticleModelUpdateManyArgs>(
      args: SelectSubset<T, BoardArticleModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BoardArticleModel.
     * @param {BoardArticleModelUpsertArgs} args - Arguments to update or create a BoardArticleModel.
     * @example
     * // Update or create a BoardArticleModel
     * const boardArticleModel = await prisma.boardArticleModel.upsert({
     *   create: {
     *     // ... data to create a BoardArticleModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BoardArticleModel we want to update
     *   }
     * })
    **/
    upsert<T extends BoardArticleModelUpsertArgs>(
      args: SelectSubset<T, BoardArticleModelUpsertArgs>
    ): Prisma__BoardArticleModelClient<BoardArticleModelGetPayload<T>>

    /**
     * Count the number of BoardArticleModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardArticleModelCountArgs} args - Arguments to filter BoardArticleModels to count.
     * @example
     * // Count the number of BoardArticleModels
     * const count = await prisma.boardArticleModel.count({
     *   where: {
     *     // ... the filter for the BoardArticleModels we want to count
     *   }
     * })
    **/
    count<T extends BoardArticleModelCountArgs>(
      args?: Subset<T, BoardArticleModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoardArticleModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BoardArticleModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardArticleModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoardArticleModelAggregateArgs>(args: Subset<T, BoardArticleModelAggregateArgs>): Prisma.PrismaPromise<GetBoardArticleModelAggregateType<T>>

    /**
     * Group by BoardArticleModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardArticleModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoardArticleModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoardArticleModelGroupByArgs['orderBy'] }
        : { orderBy?: BoardArticleModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoardArticleModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoardArticleModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BoardArticleModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BoardArticleModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    author<T extends UserModelArgs= {}>(args?: Subset<T, UserModelArgs>): Prisma__UserModelClient<UserModelGetPayload<T> | Null>;

    board<T extends BoardModelArgs= {}>(args?: Subset<T, BoardModelArgs>): Prisma__BoardModelClient<BoardModelGetPayload<T> | Null>;

    contents<T extends BoardArticleModel$contentsArgs= {}>(args?: Subset<T, BoardArticleModel$contentsArgs>): Prisma.PrismaPromise<Array<BoardArticleContentModelGetPayload<T>>| Null>;

    comments<T extends BoardArticleModel$commentsArgs= {}>(args?: Subset<T, BoardArticleModel$commentsArgs>): Prisma.PrismaPromise<Array<BoardCommentModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BoardArticleModel base type for findUnique actions
   */
  export type BoardArticleModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BoardArticleModel
     */
    select?: BoardArticleModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardArticleModelInclude | null
    /**
     * Filter, which BoardArticleModel to fetch.
     */
    where: BoardArticleModelWhereUniqueInput
  }

  /**
   * BoardArticleModel findUnique
   */
  export interface BoardArticleModelFindUniqueArgs extends BoardArticleModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoardArticleModel findUniqueOrThrow
   */
  export type BoardArticleModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BoardArticleModel
     */
    select?: BoardArticleModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardArticleModelInclude | null
    /**
     * Filter, which BoardArticleModel to fetch.
     */
    where: BoardArticleModelWhereUniqueInput
  }


  /**
   * BoardArticleModel base type for findFirst actions
   */
  export type BoardArticleModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BoardArticleModel
     */
    select?: BoardArticleModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardArticleModelInclude | null
    /**
     * Filter, which BoardArticleModel to fetch.
     */
    where?: BoardArticleModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardArticleModels to fetch.
     */
    orderBy?: Enumerable<BoardArticleModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardArticleModels.
     */
    cursor?: BoardArticleModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardArticleModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardArticleModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardArticleModels.
     */
    distinct?: Enumerable<BoardArticleModelScalarFieldEnum>
  }

  /**
   * BoardArticleModel findFirst
   */
  export interface BoardArticleModelFindFirstArgs extends BoardArticleModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoardArticleModel findFirstOrThrow
   */
  export type BoardArticleModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BoardArticleModel
     */
    select?: BoardArticleModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardArticleModelInclude | null
    /**
     * Filter, which BoardArticleModel to fetch.
     */
    where?: BoardArticleModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardArticleModels to fetch.
     */
    orderBy?: Enumerable<BoardArticleModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardArticleModels.
     */
    cursor?: BoardArticleModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardArticleModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardArticleModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardArticleModels.
     */
    distinct?: Enumerable<BoardArticleModelScalarFieldEnum>
  }


  /**
   * BoardArticleModel findMany
   */
  export type BoardArticleModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the BoardArticleModel
     */
    select?: BoardArticleModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardArticleModelInclude | null
    /**
     * Filter, which BoardArticleModels to fetch.
     */
    where?: BoardArticleModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardArticleModels to fetch.
     */
    orderBy?: Enumerable<BoardArticleModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BoardArticleModels.
     */
    cursor?: BoardArticleModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardArticleModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardArticleModels.
     */
    skip?: number
    distinct?: Enumerable<BoardArticleModelScalarFieldEnum>
  }


  /**
   * BoardArticleModel create
   */
  export type BoardArticleModelCreateArgs = {
    /**
     * Select specific fields to fetch from the BoardArticleModel
     */
    select?: BoardArticleModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardArticleModelInclude | null
    /**
     * The data needed to create a BoardArticleModel.
     */
    data: XOR<BoardArticleModelCreateInput, BoardArticleModelUncheckedCreateInput>
  }


  /**
   * BoardArticleModel createMany
   */
  export type BoardArticleModelCreateManyArgs = {
    /**
     * The data used to create many BoardArticleModels.
     */
    data: Enumerable<BoardArticleModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BoardArticleModel update
   */
  export type BoardArticleModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the BoardArticleModel
     */
    select?: BoardArticleModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardArticleModelInclude | null
    /**
     * The data needed to update a BoardArticleModel.
     */
    data: XOR<BoardArticleModelUpdateInput, BoardArticleModelUncheckedUpdateInput>
    /**
     * Choose, which BoardArticleModel to update.
     */
    where: BoardArticleModelWhereUniqueInput
  }


  /**
   * BoardArticleModel updateMany
   */
  export type BoardArticleModelUpdateManyArgs = {
    /**
     * The data used to update BoardArticleModels.
     */
    data: XOR<BoardArticleModelUpdateManyMutationInput, BoardArticleModelUncheckedUpdateManyInput>
    /**
     * Filter which BoardArticleModels to update
     */
    where?: BoardArticleModelWhereInput
  }


  /**
   * BoardArticleModel upsert
   */
  export type BoardArticleModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the BoardArticleModel
     */
    select?: BoardArticleModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardArticleModelInclude | null
    /**
     * The filter to search for the BoardArticleModel to update in case it exists.
     */
    where: BoardArticleModelWhereUniqueInput
    /**
     * In case the BoardArticleModel found by the `where` argument doesn't exist, create a new BoardArticleModel with this data.
     */
    create: XOR<BoardArticleModelCreateInput, BoardArticleModelUncheckedCreateInput>
    /**
     * In case the BoardArticleModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoardArticleModelUpdateInput, BoardArticleModelUncheckedUpdateInput>
  }


  /**
   * BoardArticleModel delete
   */
  export type BoardArticleModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the BoardArticleModel
     */
    select?: BoardArticleModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardArticleModelInclude | null
    /**
     * Filter which BoardArticleModel to delete.
     */
    where: BoardArticleModelWhereUniqueInput
  }


  /**
   * BoardArticleModel deleteMany
   */
  export type BoardArticleModelDeleteManyArgs = {
    /**
     * Filter which BoardArticleModels to delete
     */
    where?: BoardArticleModelWhereInput
  }


  /**
   * BoardArticleModel.contents
   */
  export type BoardArticleModel$contentsArgs = {
    /**
     * Select specific fields to fetch from the BoardArticleContentModel
     */
    select?: BoardArticleContentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardArticleContentModelInclude | null
    where?: BoardArticleContentModelWhereInput
    orderBy?: Enumerable<BoardArticleContentModelOrderByWithRelationInput>
    cursor?: BoardArticleContentModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BoardArticleContentModelScalarFieldEnum>
  }


  /**
   * BoardArticleModel.comments
   */
  export type BoardArticleModel$commentsArgs = {
    /**
     * Select specific fields to fetch from the BoardCommentModel
     */
    select?: BoardCommentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardCommentModelInclude | null
    where?: BoardCommentModelWhereInput
    orderBy?: Enumerable<BoardCommentModelOrderByWithRelationInput>
    cursor?: BoardCommentModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BoardCommentModelScalarFieldEnum>
  }


  /**
   * BoardArticleModel without action
   */
  export type BoardArticleModelArgs = {
    /**
     * Select specific fields to fetch from the BoardArticleModel
     */
    select?: BoardArticleModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardArticleModelInclude | null
  }



  /**
   * Model BoardArticleContentModel
   */


  export type AggregateBoardArticleContentModel = {
    _count: BoardArticleContentModelCountAggregateOutputType | null
    _min: BoardArticleContentModelMinAggregateOutputType | null
    _max: BoardArticleContentModelMaxAggregateOutputType | null
  }

  export type BoardArticleContentModelMinAggregateOutputType = {
    id: string | null
    text: string | null
    created_at: Date | null
    article_id: string | null
  }

  export type BoardArticleContentModelMaxAggregateOutputType = {
    id: string | null
    text: string | null
    created_at: Date | null
    article_id: string | null
  }

  export type BoardArticleContentModelCountAggregateOutputType = {
    id: number
    text: number
    created_at: number
    article_id: number
    _all: number
  }


  export type BoardArticleContentModelMinAggregateInputType = {
    id?: true
    text?: true
    created_at?: true
    article_id?: true
  }

  export type BoardArticleContentModelMaxAggregateInputType = {
    id?: true
    text?: true
    created_at?: true
    article_id?: true
  }

  export type BoardArticleContentModelCountAggregateInputType = {
    id?: true
    text?: true
    created_at?: true
    article_id?: true
    _all?: true
  }

  export type BoardArticleContentModelAggregateArgs = {
    /**
     * Filter which BoardArticleContentModel to aggregate.
     */
    where?: BoardArticleContentModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardArticleContentModels to fetch.
     */
    orderBy?: Enumerable<BoardArticleContentModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoardArticleContentModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardArticleContentModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardArticleContentModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BoardArticleContentModels
    **/
    _count?: true | BoardArticleContentModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoardArticleContentModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoardArticleContentModelMaxAggregateInputType
  }

  export type GetBoardArticleContentModelAggregateType<T extends BoardArticleContentModelAggregateArgs> = {
        [P in keyof T & keyof AggregateBoardArticleContentModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoardArticleContentModel[P]>
      : GetScalarType<T[P], AggregateBoardArticleContentModel[P]>
  }




  export type BoardArticleContentModelGroupByArgs = {
    where?: BoardArticleContentModelWhereInput
    orderBy?: Enumerable<BoardArticleContentModelOrderByWithAggregationInput>
    by: BoardArticleContentModelScalarFieldEnum[]
    having?: BoardArticleContentModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoardArticleContentModelCountAggregateInputType | true
    _min?: BoardArticleContentModelMinAggregateInputType
    _max?: BoardArticleContentModelMaxAggregateInputType
  }


  export type BoardArticleContentModelGroupByOutputType = {
    id: string
    text: string
    created_at: Date
    article_id: string
    _count: BoardArticleContentModelCountAggregateOutputType | null
    _min: BoardArticleContentModelMinAggregateOutputType | null
    _max: BoardArticleContentModelMaxAggregateOutputType | null
  }

  type GetBoardArticleContentModelGroupByPayload<T extends BoardArticleContentModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BoardArticleContentModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoardArticleContentModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoardArticleContentModelGroupByOutputType[P]>
            : GetScalarType<T[P], BoardArticleContentModelGroupByOutputType[P]>
        }
      >
    >


  export type BoardArticleContentModelSelect = {
    id?: boolean
    text?: boolean
    created_at?: boolean
    article_id?: boolean
    article?: boolean | BoardArticleModelArgs
  }


  export type BoardArticleContentModelInclude = {
    article?: boolean | BoardArticleModelArgs
  }

  export type BoardArticleContentModelGetPayload<S extends boolean | null | undefined | BoardArticleContentModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BoardArticleContentModel :
    S extends undefined ? never :
    S extends { include: any } & (BoardArticleContentModelArgs | BoardArticleContentModelFindManyArgs)
    ? BoardArticleContentModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'article' ? BoardArticleModelGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BoardArticleContentModelArgs | BoardArticleContentModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'article' ? BoardArticleModelGetPayload<S['select'][P]> :  P extends keyof BoardArticleContentModel ? BoardArticleContentModel[P] : never
  } 
      : BoardArticleContentModel


  type BoardArticleContentModelCountArgs = 
    Omit<BoardArticleContentModelFindManyArgs, 'select' | 'include'> & {
      select?: BoardArticleContentModelCountAggregateInputType | true
    }

  export interface BoardArticleContentModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BoardArticleContentModel that matches the filter.
     * @param {BoardArticleContentModelFindUniqueArgs} args - Arguments to find a BoardArticleContentModel
     * @example
     * // Get one BoardArticleContentModel
     * const boardArticleContentModel = await prisma.boardArticleContentModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BoardArticleContentModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BoardArticleContentModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BoardArticleContentModel'> extends True ? Prisma__BoardArticleContentModelClient<BoardArticleContentModelGetPayload<T>> : Prisma__BoardArticleContentModelClient<BoardArticleContentModelGetPayload<T> | null, null>

    /**
     * Find one BoardArticleContentModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BoardArticleContentModelFindUniqueOrThrowArgs} args - Arguments to find a BoardArticleContentModel
     * @example
     * // Get one BoardArticleContentModel
     * const boardArticleContentModel = await prisma.boardArticleContentModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BoardArticleContentModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BoardArticleContentModelFindUniqueOrThrowArgs>
    ): Prisma__BoardArticleContentModelClient<BoardArticleContentModelGetPayload<T>>

    /**
     * Find the first BoardArticleContentModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardArticleContentModelFindFirstArgs} args - Arguments to find a BoardArticleContentModel
     * @example
     * // Get one BoardArticleContentModel
     * const boardArticleContentModel = await prisma.boardArticleContentModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BoardArticleContentModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BoardArticleContentModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BoardArticleContentModel'> extends True ? Prisma__BoardArticleContentModelClient<BoardArticleContentModelGetPayload<T>> : Prisma__BoardArticleContentModelClient<BoardArticleContentModelGetPayload<T> | null, null>

    /**
     * Find the first BoardArticleContentModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardArticleContentModelFindFirstOrThrowArgs} args - Arguments to find a BoardArticleContentModel
     * @example
     * // Get one BoardArticleContentModel
     * const boardArticleContentModel = await prisma.boardArticleContentModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BoardArticleContentModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BoardArticleContentModelFindFirstOrThrowArgs>
    ): Prisma__BoardArticleContentModelClient<BoardArticleContentModelGetPayload<T>>

    /**
     * Find zero or more BoardArticleContentModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardArticleContentModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BoardArticleContentModels
     * const boardArticleContentModels = await prisma.boardArticleContentModel.findMany()
     * 
     * // Get first 10 BoardArticleContentModels
     * const boardArticleContentModels = await prisma.boardArticleContentModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boardArticleContentModelWithIdOnly = await prisma.boardArticleContentModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BoardArticleContentModelFindManyArgs>(
      args?: SelectSubset<T, BoardArticleContentModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<BoardArticleContentModelGetPayload<T>>>

    /**
     * Create a BoardArticleContentModel.
     * @param {BoardArticleContentModelCreateArgs} args - Arguments to create a BoardArticleContentModel.
     * @example
     * // Create one BoardArticleContentModel
     * const BoardArticleContentModel = await prisma.boardArticleContentModel.create({
     *   data: {
     *     // ... data to create a BoardArticleContentModel
     *   }
     * })
     * 
    **/
    create<T extends BoardArticleContentModelCreateArgs>(
      args: SelectSubset<T, BoardArticleContentModelCreateArgs>
    ): Prisma__BoardArticleContentModelClient<BoardArticleContentModelGetPayload<T>>

    /**
     * Create many BoardArticleContentModels.
     *     @param {BoardArticleContentModelCreateManyArgs} args - Arguments to create many BoardArticleContentModels.
     *     @example
     *     // Create many BoardArticleContentModels
     *     const boardArticleContentModel = await prisma.boardArticleContentModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BoardArticleContentModelCreateManyArgs>(
      args?: SelectSubset<T, BoardArticleContentModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BoardArticleContentModel.
     * @param {BoardArticleContentModelDeleteArgs} args - Arguments to delete one BoardArticleContentModel.
     * @example
     * // Delete one BoardArticleContentModel
     * const BoardArticleContentModel = await prisma.boardArticleContentModel.delete({
     *   where: {
     *     // ... filter to delete one BoardArticleContentModel
     *   }
     * })
     * 
    **/
    delete<T extends BoardArticleContentModelDeleteArgs>(
      args: SelectSubset<T, BoardArticleContentModelDeleteArgs>
    ): Prisma__BoardArticleContentModelClient<BoardArticleContentModelGetPayload<T>>

    /**
     * Update one BoardArticleContentModel.
     * @param {BoardArticleContentModelUpdateArgs} args - Arguments to update one BoardArticleContentModel.
     * @example
     * // Update one BoardArticleContentModel
     * const boardArticleContentModel = await prisma.boardArticleContentModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BoardArticleContentModelUpdateArgs>(
      args: SelectSubset<T, BoardArticleContentModelUpdateArgs>
    ): Prisma__BoardArticleContentModelClient<BoardArticleContentModelGetPayload<T>>

    /**
     * Delete zero or more BoardArticleContentModels.
     * @param {BoardArticleContentModelDeleteManyArgs} args - Arguments to filter BoardArticleContentModels to delete.
     * @example
     * // Delete a few BoardArticleContentModels
     * const { count } = await prisma.boardArticleContentModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BoardArticleContentModelDeleteManyArgs>(
      args?: SelectSubset<T, BoardArticleContentModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoardArticleContentModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardArticleContentModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BoardArticleContentModels
     * const boardArticleContentModel = await prisma.boardArticleContentModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BoardArticleContentModelUpdateManyArgs>(
      args: SelectSubset<T, BoardArticleContentModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BoardArticleContentModel.
     * @param {BoardArticleContentModelUpsertArgs} args - Arguments to update or create a BoardArticleContentModel.
     * @example
     * // Update or create a BoardArticleContentModel
     * const boardArticleContentModel = await prisma.boardArticleContentModel.upsert({
     *   create: {
     *     // ... data to create a BoardArticleContentModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BoardArticleContentModel we want to update
     *   }
     * })
    **/
    upsert<T extends BoardArticleContentModelUpsertArgs>(
      args: SelectSubset<T, BoardArticleContentModelUpsertArgs>
    ): Prisma__BoardArticleContentModelClient<BoardArticleContentModelGetPayload<T>>

    /**
     * Count the number of BoardArticleContentModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardArticleContentModelCountArgs} args - Arguments to filter BoardArticleContentModels to count.
     * @example
     * // Count the number of BoardArticleContentModels
     * const count = await prisma.boardArticleContentModel.count({
     *   where: {
     *     // ... the filter for the BoardArticleContentModels we want to count
     *   }
     * })
    **/
    count<T extends BoardArticleContentModelCountArgs>(
      args?: Subset<T, BoardArticleContentModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoardArticleContentModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BoardArticleContentModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardArticleContentModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoardArticleContentModelAggregateArgs>(args: Subset<T, BoardArticleContentModelAggregateArgs>): Prisma.PrismaPromise<GetBoardArticleContentModelAggregateType<T>>

    /**
     * Group by BoardArticleContentModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardArticleContentModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoardArticleContentModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoardArticleContentModelGroupByArgs['orderBy'] }
        : { orderBy?: BoardArticleContentModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoardArticleContentModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoardArticleContentModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BoardArticleContentModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BoardArticleContentModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    article<T extends BoardArticleModelArgs= {}>(args?: Subset<T, BoardArticleModelArgs>): Prisma__BoardArticleModelClient<BoardArticleModelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BoardArticleContentModel base type for findUnique actions
   */
  export type BoardArticleContentModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BoardArticleContentModel
     */
    select?: BoardArticleContentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardArticleContentModelInclude | null
    /**
     * Filter, which BoardArticleContentModel to fetch.
     */
    where: BoardArticleContentModelWhereUniqueInput
  }

  /**
   * BoardArticleContentModel findUnique
   */
  export interface BoardArticleContentModelFindUniqueArgs extends BoardArticleContentModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoardArticleContentModel findUniqueOrThrow
   */
  export type BoardArticleContentModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BoardArticleContentModel
     */
    select?: BoardArticleContentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardArticleContentModelInclude | null
    /**
     * Filter, which BoardArticleContentModel to fetch.
     */
    where: BoardArticleContentModelWhereUniqueInput
  }


  /**
   * BoardArticleContentModel base type for findFirst actions
   */
  export type BoardArticleContentModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BoardArticleContentModel
     */
    select?: BoardArticleContentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardArticleContentModelInclude | null
    /**
     * Filter, which BoardArticleContentModel to fetch.
     */
    where?: BoardArticleContentModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardArticleContentModels to fetch.
     */
    orderBy?: Enumerable<BoardArticleContentModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardArticleContentModels.
     */
    cursor?: BoardArticleContentModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardArticleContentModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardArticleContentModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardArticleContentModels.
     */
    distinct?: Enumerable<BoardArticleContentModelScalarFieldEnum>
  }

  /**
   * BoardArticleContentModel findFirst
   */
  export interface BoardArticleContentModelFindFirstArgs extends BoardArticleContentModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoardArticleContentModel findFirstOrThrow
   */
  export type BoardArticleContentModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BoardArticleContentModel
     */
    select?: BoardArticleContentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardArticleContentModelInclude | null
    /**
     * Filter, which BoardArticleContentModel to fetch.
     */
    where?: BoardArticleContentModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardArticleContentModels to fetch.
     */
    orderBy?: Enumerable<BoardArticleContentModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardArticleContentModels.
     */
    cursor?: BoardArticleContentModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardArticleContentModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardArticleContentModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardArticleContentModels.
     */
    distinct?: Enumerable<BoardArticleContentModelScalarFieldEnum>
  }


  /**
   * BoardArticleContentModel findMany
   */
  export type BoardArticleContentModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the BoardArticleContentModel
     */
    select?: BoardArticleContentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardArticleContentModelInclude | null
    /**
     * Filter, which BoardArticleContentModels to fetch.
     */
    where?: BoardArticleContentModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardArticleContentModels to fetch.
     */
    orderBy?: Enumerable<BoardArticleContentModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BoardArticleContentModels.
     */
    cursor?: BoardArticleContentModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardArticleContentModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardArticleContentModels.
     */
    skip?: number
    distinct?: Enumerable<BoardArticleContentModelScalarFieldEnum>
  }


  /**
   * BoardArticleContentModel create
   */
  export type BoardArticleContentModelCreateArgs = {
    /**
     * Select specific fields to fetch from the BoardArticleContentModel
     */
    select?: BoardArticleContentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardArticleContentModelInclude | null
    /**
     * The data needed to create a BoardArticleContentModel.
     */
    data: XOR<BoardArticleContentModelCreateInput, BoardArticleContentModelUncheckedCreateInput>
  }


  /**
   * BoardArticleContentModel createMany
   */
  export type BoardArticleContentModelCreateManyArgs = {
    /**
     * The data used to create many BoardArticleContentModels.
     */
    data: Enumerable<BoardArticleContentModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BoardArticleContentModel update
   */
  export type BoardArticleContentModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the BoardArticleContentModel
     */
    select?: BoardArticleContentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardArticleContentModelInclude | null
    /**
     * The data needed to update a BoardArticleContentModel.
     */
    data: XOR<BoardArticleContentModelUpdateInput, BoardArticleContentModelUncheckedUpdateInput>
    /**
     * Choose, which BoardArticleContentModel to update.
     */
    where: BoardArticleContentModelWhereUniqueInput
  }


  /**
   * BoardArticleContentModel updateMany
   */
  export type BoardArticleContentModelUpdateManyArgs = {
    /**
     * The data used to update BoardArticleContentModels.
     */
    data: XOR<BoardArticleContentModelUpdateManyMutationInput, BoardArticleContentModelUncheckedUpdateManyInput>
    /**
     * Filter which BoardArticleContentModels to update
     */
    where?: BoardArticleContentModelWhereInput
  }


  /**
   * BoardArticleContentModel upsert
   */
  export type BoardArticleContentModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the BoardArticleContentModel
     */
    select?: BoardArticleContentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardArticleContentModelInclude | null
    /**
     * The filter to search for the BoardArticleContentModel to update in case it exists.
     */
    where: BoardArticleContentModelWhereUniqueInput
    /**
     * In case the BoardArticleContentModel found by the `where` argument doesn't exist, create a new BoardArticleContentModel with this data.
     */
    create: XOR<BoardArticleContentModelCreateInput, BoardArticleContentModelUncheckedCreateInput>
    /**
     * In case the BoardArticleContentModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoardArticleContentModelUpdateInput, BoardArticleContentModelUncheckedUpdateInput>
  }


  /**
   * BoardArticleContentModel delete
   */
  export type BoardArticleContentModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the BoardArticleContentModel
     */
    select?: BoardArticleContentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardArticleContentModelInclude | null
    /**
     * Filter which BoardArticleContentModel to delete.
     */
    where: BoardArticleContentModelWhereUniqueInput
  }


  /**
   * BoardArticleContentModel deleteMany
   */
  export type BoardArticleContentModelDeleteManyArgs = {
    /**
     * Filter which BoardArticleContentModels to delete
     */
    where?: BoardArticleContentModelWhereInput
  }


  /**
   * BoardArticleContentModel without action
   */
  export type BoardArticleContentModelArgs = {
    /**
     * Select specific fields to fetch from the BoardArticleContentModel
     */
    select?: BoardArticleContentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardArticleContentModelInclude | null
  }



  /**
   * Model BoardCommentModel
   */


  export type AggregateBoardCommentModel = {
    _count: BoardCommentModelCountAggregateOutputType | null
    _min: BoardCommentModelMinAggregateOutputType | null
    _max: BoardCommentModelMaxAggregateOutputType | null
  }

  export type BoardCommentModelMinAggregateOutputType = {
    id: string | null
    author_id: string | null
    article_id: string | null
  }

  export type BoardCommentModelMaxAggregateOutputType = {
    id: string | null
    author_id: string | null
    article_id: string | null
  }

  export type BoardCommentModelCountAggregateOutputType = {
    id: number
    author_id: number
    article_id: number
    _all: number
  }


  export type BoardCommentModelMinAggregateInputType = {
    id?: true
    author_id?: true
    article_id?: true
  }

  export type BoardCommentModelMaxAggregateInputType = {
    id?: true
    author_id?: true
    article_id?: true
  }

  export type BoardCommentModelCountAggregateInputType = {
    id?: true
    author_id?: true
    article_id?: true
    _all?: true
  }

  export type BoardCommentModelAggregateArgs = {
    /**
     * Filter which BoardCommentModel to aggregate.
     */
    where?: BoardCommentModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardCommentModels to fetch.
     */
    orderBy?: Enumerable<BoardCommentModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoardCommentModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardCommentModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardCommentModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BoardCommentModels
    **/
    _count?: true | BoardCommentModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoardCommentModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoardCommentModelMaxAggregateInputType
  }

  export type GetBoardCommentModelAggregateType<T extends BoardCommentModelAggregateArgs> = {
        [P in keyof T & keyof AggregateBoardCommentModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoardCommentModel[P]>
      : GetScalarType<T[P], AggregateBoardCommentModel[P]>
  }




  export type BoardCommentModelGroupByArgs = {
    where?: BoardCommentModelWhereInput
    orderBy?: Enumerable<BoardCommentModelOrderByWithAggregationInput>
    by: BoardCommentModelScalarFieldEnum[]
    having?: BoardCommentModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoardCommentModelCountAggregateInputType | true
    _min?: BoardCommentModelMinAggregateInputType
    _max?: BoardCommentModelMaxAggregateInputType
  }


  export type BoardCommentModelGroupByOutputType = {
    id: string
    author_id: string
    article_id: string
    _count: BoardCommentModelCountAggregateOutputType | null
    _min: BoardCommentModelMinAggregateOutputType | null
    _max: BoardCommentModelMaxAggregateOutputType | null
  }

  type GetBoardCommentModelGroupByPayload<T extends BoardCommentModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BoardCommentModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoardCommentModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoardCommentModelGroupByOutputType[P]>
            : GetScalarType<T[P], BoardCommentModelGroupByOutputType[P]>
        }
      >
    >


  export type BoardCommentModelSelect = {
    id?: boolean
    author_id?: boolean
    article_id?: boolean
    author?: boolean | UserModelArgs
    article?: boolean | BoardArticleModelArgs
    contents?: boolean | BoardCommentModel$contentsArgs
    _count?: boolean | BoardCommentModelCountOutputTypeArgs
  }


  export type BoardCommentModelInclude = {
    author?: boolean | UserModelArgs
    article?: boolean | BoardArticleModelArgs
    contents?: boolean | BoardCommentModel$contentsArgs
    _count?: boolean | BoardCommentModelCountOutputTypeArgs
  }

  export type BoardCommentModelGetPayload<S extends boolean | null | undefined | BoardCommentModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BoardCommentModel :
    S extends undefined ? never :
    S extends { include: any } & (BoardCommentModelArgs | BoardCommentModelFindManyArgs)
    ? BoardCommentModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'author' ? UserModelGetPayload<S['include'][P]> :
        P extends 'article' ? BoardArticleModelGetPayload<S['include'][P]> :
        P extends 'contents' ? Array < BoardCommentContentModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? BoardCommentModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BoardCommentModelArgs | BoardCommentModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'author' ? UserModelGetPayload<S['select'][P]> :
        P extends 'article' ? BoardArticleModelGetPayload<S['select'][P]> :
        P extends 'contents' ? Array < BoardCommentContentModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? BoardCommentModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BoardCommentModel ? BoardCommentModel[P] : never
  } 
      : BoardCommentModel


  type BoardCommentModelCountArgs = 
    Omit<BoardCommentModelFindManyArgs, 'select' | 'include'> & {
      select?: BoardCommentModelCountAggregateInputType | true
    }

  export interface BoardCommentModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BoardCommentModel that matches the filter.
     * @param {BoardCommentModelFindUniqueArgs} args - Arguments to find a BoardCommentModel
     * @example
     * // Get one BoardCommentModel
     * const boardCommentModel = await prisma.boardCommentModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BoardCommentModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BoardCommentModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BoardCommentModel'> extends True ? Prisma__BoardCommentModelClient<BoardCommentModelGetPayload<T>> : Prisma__BoardCommentModelClient<BoardCommentModelGetPayload<T> | null, null>

    /**
     * Find one BoardCommentModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BoardCommentModelFindUniqueOrThrowArgs} args - Arguments to find a BoardCommentModel
     * @example
     * // Get one BoardCommentModel
     * const boardCommentModel = await prisma.boardCommentModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BoardCommentModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BoardCommentModelFindUniqueOrThrowArgs>
    ): Prisma__BoardCommentModelClient<BoardCommentModelGetPayload<T>>

    /**
     * Find the first BoardCommentModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardCommentModelFindFirstArgs} args - Arguments to find a BoardCommentModel
     * @example
     * // Get one BoardCommentModel
     * const boardCommentModel = await prisma.boardCommentModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BoardCommentModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BoardCommentModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BoardCommentModel'> extends True ? Prisma__BoardCommentModelClient<BoardCommentModelGetPayload<T>> : Prisma__BoardCommentModelClient<BoardCommentModelGetPayload<T> | null, null>

    /**
     * Find the first BoardCommentModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardCommentModelFindFirstOrThrowArgs} args - Arguments to find a BoardCommentModel
     * @example
     * // Get one BoardCommentModel
     * const boardCommentModel = await prisma.boardCommentModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BoardCommentModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BoardCommentModelFindFirstOrThrowArgs>
    ): Prisma__BoardCommentModelClient<BoardCommentModelGetPayload<T>>

    /**
     * Find zero or more BoardCommentModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardCommentModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BoardCommentModels
     * const boardCommentModels = await prisma.boardCommentModel.findMany()
     * 
     * // Get first 10 BoardCommentModels
     * const boardCommentModels = await prisma.boardCommentModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boardCommentModelWithIdOnly = await prisma.boardCommentModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BoardCommentModelFindManyArgs>(
      args?: SelectSubset<T, BoardCommentModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<BoardCommentModelGetPayload<T>>>

    /**
     * Create a BoardCommentModel.
     * @param {BoardCommentModelCreateArgs} args - Arguments to create a BoardCommentModel.
     * @example
     * // Create one BoardCommentModel
     * const BoardCommentModel = await prisma.boardCommentModel.create({
     *   data: {
     *     // ... data to create a BoardCommentModel
     *   }
     * })
     * 
    **/
    create<T extends BoardCommentModelCreateArgs>(
      args: SelectSubset<T, BoardCommentModelCreateArgs>
    ): Prisma__BoardCommentModelClient<BoardCommentModelGetPayload<T>>

    /**
     * Create many BoardCommentModels.
     *     @param {BoardCommentModelCreateManyArgs} args - Arguments to create many BoardCommentModels.
     *     @example
     *     // Create many BoardCommentModels
     *     const boardCommentModel = await prisma.boardCommentModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BoardCommentModelCreateManyArgs>(
      args?: SelectSubset<T, BoardCommentModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BoardCommentModel.
     * @param {BoardCommentModelDeleteArgs} args - Arguments to delete one BoardCommentModel.
     * @example
     * // Delete one BoardCommentModel
     * const BoardCommentModel = await prisma.boardCommentModel.delete({
     *   where: {
     *     // ... filter to delete one BoardCommentModel
     *   }
     * })
     * 
    **/
    delete<T extends BoardCommentModelDeleteArgs>(
      args: SelectSubset<T, BoardCommentModelDeleteArgs>
    ): Prisma__BoardCommentModelClient<BoardCommentModelGetPayload<T>>

    /**
     * Update one BoardCommentModel.
     * @param {BoardCommentModelUpdateArgs} args - Arguments to update one BoardCommentModel.
     * @example
     * // Update one BoardCommentModel
     * const boardCommentModel = await prisma.boardCommentModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BoardCommentModelUpdateArgs>(
      args: SelectSubset<T, BoardCommentModelUpdateArgs>
    ): Prisma__BoardCommentModelClient<BoardCommentModelGetPayload<T>>

    /**
     * Delete zero or more BoardCommentModels.
     * @param {BoardCommentModelDeleteManyArgs} args - Arguments to filter BoardCommentModels to delete.
     * @example
     * // Delete a few BoardCommentModels
     * const { count } = await prisma.boardCommentModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BoardCommentModelDeleteManyArgs>(
      args?: SelectSubset<T, BoardCommentModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoardCommentModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardCommentModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BoardCommentModels
     * const boardCommentModel = await prisma.boardCommentModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BoardCommentModelUpdateManyArgs>(
      args: SelectSubset<T, BoardCommentModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BoardCommentModel.
     * @param {BoardCommentModelUpsertArgs} args - Arguments to update or create a BoardCommentModel.
     * @example
     * // Update or create a BoardCommentModel
     * const boardCommentModel = await prisma.boardCommentModel.upsert({
     *   create: {
     *     // ... data to create a BoardCommentModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BoardCommentModel we want to update
     *   }
     * })
    **/
    upsert<T extends BoardCommentModelUpsertArgs>(
      args: SelectSubset<T, BoardCommentModelUpsertArgs>
    ): Prisma__BoardCommentModelClient<BoardCommentModelGetPayload<T>>

    /**
     * Count the number of BoardCommentModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardCommentModelCountArgs} args - Arguments to filter BoardCommentModels to count.
     * @example
     * // Count the number of BoardCommentModels
     * const count = await prisma.boardCommentModel.count({
     *   where: {
     *     // ... the filter for the BoardCommentModels we want to count
     *   }
     * })
    **/
    count<T extends BoardCommentModelCountArgs>(
      args?: Subset<T, BoardCommentModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoardCommentModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BoardCommentModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardCommentModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoardCommentModelAggregateArgs>(args: Subset<T, BoardCommentModelAggregateArgs>): Prisma.PrismaPromise<GetBoardCommentModelAggregateType<T>>

    /**
     * Group by BoardCommentModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardCommentModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoardCommentModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoardCommentModelGroupByArgs['orderBy'] }
        : { orderBy?: BoardCommentModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoardCommentModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoardCommentModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BoardCommentModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BoardCommentModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    author<T extends UserModelArgs= {}>(args?: Subset<T, UserModelArgs>): Prisma__UserModelClient<UserModelGetPayload<T> | Null>;

    article<T extends BoardArticleModelArgs= {}>(args?: Subset<T, BoardArticleModelArgs>): Prisma__BoardArticleModelClient<BoardArticleModelGetPayload<T> | Null>;

    contents<T extends BoardCommentModel$contentsArgs= {}>(args?: Subset<T, BoardCommentModel$contentsArgs>): Prisma.PrismaPromise<Array<BoardCommentContentModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BoardCommentModel base type for findUnique actions
   */
  export type BoardCommentModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BoardCommentModel
     */
    select?: BoardCommentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardCommentModelInclude | null
    /**
     * Filter, which BoardCommentModel to fetch.
     */
    where: BoardCommentModelWhereUniqueInput
  }

  /**
   * BoardCommentModel findUnique
   */
  export interface BoardCommentModelFindUniqueArgs extends BoardCommentModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoardCommentModel findUniqueOrThrow
   */
  export type BoardCommentModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BoardCommentModel
     */
    select?: BoardCommentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardCommentModelInclude | null
    /**
     * Filter, which BoardCommentModel to fetch.
     */
    where: BoardCommentModelWhereUniqueInput
  }


  /**
   * BoardCommentModel base type for findFirst actions
   */
  export type BoardCommentModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BoardCommentModel
     */
    select?: BoardCommentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardCommentModelInclude | null
    /**
     * Filter, which BoardCommentModel to fetch.
     */
    where?: BoardCommentModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardCommentModels to fetch.
     */
    orderBy?: Enumerable<BoardCommentModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardCommentModels.
     */
    cursor?: BoardCommentModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardCommentModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardCommentModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardCommentModels.
     */
    distinct?: Enumerable<BoardCommentModelScalarFieldEnum>
  }

  /**
   * BoardCommentModel findFirst
   */
  export interface BoardCommentModelFindFirstArgs extends BoardCommentModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoardCommentModel findFirstOrThrow
   */
  export type BoardCommentModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BoardCommentModel
     */
    select?: BoardCommentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardCommentModelInclude | null
    /**
     * Filter, which BoardCommentModel to fetch.
     */
    where?: BoardCommentModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardCommentModels to fetch.
     */
    orderBy?: Enumerable<BoardCommentModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardCommentModels.
     */
    cursor?: BoardCommentModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardCommentModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardCommentModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardCommentModels.
     */
    distinct?: Enumerable<BoardCommentModelScalarFieldEnum>
  }


  /**
   * BoardCommentModel findMany
   */
  export type BoardCommentModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the BoardCommentModel
     */
    select?: BoardCommentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardCommentModelInclude | null
    /**
     * Filter, which BoardCommentModels to fetch.
     */
    where?: BoardCommentModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardCommentModels to fetch.
     */
    orderBy?: Enumerable<BoardCommentModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BoardCommentModels.
     */
    cursor?: BoardCommentModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardCommentModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardCommentModels.
     */
    skip?: number
    distinct?: Enumerable<BoardCommentModelScalarFieldEnum>
  }


  /**
   * BoardCommentModel create
   */
  export type BoardCommentModelCreateArgs = {
    /**
     * Select specific fields to fetch from the BoardCommentModel
     */
    select?: BoardCommentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardCommentModelInclude | null
    /**
     * The data needed to create a BoardCommentModel.
     */
    data: XOR<BoardCommentModelCreateInput, BoardCommentModelUncheckedCreateInput>
  }


  /**
   * BoardCommentModel createMany
   */
  export type BoardCommentModelCreateManyArgs = {
    /**
     * The data used to create many BoardCommentModels.
     */
    data: Enumerable<BoardCommentModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BoardCommentModel update
   */
  export type BoardCommentModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the BoardCommentModel
     */
    select?: BoardCommentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardCommentModelInclude | null
    /**
     * The data needed to update a BoardCommentModel.
     */
    data: XOR<BoardCommentModelUpdateInput, BoardCommentModelUncheckedUpdateInput>
    /**
     * Choose, which BoardCommentModel to update.
     */
    where: BoardCommentModelWhereUniqueInput
  }


  /**
   * BoardCommentModel updateMany
   */
  export type BoardCommentModelUpdateManyArgs = {
    /**
     * The data used to update BoardCommentModels.
     */
    data: XOR<BoardCommentModelUpdateManyMutationInput, BoardCommentModelUncheckedUpdateManyInput>
    /**
     * Filter which BoardCommentModels to update
     */
    where?: BoardCommentModelWhereInput
  }


  /**
   * BoardCommentModel upsert
   */
  export type BoardCommentModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the BoardCommentModel
     */
    select?: BoardCommentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardCommentModelInclude | null
    /**
     * The filter to search for the BoardCommentModel to update in case it exists.
     */
    where: BoardCommentModelWhereUniqueInput
    /**
     * In case the BoardCommentModel found by the `where` argument doesn't exist, create a new BoardCommentModel with this data.
     */
    create: XOR<BoardCommentModelCreateInput, BoardCommentModelUncheckedCreateInput>
    /**
     * In case the BoardCommentModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoardCommentModelUpdateInput, BoardCommentModelUncheckedUpdateInput>
  }


  /**
   * BoardCommentModel delete
   */
  export type BoardCommentModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the BoardCommentModel
     */
    select?: BoardCommentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardCommentModelInclude | null
    /**
     * Filter which BoardCommentModel to delete.
     */
    where: BoardCommentModelWhereUniqueInput
  }


  /**
   * BoardCommentModel deleteMany
   */
  export type BoardCommentModelDeleteManyArgs = {
    /**
     * Filter which BoardCommentModels to delete
     */
    where?: BoardCommentModelWhereInput
  }


  /**
   * BoardCommentModel.contents
   */
  export type BoardCommentModel$contentsArgs = {
    /**
     * Select specific fields to fetch from the BoardCommentContentModel
     */
    select?: BoardCommentContentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardCommentContentModelInclude | null
    where?: BoardCommentContentModelWhereInput
    orderBy?: Enumerable<BoardCommentContentModelOrderByWithRelationInput>
    cursor?: BoardCommentContentModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BoardCommentContentModelScalarFieldEnum>
  }


  /**
   * BoardCommentModel without action
   */
  export type BoardCommentModelArgs = {
    /**
     * Select specific fields to fetch from the BoardCommentModel
     */
    select?: BoardCommentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardCommentModelInclude | null
  }



  /**
   * Model BoardCommentContentModel
   */


  export type AggregateBoardCommentContentModel = {
    _count: BoardCommentContentModelCountAggregateOutputType | null
    _min: BoardCommentContentModelMinAggregateOutputType | null
    _max: BoardCommentContentModelMaxAggregateOutputType | null
  }

  export type BoardCommentContentModelMinAggregateOutputType = {
    id: string | null
    text: string | null
    created_at: Date | null
    comment_id: string | null
  }

  export type BoardCommentContentModelMaxAggregateOutputType = {
    id: string | null
    text: string | null
    created_at: Date | null
    comment_id: string | null
  }

  export type BoardCommentContentModelCountAggregateOutputType = {
    id: number
    text: number
    created_at: number
    comment_id: number
    _all: number
  }


  export type BoardCommentContentModelMinAggregateInputType = {
    id?: true
    text?: true
    created_at?: true
    comment_id?: true
  }

  export type BoardCommentContentModelMaxAggregateInputType = {
    id?: true
    text?: true
    created_at?: true
    comment_id?: true
  }

  export type BoardCommentContentModelCountAggregateInputType = {
    id?: true
    text?: true
    created_at?: true
    comment_id?: true
    _all?: true
  }

  export type BoardCommentContentModelAggregateArgs = {
    /**
     * Filter which BoardCommentContentModel to aggregate.
     */
    where?: BoardCommentContentModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardCommentContentModels to fetch.
     */
    orderBy?: Enumerable<BoardCommentContentModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoardCommentContentModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardCommentContentModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardCommentContentModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BoardCommentContentModels
    **/
    _count?: true | BoardCommentContentModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoardCommentContentModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoardCommentContentModelMaxAggregateInputType
  }

  export type GetBoardCommentContentModelAggregateType<T extends BoardCommentContentModelAggregateArgs> = {
        [P in keyof T & keyof AggregateBoardCommentContentModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoardCommentContentModel[P]>
      : GetScalarType<T[P], AggregateBoardCommentContentModel[P]>
  }




  export type BoardCommentContentModelGroupByArgs = {
    where?: BoardCommentContentModelWhereInput
    orderBy?: Enumerable<BoardCommentContentModelOrderByWithAggregationInput>
    by: BoardCommentContentModelScalarFieldEnum[]
    having?: BoardCommentContentModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoardCommentContentModelCountAggregateInputType | true
    _min?: BoardCommentContentModelMinAggregateInputType
    _max?: BoardCommentContentModelMaxAggregateInputType
  }


  export type BoardCommentContentModelGroupByOutputType = {
    id: string
    text: string
    created_at: Date
    comment_id: string
    _count: BoardCommentContentModelCountAggregateOutputType | null
    _min: BoardCommentContentModelMinAggregateOutputType | null
    _max: BoardCommentContentModelMaxAggregateOutputType | null
  }

  type GetBoardCommentContentModelGroupByPayload<T extends BoardCommentContentModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BoardCommentContentModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoardCommentContentModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoardCommentContentModelGroupByOutputType[P]>
            : GetScalarType<T[P], BoardCommentContentModelGroupByOutputType[P]>
        }
      >
    >


  export type BoardCommentContentModelSelect = {
    id?: boolean
    text?: boolean
    created_at?: boolean
    comment_id?: boolean
    comment?: boolean | BoardCommentModelArgs
  }


  export type BoardCommentContentModelInclude = {
    comment?: boolean | BoardCommentModelArgs
  }

  export type BoardCommentContentModelGetPayload<S extends boolean | null | undefined | BoardCommentContentModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BoardCommentContentModel :
    S extends undefined ? never :
    S extends { include: any } & (BoardCommentContentModelArgs | BoardCommentContentModelFindManyArgs)
    ? BoardCommentContentModel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'comment' ? BoardCommentModelGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BoardCommentContentModelArgs | BoardCommentContentModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'comment' ? BoardCommentModelGetPayload<S['select'][P]> :  P extends keyof BoardCommentContentModel ? BoardCommentContentModel[P] : never
  } 
      : BoardCommentContentModel


  type BoardCommentContentModelCountArgs = 
    Omit<BoardCommentContentModelFindManyArgs, 'select' | 'include'> & {
      select?: BoardCommentContentModelCountAggregateInputType | true
    }

  export interface BoardCommentContentModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BoardCommentContentModel that matches the filter.
     * @param {BoardCommentContentModelFindUniqueArgs} args - Arguments to find a BoardCommentContentModel
     * @example
     * // Get one BoardCommentContentModel
     * const boardCommentContentModel = await prisma.boardCommentContentModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BoardCommentContentModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BoardCommentContentModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BoardCommentContentModel'> extends True ? Prisma__BoardCommentContentModelClient<BoardCommentContentModelGetPayload<T>> : Prisma__BoardCommentContentModelClient<BoardCommentContentModelGetPayload<T> | null, null>

    /**
     * Find one BoardCommentContentModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BoardCommentContentModelFindUniqueOrThrowArgs} args - Arguments to find a BoardCommentContentModel
     * @example
     * // Get one BoardCommentContentModel
     * const boardCommentContentModel = await prisma.boardCommentContentModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BoardCommentContentModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BoardCommentContentModelFindUniqueOrThrowArgs>
    ): Prisma__BoardCommentContentModelClient<BoardCommentContentModelGetPayload<T>>

    /**
     * Find the first BoardCommentContentModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardCommentContentModelFindFirstArgs} args - Arguments to find a BoardCommentContentModel
     * @example
     * // Get one BoardCommentContentModel
     * const boardCommentContentModel = await prisma.boardCommentContentModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BoardCommentContentModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BoardCommentContentModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BoardCommentContentModel'> extends True ? Prisma__BoardCommentContentModelClient<BoardCommentContentModelGetPayload<T>> : Prisma__BoardCommentContentModelClient<BoardCommentContentModelGetPayload<T> | null, null>

    /**
     * Find the first BoardCommentContentModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardCommentContentModelFindFirstOrThrowArgs} args - Arguments to find a BoardCommentContentModel
     * @example
     * // Get one BoardCommentContentModel
     * const boardCommentContentModel = await prisma.boardCommentContentModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BoardCommentContentModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BoardCommentContentModelFindFirstOrThrowArgs>
    ): Prisma__BoardCommentContentModelClient<BoardCommentContentModelGetPayload<T>>

    /**
     * Find zero or more BoardCommentContentModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardCommentContentModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BoardCommentContentModels
     * const boardCommentContentModels = await prisma.boardCommentContentModel.findMany()
     * 
     * // Get first 10 BoardCommentContentModels
     * const boardCommentContentModels = await prisma.boardCommentContentModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boardCommentContentModelWithIdOnly = await prisma.boardCommentContentModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BoardCommentContentModelFindManyArgs>(
      args?: SelectSubset<T, BoardCommentContentModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<BoardCommentContentModelGetPayload<T>>>

    /**
     * Create a BoardCommentContentModel.
     * @param {BoardCommentContentModelCreateArgs} args - Arguments to create a BoardCommentContentModel.
     * @example
     * // Create one BoardCommentContentModel
     * const BoardCommentContentModel = await prisma.boardCommentContentModel.create({
     *   data: {
     *     // ... data to create a BoardCommentContentModel
     *   }
     * })
     * 
    **/
    create<T extends BoardCommentContentModelCreateArgs>(
      args: SelectSubset<T, BoardCommentContentModelCreateArgs>
    ): Prisma__BoardCommentContentModelClient<BoardCommentContentModelGetPayload<T>>

    /**
     * Create many BoardCommentContentModels.
     *     @param {BoardCommentContentModelCreateManyArgs} args - Arguments to create many BoardCommentContentModels.
     *     @example
     *     // Create many BoardCommentContentModels
     *     const boardCommentContentModel = await prisma.boardCommentContentModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BoardCommentContentModelCreateManyArgs>(
      args?: SelectSubset<T, BoardCommentContentModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BoardCommentContentModel.
     * @param {BoardCommentContentModelDeleteArgs} args - Arguments to delete one BoardCommentContentModel.
     * @example
     * // Delete one BoardCommentContentModel
     * const BoardCommentContentModel = await prisma.boardCommentContentModel.delete({
     *   where: {
     *     // ... filter to delete one BoardCommentContentModel
     *   }
     * })
     * 
    **/
    delete<T extends BoardCommentContentModelDeleteArgs>(
      args: SelectSubset<T, BoardCommentContentModelDeleteArgs>
    ): Prisma__BoardCommentContentModelClient<BoardCommentContentModelGetPayload<T>>

    /**
     * Update one BoardCommentContentModel.
     * @param {BoardCommentContentModelUpdateArgs} args - Arguments to update one BoardCommentContentModel.
     * @example
     * // Update one BoardCommentContentModel
     * const boardCommentContentModel = await prisma.boardCommentContentModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BoardCommentContentModelUpdateArgs>(
      args: SelectSubset<T, BoardCommentContentModelUpdateArgs>
    ): Prisma__BoardCommentContentModelClient<BoardCommentContentModelGetPayload<T>>

    /**
     * Delete zero or more BoardCommentContentModels.
     * @param {BoardCommentContentModelDeleteManyArgs} args - Arguments to filter BoardCommentContentModels to delete.
     * @example
     * // Delete a few BoardCommentContentModels
     * const { count } = await prisma.boardCommentContentModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BoardCommentContentModelDeleteManyArgs>(
      args?: SelectSubset<T, BoardCommentContentModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoardCommentContentModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardCommentContentModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BoardCommentContentModels
     * const boardCommentContentModel = await prisma.boardCommentContentModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BoardCommentContentModelUpdateManyArgs>(
      args: SelectSubset<T, BoardCommentContentModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BoardCommentContentModel.
     * @param {BoardCommentContentModelUpsertArgs} args - Arguments to update or create a BoardCommentContentModel.
     * @example
     * // Update or create a BoardCommentContentModel
     * const boardCommentContentModel = await prisma.boardCommentContentModel.upsert({
     *   create: {
     *     // ... data to create a BoardCommentContentModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BoardCommentContentModel we want to update
     *   }
     * })
    **/
    upsert<T extends BoardCommentContentModelUpsertArgs>(
      args: SelectSubset<T, BoardCommentContentModelUpsertArgs>
    ): Prisma__BoardCommentContentModelClient<BoardCommentContentModelGetPayload<T>>

    /**
     * Count the number of BoardCommentContentModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardCommentContentModelCountArgs} args - Arguments to filter BoardCommentContentModels to count.
     * @example
     * // Count the number of BoardCommentContentModels
     * const count = await prisma.boardCommentContentModel.count({
     *   where: {
     *     // ... the filter for the BoardCommentContentModels we want to count
     *   }
     * })
    **/
    count<T extends BoardCommentContentModelCountArgs>(
      args?: Subset<T, BoardCommentContentModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoardCommentContentModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BoardCommentContentModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardCommentContentModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoardCommentContentModelAggregateArgs>(args: Subset<T, BoardCommentContentModelAggregateArgs>): Prisma.PrismaPromise<GetBoardCommentContentModelAggregateType<T>>

    /**
     * Group by BoardCommentContentModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardCommentContentModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoardCommentContentModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoardCommentContentModelGroupByArgs['orderBy'] }
        : { orderBy?: BoardCommentContentModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoardCommentContentModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoardCommentContentModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BoardCommentContentModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BoardCommentContentModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    comment<T extends BoardCommentModelArgs= {}>(args?: Subset<T, BoardCommentModelArgs>): Prisma__BoardCommentModelClient<BoardCommentModelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BoardCommentContentModel base type for findUnique actions
   */
  export type BoardCommentContentModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BoardCommentContentModel
     */
    select?: BoardCommentContentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardCommentContentModelInclude | null
    /**
     * Filter, which BoardCommentContentModel to fetch.
     */
    where: BoardCommentContentModelWhereUniqueInput
  }

  /**
   * BoardCommentContentModel findUnique
   */
  export interface BoardCommentContentModelFindUniqueArgs extends BoardCommentContentModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoardCommentContentModel findUniqueOrThrow
   */
  export type BoardCommentContentModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BoardCommentContentModel
     */
    select?: BoardCommentContentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardCommentContentModelInclude | null
    /**
     * Filter, which BoardCommentContentModel to fetch.
     */
    where: BoardCommentContentModelWhereUniqueInput
  }


  /**
   * BoardCommentContentModel base type for findFirst actions
   */
  export type BoardCommentContentModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BoardCommentContentModel
     */
    select?: BoardCommentContentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardCommentContentModelInclude | null
    /**
     * Filter, which BoardCommentContentModel to fetch.
     */
    where?: BoardCommentContentModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardCommentContentModels to fetch.
     */
    orderBy?: Enumerable<BoardCommentContentModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardCommentContentModels.
     */
    cursor?: BoardCommentContentModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardCommentContentModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardCommentContentModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardCommentContentModels.
     */
    distinct?: Enumerable<BoardCommentContentModelScalarFieldEnum>
  }

  /**
   * BoardCommentContentModel findFirst
   */
  export interface BoardCommentContentModelFindFirstArgs extends BoardCommentContentModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoardCommentContentModel findFirstOrThrow
   */
  export type BoardCommentContentModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BoardCommentContentModel
     */
    select?: BoardCommentContentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardCommentContentModelInclude | null
    /**
     * Filter, which BoardCommentContentModel to fetch.
     */
    where?: BoardCommentContentModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardCommentContentModels to fetch.
     */
    orderBy?: Enumerable<BoardCommentContentModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardCommentContentModels.
     */
    cursor?: BoardCommentContentModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardCommentContentModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardCommentContentModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardCommentContentModels.
     */
    distinct?: Enumerable<BoardCommentContentModelScalarFieldEnum>
  }


  /**
   * BoardCommentContentModel findMany
   */
  export type BoardCommentContentModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the BoardCommentContentModel
     */
    select?: BoardCommentContentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardCommentContentModelInclude | null
    /**
     * Filter, which BoardCommentContentModels to fetch.
     */
    where?: BoardCommentContentModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardCommentContentModels to fetch.
     */
    orderBy?: Enumerable<BoardCommentContentModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BoardCommentContentModels.
     */
    cursor?: BoardCommentContentModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardCommentContentModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardCommentContentModels.
     */
    skip?: number
    distinct?: Enumerable<BoardCommentContentModelScalarFieldEnum>
  }


  /**
   * BoardCommentContentModel create
   */
  export type BoardCommentContentModelCreateArgs = {
    /**
     * Select specific fields to fetch from the BoardCommentContentModel
     */
    select?: BoardCommentContentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardCommentContentModelInclude | null
    /**
     * The data needed to create a BoardCommentContentModel.
     */
    data: XOR<BoardCommentContentModelCreateInput, BoardCommentContentModelUncheckedCreateInput>
  }


  /**
   * BoardCommentContentModel createMany
   */
  export type BoardCommentContentModelCreateManyArgs = {
    /**
     * The data used to create many BoardCommentContentModels.
     */
    data: Enumerable<BoardCommentContentModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BoardCommentContentModel update
   */
  export type BoardCommentContentModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the BoardCommentContentModel
     */
    select?: BoardCommentContentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardCommentContentModelInclude | null
    /**
     * The data needed to update a BoardCommentContentModel.
     */
    data: XOR<BoardCommentContentModelUpdateInput, BoardCommentContentModelUncheckedUpdateInput>
    /**
     * Choose, which BoardCommentContentModel to update.
     */
    where: BoardCommentContentModelWhereUniqueInput
  }


  /**
   * BoardCommentContentModel updateMany
   */
  export type BoardCommentContentModelUpdateManyArgs = {
    /**
     * The data used to update BoardCommentContentModels.
     */
    data: XOR<BoardCommentContentModelUpdateManyMutationInput, BoardCommentContentModelUncheckedUpdateManyInput>
    /**
     * Filter which BoardCommentContentModels to update
     */
    where?: BoardCommentContentModelWhereInput
  }


  /**
   * BoardCommentContentModel upsert
   */
  export type BoardCommentContentModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the BoardCommentContentModel
     */
    select?: BoardCommentContentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardCommentContentModelInclude | null
    /**
     * The filter to search for the BoardCommentContentModel to update in case it exists.
     */
    where: BoardCommentContentModelWhereUniqueInput
    /**
     * In case the BoardCommentContentModel found by the `where` argument doesn't exist, create a new BoardCommentContentModel with this data.
     */
    create: XOR<BoardCommentContentModelCreateInput, BoardCommentContentModelUncheckedCreateInput>
    /**
     * In case the BoardCommentContentModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoardCommentContentModelUpdateInput, BoardCommentContentModelUncheckedUpdateInput>
  }


  /**
   * BoardCommentContentModel delete
   */
  export type BoardCommentContentModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the BoardCommentContentModel
     */
    select?: BoardCommentContentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardCommentContentModelInclude | null
    /**
     * Filter which BoardCommentContentModel to delete.
     */
    where: BoardCommentContentModelWhereUniqueInput
  }


  /**
   * BoardCommentContentModel deleteMany
   */
  export type BoardCommentContentModelDeleteManyArgs = {
    /**
     * Filter which BoardCommentContentModels to delete
     */
    where?: BoardCommentContentModelWhereInput
  }


  /**
   * BoardCommentContentModel without action
   */
  export type BoardCommentContentModelArgs = {
    /**
     * Select specific fields to fetch from the BoardCommentContentModel
     */
    select?: BoardCommentContentModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardCommentContentModelInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AuthenticationModelScalarFieldEnum: {
    id: 'id',
    oauth_sub: 'oauth_sub',
    oauth_type: 'oauth_type',
    business_user_id: 'business_user_id',
    customer_id: 'customer_id'
  };

  export type AuthenticationModelScalarFieldEnum = (typeof AuthenticationModelScalarFieldEnum)[keyof typeof AuthenticationModelScalarFieldEnum]


  export const BoardArticleContentModelScalarFieldEnum: {
    id: 'id',
    text: 'text',
    created_at: 'created_at',
    article_id: 'article_id'
  };

  export type BoardArticleContentModelScalarFieldEnum = (typeof BoardArticleContentModelScalarFieldEnum)[keyof typeof BoardArticleContentModelScalarFieldEnum]


  export const BoardArticleModelScalarFieldEnum: {
    id: 'id',
    title: 'title',
    author_id: 'author_id',
    board_id: 'board_id'
  };

  export type BoardArticleModelScalarFieldEnum = (typeof BoardArticleModelScalarFieldEnum)[keyof typeof BoardArticleModelScalarFieldEnum]


  export const BoardCommentContentModelScalarFieldEnum: {
    id: 'id',
    text: 'text',
    created_at: 'created_at',
    comment_id: 'comment_id'
  };

  export type BoardCommentContentModelScalarFieldEnum = (typeof BoardCommentContentModelScalarFieldEnum)[keyof typeof BoardCommentContentModelScalarFieldEnum]


  export const BoardCommentModelScalarFieldEnum: {
    id: 'id',
    author_id: 'author_id',
    article_id: 'article_id'
  };

  export type BoardCommentModelScalarFieldEnum = (typeof BoardCommentModelScalarFieldEnum)[keyof typeof BoardCommentModelScalarFieldEnum]


  export const BoardModelScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type BoardModelScalarFieldEnum = (typeof BoardModelScalarFieldEnum)[keyof typeof BoardModelScalarFieldEnum]


  export const BusinessRateCategoryModelScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type BusinessRateCategoryModelScalarFieldEnum = (typeof BusinessRateCategoryModelScalarFieldEnum)[keyof typeof BusinessRateCategoryModelScalarFieldEnum]


  export const BusinessRateModelScalarFieldEnum: {
    id: 'id',
    category_id: 'category_id',
    ratee_id: 'ratee_id',
    rater_id: 'rater_id',
    rate: 'rate'
  };

  export type BusinessRateModelScalarFieldEnum = (typeof BusinessRateModelScalarFieldEnum)[keyof typeof BusinessRateModelScalarFieldEnum]


  export const BusinessReviewModelScalarFieldEnum: {
    id: 'id',
    reviewee_id: 'reviewee_id',
    reviewer_id: 'reviewer_id',
    review: 'review'
  };

  export type BusinessReviewModelScalarFieldEnum = (typeof BusinessReviewModelScalarFieldEnum)[keyof typeof BusinessReviewModelScalarFieldEnum]


  export const BusinessUserModelScalarFieldEnum: {
    id: 'id',
    is_verified: 'is_verified',
    introduction_title: 'introduction_title',
    introduction_content: 'introduction_content'
  };

  export type BusinessUserModelScalarFieldEnum = (typeof BusinessUserModelScalarFieldEnum)[keyof typeof BusinessUserModelScalarFieldEnum]


  export const CustomerModelScalarFieldEnum: {
    id: 'id',
    birth: 'birth',
    gender: 'gender'
  };

  export type CustomerModelScalarFieldEnum = (typeof CustomerModelScalarFieldEnum)[keyof typeof CustomerModelScalarFieldEnum]


  export const HomeCareCompanyModelScalarFieldEnum: {
    id: 'id',
    business_registration_num: 'business_registration_num',
    specialized_field_id: 'specialized_field_id'
  };

  export type HomeCareCompanyModelScalarFieldEnum = (typeof HomeCareCompanyModelScalarFieldEnum)[keyof typeof HomeCareCompanyModelScalarFieldEnum]


  export const HomeCareIntroductionImageModelScalarFieldEnum: {
    id: 'id',
    image_url: 'image_url',
    company_id: 'company_id'
  };

  export type HomeCareIntroductionImageModelScalarFieldEnum = (typeof HomeCareIntroductionImageModelScalarFieldEnum)[keyof typeof HomeCareIntroductionImageModelScalarFieldEnum]


  export const HomeCareSpecializedSubFieldModelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    super_id: 'super_id'
  };

  export type HomeCareSpecializedSubFieldModelScalarFieldEnum = (typeof HomeCareSpecializedSubFieldModelScalarFieldEnum)[keyof typeof HomeCareSpecializedSubFieldModelScalarFieldEnum]


  export const HomeCareSpecializedSuperFieldModelScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type HomeCareSpecializedSuperFieldModelScalarFieldEnum = (typeof HomeCareSpecializedSuperFieldModelScalarFieldEnum)[keyof typeof HomeCareSpecializedSuperFieldModelScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const RealEstateAgentModelScalarFieldEnum: {
    id: 'id',
    is_licensed: 'is_licensed',
    real_estate_num: 'real_estate_num',
    real_estate_name: 'real_estate_name',
    real_estate_phone: 'real_estate_phone',
    licensed_agent_name: 'licensed_agent_name',
    specialized_field_id: 'specialized_field_id'
  };

  export type RealEstateAgentModelScalarFieldEnum = (typeof RealEstateAgentModelScalarFieldEnum)[keyof typeof RealEstateAgentModelScalarFieldEnum]


  export const RealEstatePropertyModelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    main_image_url: 'main_image_url',
    agent_id: 'agent_id'
  };

  export type RealEstatePropertyModelScalarFieldEnum = (typeof RealEstatePropertyModelScalarFieldEnum)[keyof typeof RealEstatePropertyModelScalarFieldEnum]


  export const RealEstateSpecializedSubFieldModelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    super_id: 'super_id'
  };

  export type RealEstateSpecializedSubFieldModelScalarFieldEnum = (typeof RealEstateSpecializedSubFieldModelScalarFieldEnum)[keyof typeof RealEstateSpecializedSubFieldModelScalarFieldEnum]


  export const RealEstateSpecializedSuperFieldModelScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RealEstateSpecializedSuperFieldModelScalarFieldEnum = (typeof RealEstateSpecializedSuperFieldModelScalarFieldEnum)[keyof typeof RealEstateSpecializedSuperFieldModelScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserModelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    email_verified: 'email_verified',
    phone: 'phone',
    phone_verified: 'phone_verified',
    address_first: 'address_first',
    address_second: 'address_second',
    profile_image: 'profile_image'
  };

  export type UserModelScalarFieldEnum = (typeof UserModelScalarFieldEnum)[keyof typeof UserModelScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type AuthenticationModelWhereInput = {
    AND?: Enumerable<AuthenticationModelWhereInput>
    OR?: Enumerable<AuthenticationModelWhereInput>
    NOT?: Enumerable<AuthenticationModelWhereInput>
    id?: StringFilter | string
    oauth_sub?: StringFilter | string
    oauth_type?: StringFilter | string
    business_user_id?: StringNullableFilter | string | null
    customer_id?: StringNullableFilter | string | null
    business_user?: XOR<BusinessUserModelRelationFilter, BusinessUserModelWhereInput> | null
    customer?: XOR<CustomerModelRelationFilter, CustomerModelWhereInput> | null
  }

  export type AuthenticationModelOrderByWithRelationInput = {
    id?: SortOrder
    oauth_sub?: SortOrder
    oauth_type?: SortOrder
    business_user_id?: SortOrder
    customer_id?: SortOrder
    business_user?: BusinessUserModelOrderByWithRelationInput
    customer?: CustomerModelOrderByWithRelationInput
  }

  export type AuthenticationModelWhereUniqueInput = {
    id?: string
    oauth_sub_oauth_type?: AuthenticationModelOauth_subOauth_typeCompoundUniqueInput
  }

  export type AuthenticationModelOrderByWithAggregationInput = {
    id?: SortOrder
    oauth_sub?: SortOrder
    oauth_type?: SortOrder
    business_user_id?: SortOrder
    customer_id?: SortOrder
    _count?: AuthenticationModelCountOrderByAggregateInput
    _max?: AuthenticationModelMaxOrderByAggregateInput
    _min?: AuthenticationModelMinOrderByAggregateInput
  }

  export type AuthenticationModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AuthenticationModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<AuthenticationModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AuthenticationModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    oauth_sub?: StringWithAggregatesFilter | string
    oauth_type?: StringWithAggregatesFilter | string
    business_user_id?: StringNullableWithAggregatesFilter | string | null
    customer_id?: StringNullableWithAggregatesFilter | string | null
  }

  export type UserModelWhereInput = {
    AND?: Enumerable<UserModelWhereInput>
    OR?: Enumerable<UserModelWhereInput>
    NOT?: Enumerable<UserModelWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    email?: StringNullableFilter | string | null
    email_verified?: BoolFilter | boolean
    phone?: StringNullableFilter | string | null
    phone_verified?: BoolFilter | boolean
    address_first?: StringNullableFilter | string | null
    address_second?: StringNullableFilter | string | null
    profile_image?: StringNullableFilter | string | null
    customer?: XOR<CustomerModelRelationFilter, CustomerModelWhereInput> | null
    business_user?: XOR<BusinessUserModelRelationFilter, BusinessUserModelWhereInput> | null
    board_articles?: BoardArticleModelListRelationFilter
    board_comments?: BoardCommentModelListRelationFilter
  }

  export type UserModelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified?: SortOrder
    phone?: SortOrder
    phone_verified?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
    profile_image?: SortOrder
    customer?: CustomerModelOrderByWithRelationInput
    business_user?: BusinessUserModelOrderByWithRelationInput
    board_articles?: BoardArticleModelOrderByRelationAggregateInput
    board_comments?: BoardCommentModelOrderByRelationAggregateInput
  }

  export type UserModelWhereUniqueInput = {
    id?: string
  }

  export type UserModelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified?: SortOrder
    phone?: SortOrder
    phone_verified?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
    profile_image?: SortOrder
    _count?: UserModelCountOrderByAggregateInput
    _max?: UserModelMaxOrderByAggregateInput
    _min?: UserModelMinOrderByAggregateInput
  }

  export type UserModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    email?: StringNullableWithAggregatesFilter | string | null
    email_verified?: BoolWithAggregatesFilter | boolean
    phone?: StringNullableWithAggregatesFilter | string | null
    phone_verified?: BoolWithAggregatesFilter | boolean
    address_first?: StringNullableWithAggregatesFilter | string | null
    address_second?: StringNullableWithAggregatesFilter | string | null
    profile_image?: StringNullableWithAggregatesFilter | string | null
  }

  export type CustomerModelWhereInput = {
    AND?: Enumerable<CustomerModelWhereInput>
    OR?: Enumerable<CustomerModelWhereInput>
    NOT?: Enumerable<CustomerModelWhereInput>
    id?: StringFilter | string
    birth?: StringNullableFilter | string | null
    gender?: StringNullableFilter | string | null
    user?: XOR<UserModelRelationFilter, UserModelWhereInput>
    authentications?: AuthenticationModelListRelationFilter
    rates?: BusinessRateModelListRelationFilter
    reviews?: BusinessReviewModelListRelationFilter
  }

  export type CustomerModelOrderByWithRelationInput = {
    id?: SortOrder
    birth?: SortOrder
    gender?: SortOrder
    user?: UserModelOrderByWithRelationInput
    authentications?: AuthenticationModelOrderByRelationAggregateInput
    rates?: BusinessRateModelOrderByRelationAggregateInput
    reviews?: BusinessReviewModelOrderByRelationAggregateInput
  }

  export type CustomerModelWhereUniqueInput = {
    id?: string
  }

  export type CustomerModelOrderByWithAggregationInput = {
    id?: SortOrder
    birth?: SortOrder
    gender?: SortOrder
    _count?: CustomerModelCountOrderByAggregateInput
    _max?: CustomerModelMaxOrderByAggregateInput
    _min?: CustomerModelMinOrderByAggregateInput
  }

  export type CustomerModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    birth?: StringNullableWithAggregatesFilter | string | null
    gender?: StringNullableWithAggregatesFilter | string | null
  }

  export type BusinessUserModelWhereInput = {
    AND?: Enumerable<BusinessUserModelWhereInput>
    OR?: Enumerable<BusinessUserModelWhereInput>
    NOT?: Enumerable<BusinessUserModelWhereInput>
    id?: StringFilter | string
    is_verified?: BoolFilter | boolean
    introduction_title?: StringFilter | string
    introduction_content?: StringFilter | string
    user?: XOR<UserModelRelationFilter, UserModelWhereInput>
    authentications?: AuthenticationModelListRelationFilter
    real_estate_agent?: XOR<RealEstateAgentModelRelationFilter, RealEstateAgentModelWhereInput> | null
    home_care_company?: XOR<HomeCareCompanyModelRelationFilter, HomeCareCompanyModelWhereInput> | null
    rates?: BusinessRateModelListRelationFilter
    reviews?: BusinessReviewModelListRelationFilter
  }

  export type BusinessUserModelOrderByWithRelationInput = {
    id?: SortOrder
    is_verified?: SortOrder
    introduction_title?: SortOrder
    introduction_content?: SortOrder
    user?: UserModelOrderByWithRelationInput
    authentications?: AuthenticationModelOrderByRelationAggregateInput
    real_estate_agent?: RealEstateAgentModelOrderByWithRelationInput
    home_care_company?: HomeCareCompanyModelOrderByWithRelationInput
    rates?: BusinessRateModelOrderByRelationAggregateInput
    reviews?: BusinessReviewModelOrderByRelationAggregateInput
  }

  export type BusinessUserModelWhereUniqueInput = {
    id?: string
  }

  export type BusinessUserModelOrderByWithAggregationInput = {
    id?: SortOrder
    is_verified?: SortOrder
    introduction_title?: SortOrder
    introduction_content?: SortOrder
    _count?: BusinessUserModelCountOrderByAggregateInput
    _max?: BusinessUserModelMaxOrderByAggregateInput
    _min?: BusinessUserModelMinOrderByAggregateInput
  }

  export type BusinessUserModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BusinessUserModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<BusinessUserModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BusinessUserModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    is_verified?: BoolWithAggregatesFilter | boolean
    introduction_title?: StringWithAggregatesFilter | string
    introduction_content?: StringWithAggregatesFilter | string
  }

  export type RealEstateAgentModelWhereInput = {
    AND?: Enumerable<RealEstateAgentModelWhereInput>
    OR?: Enumerable<RealEstateAgentModelWhereInput>
    NOT?: Enumerable<RealEstateAgentModelWhereInput>
    id?: StringFilter | string
    is_licensed?: BoolFilter | boolean
    real_estate_num?: StringFilter | string
    real_estate_name?: StringFilter | string
    real_estate_phone?: StringFilter | string
    licensed_agent_name?: StringFilter | string
    specialized_field_id?: StringNullableFilter | string | null
    business?: XOR<BusinessUserModelRelationFilter, BusinessUserModelWhereInput>
    specialized_field?: XOR<RealEstateSpecializedSubFieldModelRelationFilter, RealEstateSpecializedSubFieldModelWhereInput> | null
    properties?: RealEstatePropertyModelListRelationFilter
  }

  export type RealEstateAgentModelOrderByWithRelationInput = {
    id?: SortOrder
    is_licensed?: SortOrder
    real_estate_num?: SortOrder
    real_estate_name?: SortOrder
    real_estate_phone?: SortOrder
    licensed_agent_name?: SortOrder
    specialized_field_id?: SortOrder
    business?: BusinessUserModelOrderByWithRelationInput
    specialized_field?: RealEstateSpecializedSubFieldModelOrderByWithRelationInput
    properties?: RealEstatePropertyModelOrderByRelationAggregateInput
  }

  export type RealEstateAgentModelWhereUniqueInput = {
    id?: string
  }

  export type RealEstateAgentModelOrderByWithAggregationInput = {
    id?: SortOrder
    is_licensed?: SortOrder
    real_estate_num?: SortOrder
    real_estate_name?: SortOrder
    real_estate_phone?: SortOrder
    licensed_agent_name?: SortOrder
    specialized_field_id?: SortOrder
    _count?: RealEstateAgentModelCountOrderByAggregateInput
    _max?: RealEstateAgentModelMaxOrderByAggregateInput
    _min?: RealEstateAgentModelMinOrderByAggregateInput
  }

  export type RealEstateAgentModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RealEstateAgentModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<RealEstateAgentModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RealEstateAgentModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    is_licensed?: BoolWithAggregatesFilter | boolean
    real_estate_num?: StringWithAggregatesFilter | string
    real_estate_name?: StringWithAggregatesFilter | string
    real_estate_phone?: StringWithAggregatesFilter | string
    licensed_agent_name?: StringWithAggregatesFilter | string
    specialized_field_id?: StringNullableWithAggregatesFilter | string | null
  }

  export type HomeCareCompanyModelWhereInput = {
    AND?: Enumerable<HomeCareCompanyModelWhereInput>
    OR?: Enumerable<HomeCareCompanyModelWhereInput>
    NOT?: Enumerable<HomeCareCompanyModelWhereInput>
    id?: StringFilter | string
    business_registration_num?: StringFilter | string
    specialized_field_id?: StringNullableFilter | string | null
    business?: XOR<BusinessUserModelRelationFilter, BusinessUserModelWhereInput>
    specialized_field?: XOR<HomeCareSpecializedSubFieldModelRelationFilter, HomeCareSpecializedSubFieldModelWhereInput> | null
    introduction_images?: HomeCareIntroductionImageModelListRelationFilter
  }

  export type HomeCareCompanyModelOrderByWithRelationInput = {
    id?: SortOrder
    business_registration_num?: SortOrder
    specialized_field_id?: SortOrder
    business?: BusinessUserModelOrderByWithRelationInput
    specialized_field?: HomeCareSpecializedSubFieldModelOrderByWithRelationInput
    introduction_images?: HomeCareIntroductionImageModelOrderByRelationAggregateInput
  }

  export type HomeCareCompanyModelWhereUniqueInput = {
    id?: string
  }

  export type HomeCareCompanyModelOrderByWithAggregationInput = {
    id?: SortOrder
    business_registration_num?: SortOrder
    specialized_field_id?: SortOrder
    _count?: HomeCareCompanyModelCountOrderByAggregateInput
    _max?: HomeCareCompanyModelMaxOrderByAggregateInput
    _min?: HomeCareCompanyModelMinOrderByAggregateInput
  }

  export type HomeCareCompanyModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HomeCareCompanyModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<HomeCareCompanyModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HomeCareCompanyModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    business_registration_num?: StringWithAggregatesFilter | string
    specialized_field_id?: StringNullableWithAggregatesFilter | string | null
  }

  export type HomeCareIntroductionImageModelWhereInput = {
    AND?: Enumerable<HomeCareIntroductionImageModelWhereInput>
    OR?: Enumerable<HomeCareIntroductionImageModelWhereInput>
    NOT?: Enumerable<HomeCareIntroductionImageModelWhereInput>
    id?: StringFilter | string
    image_url?: StringFilter | string
    company_id?: StringFilter | string
    company?: XOR<HomeCareCompanyModelRelationFilter, HomeCareCompanyModelWhereInput>
  }

  export type HomeCareIntroductionImageModelOrderByWithRelationInput = {
    id?: SortOrder
    image_url?: SortOrder
    company_id?: SortOrder
    company?: HomeCareCompanyModelOrderByWithRelationInput
  }

  export type HomeCareIntroductionImageModelWhereUniqueInput = {
    id?: string
  }

  export type HomeCareIntroductionImageModelOrderByWithAggregationInput = {
    id?: SortOrder
    image_url?: SortOrder
    company_id?: SortOrder
    _count?: HomeCareIntroductionImageModelCountOrderByAggregateInput
    _max?: HomeCareIntroductionImageModelMaxOrderByAggregateInput
    _min?: HomeCareIntroductionImageModelMinOrderByAggregateInput
  }

  export type HomeCareIntroductionImageModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HomeCareIntroductionImageModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<HomeCareIntroductionImageModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HomeCareIntroductionImageModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    image_url?: StringWithAggregatesFilter | string
    company_id?: StringWithAggregatesFilter | string
  }

  export type RealEstatePropertyModelWhereInput = {
    AND?: Enumerable<RealEstatePropertyModelWhereInput>
    OR?: Enumerable<RealEstatePropertyModelWhereInput>
    NOT?: Enumerable<RealEstatePropertyModelWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    main_image_url?: StringFilter | string
    agent_id?: StringFilter | string
    agent?: XOR<RealEstateAgentModelRelationFilter, RealEstateAgentModelWhereInput>
  }

  export type RealEstatePropertyModelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    main_image_url?: SortOrder
    agent_id?: SortOrder
    agent?: RealEstateAgentModelOrderByWithRelationInput
  }

  export type RealEstatePropertyModelWhereUniqueInput = {
    id?: string
  }

  export type RealEstatePropertyModelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    main_image_url?: SortOrder
    agent_id?: SortOrder
    _count?: RealEstatePropertyModelCountOrderByAggregateInput
    _max?: RealEstatePropertyModelMaxOrderByAggregateInput
    _min?: RealEstatePropertyModelMinOrderByAggregateInput
  }

  export type RealEstatePropertyModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RealEstatePropertyModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<RealEstatePropertyModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RealEstatePropertyModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    main_image_url?: StringWithAggregatesFilter | string
    agent_id?: StringWithAggregatesFilter | string
  }

  export type HomeCareSpecializedSuperFieldModelWhereInput = {
    AND?: Enumerable<HomeCareSpecializedSuperFieldModelWhereInput>
    OR?: Enumerable<HomeCareSpecializedSuperFieldModelWhereInput>
    NOT?: Enumerable<HomeCareSpecializedSuperFieldModelWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    sub?: HomeCareSpecializedSubFieldModelListRelationFilter
  }

  export type HomeCareSpecializedSuperFieldModelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    sub?: HomeCareSpecializedSubFieldModelOrderByRelationAggregateInput
  }

  export type HomeCareSpecializedSuperFieldModelWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type HomeCareSpecializedSuperFieldModelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: HomeCareSpecializedSuperFieldModelCountOrderByAggregateInput
    _max?: HomeCareSpecializedSuperFieldModelMaxOrderByAggregateInput
    _min?: HomeCareSpecializedSuperFieldModelMinOrderByAggregateInput
  }

  export type HomeCareSpecializedSuperFieldModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HomeCareSpecializedSuperFieldModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<HomeCareSpecializedSuperFieldModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HomeCareSpecializedSuperFieldModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
  }

  export type HomeCareSpecializedSubFieldModelWhereInput = {
    AND?: Enumerable<HomeCareSpecializedSubFieldModelWhereInput>
    OR?: Enumerable<HomeCareSpecializedSubFieldModelWhereInput>
    NOT?: Enumerable<HomeCareSpecializedSubFieldModelWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    super_id?: StringFilter | string
    super?: XOR<HomeCareSpecializedSuperFieldModelRelationFilter, HomeCareSpecializedSuperFieldModelWhereInput>
    home_care_companies?: HomeCareCompanyModelListRelationFilter
  }

  export type HomeCareSpecializedSubFieldModelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    super_id?: SortOrder
    super?: HomeCareSpecializedSuperFieldModelOrderByWithRelationInput
    home_care_companies?: HomeCareCompanyModelOrderByRelationAggregateInput
  }

  export type HomeCareSpecializedSubFieldModelWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type HomeCareSpecializedSubFieldModelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    super_id?: SortOrder
    _count?: HomeCareSpecializedSubFieldModelCountOrderByAggregateInput
    _max?: HomeCareSpecializedSubFieldModelMaxOrderByAggregateInput
    _min?: HomeCareSpecializedSubFieldModelMinOrderByAggregateInput
  }

  export type HomeCareSpecializedSubFieldModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HomeCareSpecializedSubFieldModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<HomeCareSpecializedSubFieldModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HomeCareSpecializedSubFieldModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    super_id?: StringWithAggregatesFilter | string
  }

  export type RealEstateSpecializedSuperFieldModelWhereInput = {
    AND?: Enumerable<RealEstateSpecializedSuperFieldModelWhereInput>
    OR?: Enumerable<RealEstateSpecializedSuperFieldModelWhereInput>
    NOT?: Enumerable<RealEstateSpecializedSuperFieldModelWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    sub?: RealEstateSpecializedSubFieldModelListRelationFilter
  }

  export type RealEstateSpecializedSuperFieldModelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    sub?: RealEstateSpecializedSubFieldModelOrderByRelationAggregateInput
  }

  export type RealEstateSpecializedSuperFieldModelWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type RealEstateSpecializedSuperFieldModelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: RealEstateSpecializedSuperFieldModelCountOrderByAggregateInput
    _max?: RealEstateSpecializedSuperFieldModelMaxOrderByAggregateInput
    _min?: RealEstateSpecializedSuperFieldModelMinOrderByAggregateInput
  }

  export type RealEstateSpecializedSuperFieldModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RealEstateSpecializedSuperFieldModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<RealEstateSpecializedSuperFieldModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RealEstateSpecializedSuperFieldModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
  }

  export type RealEstateSpecializedSubFieldModelWhereInput = {
    AND?: Enumerable<RealEstateSpecializedSubFieldModelWhereInput>
    OR?: Enumerable<RealEstateSpecializedSubFieldModelWhereInput>
    NOT?: Enumerable<RealEstateSpecializedSubFieldModelWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    super_id?: StringFilter | string
    super?: XOR<RealEstateSpecializedSuperFieldModelRelationFilter, RealEstateSpecializedSuperFieldModelWhereInput>
    real_estate_agents?: RealEstateAgentModelListRelationFilter
  }

  export type RealEstateSpecializedSubFieldModelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    super_id?: SortOrder
    super?: RealEstateSpecializedSuperFieldModelOrderByWithRelationInput
    real_estate_agents?: RealEstateAgentModelOrderByRelationAggregateInput
  }

  export type RealEstateSpecializedSubFieldModelWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type RealEstateSpecializedSubFieldModelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    super_id?: SortOrder
    _count?: RealEstateSpecializedSubFieldModelCountOrderByAggregateInput
    _max?: RealEstateSpecializedSubFieldModelMaxOrderByAggregateInput
    _min?: RealEstateSpecializedSubFieldModelMinOrderByAggregateInput
  }

  export type RealEstateSpecializedSubFieldModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RealEstateSpecializedSubFieldModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<RealEstateSpecializedSubFieldModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RealEstateSpecializedSubFieldModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    super_id?: StringWithAggregatesFilter | string
  }

  export type BusinessRateModelWhereInput = {
    AND?: Enumerable<BusinessRateModelWhereInput>
    OR?: Enumerable<BusinessRateModelWhereInput>
    NOT?: Enumerable<BusinessRateModelWhereInput>
    id?: StringFilter | string
    category_id?: StringFilter | string
    ratee_id?: StringFilter | string
    rater_id?: StringFilter | string
    rate?: IntFilter | number
    ratee?: XOR<BusinessUserModelRelationFilter, BusinessUserModelWhereInput>
    rater?: XOR<CustomerModelRelationFilter, CustomerModelWhereInput>
    category?: XOR<BusinessRateCategoryModelRelationFilter, BusinessRateCategoryModelWhereInput>
  }

  export type BusinessRateModelOrderByWithRelationInput = {
    id?: SortOrder
    category_id?: SortOrder
    ratee_id?: SortOrder
    rater_id?: SortOrder
    rate?: SortOrder
    ratee?: BusinessUserModelOrderByWithRelationInput
    rater?: CustomerModelOrderByWithRelationInput
    category?: BusinessRateCategoryModelOrderByWithRelationInput
  }

  export type BusinessRateModelWhereUniqueInput = {
    id?: string
  }

  export type BusinessRateModelOrderByWithAggregationInput = {
    id?: SortOrder
    category_id?: SortOrder
    ratee_id?: SortOrder
    rater_id?: SortOrder
    rate?: SortOrder
    _count?: BusinessRateModelCountOrderByAggregateInput
    _avg?: BusinessRateModelAvgOrderByAggregateInput
    _max?: BusinessRateModelMaxOrderByAggregateInput
    _min?: BusinessRateModelMinOrderByAggregateInput
    _sum?: BusinessRateModelSumOrderByAggregateInput
  }

  export type BusinessRateModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BusinessRateModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<BusinessRateModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BusinessRateModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    category_id?: StringWithAggregatesFilter | string
    ratee_id?: StringWithAggregatesFilter | string
    rater_id?: StringWithAggregatesFilter | string
    rate?: IntWithAggregatesFilter | number
  }

  export type BusinessRateCategoryModelWhereInput = {
    AND?: Enumerable<BusinessRateCategoryModelWhereInput>
    OR?: Enumerable<BusinessRateCategoryModelWhereInput>
    NOT?: Enumerable<BusinessRateCategoryModelWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    rates?: BusinessRateModelListRelationFilter
  }

  export type BusinessRateCategoryModelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    rates?: BusinessRateModelOrderByRelationAggregateInput
  }

  export type BusinessRateCategoryModelWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type BusinessRateCategoryModelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: BusinessRateCategoryModelCountOrderByAggregateInput
    _max?: BusinessRateCategoryModelMaxOrderByAggregateInput
    _min?: BusinessRateCategoryModelMinOrderByAggregateInput
  }

  export type BusinessRateCategoryModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BusinessRateCategoryModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<BusinessRateCategoryModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BusinessRateCategoryModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
  }

  export type BusinessReviewModelWhereInput = {
    AND?: Enumerable<BusinessReviewModelWhereInput>
    OR?: Enumerable<BusinessReviewModelWhereInput>
    NOT?: Enumerable<BusinessReviewModelWhereInput>
    id?: StringFilter | string
    reviewee_id?: StringFilter | string
    reviewer_id?: StringFilter | string
    review?: StringFilter | string
    reviewee?: XOR<BusinessUserModelRelationFilter, BusinessUserModelWhereInput>
    reviewer?: XOR<CustomerModelRelationFilter, CustomerModelWhereInput>
  }

  export type BusinessReviewModelOrderByWithRelationInput = {
    id?: SortOrder
    reviewee_id?: SortOrder
    reviewer_id?: SortOrder
    review?: SortOrder
    reviewee?: BusinessUserModelOrderByWithRelationInput
    reviewer?: CustomerModelOrderByWithRelationInput
  }

  export type BusinessReviewModelWhereUniqueInput = {
    id?: string
  }

  export type BusinessReviewModelOrderByWithAggregationInput = {
    id?: SortOrder
    reviewee_id?: SortOrder
    reviewer_id?: SortOrder
    review?: SortOrder
    _count?: BusinessReviewModelCountOrderByAggregateInput
    _max?: BusinessReviewModelMaxOrderByAggregateInput
    _min?: BusinessReviewModelMinOrderByAggregateInput
  }

  export type BusinessReviewModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BusinessReviewModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<BusinessReviewModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BusinessReviewModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    reviewee_id?: StringWithAggregatesFilter | string
    reviewer_id?: StringWithAggregatesFilter | string
    review?: StringWithAggregatesFilter | string
  }

  export type BoardModelWhereInput = {
    AND?: Enumerable<BoardModelWhereInput>
    OR?: Enumerable<BoardModelWhereInput>
    NOT?: Enumerable<BoardModelWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    articles?: BoardArticleModelListRelationFilter
  }

  export type BoardModelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    articles?: BoardArticleModelOrderByRelationAggregateInput
  }

  export type BoardModelWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type BoardModelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: BoardModelCountOrderByAggregateInput
    _max?: BoardModelMaxOrderByAggregateInput
    _min?: BoardModelMinOrderByAggregateInput
  }

  export type BoardModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BoardModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<BoardModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BoardModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
  }

  export type BoardArticleModelWhereInput = {
    AND?: Enumerable<BoardArticleModelWhereInput>
    OR?: Enumerable<BoardArticleModelWhereInput>
    NOT?: Enumerable<BoardArticleModelWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    author_id?: StringFilter | string
    board_id?: StringFilter | string
    author?: XOR<UserModelRelationFilter, UserModelWhereInput>
    board?: XOR<BoardModelRelationFilter, BoardModelWhereInput>
    contents?: BoardArticleContentModelListRelationFilter
    comments?: BoardCommentModelListRelationFilter
  }

  export type BoardArticleModelOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    author_id?: SortOrder
    board_id?: SortOrder
    author?: UserModelOrderByWithRelationInput
    board?: BoardModelOrderByWithRelationInput
    contents?: BoardArticleContentModelOrderByRelationAggregateInput
    comments?: BoardCommentModelOrderByRelationAggregateInput
  }

  export type BoardArticleModelWhereUniqueInput = {
    id?: string
  }

  export type BoardArticleModelOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    author_id?: SortOrder
    board_id?: SortOrder
    _count?: BoardArticleModelCountOrderByAggregateInput
    _max?: BoardArticleModelMaxOrderByAggregateInput
    _min?: BoardArticleModelMinOrderByAggregateInput
  }

  export type BoardArticleModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BoardArticleModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<BoardArticleModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BoardArticleModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    author_id?: StringWithAggregatesFilter | string
    board_id?: StringWithAggregatesFilter | string
  }

  export type BoardArticleContentModelWhereInput = {
    AND?: Enumerable<BoardArticleContentModelWhereInput>
    OR?: Enumerable<BoardArticleContentModelWhereInput>
    NOT?: Enumerable<BoardArticleContentModelWhereInput>
    id?: StringFilter | string
    text?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    article_id?: StringFilter | string
    article?: XOR<BoardArticleModelRelationFilter, BoardArticleModelWhereInput>
  }

  export type BoardArticleContentModelOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    created_at?: SortOrder
    article_id?: SortOrder
    article?: BoardArticleModelOrderByWithRelationInput
  }

  export type BoardArticleContentModelWhereUniqueInput = {
    id?: string
  }

  export type BoardArticleContentModelOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    created_at?: SortOrder
    article_id?: SortOrder
    _count?: BoardArticleContentModelCountOrderByAggregateInput
    _max?: BoardArticleContentModelMaxOrderByAggregateInput
    _min?: BoardArticleContentModelMinOrderByAggregateInput
  }

  export type BoardArticleContentModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BoardArticleContentModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<BoardArticleContentModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BoardArticleContentModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    text?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    article_id?: StringWithAggregatesFilter | string
  }

  export type BoardCommentModelWhereInput = {
    AND?: Enumerable<BoardCommentModelWhereInput>
    OR?: Enumerable<BoardCommentModelWhereInput>
    NOT?: Enumerable<BoardCommentModelWhereInput>
    id?: StringFilter | string
    author_id?: StringFilter | string
    article_id?: StringFilter | string
    author?: XOR<UserModelRelationFilter, UserModelWhereInput>
    article?: XOR<BoardArticleModelRelationFilter, BoardArticleModelWhereInput>
    contents?: BoardCommentContentModelListRelationFilter
  }

  export type BoardCommentModelOrderByWithRelationInput = {
    id?: SortOrder
    author_id?: SortOrder
    article_id?: SortOrder
    author?: UserModelOrderByWithRelationInput
    article?: BoardArticleModelOrderByWithRelationInput
    contents?: BoardCommentContentModelOrderByRelationAggregateInput
  }

  export type BoardCommentModelWhereUniqueInput = {
    id?: string
  }

  export type BoardCommentModelOrderByWithAggregationInput = {
    id?: SortOrder
    author_id?: SortOrder
    article_id?: SortOrder
    _count?: BoardCommentModelCountOrderByAggregateInput
    _max?: BoardCommentModelMaxOrderByAggregateInput
    _min?: BoardCommentModelMinOrderByAggregateInput
  }

  export type BoardCommentModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BoardCommentModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<BoardCommentModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BoardCommentModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    author_id?: StringWithAggregatesFilter | string
    article_id?: StringWithAggregatesFilter | string
  }

  export type BoardCommentContentModelWhereInput = {
    AND?: Enumerable<BoardCommentContentModelWhereInput>
    OR?: Enumerable<BoardCommentContentModelWhereInput>
    NOT?: Enumerable<BoardCommentContentModelWhereInput>
    id?: StringFilter | string
    text?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    comment_id?: StringFilter | string
    comment?: XOR<BoardCommentModelRelationFilter, BoardCommentModelWhereInput>
  }

  export type BoardCommentContentModelOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    created_at?: SortOrder
    comment_id?: SortOrder
    comment?: BoardCommentModelOrderByWithRelationInput
  }

  export type BoardCommentContentModelWhereUniqueInput = {
    id?: string
  }

  export type BoardCommentContentModelOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    created_at?: SortOrder
    comment_id?: SortOrder
    _count?: BoardCommentContentModelCountOrderByAggregateInput
    _max?: BoardCommentContentModelMaxOrderByAggregateInput
    _min?: BoardCommentContentModelMinOrderByAggregateInput
  }

  export type BoardCommentContentModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BoardCommentContentModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<BoardCommentContentModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BoardCommentContentModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    text?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    comment_id?: StringWithAggregatesFilter | string
  }

  export type AuthenticationModelCreateInput = {
    id: string
    oauth_sub: string
    oauth_type: string
    business_user?: BusinessUserModelCreateNestedOneWithoutAuthenticationsInput
    customer?: CustomerModelCreateNestedOneWithoutAuthenticationsInput
  }

  export type AuthenticationModelUncheckedCreateInput = {
    id: string
    oauth_sub: string
    oauth_type: string
    business_user_id?: string | null
    customer_id?: string | null
  }

  export type AuthenticationModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    oauth_sub?: StringFieldUpdateOperationsInput | string
    oauth_type?: StringFieldUpdateOperationsInput | string
    business_user?: BusinessUserModelUpdateOneWithoutAuthenticationsNestedInput
    customer?: CustomerModelUpdateOneWithoutAuthenticationsNestedInput
  }

  export type AuthenticationModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    oauth_sub?: StringFieldUpdateOperationsInput | string
    oauth_type?: StringFieldUpdateOperationsInput | string
    business_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuthenticationModelCreateManyInput = {
    id: string
    oauth_sub: string
    oauth_type: string
    business_user_id?: string | null
    customer_id?: string | null
  }

  export type AuthenticationModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    oauth_sub?: StringFieldUpdateOperationsInput | string
    oauth_type?: StringFieldUpdateOperationsInput | string
  }

  export type AuthenticationModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    oauth_sub?: StringFieldUpdateOperationsInput | string
    oauth_type?: StringFieldUpdateOperationsInput | string
    business_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserModelCreateInput = {
    id: string
    name: string
    email?: string | null
    email_verified: boolean
    phone?: string | null
    phone_verified: boolean
    address_first?: string | null
    address_second?: string | null
    profile_image?: string | null
    customer?: CustomerModelCreateNestedOneWithoutUserInput
    business_user?: BusinessUserModelCreateNestedOneWithoutUserInput
    board_articles?: BoardArticleModelCreateNestedManyWithoutAuthorInput
    board_comments?: BoardCommentModelCreateNestedManyWithoutAuthorInput
  }

  export type UserModelUncheckedCreateInput = {
    id: string
    name: string
    email?: string | null
    email_verified: boolean
    phone?: string | null
    phone_verified: boolean
    address_first?: string | null
    address_second?: string | null
    profile_image?: string | null
    customer?: CustomerModelUncheckedCreateNestedOneWithoutUserInput
    business_user?: BusinessUserModelUncheckedCreateNestedOneWithoutUserInput
    board_articles?: BoardArticleModelUncheckedCreateNestedManyWithoutAuthorInput
    board_comments?: BoardCommentModelUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerModelUpdateOneWithoutUserNestedInput
    business_user?: BusinessUserModelUpdateOneWithoutUserNestedInput
    board_articles?: BoardArticleModelUpdateManyWithoutAuthorNestedInput
    board_comments?: BoardCommentModelUpdateManyWithoutAuthorNestedInput
  }

  export type UserModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerModelUncheckedUpdateOneWithoutUserNestedInput
    business_user?: BusinessUserModelUncheckedUpdateOneWithoutUserNestedInput
    board_articles?: BoardArticleModelUncheckedUpdateManyWithoutAuthorNestedInput
    board_comments?: BoardCommentModelUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserModelCreateManyInput = {
    id: string
    name: string
    email?: string | null
    email_verified: boolean
    phone?: string | null
    phone_verified: boolean
    address_first?: string | null
    address_second?: string | null
    profile_image?: string | null
  }

  export type UserModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerModelCreateInput = {
    birth?: string | null
    gender?: string | null
    user: UserModelCreateNestedOneWithoutCustomerInput
    authentications?: AuthenticationModelCreateNestedManyWithoutCustomerInput
    rates?: BusinessRateModelCreateNestedManyWithoutRaterInput
    reviews?: BusinessReviewModelCreateNestedManyWithoutReviewerInput
  }

  export type CustomerModelUncheckedCreateInput = {
    id: string
    birth?: string | null
    gender?: string | null
    authentications?: AuthenticationModelUncheckedCreateNestedManyWithoutCustomerInput
    rates?: BusinessRateModelUncheckedCreateNestedManyWithoutRaterInput
    reviews?: BusinessReviewModelUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type CustomerModelUpdateInput = {
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserModelUpdateOneRequiredWithoutCustomerNestedInput
    authentications?: AuthenticationModelUpdateManyWithoutCustomerNestedInput
    rates?: BusinessRateModelUpdateManyWithoutRaterNestedInput
    reviews?: BusinessReviewModelUpdateManyWithoutReviewerNestedInput
  }

  export type CustomerModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    authentications?: AuthenticationModelUncheckedUpdateManyWithoutCustomerNestedInput
    rates?: BusinessRateModelUncheckedUpdateManyWithoutRaterNestedInput
    reviews?: BusinessReviewModelUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type CustomerModelCreateManyInput = {
    id: string
    birth?: string | null
    gender?: string | null
  }

  export type CustomerModelUpdateManyMutationInput = {
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusinessUserModelCreateInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    user: UserModelCreateNestedOneWithoutBusiness_userInput
    authentications?: AuthenticationModelCreateNestedManyWithoutBusiness_userInput
    real_estate_agent?: RealEstateAgentModelCreateNestedOneWithoutBusinessInput
    home_care_company?: HomeCareCompanyModelCreateNestedOneWithoutBusinessInput
    rates?: BusinessRateModelCreateNestedManyWithoutRateeInput
    reviews?: BusinessReviewModelCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelUncheckedCreateInput = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    authentications?: AuthenticationModelUncheckedCreateNestedManyWithoutBusiness_userInput
    real_estate_agent?: RealEstateAgentModelUncheckedCreateNestedOneWithoutBusinessInput
    home_care_company?: HomeCareCompanyModelUncheckedCreateNestedOneWithoutBusinessInput
    rates?: BusinessRateModelUncheckedCreateNestedManyWithoutRateeInput
    reviews?: BusinessReviewModelUncheckedCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelUpdateInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    user?: UserModelUpdateOneRequiredWithoutBusiness_userNestedInput
    authentications?: AuthenticationModelUpdateManyWithoutBusiness_userNestedInput
    real_estate_agent?: RealEstateAgentModelUpdateOneWithoutBusinessNestedInput
    home_care_company?: HomeCareCompanyModelUpdateOneWithoutBusinessNestedInput
    rates?: BusinessRateModelUpdateManyWithoutRateeNestedInput
    reviews?: BusinessReviewModelUpdateManyWithoutRevieweeNestedInput
  }

  export type BusinessUserModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    authentications?: AuthenticationModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    real_estate_agent?: RealEstateAgentModelUncheckedUpdateOneWithoutBusinessNestedInput
    home_care_company?: HomeCareCompanyModelUncheckedUpdateOneWithoutBusinessNestedInput
    rates?: BusinessRateModelUncheckedUpdateManyWithoutRateeNestedInput
    reviews?: BusinessReviewModelUncheckedUpdateManyWithoutRevieweeNestedInput
  }

  export type BusinessUserModelCreateManyInput = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
  }

  export type BusinessUserModelUpdateManyMutationInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUserModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
  }

  export type RealEstateAgentModelCreateInput = {
    is_licensed: boolean
    real_estate_num: string
    real_estate_name: string
    real_estate_phone: string
    licensed_agent_name: string
    business: BusinessUserModelCreateNestedOneWithoutReal_estate_agentInput
    specialized_field?: RealEstateSpecializedSubFieldModelCreateNestedOneWithoutReal_estate_agentsInput
    properties?: RealEstatePropertyModelCreateNestedManyWithoutAgentInput
  }

  export type RealEstateAgentModelUncheckedCreateInput = {
    id: string
    is_licensed: boolean
    real_estate_num: string
    real_estate_name: string
    real_estate_phone: string
    licensed_agent_name: string
    specialized_field_id?: string | null
    properties?: RealEstatePropertyModelUncheckedCreateNestedManyWithoutAgentInput
  }

  export type RealEstateAgentModelUpdateInput = {
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    real_estate_num?: StringFieldUpdateOperationsInput | string
    real_estate_name?: StringFieldUpdateOperationsInput | string
    real_estate_phone?: StringFieldUpdateOperationsInput | string
    licensed_agent_name?: StringFieldUpdateOperationsInput | string
    business?: BusinessUserModelUpdateOneRequiredWithoutReal_estate_agentNestedInput
    specialized_field?: RealEstateSpecializedSubFieldModelUpdateOneWithoutReal_estate_agentsNestedInput
    properties?: RealEstatePropertyModelUpdateManyWithoutAgentNestedInput
  }

  export type RealEstateAgentModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    real_estate_num?: StringFieldUpdateOperationsInput | string
    real_estate_name?: StringFieldUpdateOperationsInput | string
    real_estate_phone?: StringFieldUpdateOperationsInput | string
    licensed_agent_name?: StringFieldUpdateOperationsInput | string
    specialized_field_id?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: RealEstatePropertyModelUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type RealEstateAgentModelCreateManyInput = {
    id: string
    is_licensed: boolean
    real_estate_num: string
    real_estate_name: string
    real_estate_phone: string
    licensed_agent_name: string
    specialized_field_id?: string | null
  }

  export type RealEstateAgentModelUpdateManyMutationInput = {
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    real_estate_num?: StringFieldUpdateOperationsInput | string
    real_estate_name?: StringFieldUpdateOperationsInput | string
    real_estate_phone?: StringFieldUpdateOperationsInput | string
    licensed_agent_name?: StringFieldUpdateOperationsInput | string
  }

  export type RealEstateAgentModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    real_estate_num?: StringFieldUpdateOperationsInput | string
    real_estate_name?: StringFieldUpdateOperationsInput | string
    real_estate_phone?: StringFieldUpdateOperationsInput | string
    licensed_agent_name?: StringFieldUpdateOperationsInput | string
    specialized_field_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HomeCareCompanyModelCreateInput = {
    business_registration_num: string
    business: BusinessUserModelCreateNestedOneWithoutHome_care_companyInput
    specialized_field?: HomeCareSpecializedSubFieldModelCreateNestedOneWithoutHome_care_companiesInput
    introduction_images?: HomeCareIntroductionImageModelCreateNestedManyWithoutCompanyInput
  }

  export type HomeCareCompanyModelUncheckedCreateInput = {
    id: string
    business_registration_num: string
    specialized_field_id?: string | null
    introduction_images?: HomeCareIntroductionImageModelUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type HomeCareCompanyModelUpdateInput = {
    business_registration_num?: StringFieldUpdateOperationsInput | string
    business?: BusinessUserModelUpdateOneRequiredWithoutHome_care_companyNestedInput
    specialized_field?: HomeCareSpecializedSubFieldModelUpdateOneWithoutHome_care_companiesNestedInput
    introduction_images?: HomeCareIntroductionImageModelUpdateManyWithoutCompanyNestedInput
  }

  export type HomeCareCompanyModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    business_registration_num?: StringFieldUpdateOperationsInput | string
    specialized_field_id?: NullableStringFieldUpdateOperationsInput | string | null
    introduction_images?: HomeCareIntroductionImageModelUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type HomeCareCompanyModelCreateManyInput = {
    id: string
    business_registration_num: string
    specialized_field_id?: string | null
  }

  export type HomeCareCompanyModelUpdateManyMutationInput = {
    business_registration_num?: StringFieldUpdateOperationsInput | string
  }

  export type HomeCareCompanyModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    business_registration_num?: StringFieldUpdateOperationsInput | string
    specialized_field_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HomeCareIntroductionImageModelCreateInput = {
    id: string
    image_url: string
    company: HomeCareCompanyModelCreateNestedOneWithoutIntroduction_imagesInput
  }

  export type HomeCareIntroductionImageModelUncheckedCreateInput = {
    id: string
    image_url: string
    company_id: string
  }

  export type HomeCareIntroductionImageModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    company?: HomeCareCompanyModelUpdateOneRequiredWithoutIntroduction_imagesNestedInput
  }

  export type HomeCareIntroductionImageModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
  }

  export type HomeCareIntroductionImageModelCreateManyInput = {
    id: string
    image_url: string
    company_id: string
  }

  export type HomeCareIntroductionImageModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type HomeCareIntroductionImageModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
  }

  export type RealEstatePropertyModelCreateInput = {
    id: string
    name: string
    main_image_url: string
    agent: RealEstateAgentModelCreateNestedOneWithoutPropertiesInput
  }

  export type RealEstatePropertyModelUncheckedCreateInput = {
    id: string
    name: string
    main_image_url: string
    agent_id: string
  }

  export type RealEstatePropertyModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
    agent?: RealEstateAgentModelUpdateOneRequiredWithoutPropertiesNestedInput
  }

  export type RealEstatePropertyModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
    agent_id?: StringFieldUpdateOperationsInput | string
  }

  export type RealEstatePropertyModelCreateManyInput = {
    id: string
    name: string
    main_image_url: string
    agent_id: string
  }

  export type RealEstatePropertyModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
  }

  export type RealEstatePropertyModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
    agent_id?: StringFieldUpdateOperationsInput | string
  }

  export type HomeCareSpecializedSuperFieldModelCreateInput = {
    id: string
    name: string
    sub?: HomeCareSpecializedSubFieldModelCreateNestedManyWithoutSuperInput
  }

  export type HomeCareSpecializedSuperFieldModelUncheckedCreateInput = {
    id: string
    name: string
    sub?: HomeCareSpecializedSubFieldModelUncheckedCreateNestedManyWithoutSuperInput
  }

  export type HomeCareSpecializedSuperFieldModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sub?: HomeCareSpecializedSubFieldModelUpdateManyWithoutSuperNestedInput
  }

  export type HomeCareSpecializedSuperFieldModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sub?: HomeCareSpecializedSubFieldModelUncheckedUpdateManyWithoutSuperNestedInput
  }

  export type HomeCareSpecializedSuperFieldModelCreateManyInput = {
    id: string
    name: string
  }

  export type HomeCareSpecializedSuperFieldModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type HomeCareSpecializedSuperFieldModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type HomeCareSpecializedSubFieldModelCreateInput = {
    id: string
    name: string
    super: HomeCareSpecializedSuperFieldModelCreateNestedOneWithoutSubInput
    home_care_companies?: HomeCareCompanyModelCreateNestedManyWithoutSpecialized_fieldInput
  }

  export type HomeCareSpecializedSubFieldModelUncheckedCreateInput = {
    id: string
    name: string
    super_id: string
    home_care_companies?: HomeCareCompanyModelUncheckedCreateNestedManyWithoutSpecialized_fieldInput
  }

  export type HomeCareSpecializedSubFieldModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    super?: HomeCareSpecializedSuperFieldModelUpdateOneRequiredWithoutSubNestedInput
    home_care_companies?: HomeCareCompanyModelUpdateManyWithoutSpecialized_fieldNestedInput
  }

  export type HomeCareSpecializedSubFieldModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    super_id?: StringFieldUpdateOperationsInput | string
    home_care_companies?: HomeCareCompanyModelUncheckedUpdateManyWithoutSpecialized_fieldNestedInput
  }

  export type HomeCareSpecializedSubFieldModelCreateManyInput = {
    id: string
    name: string
    super_id: string
  }

  export type HomeCareSpecializedSubFieldModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type HomeCareSpecializedSubFieldModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    super_id?: StringFieldUpdateOperationsInput | string
  }

  export type RealEstateSpecializedSuperFieldModelCreateInput = {
    id: string
    name: string
    sub?: RealEstateSpecializedSubFieldModelCreateNestedManyWithoutSuperInput
  }

  export type RealEstateSpecializedSuperFieldModelUncheckedCreateInput = {
    id: string
    name: string
    sub?: RealEstateSpecializedSubFieldModelUncheckedCreateNestedManyWithoutSuperInput
  }

  export type RealEstateSpecializedSuperFieldModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sub?: RealEstateSpecializedSubFieldModelUpdateManyWithoutSuperNestedInput
  }

  export type RealEstateSpecializedSuperFieldModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sub?: RealEstateSpecializedSubFieldModelUncheckedUpdateManyWithoutSuperNestedInput
  }

  export type RealEstateSpecializedSuperFieldModelCreateManyInput = {
    id: string
    name: string
  }

  export type RealEstateSpecializedSuperFieldModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RealEstateSpecializedSuperFieldModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RealEstateSpecializedSubFieldModelCreateInput = {
    id: string
    name: string
    super: RealEstateSpecializedSuperFieldModelCreateNestedOneWithoutSubInput
    real_estate_agents?: RealEstateAgentModelCreateNestedManyWithoutSpecialized_fieldInput
  }

  export type RealEstateSpecializedSubFieldModelUncheckedCreateInput = {
    id: string
    name: string
    super_id: string
    real_estate_agents?: RealEstateAgentModelUncheckedCreateNestedManyWithoutSpecialized_fieldInput
  }

  export type RealEstateSpecializedSubFieldModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    super?: RealEstateSpecializedSuperFieldModelUpdateOneRequiredWithoutSubNestedInput
    real_estate_agents?: RealEstateAgentModelUpdateManyWithoutSpecialized_fieldNestedInput
  }

  export type RealEstateSpecializedSubFieldModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    super_id?: StringFieldUpdateOperationsInput | string
    real_estate_agents?: RealEstateAgentModelUncheckedUpdateManyWithoutSpecialized_fieldNestedInput
  }

  export type RealEstateSpecializedSubFieldModelCreateManyInput = {
    id: string
    name: string
    super_id: string
  }

  export type RealEstateSpecializedSubFieldModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RealEstateSpecializedSubFieldModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    super_id?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessRateModelCreateInput = {
    id: string
    rate: number
    ratee: BusinessUserModelCreateNestedOneWithoutRatesInput
    rater: CustomerModelCreateNestedOneWithoutRatesInput
    category: BusinessRateCategoryModelCreateNestedOneWithoutRatesInput
  }

  export type BusinessRateModelUncheckedCreateInput = {
    id: string
    category_id: string
    ratee_id: string
    rater_id: string
    rate: number
  }

  export type BusinessRateModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rate?: IntFieldUpdateOperationsInput | number
    ratee?: BusinessUserModelUpdateOneRequiredWithoutRatesNestedInput
    rater?: CustomerModelUpdateOneRequiredWithoutRatesNestedInput
    category?: BusinessRateCategoryModelUpdateOneRequiredWithoutRatesNestedInput
  }

  export type BusinessRateModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_id?: StringFieldUpdateOperationsInput | string
    ratee_id?: StringFieldUpdateOperationsInput | string
    rater_id?: StringFieldUpdateOperationsInput | string
    rate?: IntFieldUpdateOperationsInput | number
  }

  export type BusinessRateModelCreateManyInput = {
    id: string
    category_id: string
    ratee_id: string
    rater_id: string
    rate: number
  }

  export type BusinessRateModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rate?: IntFieldUpdateOperationsInput | number
  }

  export type BusinessRateModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_id?: StringFieldUpdateOperationsInput | string
    ratee_id?: StringFieldUpdateOperationsInput | string
    rater_id?: StringFieldUpdateOperationsInput | string
    rate?: IntFieldUpdateOperationsInput | number
  }

  export type BusinessRateCategoryModelCreateInput = {
    id: string
    name: string
    rates?: BusinessRateModelCreateNestedManyWithoutCategoryInput
  }

  export type BusinessRateCategoryModelUncheckedCreateInput = {
    id: string
    name: string
    rates?: BusinessRateModelUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type BusinessRateCategoryModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rates?: BusinessRateModelUpdateManyWithoutCategoryNestedInput
  }

  export type BusinessRateCategoryModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rates?: BusinessRateModelUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type BusinessRateCategoryModelCreateManyInput = {
    id: string
    name: string
  }

  export type BusinessRateCategoryModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessRateCategoryModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessReviewModelCreateInput = {
    id: string
    review: string
    reviewee: BusinessUserModelCreateNestedOneWithoutReviewsInput
    reviewer: CustomerModelCreateNestedOneWithoutReviewsInput
  }

  export type BusinessReviewModelUncheckedCreateInput = {
    id: string
    reviewee_id: string
    reviewer_id: string
    review: string
  }

  export type BusinessReviewModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    review?: StringFieldUpdateOperationsInput | string
    reviewee?: BusinessUserModelUpdateOneRequiredWithoutReviewsNestedInput
    reviewer?: CustomerModelUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type BusinessReviewModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewee_id?: StringFieldUpdateOperationsInput | string
    reviewer_id?: StringFieldUpdateOperationsInput | string
    review?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessReviewModelCreateManyInput = {
    id: string
    reviewee_id: string
    reviewer_id: string
    review: string
  }

  export type BusinessReviewModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    review?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessReviewModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewee_id?: StringFieldUpdateOperationsInput | string
    reviewer_id?: StringFieldUpdateOperationsInput | string
    review?: StringFieldUpdateOperationsInput | string
  }

  export type BoardModelCreateInput = {
    id: string
    name: string
    articles?: BoardArticleModelCreateNestedManyWithoutBoardInput
  }

  export type BoardModelUncheckedCreateInput = {
    id: string
    name: string
    articles?: BoardArticleModelUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    articles?: BoardArticleModelUpdateManyWithoutBoardNestedInput
  }

  export type BoardModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    articles?: BoardArticleModelUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type BoardModelCreateManyInput = {
    id: string
    name: string
  }

  export type BoardModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BoardModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BoardArticleModelCreateInput = {
    id: string
    title: string
    author: UserModelCreateNestedOneWithoutBoard_articlesInput
    board: BoardModelCreateNestedOneWithoutArticlesInput
    contents?: BoardArticleContentModelCreateNestedManyWithoutArticleInput
    comments?: BoardCommentModelCreateNestedManyWithoutArticleInput
  }

  export type BoardArticleModelUncheckedCreateInput = {
    id: string
    title: string
    author_id: string
    board_id: string
    contents?: BoardArticleContentModelUncheckedCreateNestedManyWithoutArticleInput
    comments?: BoardCommentModelUncheckedCreateNestedManyWithoutArticleInput
  }

  export type BoardArticleModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: UserModelUpdateOneRequiredWithoutBoard_articlesNestedInput
    board?: BoardModelUpdateOneRequiredWithoutArticlesNestedInput
    contents?: BoardArticleContentModelUpdateManyWithoutArticleNestedInput
    comments?: BoardCommentModelUpdateManyWithoutArticleNestedInput
  }

  export type BoardArticleModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
    board_id?: StringFieldUpdateOperationsInput | string
    contents?: BoardArticleContentModelUncheckedUpdateManyWithoutArticleNestedInput
    comments?: BoardCommentModelUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type BoardArticleModelCreateManyInput = {
    id: string
    title: string
    author_id: string
    board_id: string
  }

  export type BoardArticleModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type BoardArticleModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
    board_id?: StringFieldUpdateOperationsInput | string
  }

  export type BoardArticleContentModelCreateInput = {
    id: string
    text: string
    created_at: Date | string
    article: BoardArticleModelCreateNestedOneWithoutContentsInput
  }

  export type BoardArticleContentModelUncheckedCreateInput = {
    id: string
    text: string
    created_at: Date | string
    article_id: string
  }

  export type BoardArticleContentModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: BoardArticleModelUpdateOneRequiredWithoutContentsNestedInput
  }

  export type BoardArticleContentModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    article_id?: StringFieldUpdateOperationsInput | string
  }

  export type BoardArticleContentModelCreateManyInput = {
    id: string
    text: string
    created_at: Date | string
    article_id: string
  }

  export type BoardArticleContentModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardArticleContentModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    article_id?: StringFieldUpdateOperationsInput | string
  }

  export type BoardCommentModelCreateInput = {
    id: string
    author: UserModelCreateNestedOneWithoutBoard_commentsInput
    article: BoardArticleModelCreateNestedOneWithoutCommentsInput
    contents?: BoardCommentContentModelCreateNestedManyWithoutCommentInput
  }

  export type BoardCommentModelUncheckedCreateInput = {
    id: string
    author_id: string
    article_id: string
    contents?: BoardCommentContentModelUncheckedCreateNestedManyWithoutCommentInput
  }

  export type BoardCommentModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    author?: UserModelUpdateOneRequiredWithoutBoard_commentsNestedInput
    article?: BoardArticleModelUpdateOneRequiredWithoutCommentsNestedInput
    contents?: BoardCommentContentModelUpdateManyWithoutCommentNestedInput
  }

  export type BoardCommentModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
    article_id?: StringFieldUpdateOperationsInput | string
    contents?: BoardCommentContentModelUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type BoardCommentModelCreateManyInput = {
    id: string
    author_id: string
    article_id: string
  }

  export type BoardCommentModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type BoardCommentModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
    article_id?: StringFieldUpdateOperationsInput | string
  }

  export type BoardCommentContentModelCreateInput = {
    id: string
    text: string
    created_at: Date | string
    comment: BoardCommentModelCreateNestedOneWithoutContentsInput
  }

  export type BoardCommentContentModelUncheckedCreateInput = {
    id: string
    text: string
    created_at: Date | string
    comment_id: string
  }

  export type BoardCommentContentModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: BoardCommentModelUpdateOneRequiredWithoutContentsNestedInput
  }

  export type BoardCommentContentModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment_id?: StringFieldUpdateOperationsInput | string
  }

  export type BoardCommentContentModelCreateManyInput = {
    id: string
    text: string
    created_at: Date | string
    comment_id: string
  }

  export type BoardCommentContentModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardCommentContentModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment_id?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type BusinessUserModelRelationFilter = {
    is?: BusinessUserModelWhereInput
    isNot?: BusinessUserModelWhereInput
  }

  export type CustomerModelRelationFilter = {
    is?: CustomerModelWhereInput
    isNot?: CustomerModelWhereInput
  }

  export type AuthenticationModelOauth_subOauth_typeCompoundUniqueInput = {
    oauth_sub: string
    oauth_type: string
  }

  export type AuthenticationModelCountOrderByAggregateInput = {
    id?: SortOrder
    oauth_sub?: SortOrder
    oauth_type?: SortOrder
    business_user_id?: SortOrder
    customer_id?: SortOrder
  }

  export type AuthenticationModelMaxOrderByAggregateInput = {
    id?: SortOrder
    oauth_sub?: SortOrder
    oauth_type?: SortOrder
    business_user_id?: SortOrder
    customer_id?: SortOrder
  }

  export type AuthenticationModelMinOrderByAggregateInput = {
    id?: SortOrder
    oauth_sub?: SortOrder
    oauth_type?: SortOrder
    business_user_id?: SortOrder
    customer_id?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type BoardArticleModelListRelationFilter = {
    every?: BoardArticleModelWhereInput
    some?: BoardArticleModelWhereInput
    none?: BoardArticleModelWhereInput
  }

  export type BoardCommentModelListRelationFilter = {
    every?: BoardCommentModelWhereInput
    some?: BoardCommentModelWhereInput
    none?: BoardCommentModelWhereInput
  }

  export type BoardArticleModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BoardCommentModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserModelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified?: SortOrder
    phone?: SortOrder
    phone_verified?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
    profile_image?: SortOrder
  }

  export type UserModelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified?: SortOrder
    phone?: SortOrder
    phone_verified?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
    profile_image?: SortOrder
  }

  export type UserModelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified?: SortOrder
    phone?: SortOrder
    phone_verified?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
    profile_image?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type UserModelRelationFilter = {
    is?: UserModelWhereInput
    isNot?: UserModelWhereInput
  }

  export type AuthenticationModelListRelationFilter = {
    every?: AuthenticationModelWhereInput
    some?: AuthenticationModelWhereInput
    none?: AuthenticationModelWhereInput
  }

  export type BusinessRateModelListRelationFilter = {
    every?: BusinessRateModelWhereInput
    some?: BusinessRateModelWhereInput
    none?: BusinessRateModelWhereInput
  }

  export type BusinessReviewModelListRelationFilter = {
    every?: BusinessReviewModelWhereInput
    some?: BusinessReviewModelWhereInput
    none?: BusinessReviewModelWhereInput
  }

  export type AuthenticationModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessRateModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessReviewModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerModelCountOrderByAggregateInput = {
    id?: SortOrder
    birth?: SortOrder
    gender?: SortOrder
  }

  export type CustomerModelMaxOrderByAggregateInput = {
    id?: SortOrder
    birth?: SortOrder
    gender?: SortOrder
  }

  export type CustomerModelMinOrderByAggregateInput = {
    id?: SortOrder
    birth?: SortOrder
    gender?: SortOrder
  }

  export type RealEstateAgentModelRelationFilter = {
    is?: RealEstateAgentModelWhereInput
    isNot?: RealEstateAgentModelWhereInput
  }

  export type HomeCareCompanyModelRelationFilter = {
    is?: HomeCareCompanyModelWhereInput
    isNot?: HomeCareCompanyModelWhereInput
  }

  export type BusinessUserModelCountOrderByAggregateInput = {
    id?: SortOrder
    is_verified?: SortOrder
    introduction_title?: SortOrder
    introduction_content?: SortOrder
  }

  export type BusinessUserModelMaxOrderByAggregateInput = {
    id?: SortOrder
    is_verified?: SortOrder
    introduction_title?: SortOrder
    introduction_content?: SortOrder
  }

  export type BusinessUserModelMinOrderByAggregateInput = {
    id?: SortOrder
    is_verified?: SortOrder
    introduction_title?: SortOrder
    introduction_content?: SortOrder
  }

  export type RealEstateSpecializedSubFieldModelRelationFilter = {
    is?: RealEstateSpecializedSubFieldModelWhereInput | null
    isNot?: RealEstateSpecializedSubFieldModelWhereInput | null
  }

  export type RealEstatePropertyModelListRelationFilter = {
    every?: RealEstatePropertyModelWhereInput
    some?: RealEstatePropertyModelWhereInput
    none?: RealEstatePropertyModelWhereInput
  }

  export type RealEstatePropertyModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RealEstateAgentModelCountOrderByAggregateInput = {
    id?: SortOrder
    is_licensed?: SortOrder
    real_estate_num?: SortOrder
    real_estate_name?: SortOrder
    real_estate_phone?: SortOrder
    licensed_agent_name?: SortOrder
    specialized_field_id?: SortOrder
  }

  export type RealEstateAgentModelMaxOrderByAggregateInput = {
    id?: SortOrder
    is_licensed?: SortOrder
    real_estate_num?: SortOrder
    real_estate_name?: SortOrder
    real_estate_phone?: SortOrder
    licensed_agent_name?: SortOrder
    specialized_field_id?: SortOrder
  }

  export type RealEstateAgentModelMinOrderByAggregateInput = {
    id?: SortOrder
    is_licensed?: SortOrder
    real_estate_num?: SortOrder
    real_estate_name?: SortOrder
    real_estate_phone?: SortOrder
    licensed_agent_name?: SortOrder
    specialized_field_id?: SortOrder
  }

  export type HomeCareSpecializedSubFieldModelRelationFilter = {
    is?: HomeCareSpecializedSubFieldModelWhereInput | null
    isNot?: HomeCareSpecializedSubFieldModelWhereInput | null
  }

  export type HomeCareIntroductionImageModelListRelationFilter = {
    every?: HomeCareIntroductionImageModelWhereInput
    some?: HomeCareIntroductionImageModelWhereInput
    none?: HomeCareIntroductionImageModelWhereInput
  }

  export type HomeCareIntroductionImageModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HomeCareCompanyModelCountOrderByAggregateInput = {
    id?: SortOrder
    business_registration_num?: SortOrder
    specialized_field_id?: SortOrder
  }

  export type HomeCareCompanyModelMaxOrderByAggregateInput = {
    id?: SortOrder
    business_registration_num?: SortOrder
    specialized_field_id?: SortOrder
  }

  export type HomeCareCompanyModelMinOrderByAggregateInput = {
    id?: SortOrder
    business_registration_num?: SortOrder
    specialized_field_id?: SortOrder
  }

  export type HomeCareIntroductionImageModelCountOrderByAggregateInput = {
    id?: SortOrder
    image_url?: SortOrder
    company_id?: SortOrder
  }

  export type HomeCareIntroductionImageModelMaxOrderByAggregateInput = {
    id?: SortOrder
    image_url?: SortOrder
    company_id?: SortOrder
  }

  export type HomeCareIntroductionImageModelMinOrderByAggregateInput = {
    id?: SortOrder
    image_url?: SortOrder
    company_id?: SortOrder
  }

  export type RealEstatePropertyModelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    main_image_url?: SortOrder
    agent_id?: SortOrder
  }

  export type RealEstatePropertyModelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    main_image_url?: SortOrder
    agent_id?: SortOrder
  }

  export type RealEstatePropertyModelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    main_image_url?: SortOrder
    agent_id?: SortOrder
  }

  export type HomeCareSpecializedSubFieldModelListRelationFilter = {
    every?: HomeCareSpecializedSubFieldModelWhereInput
    some?: HomeCareSpecializedSubFieldModelWhereInput
    none?: HomeCareSpecializedSubFieldModelWhereInput
  }

  export type HomeCareSpecializedSubFieldModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HomeCareSpecializedSuperFieldModelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type HomeCareSpecializedSuperFieldModelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type HomeCareSpecializedSuperFieldModelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type HomeCareSpecializedSuperFieldModelRelationFilter = {
    is?: HomeCareSpecializedSuperFieldModelWhereInput
    isNot?: HomeCareSpecializedSuperFieldModelWhereInput
  }

  export type HomeCareCompanyModelListRelationFilter = {
    every?: HomeCareCompanyModelWhereInput
    some?: HomeCareCompanyModelWhereInput
    none?: HomeCareCompanyModelWhereInput
  }

  export type HomeCareCompanyModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HomeCareSpecializedSubFieldModelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    super_id?: SortOrder
  }

  export type HomeCareSpecializedSubFieldModelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    super_id?: SortOrder
  }

  export type HomeCareSpecializedSubFieldModelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    super_id?: SortOrder
  }

  export type RealEstateSpecializedSubFieldModelListRelationFilter = {
    every?: RealEstateSpecializedSubFieldModelWhereInput
    some?: RealEstateSpecializedSubFieldModelWhereInput
    none?: RealEstateSpecializedSubFieldModelWhereInput
  }

  export type RealEstateSpecializedSubFieldModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RealEstateSpecializedSuperFieldModelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RealEstateSpecializedSuperFieldModelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RealEstateSpecializedSuperFieldModelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RealEstateSpecializedSuperFieldModelRelationFilter = {
    is?: RealEstateSpecializedSuperFieldModelWhereInput
    isNot?: RealEstateSpecializedSuperFieldModelWhereInput
  }

  export type RealEstateAgentModelListRelationFilter = {
    every?: RealEstateAgentModelWhereInput
    some?: RealEstateAgentModelWhereInput
    none?: RealEstateAgentModelWhereInput
  }

  export type RealEstateAgentModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RealEstateSpecializedSubFieldModelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    super_id?: SortOrder
  }

  export type RealEstateSpecializedSubFieldModelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    super_id?: SortOrder
  }

  export type RealEstateSpecializedSubFieldModelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    super_id?: SortOrder
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type BusinessRateCategoryModelRelationFilter = {
    is?: BusinessRateCategoryModelWhereInput
    isNot?: BusinessRateCategoryModelWhereInput
  }

  export type BusinessRateModelCountOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    ratee_id?: SortOrder
    rater_id?: SortOrder
    rate?: SortOrder
  }

  export type BusinessRateModelAvgOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type BusinessRateModelMaxOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    ratee_id?: SortOrder
    rater_id?: SortOrder
    rate?: SortOrder
  }

  export type BusinessRateModelMinOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    ratee_id?: SortOrder
    rater_id?: SortOrder
    rate?: SortOrder
  }

  export type BusinessRateModelSumOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type BusinessRateCategoryModelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type BusinessRateCategoryModelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type BusinessRateCategoryModelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type BusinessReviewModelCountOrderByAggregateInput = {
    id?: SortOrder
    reviewee_id?: SortOrder
    reviewer_id?: SortOrder
    review?: SortOrder
  }

  export type BusinessReviewModelMaxOrderByAggregateInput = {
    id?: SortOrder
    reviewee_id?: SortOrder
    reviewer_id?: SortOrder
    review?: SortOrder
  }

  export type BusinessReviewModelMinOrderByAggregateInput = {
    id?: SortOrder
    reviewee_id?: SortOrder
    reviewer_id?: SortOrder
    review?: SortOrder
  }

  export type BoardModelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type BoardModelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type BoardModelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type BoardModelRelationFilter = {
    is?: BoardModelWhereInput
    isNot?: BoardModelWhereInput
  }

  export type BoardArticleContentModelListRelationFilter = {
    every?: BoardArticleContentModelWhereInput
    some?: BoardArticleContentModelWhereInput
    none?: BoardArticleContentModelWhereInput
  }

  export type BoardArticleContentModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BoardArticleModelCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    author_id?: SortOrder
    board_id?: SortOrder
  }

  export type BoardArticleModelMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    author_id?: SortOrder
    board_id?: SortOrder
  }

  export type BoardArticleModelMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    author_id?: SortOrder
    board_id?: SortOrder
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type BoardArticleModelRelationFilter = {
    is?: BoardArticleModelWhereInput
    isNot?: BoardArticleModelWhereInput
  }

  export type BoardArticleContentModelCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    created_at?: SortOrder
    article_id?: SortOrder
  }

  export type BoardArticleContentModelMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    created_at?: SortOrder
    article_id?: SortOrder
  }

  export type BoardArticleContentModelMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    created_at?: SortOrder
    article_id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type BoardCommentContentModelListRelationFilter = {
    every?: BoardCommentContentModelWhereInput
    some?: BoardCommentContentModelWhereInput
    none?: BoardCommentContentModelWhereInput
  }

  export type BoardCommentContentModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BoardCommentModelCountOrderByAggregateInput = {
    id?: SortOrder
    author_id?: SortOrder
    article_id?: SortOrder
  }

  export type BoardCommentModelMaxOrderByAggregateInput = {
    id?: SortOrder
    author_id?: SortOrder
    article_id?: SortOrder
  }

  export type BoardCommentModelMinOrderByAggregateInput = {
    id?: SortOrder
    author_id?: SortOrder
    article_id?: SortOrder
  }

  export type BoardCommentModelRelationFilter = {
    is?: BoardCommentModelWhereInput
    isNot?: BoardCommentModelWhereInput
  }

  export type BoardCommentContentModelCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    created_at?: SortOrder
    comment_id?: SortOrder
  }

  export type BoardCommentContentModelMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    created_at?: SortOrder
    comment_id?: SortOrder
  }

  export type BoardCommentContentModelMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    created_at?: SortOrder
    comment_id?: SortOrder
  }

  export type BusinessUserModelCreateNestedOneWithoutAuthenticationsInput = {
    create?: XOR<BusinessUserModelCreateWithoutAuthenticationsInput, BusinessUserModelUncheckedCreateWithoutAuthenticationsInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutAuthenticationsInput
    connect?: BusinessUserModelWhereUniqueInput
  }

  export type CustomerModelCreateNestedOneWithoutAuthenticationsInput = {
    create?: XOR<CustomerModelCreateWithoutAuthenticationsInput, CustomerModelUncheckedCreateWithoutAuthenticationsInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutAuthenticationsInput
    connect?: CustomerModelWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BusinessUserModelUpdateOneWithoutAuthenticationsNestedInput = {
    create?: XOR<BusinessUserModelCreateWithoutAuthenticationsInput, BusinessUserModelUncheckedCreateWithoutAuthenticationsInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutAuthenticationsInput
    upsert?: BusinessUserModelUpsertWithoutAuthenticationsInput
    disconnect?: boolean
    delete?: boolean
    connect?: BusinessUserModelWhereUniqueInput
    update?: XOR<BusinessUserModelUpdateWithoutAuthenticationsInput, BusinessUserModelUncheckedUpdateWithoutAuthenticationsInput>
  }

  export type CustomerModelUpdateOneWithoutAuthenticationsNestedInput = {
    create?: XOR<CustomerModelCreateWithoutAuthenticationsInput, CustomerModelUncheckedCreateWithoutAuthenticationsInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutAuthenticationsInput
    upsert?: CustomerModelUpsertWithoutAuthenticationsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CustomerModelWhereUniqueInput
    update?: XOR<CustomerModelUpdateWithoutAuthenticationsInput, CustomerModelUncheckedUpdateWithoutAuthenticationsInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type CustomerModelCreateNestedOneWithoutUserInput = {
    create?: XOR<CustomerModelCreateWithoutUserInput, CustomerModelUncheckedCreateWithoutUserInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutUserInput
    connect?: CustomerModelWhereUniqueInput
  }

  export type BusinessUserModelCreateNestedOneWithoutUserInput = {
    create?: XOR<BusinessUserModelCreateWithoutUserInput, BusinessUserModelUncheckedCreateWithoutUserInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutUserInput
    connect?: BusinessUserModelWhereUniqueInput
  }

  export type BoardArticleModelCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<BoardArticleModelCreateWithoutAuthorInput>, Enumerable<BoardArticleModelUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<BoardArticleModelCreateOrConnectWithoutAuthorInput>
    createMany?: BoardArticleModelCreateManyAuthorInputEnvelope
    connect?: Enumerable<BoardArticleModelWhereUniqueInput>
  }

  export type BoardCommentModelCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<BoardCommentModelCreateWithoutAuthorInput>, Enumerable<BoardCommentModelUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<BoardCommentModelCreateOrConnectWithoutAuthorInput>
    createMany?: BoardCommentModelCreateManyAuthorInputEnvelope
    connect?: Enumerable<BoardCommentModelWhereUniqueInput>
  }

  export type CustomerModelUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CustomerModelCreateWithoutUserInput, CustomerModelUncheckedCreateWithoutUserInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutUserInput
    connect?: CustomerModelWhereUniqueInput
  }

  export type BusinessUserModelUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<BusinessUserModelCreateWithoutUserInput, BusinessUserModelUncheckedCreateWithoutUserInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutUserInput
    connect?: BusinessUserModelWhereUniqueInput
  }

  export type BoardArticleModelUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<BoardArticleModelCreateWithoutAuthorInput>, Enumerable<BoardArticleModelUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<BoardArticleModelCreateOrConnectWithoutAuthorInput>
    createMany?: BoardArticleModelCreateManyAuthorInputEnvelope
    connect?: Enumerable<BoardArticleModelWhereUniqueInput>
  }

  export type BoardCommentModelUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<BoardCommentModelCreateWithoutAuthorInput>, Enumerable<BoardCommentModelUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<BoardCommentModelCreateOrConnectWithoutAuthorInput>
    createMany?: BoardCommentModelCreateManyAuthorInputEnvelope
    connect?: Enumerable<BoardCommentModelWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CustomerModelUpdateOneWithoutUserNestedInput = {
    create?: XOR<CustomerModelCreateWithoutUserInput, CustomerModelUncheckedCreateWithoutUserInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutUserInput
    upsert?: CustomerModelUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: CustomerModelWhereUniqueInput
    update?: XOR<CustomerModelUpdateWithoutUserInput, CustomerModelUncheckedUpdateWithoutUserInput>
  }

  export type BusinessUserModelUpdateOneWithoutUserNestedInput = {
    create?: XOR<BusinessUserModelCreateWithoutUserInput, BusinessUserModelUncheckedCreateWithoutUserInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutUserInput
    upsert?: BusinessUserModelUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: BusinessUserModelWhereUniqueInput
    update?: XOR<BusinessUserModelUpdateWithoutUserInput, BusinessUserModelUncheckedUpdateWithoutUserInput>
  }

  export type BoardArticleModelUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<BoardArticleModelCreateWithoutAuthorInput>, Enumerable<BoardArticleModelUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<BoardArticleModelCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<BoardArticleModelUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: BoardArticleModelCreateManyAuthorInputEnvelope
    set?: Enumerable<BoardArticleModelWhereUniqueInput>
    disconnect?: Enumerable<BoardArticleModelWhereUniqueInput>
    delete?: Enumerable<BoardArticleModelWhereUniqueInput>
    connect?: Enumerable<BoardArticleModelWhereUniqueInput>
    update?: Enumerable<BoardArticleModelUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<BoardArticleModelUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<BoardArticleModelScalarWhereInput>
  }

  export type BoardCommentModelUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<BoardCommentModelCreateWithoutAuthorInput>, Enumerable<BoardCommentModelUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<BoardCommentModelCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<BoardCommentModelUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: BoardCommentModelCreateManyAuthorInputEnvelope
    set?: Enumerable<BoardCommentModelWhereUniqueInput>
    disconnect?: Enumerable<BoardCommentModelWhereUniqueInput>
    delete?: Enumerable<BoardCommentModelWhereUniqueInput>
    connect?: Enumerable<BoardCommentModelWhereUniqueInput>
    update?: Enumerable<BoardCommentModelUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<BoardCommentModelUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<BoardCommentModelScalarWhereInput>
  }

  export type CustomerModelUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CustomerModelCreateWithoutUserInput, CustomerModelUncheckedCreateWithoutUserInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutUserInput
    upsert?: CustomerModelUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: CustomerModelWhereUniqueInput
    update?: XOR<CustomerModelUpdateWithoutUserInput, CustomerModelUncheckedUpdateWithoutUserInput>
  }

  export type BusinessUserModelUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<BusinessUserModelCreateWithoutUserInput, BusinessUserModelUncheckedCreateWithoutUserInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutUserInput
    upsert?: BusinessUserModelUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: BusinessUserModelWhereUniqueInput
    update?: XOR<BusinessUserModelUpdateWithoutUserInput, BusinessUserModelUncheckedUpdateWithoutUserInput>
  }

  export type BoardArticleModelUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<BoardArticleModelCreateWithoutAuthorInput>, Enumerable<BoardArticleModelUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<BoardArticleModelCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<BoardArticleModelUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: BoardArticleModelCreateManyAuthorInputEnvelope
    set?: Enumerable<BoardArticleModelWhereUniqueInput>
    disconnect?: Enumerable<BoardArticleModelWhereUniqueInput>
    delete?: Enumerable<BoardArticleModelWhereUniqueInput>
    connect?: Enumerable<BoardArticleModelWhereUniqueInput>
    update?: Enumerable<BoardArticleModelUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<BoardArticleModelUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<BoardArticleModelScalarWhereInput>
  }

  export type BoardCommentModelUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<BoardCommentModelCreateWithoutAuthorInput>, Enumerable<BoardCommentModelUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<BoardCommentModelCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<BoardCommentModelUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: BoardCommentModelCreateManyAuthorInputEnvelope
    set?: Enumerable<BoardCommentModelWhereUniqueInput>
    disconnect?: Enumerable<BoardCommentModelWhereUniqueInput>
    delete?: Enumerable<BoardCommentModelWhereUniqueInput>
    connect?: Enumerable<BoardCommentModelWhereUniqueInput>
    update?: Enumerable<BoardCommentModelUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<BoardCommentModelUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<BoardCommentModelScalarWhereInput>
  }

  export type UserModelCreateNestedOneWithoutCustomerInput = {
    create?: XOR<UserModelCreateWithoutCustomerInput, UserModelUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: UserModelCreateOrConnectWithoutCustomerInput
    connect?: UserModelWhereUniqueInput
  }

  export type AuthenticationModelCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<AuthenticationModelCreateWithoutCustomerInput>, Enumerable<AuthenticationModelUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<AuthenticationModelCreateOrConnectWithoutCustomerInput>
    createMany?: AuthenticationModelCreateManyCustomerInputEnvelope
    connect?: Enumerable<AuthenticationModelWhereUniqueInput>
  }

  export type BusinessRateModelCreateNestedManyWithoutRaterInput = {
    create?: XOR<Enumerable<BusinessRateModelCreateWithoutRaterInput>, Enumerable<BusinessRateModelUncheckedCreateWithoutRaterInput>>
    connectOrCreate?: Enumerable<BusinessRateModelCreateOrConnectWithoutRaterInput>
    createMany?: BusinessRateModelCreateManyRaterInputEnvelope
    connect?: Enumerable<BusinessRateModelWhereUniqueInput>
  }

  export type BusinessReviewModelCreateNestedManyWithoutReviewerInput = {
    create?: XOR<Enumerable<BusinessReviewModelCreateWithoutReviewerInput>, Enumerable<BusinessReviewModelUncheckedCreateWithoutReviewerInput>>
    connectOrCreate?: Enumerable<BusinessReviewModelCreateOrConnectWithoutReviewerInput>
    createMany?: BusinessReviewModelCreateManyReviewerInputEnvelope
    connect?: Enumerable<BusinessReviewModelWhereUniqueInput>
  }

  export type AuthenticationModelUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<AuthenticationModelCreateWithoutCustomerInput>, Enumerable<AuthenticationModelUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<AuthenticationModelCreateOrConnectWithoutCustomerInput>
    createMany?: AuthenticationModelCreateManyCustomerInputEnvelope
    connect?: Enumerable<AuthenticationModelWhereUniqueInput>
  }

  export type BusinessRateModelUncheckedCreateNestedManyWithoutRaterInput = {
    create?: XOR<Enumerable<BusinessRateModelCreateWithoutRaterInput>, Enumerable<BusinessRateModelUncheckedCreateWithoutRaterInput>>
    connectOrCreate?: Enumerable<BusinessRateModelCreateOrConnectWithoutRaterInput>
    createMany?: BusinessRateModelCreateManyRaterInputEnvelope
    connect?: Enumerable<BusinessRateModelWhereUniqueInput>
  }

  export type BusinessReviewModelUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<Enumerable<BusinessReviewModelCreateWithoutReviewerInput>, Enumerable<BusinessReviewModelUncheckedCreateWithoutReviewerInput>>
    connectOrCreate?: Enumerable<BusinessReviewModelCreateOrConnectWithoutReviewerInput>
    createMany?: BusinessReviewModelCreateManyReviewerInputEnvelope
    connect?: Enumerable<BusinessReviewModelWhereUniqueInput>
  }

  export type UserModelUpdateOneRequiredWithoutCustomerNestedInput = {
    create?: XOR<UserModelCreateWithoutCustomerInput, UserModelUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: UserModelCreateOrConnectWithoutCustomerInput
    upsert?: UserModelUpsertWithoutCustomerInput
    connect?: UserModelWhereUniqueInput
    update?: XOR<UserModelUpdateWithoutCustomerInput, UserModelUncheckedUpdateWithoutCustomerInput>
  }

  export type AuthenticationModelUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<AuthenticationModelCreateWithoutCustomerInput>, Enumerable<AuthenticationModelUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<AuthenticationModelCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<AuthenticationModelUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: AuthenticationModelCreateManyCustomerInputEnvelope
    set?: Enumerable<AuthenticationModelWhereUniqueInput>
    disconnect?: Enumerable<AuthenticationModelWhereUniqueInput>
    delete?: Enumerable<AuthenticationModelWhereUniqueInput>
    connect?: Enumerable<AuthenticationModelWhereUniqueInput>
    update?: Enumerable<AuthenticationModelUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<AuthenticationModelUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<AuthenticationModelScalarWhereInput>
  }

  export type BusinessRateModelUpdateManyWithoutRaterNestedInput = {
    create?: XOR<Enumerable<BusinessRateModelCreateWithoutRaterInput>, Enumerable<BusinessRateModelUncheckedCreateWithoutRaterInput>>
    connectOrCreate?: Enumerable<BusinessRateModelCreateOrConnectWithoutRaterInput>
    upsert?: Enumerable<BusinessRateModelUpsertWithWhereUniqueWithoutRaterInput>
    createMany?: BusinessRateModelCreateManyRaterInputEnvelope
    set?: Enumerable<BusinessRateModelWhereUniqueInput>
    disconnect?: Enumerable<BusinessRateModelWhereUniqueInput>
    delete?: Enumerable<BusinessRateModelWhereUniqueInput>
    connect?: Enumerable<BusinessRateModelWhereUniqueInput>
    update?: Enumerable<BusinessRateModelUpdateWithWhereUniqueWithoutRaterInput>
    updateMany?: Enumerable<BusinessRateModelUpdateManyWithWhereWithoutRaterInput>
    deleteMany?: Enumerable<BusinessRateModelScalarWhereInput>
  }

  export type BusinessReviewModelUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<Enumerable<BusinessReviewModelCreateWithoutReviewerInput>, Enumerable<BusinessReviewModelUncheckedCreateWithoutReviewerInput>>
    connectOrCreate?: Enumerable<BusinessReviewModelCreateOrConnectWithoutReviewerInput>
    upsert?: Enumerable<BusinessReviewModelUpsertWithWhereUniqueWithoutReviewerInput>
    createMany?: BusinessReviewModelCreateManyReviewerInputEnvelope
    set?: Enumerable<BusinessReviewModelWhereUniqueInput>
    disconnect?: Enumerable<BusinessReviewModelWhereUniqueInput>
    delete?: Enumerable<BusinessReviewModelWhereUniqueInput>
    connect?: Enumerable<BusinessReviewModelWhereUniqueInput>
    update?: Enumerable<BusinessReviewModelUpdateWithWhereUniqueWithoutReviewerInput>
    updateMany?: Enumerable<BusinessReviewModelUpdateManyWithWhereWithoutReviewerInput>
    deleteMany?: Enumerable<BusinessReviewModelScalarWhereInput>
  }

  export type AuthenticationModelUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<AuthenticationModelCreateWithoutCustomerInput>, Enumerable<AuthenticationModelUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<AuthenticationModelCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<AuthenticationModelUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: AuthenticationModelCreateManyCustomerInputEnvelope
    set?: Enumerable<AuthenticationModelWhereUniqueInput>
    disconnect?: Enumerable<AuthenticationModelWhereUniqueInput>
    delete?: Enumerable<AuthenticationModelWhereUniqueInput>
    connect?: Enumerable<AuthenticationModelWhereUniqueInput>
    update?: Enumerable<AuthenticationModelUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<AuthenticationModelUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<AuthenticationModelScalarWhereInput>
  }

  export type BusinessRateModelUncheckedUpdateManyWithoutRaterNestedInput = {
    create?: XOR<Enumerable<BusinessRateModelCreateWithoutRaterInput>, Enumerable<BusinessRateModelUncheckedCreateWithoutRaterInput>>
    connectOrCreate?: Enumerable<BusinessRateModelCreateOrConnectWithoutRaterInput>
    upsert?: Enumerable<BusinessRateModelUpsertWithWhereUniqueWithoutRaterInput>
    createMany?: BusinessRateModelCreateManyRaterInputEnvelope
    set?: Enumerable<BusinessRateModelWhereUniqueInput>
    disconnect?: Enumerable<BusinessRateModelWhereUniqueInput>
    delete?: Enumerable<BusinessRateModelWhereUniqueInput>
    connect?: Enumerable<BusinessRateModelWhereUniqueInput>
    update?: Enumerable<BusinessRateModelUpdateWithWhereUniqueWithoutRaterInput>
    updateMany?: Enumerable<BusinessRateModelUpdateManyWithWhereWithoutRaterInput>
    deleteMany?: Enumerable<BusinessRateModelScalarWhereInput>
  }

  export type BusinessReviewModelUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<Enumerable<BusinessReviewModelCreateWithoutReviewerInput>, Enumerable<BusinessReviewModelUncheckedCreateWithoutReviewerInput>>
    connectOrCreate?: Enumerable<BusinessReviewModelCreateOrConnectWithoutReviewerInput>
    upsert?: Enumerable<BusinessReviewModelUpsertWithWhereUniqueWithoutReviewerInput>
    createMany?: BusinessReviewModelCreateManyReviewerInputEnvelope
    set?: Enumerable<BusinessReviewModelWhereUniqueInput>
    disconnect?: Enumerable<BusinessReviewModelWhereUniqueInput>
    delete?: Enumerable<BusinessReviewModelWhereUniqueInput>
    connect?: Enumerable<BusinessReviewModelWhereUniqueInput>
    update?: Enumerable<BusinessReviewModelUpdateWithWhereUniqueWithoutReviewerInput>
    updateMany?: Enumerable<BusinessReviewModelUpdateManyWithWhereWithoutReviewerInput>
    deleteMany?: Enumerable<BusinessReviewModelScalarWhereInput>
  }

  export type UserModelCreateNestedOneWithoutBusiness_userInput = {
    create?: XOR<UserModelCreateWithoutBusiness_userInput, UserModelUncheckedCreateWithoutBusiness_userInput>
    connectOrCreate?: UserModelCreateOrConnectWithoutBusiness_userInput
    connect?: UserModelWhereUniqueInput
  }

  export type AuthenticationModelCreateNestedManyWithoutBusiness_userInput = {
    create?: XOR<Enumerable<AuthenticationModelCreateWithoutBusiness_userInput>, Enumerable<AuthenticationModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<AuthenticationModelCreateOrConnectWithoutBusiness_userInput>
    createMany?: AuthenticationModelCreateManyBusiness_userInputEnvelope
    connect?: Enumerable<AuthenticationModelWhereUniqueInput>
  }

  export type RealEstateAgentModelCreateNestedOneWithoutBusinessInput = {
    create?: XOR<RealEstateAgentModelCreateWithoutBusinessInput, RealEstateAgentModelUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: RealEstateAgentModelCreateOrConnectWithoutBusinessInput
    connect?: RealEstateAgentModelWhereUniqueInput
  }

  export type HomeCareCompanyModelCreateNestedOneWithoutBusinessInput = {
    create?: XOR<HomeCareCompanyModelCreateWithoutBusinessInput, HomeCareCompanyModelUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: HomeCareCompanyModelCreateOrConnectWithoutBusinessInput
    connect?: HomeCareCompanyModelWhereUniqueInput
  }

  export type BusinessRateModelCreateNestedManyWithoutRateeInput = {
    create?: XOR<Enumerable<BusinessRateModelCreateWithoutRateeInput>, Enumerable<BusinessRateModelUncheckedCreateWithoutRateeInput>>
    connectOrCreate?: Enumerable<BusinessRateModelCreateOrConnectWithoutRateeInput>
    createMany?: BusinessRateModelCreateManyRateeInputEnvelope
    connect?: Enumerable<BusinessRateModelWhereUniqueInput>
  }

  export type BusinessReviewModelCreateNestedManyWithoutRevieweeInput = {
    create?: XOR<Enumerable<BusinessReviewModelCreateWithoutRevieweeInput>, Enumerable<BusinessReviewModelUncheckedCreateWithoutRevieweeInput>>
    connectOrCreate?: Enumerable<BusinessReviewModelCreateOrConnectWithoutRevieweeInput>
    createMany?: BusinessReviewModelCreateManyRevieweeInputEnvelope
    connect?: Enumerable<BusinessReviewModelWhereUniqueInput>
  }

  export type AuthenticationModelUncheckedCreateNestedManyWithoutBusiness_userInput = {
    create?: XOR<Enumerable<AuthenticationModelCreateWithoutBusiness_userInput>, Enumerable<AuthenticationModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<AuthenticationModelCreateOrConnectWithoutBusiness_userInput>
    createMany?: AuthenticationModelCreateManyBusiness_userInputEnvelope
    connect?: Enumerable<AuthenticationModelWhereUniqueInput>
  }

  export type RealEstateAgentModelUncheckedCreateNestedOneWithoutBusinessInput = {
    create?: XOR<RealEstateAgentModelCreateWithoutBusinessInput, RealEstateAgentModelUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: RealEstateAgentModelCreateOrConnectWithoutBusinessInput
    connect?: RealEstateAgentModelWhereUniqueInput
  }

  export type HomeCareCompanyModelUncheckedCreateNestedOneWithoutBusinessInput = {
    create?: XOR<HomeCareCompanyModelCreateWithoutBusinessInput, HomeCareCompanyModelUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: HomeCareCompanyModelCreateOrConnectWithoutBusinessInput
    connect?: HomeCareCompanyModelWhereUniqueInput
  }

  export type BusinessRateModelUncheckedCreateNestedManyWithoutRateeInput = {
    create?: XOR<Enumerable<BusinessRateModelCreateWithoutRateeInput>, Enumerable<BusinessRateModelUncheckedCreateWithoutRateeInput>>
    connectOrCreate?: Enumerable<BusinessRateModelCreateOrConnectWithoutRateeInput>
    createMany?: BusinessRateModelCreateManyRateeInputEnvelope
    connect?: Enumerable<BusinessRateModelWhereUniqueInput>
  }

  export type BusinessReviewModelUncheckedCreateNestedManyWithoutRevieweeInput = {
    create?: XOR<Enumerable<BusinessReviewModelCreateWithoutRevieweeInput>, Enumerable<BusinessReviewModelUncheckedCreateWithoutRevieweeInput>>
    connectOrCreate?: Enumerable<BusinessReviewModelCreateOrConnectWithoutRevieweeInput>
    createMany?: BusinessReviewModelCreateManyRevieweeInputEnvelope
    connect?: Enumerable<BusinessReviewModelWhereUniqueInput>
  }

  export type UserModelUpdateOneRequiredWithoutBusiness_userNestedInput = {
    create?: XOR<UserModelCreateWithoutBusiness_userInput, UserModelUncheckedCreateWithoutBusiness_userInput>
    connectOrCreate?: UserModelCreateOrConnectWithoutBusiness_userInput
    upsert?: UserModelUpsertWithoutBusiness_userInput
    connect?: UserModelWhereUniqueInput
    update?: XOR<UserModelUpdateWithoutBusiness_userInput, UserModelUncheckedUpdateWithoutBusiness_userInput>
  }

  export type AuthenticationModelUpdateManyWithoutBusiness_userNestedInput = {
    create?: XOR<Enumerable<AuthenticationModelCreateWithoutBusiness_userInput>, Enumerable<AuthenticationModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<AuthenticationModelCreateOrConnectWithoutBusiness_userInput>
    upsert?: Enumerable<AuthenticationModelUpsertWithWhereUniqueWithoutBusiness_userInput>
    createMany?: AuthenticationModelCreateManyBusiness_userInputEnvelope
    set?: Enumerable<AuthenticationModelWhereUniqueInput>
    disconnect?: Enumerable<AuthenticationModelWhereUniqueInput>
    delete?: Enumerable<AuthenticationModelWhereUniqueInput>
    connect?: Enumerable<AuthenticationModelWhereUniqueInput>
    update?: Enumerable<AuthenticationModelUpdateWithWhereUniqueWithoutBusiness_userInput>
    updateMany?: Enumerable<AuthenticationModelUpdateManyWithWhereWithoutBusiness_userInput>
    deleteMany?: Enumerable<AuthenticationModelScalarWhereInput>
  }

  export type RealEstateAgentModelUpdateOneWithoutBusinessNestedInput = {
    create?: XOR<RealEstateAgentModelCreateWithoutBusinessInput, RealEstateAgentModelUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: RealEstateAgentModelCreateOrConnectWithoutBusinessInput
    upsert?: RealEstateAgentModelUpsertWithoutBusinessInput
    disconnect?: boolean
    delete?: boolean
    connect?: RealEstateAgentModelWhereUniqueInput
    update?: XOR<RealEstateAgentModelUpdateWithoutBusinessInput, RealEstateAgentModelUncheckedUpdateWithoutBusinessInput>
  }

  export type HomeCareCompanyModelUpdateOneWithoutBusinessNestedInput = {
    create?: XOR<HomeCareCompanyModelCreateWithoutBusinessInput, HomeCareCompanyModelUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: HomeCareCompanyModelCreateOrConnectWithoutBusinessInput
    upsert?: HomeCareCompanyModelUpsertWithoutBusinessInput
    disconnect?: boolean
    delete?: boolean
    connect?: HomeCareCompanyModelWhereUniqueInput
    update?: XOR<HomeCareCompanyModelUpdateWithoutBusinessInput, HomeCareCompanyModelUncheckedUpdateWithoutBusinessInput>
  }

  export type BusinessRateModelUpdateManyWithoutRateeNestedInput = {
    create?: XOR<Enumerable<BusinessRateModelCreateWithoutRateeInput>, Enumerable<BusinessRateModelUncheckedCreateWithoutRateeInput>>
    connectOrCreate?: Enumerable<BusinessRateModelCreateOrConnectWithoutRateeInput>
    upsert?: Enumerable<BusinessRateModelUpsertWithWhereUniqueWithoutRateeInput>
    createMany?: BusinessRateModelCreateManyRateeInputEnvelope
    set?: Enumerable<BusinessRateModelWhereUniqueInput>
    disconnect?: Enumerable<BusinessRateModelWhereUniqueInput>
    delete?: Enumerable<BusinessRateModelWhereUniqueInput>
    connect?: Enumerable<BusinessRateModelWhereUniqueInput>
    update?: Enumerable<BusinessRateModelUpdateWithWhereUniqueWithoutRateeInput>
    updateMany?: Enumerable<BusinessRateModelUpdateManyWithWhereWithoutRateeInput>
    deleteMany?: Enumerable<BusinessRateModelScalarWhereInput>
  }

  export type BusinessReviewModelUpdateManyWithoutRevieweeNestedInput = {
    create?: XOR<Enumerable<BusinessReviewModelCreateWithoutRevieweeInput>, Enumerable<BusinessReviewModelUncheckedCreateWithoutRevieweeInput>>
    connectOrCreate?: Enumerable<BusinessReviewModelCreateOrConnectWithoutRevieweeInput>
    upsert?: Enumerable<BusinessReviewModelUpsertWithWhereUniqueWithoutRevieweeInput>
    createMany?: BusinessReviewModelCreateManyRevieweeInputEnvelope
    set?: Enumerable<BusinessReviewModelWhereUniqueInput>
    disconnect?: Enumerable<BusinessReviewModelWhereUniqueInput>
    delete?: Enumerable<BusinessReviewModelWhereUniqueInput>
    connect?: Enumerable<BusinessReviewModelWhereUniqueInput>
    update?: Enumerable<BusinessReviewModelUpdateWithWhereUniqueWithoutRevieweeInput>
    updateMany?: Enumerable<BusinessReviewModelUpdateManyWithWhereWithoutRevieweeInput>
    deleteMany?: Enumerable<BusinessReviewModelScalarWhereInput>
  }

  export type AuthenticationModelUncheckedUpdateManyWithoutBusiness_userNestedInput = {
    create?: XOR<Enumerable<AuthenticationModelCreateWithoutBusiness_userInput>, Enumerable<AuthenticationModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<AuthenticationModelCreateOrConnectWithoutBusiness_userInput>
    upsert?: Enumerable<AuthenticationModelUpsertWithWhereUniqueWithoutBusiness_userInput>
    createMany?: AuthenticationModelCreateManyBusiness_userInputEnvelope
    set?: Enumerable<AuthenticationModelWhereUniqueInput>
    disconnect?: Enumerable<AuthenticationModelWhereUniqueInput>
    delete?: Enumerable<AuthenticationModelWhereUniqueInput>
    connect?: Enumerable<AuthenticationModelWhereUniqueInput>
    update?: Enumerable<AuthenticationModelUpdateWithWhereUniqueWithoutBusiness_userInput>
    updateMany?: Enumerable<AuthenticationModelUpdateManyWithWhereWithoutBusiness_userInput>
    deleteMany?: Enumerable<AuthenticationModelScalarWhereInput>
  }

  export type RealEstateAgentModelUncheckedUpdateOneWithoutBusinessNestedInput = {
    create?: XOR<RealEstateAgentModelCreateWithoutBusinessInput, RealEstateAgentModelUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: RealEstateAgentModelCreateOrConnectWithoutBusinessInput
    upsert?: RealEstateAgentModelUpsertWithoutBusinessInput
    disconnect?: boolean
    delete?: boolean
    connect?: RealEstateAgentModelWhereUniqueInput
    update?: XOR<RealEstateAgentModelUpdateWithoutBusinessInput, RealEstateAgentModelUncheckedUpdateWithoutBusinessInput>
  }

  export type HomeCareCompanyModelUncheckedUpdateOneWithoutBusinessNestedInput = {
    create?: XOR<HomeCareCompanyModelCreateWithoutBusinessInput, HomeCareCompanyModelUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: HomeCareCompanyModelCreateOrConnectWithoutBusinessInput
    upsert?: HomeCareCompanyModelUpsertWithoutBusinessInput
    disconnect?: boolean
    delete?: boolean
    connect?: HomeCareCompanyModelWhereUniqueInput
    update?: XOR<HomeCareCompanyModelUpdateWithoutBusinessInput, HomeCareCompanyModelUncheckedUpdateWithoutBusinessInput>
  }

  export type BusinessRateModelUncheckedUpdateManyWithoutRateeNestedInput = {
    create?: XOR<Enumerable<BusinessRateModelCreateWithoutRateeInput>, Enumerable<BusinessRateModelUncheckedCreateWithoutRateeInput>>
    connectOrCreate?: Enumerable<BusinessRateModelCreateOrConnectWithoutRateeInput>
    upsert?: Enumerable<BusinessRateModelUpsertWithWhereUniqueWithoutRateeInput>
    createMany?: BusinessRateModelCreateManyRateeInputEnvelope
    set?: Enumerable<BusinessRateModelWhereUniqueInput>
    disconnect?: Enumerable<BusinessRateModelWhereUniqueInput>
    delete?: Enumerable<BusinessRateModelWhereUniqueInput>
    connect?: Enumerable<BusinessRateModelWhereUniqueInput>
    update?: Enumerable<BusinessRateModelUpdateWithWhereUniqueWithoutRateeInput>
    updateMany?: Enumerable<BusinessRateModelUpdateManyWithWhereWithoutRateeInput>
    deleteMany?: Enumerable<BusinessRateModelScalarWhereInput>
  }

  export type BusinessReviewModelUncheckedUpdateManyWithoutRevieweeNestedInput = {
    create?: XOR<Enumerable<BusinessReviewModelCreateWithoutRevieweeInput>, Enumerable<BusinessReviewModelUncheckedCreateWithoutRevieweeInput>>
    connectOrCreate?: Enumerable<BusinessReviewModelCreateOrConnectWithoutRevieweeInput>
    upsert?: Enumerable<BusinessReviewModelUpsertWithWhereUniqueWithoutRevieweeInput>
    createMany?: BusinessReviewModelCreateManyRevieweeInputEnvelope
    set?: Enumerable<BusinessReviewModelWhereUniqueInput>
    disconnect?: Enumerable<BusinessReviewModelWhereUniqueInput>
    delete?: Enumerable<BusinessReviewModelWhereUniqueInput>
    connect?: Enumerable<BusinessReviewModelWhereUniqueInput>
    update?: Enumerable<BusinessReviewModelUpdateWithWhereUniqueWithoutRevieweeInput>
    updateMany?: Enumerable<BusinessReviewModelUpdateManyWithWhereWithoutRevieweeInput>
    deleteMany?: Enumerable<BusinessReviewModelScalarWhereInput>
  }

  export type BusinessUserModelCreateNestedOneWithoutReal_estate_agentInput = {
    create?: XOR<BusinessUserModelCreateWithoutReal_estate_agentInput, BusinessUserModelUncheckedCreateWithoutReal_estate_agentInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutReal_estate_agentInput
    connect?: BusinessUserModelWhereUniqueInput
  }

  export type RealEstateSpecializedSubFieldModelCreateNestedOneWithoutReal_estate_agentsInput = {
    create?: XOR<RealEstateSpecializedSubFieldModelCreateWithoutReal_estate_agentsInput, RealEstateSpecializedSubFieldModelUncheckedCreateWithoutReal_estate_agentsInput>
    connectOrCreate?: RealEstateSpecializedSubFieldModelCreateOrConnectWithoutReal_estate_agentsInput
    connect?: RealEstateSpecializedSubFieldModelWhereUniqueInput
  }

  export type RealEstatePropertyModelCreateNestedManyWithoutAgentInput = {
    create?: XOR<Enumerable<RealEstatePropertyModelCreateWithoutAgentInput>, Enumerable<RealEstatePropertyModelUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<RealEstatePropertyModelCreateOrConnectWithoutAgentInput>
    createMany?: RealEstatePropertyModelCreateManyAgentInputEnvelope
    connect?: Enumerable<RealEstatePropertyModelWhereUniqueInput>
  }

  export type RealEstatePropertyModelUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<Enumerable<RealEstatePropertyModelCreateWithoutAgentInput>, Enumerable<RealEstatePropertyModelUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<RealEstatePropertyModelCreateOrConnectWithoutAgentInput>
    createMany?: RealEstatePropertyModelCreateManyAgentInputEnvelope
    connect?: Enumerable<RealEstatePropertyModelWhereUniqueInput>
  }

  export type BusinessUserModelUpdateOneRequiredWithoutReal_estate_agentNestedInput = {
    create?: XOR<BusinessUserModelCreateWithoutReal_estate_agentInput, BusinessUserModelUncheckedCreateWithoutReal_estate_agentInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutReal_estate_agentInput
    upsert?: BusinessUserModelUpsertWithoutReal_estate_agentInput
    connect?: BusinessUserModelWhereUniqueInput
    update?: XOR<BusinessUserModelUpdateWithoutReal_estate_agentInput, BusinessUserModelUncheckedUpdateWithoutReal_estate_agentInput>
  }

  export type RealEstateSpecializedSubFieldModelUpdateOneWithoutReal_estate_agentsNestedInput = {
    create?: XOR<RealEstateSpecializedSubFieldModelCreateWithoutReal_estate_agentsInput, RealEstateSpecializedSubFieldModelUncheckedCreateWithoutReal_estate_agentsInput>
    connectOrCreate?: RealEstateSpecializedSubFieldModelCreateOrConnectWithoutReal_estate_agentsInput
    upsert?: RealEstateSpecializedSubFieldModelUpsertWithoutReal_estate_agentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: RealEstateSpecializedSubFieldModelWhereUniqueInput
    update?: XOR<RealEstateSpecializedSubFieldModelUpdateWithoutReal_estate_agentsInput, RealEstateSpecializedSubFieldModelUncheckedUpdateWithoutReal_estate_agentsInput>
  }

  export type RealEstatePropertyModelUpdateManyWithoutAgentNestedInput = {
    create?: XOR<Enumerable<RealEstatePropertyModelCreateWithoutAgentInput>, Enumerable<RealEstatePropertyModelUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<RealEstatePropertyModelCreateOrConnectWithoutAgentInput>
    upsert?: Enumerable<RealEstatePropertyModelUpsertWithWhereUniqueWithoutAgentInput>
    createMany?: RealEstatePropertyModelCreateManyAgentInputEnvelope
    set?: Enumerable<RealEstatePropertyModelWhereUniqueInput>
    disconnect?: Enumerable<RealEstatePropertyModelWhereUniqueInput>
    delete?: Enumerable<RealEstatePropertyModelWhereUniqueInput>
    connect?: Enumerable<RealEstatePropertyModelWhereUniqueInput>
    update?: Enumerable<RealEstatePropertyModelUpdateWithWhereUniqueWithoutAgentInput>
    updateMany?: Enumerable<RealEstatePropertyModelUpdateManyWithWhereWithoutAgentInput>
    deleteMany?: Enumerable<RealEstatePropertyModelScalarWhereInput>
  }

  export type RealEstatePropertyModelUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<Enumerable<RealEstatePropertyModelCreateWithoutAgentInput>, Enumerable<RealEstatePropertyModelUncheckedCreateWithoutAgentInput>>
    connectOrCreate?: Enumerable<RealEstatePropertyModelCreateOrConnectWithoutAgentInput>
    upsert?: Enumerable<RealEstatePropertyModelUpsertWithWhereUniqueWithoutAgentInput>
    createMany?: RealEstatePropertyModelCreateManyAgentInputEnvelope
    set?: Enumerable<RealEstatePropertyModelWhereUniqueInput>
    disconnect?: Enumerable<RealEstatePropertyModelWhereUniqueInput>
    delete?: Enumerable<RealEstatePropertyModelWhereUniqueInput>
    connect?: Enumerable<RealEstatePropertyModelWhereUniqueInput>
    update?: Enumerable<RealEstatePropertyModelUpdateWithWhereUniqueWithoutAgentInput>
    updateMany?: Enumerable<RealEstatePropertyModelUpdateManyWithWhereWithoutAgentInput>
    deleteMany?: Enumerable<RealEstatePropertyModelScalarWhereInput>
  }

  export type BusinessUserModelCreateNestedOneWithoutHome_care_companyInput = {
    create?: XOR<BusinessUserModelCreateWithoutHome_care_companyInput, BusinessUserModelUncheckedCreateWithoutHome_care_companyInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutHome_care_companyInput
    connect?: BusinessUserModelWhereUniqueInput
  }

  export type HomeCareSpecializedSubFieldModelCreateNestedOneWithoutHome_care_companiesInput = {
    create?: XOR<HomeCareSpecializedSubFieldModelCreateWithoutHome_care_companiesInput, HomeCareSpecializedSubFieldModelUncheckedCreateWithoutHome_care_companiesInput>
    connectOrCreate?: HomeCareSpecializedSubFieldModelCreateOrConnectWithoutHome_care_companiesInput
    connect?: HomeCareSpecializedSubFieldModelWhereUniqueInput
  }

  export type HomeCareIntroductionImageModelCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<HomeCareIntroductionImageModelCreateWithoutCompanyInput>, Enumerable<HomeCareIntroductionImageModelUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<HomeCareIntroductionImageModelCreateOrConnectWithoutCompanyInput>
    createMany?: HomeCareIntroductionImageModelCreateManyCompanyInputEnvelope
    connect?: Enumerable<HomeCareIntroductionImageModelWhereUniqueInput>
  }

  export type HomeCareIntroductionImageModelUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<HomeCareIntroductionImageModelCreateWithoutCompanyInput>, Enumerable<HomeCareIntroductionImageModelUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<HomeCareIntroductionImageModelCreateOrConnectWithoutCompanyInput>
    createMany?: HomeCareIntroductionImageModelCreateManyCompanyInputEnvelope
    connect?: Enumerable<HomeCareIntroductionImageModelWhereUniqueInput>
  }

  export type BusinessUserModelUpdateOneRequiredWithoutHome_care_companyNestedInput = {
    create?: XOR<BusinessUserModelCreateWithoutHome_care_companyInput, BusinessUserModelUncheckedCreateWithoutHome_care_companyInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutHome_care_companyInput
    upsert?: BusinessUserModelUpsertWithoutHome_care_companyInput
    connect?: BusinessUserModelWhereUniqueInput
    update?: XOR<BusinessUserModelUpdateWithoutHome_care_companyInput, BusinessUserModelUncheckedUpdateWithoutHome_care_companyInput>
  }

  export type HomeCareSpecializedSubFieldModelUpdateOneWithoutHome_care_companiesNestedInput = {
    create?: XOR<HomeCareSpecializedSubFieldModelCreateWithoutHome_care_companiesInput, HomeCareSpecializedSubFieldModelUncheckedCreateWithoutHome_care_companiesInput>
    connectOrCreate?: HomeCareSpecializedSubFieldModelCreateOrConnectWithoutHome_care_companiesInput
    upsert?: HomeCareSpecializedSubFieldModelUpsertWithoutHome_care_companiesInput
    disconnect?: boolean
    delete?: boolean
    connect?: HomeCareSpecializedSubFieldModelWhereUniqueInput
    update?: XOR<HomeCareSpecializedSubFieldModelUpdateWithoutHome_care_companiesInput, HomeCareSpecializedSubFieldModelUncheckedUpdateWithoutHome_care_companiesInput>
  }

  export type HomeCareIntroductionImageModelUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<HomeCareIntroductionImageModelCreateWithoutCompanyInput>, Enumerable<HomeCareIntroductionImageModelUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<HomeCareIntroductionImageModelCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<HomeCareIntroductionImageModelUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: HomeCareIntroductionImageModelCreateManyCompanyInputEnvelope
    set?: Enumerable<HomeCareIntroductionImageModelWhereUniqueInput>
    disconnect?: Enumerable<HomeCareIntroductionImageModelWhereUniqueInput>
    delete?: Enumerable<HomeCareIntroductionImageModelWhereUniqueInput>
    connect?: Enumerable<HomeCareIntroductionImageModelWhereUniqueInput>
    update?: Enumerable<HomeCareIntroductionImageModelUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<HomeCareIntroductionImageModelUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<HomeCareIntroductionImageModelScalarWhereInput>
  }

  export type HomeCareIntroductionImageModelUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<HomeCareIntroductionImageModelCreateWithoutCompanyInput>, Enumerable<HomeCareIntroductionImageModelUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<HomeCareIntroductionImageModelCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<HomeCareIntroductionImageModelUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: HomeCareIntroductionImageModelCreateManyCompanyInputEnvelope
    set?: Enumerable<HomeCareIntroductionImageModelWhereUniqueInput>
    disconnect?: Enumerable<HomeCareIntroductionImageModelWhereUniqueInput>
    delete?: Enumerable<HomeCareIntroductionImageModelWhereUniqueInput>
    connect?: Enumerable<HomeCareIntroductionImageModelWhereUniqueInput>
    update?: Enumerable<HomeCareIntroductionImageModelUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<HomeCareIntroductionImageModelUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<HomeCareIntroductionImageModelScalarWhereInput>
  }

  export type HomeCareCompanyModelCreateNestedOneWithoutIntroduction_imagesInput = {
    create?: XOR<HomeCareCompanyModelCreateWithoutIntroduction_imagesInput, HomeCareCompanyModelUncheckedCreateWithoutIntroduction_imagesInput>
    connectOrCreate?: HomeCareCompanyModelCreateOrConnectWithoutIntroduction_imagesInput
    connect?: HomeCareCompanyModelWhereUniqueInput
  }

  export type HomeCareCompanyModelUpdateOneRequiredWithoutIntroduction_imagesNestedInput = {
    create?: XOR<HomeCareCompanyModelCreateWithoutIntroduction_imagesInput, HomeCareCompanyModelUncheckedCreateWithoutIntroduction_imagesInput>
    connectOrCreate?: HomeCareCompanyModelCreateOrConnectWithoutIntroduction_imagesInput
    upsert?: HomeCareCompanyModelUpsertWithoutIntroduction_imagesInput
    connect?: HomeCareCompanyModelWhereUniqueInput
    update?: XOR<HomeCareCompanyModelUpdateWithoutIntroduction_imagesInput, HomeCareCompanyModelUncheckedUpdateWithoutIntroduction_imagesInput>
  }

  export type RealEstateAgentModelCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<RealEstateAgentModelCreateWithoutPropertiesInput, RealEstateAgentModelUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: RealEstateAgentModelCreateOrConnectWithoutPropertiesInput
    connect?: RealEstateAgentModelWhereUniqueInput
  }

  export type RealEstateAgentModelUpdateOneRequiredWithoutPropertiesNestedInput = {
    create?: XOR<RealEstateAgentModelCreateWithoutPropertiesInput, RealEstateAgentModelUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: RealEstateAgentModelCreateOrConnectWithoutPropertiesInput
    upsert?: RealEstateAgentModelUpsertWithoutPropertiesInput
    connect?: RealEstateAgentModelWhereUniqueInput
    update?: XOR<RealEstateAgentModelUpdateWithoutPropertiesInput, RealEstateAgentModelUncheckedUpdateWithoutPropertiesInput>
  }

  export type HomeCareSpecializedSubFieldModelCreateNestedManyWithoutSuperInput = {
    create?: XOR<Enumerable<HomeCareSpecializedSubFieldModelCreateWithoutSuperInput>, Enumerable<HomeCareSpecializedSubFieldModelUncheckedCreateWithoutSuperInput>>
    connectOrCreate?: Enumerable<HomeCareSpecializedSubFieldModelCreateOrConnectWithoutSuperInput>
    createMany?: HomeCareSpecializedSubFieldModelCreateManySuperInputEnvelope
    connect?: Enumerable<HomeCareSpecializedSubFieldModelWhereUniqueInput>
  }

  export type HomeCareSpecializedSubFieldModelUncheckedCreateNestedManyWithoutSuperInput = {
    create?: XOR<Enumerable<HomeCareSpecializedSubFieldModelCreateWithoutSuperInput>, Enumerable<HomeCareSpecializedSubFieldModelUncheckedCreateWithoutSuperInput>>
    connectOrCreate?: Enumerable<HomeCareSpecializedSubFieldModelCreateOrConnectWithoutSuperInput>
    createMany?: HomeCareSpecializedSubFieldModelCreateManySuperInputEnvelope
    connect?: Enumerable<HomeCareSpecializedSubFieldModelWhereUniqueInput>
  }

  export type HomeCareSpecializedSubFieldModelUpdateManyWithoutSuperNestedInput = {
    create?: XOR<Enumerable<HomeCareSpecializedSubFieldModelCreateWithoutSuperInput>, Enumerable<HomeCareSpecializedSubFieldModelUncheckedCreateWithoutSuperInput>>
    connectOrCreate?: Enumerable<HomeCareSpecializedSubFieldModelCreateOrConnectWithoutSuperInput>
    upsert?: Enumerable<HomeCareSpecializedSubFieldModelUpsertWithWhereUniqueWithoutSuperInput>
    createMany?: HomeCareSpecializedSubFieldModelCreateManySuperInputEnvelope
    set?: Enumerable<HomeCareSpecializedSubFieldModelWhereUniqueInput>
    disconnect?: Enumerable<HomeCareSpecializedSubFieldModelWhereUniqueInput>
    delete?: Enumerable<HomeCareSpecializedSubFieldModelWhereUniqueInput>
    connect?: Enumerable<HomeCareSpecializedSubFieldModelWhereUniqueInput>
    update?: Enumerable<HomeCareSpecializedSubFieldModelUpdateWithWhereUniqueWithoutSuperInput>
    updateMany?: Enumerable<HomeCareSpecializedSubFieldModelUpdateManyWithWhereWithoutSuperInput>
    deleteMany?: Enumerable<HomeCareSpecializedSubFieldModelScalarWhereInput>
  }

  export type HomeCareSpecializedSubFieldModelUncheckedUpdateManyWithoutSuperNestedInput = {
    create?: XOR<Enumerable<HomeCareSpecializedSubFieldModelCreateWithoutSuperInput>, Enumerable<HomeCareSpecializedSubFieldModelUncheckedCreateWithoutSuperInput>>
    connectOrCreate?: Enumerable<HomeCareSpecializedSubFieldModelCreateOrConnectWithoutSuperInput>
    upsert?: Enumerable<HomeCareSpecializedSubFieldModelUpsertWithWhereUniqueWithoutSuperInput>
    createMany?: HomeCareSpecializedSubFieldModelCreateManySuperInputEnvelope
    set?: Enumerable<HomeCareSpecializedSubFieldModelWhereUniqueInput>
    disconnect?: Enumerable<HomeCareSpecializedSubFieldModelWhereUniqueInput>
    delete?: Enumerable<HomeCareSpecializedSubFieldModelWhereUniqueInput>
    connect?: Enumerable<HomeCareSpecializedSubFieldModelWhereUniqueInput>
    update?: Enumerable<HomeCareSpecializedSubFieldModelUpdateWithWhereUniqueWithoutSuperInput>
    updateMany?: Enumerable<HomeCareSpecializedSubFieldModelUpdateManyWithWhereWithoutSuperInput>
    deleteMany?: Enumerable<HomeCareSpecializedSubFieldModelScalarWhereInput>
  }

  export type HomeCareSpecializedSuperFieldModelCreateNestedOneWithoutSubInput = {
    create?: XOR<HomeCareSpecializedSuperFieldModelCreateWithoutSubInput, HomeCareSpecializedSuperFieldModelUncheckedCreateWithoutSubInput>
    connectOrCreate?: HomeCareSpecializedSuperFieldModelCreateOrConnectWithoutSubInput
    connect?: HomeCareSpecializedSuperFieldModelWhereUniqueInput
  }

  export type HomeCareCompanyModelCreateNestedManyWithoutSpecialized_fieldInput = {
    create?: XOR<Enumerable<HomeCareCompanyModelCreateWithoutSpecialized_fieldInput>, Enumerable<HomeCareCompanyModelUncheckedCreateWithoutSpecialized_fieldInput>>
    connectOrCreate?: Enumerable<HomeCareCompanyModelCreateOrConnectWithoutSpecialized_fieldInput>
    createMany?: HomeCareCompanyModelCreateManySpecialized_fieldInputEnvelope
    connect?: Enumerable<HomeCareCompanyModelWhereUniqueInput>
  }

  export type HomeCareCompanyModelUncheckedCreateNestedManyWithoutSpecialized_fieldInput = {
    create?: XOR<Enumerable<HomeCareCompanyModelCreateWithoutSpecialized_fieldInput>, Enumerable<HomeCareCompanyModelUncheckedCreateWithoutSpecialized_fieldInput>>
    connectOrCreate?: Enumerable<HomeCareCompanyModelCreateOrConnectWithoutSpecialized_fieldInput>
    createMany?: HomeCareCompanyModelCreateManySpecialized_fieldInputEnvelope
    connect?: Enumerable<HomeCareCompanyModelWhereUniqueInput>
  }

  export type HomeCareSpecializedSuperFieldModelUpdateOneRequiredWithoutSubNestedInput = {
    create?: XOR<HomeCareSpecializedSuperFieldModelCreateWithoutSubInput, HomeCareSpecializedSuperFieldModelUncheckedCreateWithoutSubInput>
    connectOrCreate?: HomeCareSpecializedSuperFieldModelCreateOrConnectWithoutSubInput
    upsert?: HomeCareSpecializedSuperFieldModelUpsertWithoutSubInput
    connect?: HomeCareSpecializedSuperFieldModelWhereUniqueInput
    update?: XOR<HomeCareSpecializedSuperFieldModelUpdateWithoutSubInput, HomeCareSpecializedSuperFieldModelUncheckedUpdateWithoutSubInput>
  }

  export type HomeCareCompanyModelUpdateManyWithoutSpecialized_fieldNestedInput = {
    create?: XOR<Enumerable<HomeCareCompanyModelCreateWithoutSpecialized_fieldInput>, Enumerable<HomeCareCompanyModelUncheckedCreateWithoutSpecialized_fieldInput>>
    connectOrCreate?: Enumerable<HomeCareCompanyModelCreateOrConnectWithoutSpecialized_fieldInput>
    upsert?: Enumerable<HomeCareCompanyModelUpsertWithWhereUniqueWithoutSpecialized_fieldInput>
    createMany?: HomeCareCompanyModelCreateManySpecialized_fieldInputEnvelope
    set?: Enumerable<HomeCareCompanyModelWhereUniqueInput>
    disconnect?: Enumerable<HomeCareCompanyModelWhereUniqueInput>
    delete?: Enumerable<HomeCareCompanyModelWhereUniqueInput>
    connect?: Enumerable<HomeCareCompanyModelWhereUniqueInput>
    update?: Enumerable<HomeCareCompanyModelUpdateWithWhereUniqueWithoutSpecialized_fieldInput>
    updateMany?: Enumerable<HomeCareCompanyModelUpdateManyWithWhereWithoutSpecialized_fieldInput>
    deleteMany?: Enumerable<HomeCareCompanyModelScalarWhereInput>
  }

  export type HomeCareCompanyModelUncheckedUpdateManyWithoutSpecialized_fieldNestedInput = {
    create?: XOR<Enumerable<HomeCareCompanyModelCreateWithoutSpecialized_fieldInput>, Enumerable<HomeCareCompanyModelUncheckedCreateWithoutSpecialized_fieldInput>>
    connectOrCreate?: Enumerable<HomeCareCompanyModelCreateOrConnectWithoutSpecialized_fieldInput>
    upsert?: Enumerable<HomeCareCompanyModelUpsertWithWhereUniqueWithoutSpecialized_fieldInput>
    createMany?: HomeCareCompanyModelCreateManySpecialized_fieldInputEnvelope
    set?: Enumerable<HomeCareCompanyModelWhereUniqueInput>
    disconnect?: Enumerable<HomeCareCompanyModelWhereUniqueInput>
    delete?: Enumerable<HomeCareCompanyModelWhereUniqueInput>
    connect?: Enumerable<HomeCareCompanyModelWhereUniqueInput>
    update?: Enumerable<HomeCareCompanyModelUpdateWithWhereUniqueWithoutSpecialized_fieldInput>
    updateMany?: Enumerable<HomeCareCompanyModelUpdateManyWithWhereWithoutSpecialized_fieldInput>
    deleteMany?: Enumerable<HomeCareCompanyModelScalarWhereInput>
  }

  export type RealEstateSpecializedSubFieldModelCreateNestedManyWithoutSuperInput = {
    create?: XOR<Enumerable<RealEstateSpecializedSubFieldModelCreateWithoutSuperInput>, Enumerable<RealEstateSpecializedSubFieldModelUncheckedCreateWithoutSuperInput>>
    connectOrCreate?: Enumerable<RealEstateSpecializedSubFieldModelCreateOrConnectWithoutSuperInput>
    createMany?: RealEstateSpecializedSubFieldModelCreateManySuperInputEnvelope
    connect?: Enumerable<RealEstateSpecializedSubFieldModelWhereUniqueInput>
  }

  export type RealEstateSpecializedSubFieldModelUncheckedCreateNestedManyWithoutSuperInput = {
    create?: XOR<Enumerable<RealEstateSpecializedSubFieldModelCreateWithoutSuperInput>, Enumerable<RealEstateSpecializedSubFieldModelUncheckedCreateWithoutSuperInput>>
    connectOrCreate?: Enumerable<RealEstateSpecializedSubFieldModelCreateOrConnectWithoutSuperInput>
    createMany?: RealEstateSpecializedSubFieldModelCreateManySuperInputEnvelope
    connect?: Enumerable<RealEstateSpecializedSubFieldModelWhereUniqueInput>
  }

  export type RealEstateSpecializedSubFieldModelUpdateManyWithoutSuperNestedInput = {
    create?: XOR<Enumerable<RealEstateSpecializedSubFieldModelCreateWithoutSuperInput>, Enumerable<RealEstateSpecializedSubFieldModelUncheckedCreateWithoutSuperInput>>
    connectOrCreate?: Enumerable<RealEstateSpecializedSubFieldModelCreateOrConnectWithoutSuperInput>
    upsert?: Enumerable<RealEstateSpecializedSubFieldModelUpsertWithWhereUniqueWithoutSuperInput>
    createMany?: RealEstateSpecializedSubFieldModelCreateManySuperInputEnvelope
    set?: Enumerable<RealEstateSpecializedSubFieldModelWhereUniqueInput>
    disconnect?: Enumerable<RealEstateSpecializedSubFieldModelWhereUniqueInput>
    delete?: Enumerable<RealEstateSpecializedSubFieldModelWhereUniqueInput>
    connect?: Enumerable<RealEstateSpecializedSubFieldModelWhereUniqueInput>
    update?: Enumerable<RealEstateSpecializedSubFieldModelUpdateWithWhereUniqueWithoutSuperInput>
    updateMany?: Enumerable<RealEstateSpecializedSubFieldModelUpdateManyWithWhereWithoutSuperInput>
    deleteMany?: Enumerable<RealEstateSpecializedSubFieldModelScalarWhereInput>
  }

  export type RealEstateSpecializedSubFieldModelUncheckedUpdateManyWithoutSuperNestedInput = {
    create?: XOR<Enumerable<RealEstateSpecializedSubFieldModelCreateWithoutSuperInput>, Enumerable<RealEstateSpecializedSubFieldModelUncheckedCreateWithoutSuperInput>>
    connectOrCreate?: Enumerable<RealEstateSpecializedSubFieldModelCreateOrConnectWithoutSuperInput>
    upsert?: Enumerable<RealEstateSpecializedSubFieldModelUpsertWithWhereUniqueWithoutSuperInput>
    createMany?: RealEstateSpecializedSubFieldModelCreateManySuperInputEnvelope
    set?: Enumerable<RealEstateSpecializedSubFieldModelWhereUniqueInput>
    disconnect?: Enumerable<RealEstateSpecializedSubFieldModelWhereUniqueInput>
    delete?: Enumerable<RealEstateSpecializedSubFieldModelWhereUniqueInput>
    connect?: Enumerable<RealEstateSpecializedSubFieldModelWhereUniqueInput>
    update?: Enumerable<RealEstateSpecializedSubFieldModelUpdateWithWhereUniqueWithoutSuperInput>
    updateMany?: Enumerable<RealEstateSpecializedSubFieldModelUpdateManyWithWhereWithoutSuperInput>
    deleteMany?: Enumerable<RealEstateSpecializedSubFieldModelScalarWhereInput>
  }

  export type RealEstateSpecializedSuperFieldModelCreateNestedOneWithoutSubInput = {
    create?: XOR<RealEstateSpecializedSuperFieldModelCreateWithoutSubInput, RealEstateSpecializedSuperFieldModelUncheckedCreateWithoutSubInput>
    connectOrCreate?: RealEstateSpecializedSuperFieldModelCreateOrConnectWithoutSubInput
    connect?: RealEstateSpecializedSuperFieldModelWhereUniqueInput
  }

  export type RealEstateAgentModelCreateNestedManyWithoutSpecialized_fieldInput = {
    create?: XOR<Enumerable<RealEstateAgentModelCreateWithoutSpecialized_fieldInput>, Enumerable<RealEstateAgentModelUncheckedCreateWithoutSpecialized_fieldInput>>
    connectOrCreate?: Enumerable<RealEstateAgentModelCreateOrConnectWithoutSpecialized_fieldInput>
    createMany?: RealEstateAgentModelCreateManySpecialized_fieldInputEnvelope
    connect?: Enumerable<RealEstateAgentModelWhereUniqueInput>
  }

  export type RealEstateAgentModelUncheckedCreateNestedManyWithoutSpecialized_fieldInput = {
    create?: XOR<Enumerable<RealEstateAgentModelCreateWithoutSpecialized_fieldInput>, Enumerable<RealEstateAgentModelUncheckedCreateWithoutSpecialized_fieldInput>>
    connectOrCreate?: Enumerable<RealEstateAgentModelCreateOrConnectWithoutSpecialized_fieldInput>
    createMany?: RealEstateAgentModelCreateManySpecialized_fieldInputEnvelope
    connect?: Enumerable<RealEstateAgentModelWhereUniqueInput>
  }

  export type RealEstateSpecializedSuperFieldModelUpdateOneRequiredWithoutSubNestedInput = {
    create?: XOR<RealEstateSpecializedSuperFieldModelCreateWithoutSubInput, RealEstateSpecializedSuperFieldModelUncheckedCreateWithoutSubInput>
    connectOrCreate?: RealEstateSpecializedSuperFieldModelCreateOrConnectWithoutSubInput
    upsert?: RealEstateSpecializedSuperFieldModelUpsertWithoutSubInput
    connect?: RealEstateSpecializedSuperFieldModelWhereUniqueInput
    update?: XOR<RealEstateSpecializedSuperFieldModelUpdateWithoutSubInput, RealEstateSpecializedSuperFieldModelUncheckedUpdateWithoutSubInput>
  }

  export type RealEstateAgentModelUpdateManyWithoutSpecialized_fieldNestedInput = {
    create?: XOR<Enumerable<RealEstateAgentModelCreateWithoutSpecialized_fieldInput>, Enumerable<RealEstateAgentModelUncheckedCreateWithoutSpecialized_fieldInput>>
    connectOrCreate?: Enumerable<RealEstateAgentModelCreateOrConnectWithoutSpecialized_fieldInput>
    upsert?: Enumerable<RealEstateAgentModelUpsertWithWhereUniqueWithoutSpecialized_fieldInput>
    createMany?: RealEstateAgentModelCreateManySpecialized_fieldInputEnvelope
    set?: Enumerable<RealEstateAgentModelWhereUniqueInput>
    disconnect?: Enumerable<RealEstateAgentModelWhereUniqueInput>
    delete?: Enumerable<RealEstateAgentModelWhereUniqueInput>
    connect?: Enumerable<RealEstateAgentModelWhereUniqueInput>
    update?: Enumerable<RealEstateAgentModelUpdateWithWhereUniqueWithoutSpecialized_fieldInput>
    updateMany?: Enumerable<RealEstateAgentModelUpdateManyWithWhereWithoutSpecialized_fieldInput>
    deleteMany?: Enumerable<RealEstateAgentModelScalarWhereInput>
  }

  export type RealEstateAgentModelUncheckedUpdateManyWithoutSpecialized_fieldNestedInput = {
    create?: XOR<Enumerable<RealEstateAgentModelCreateWithoutSpecialized_fieldInput>, Enumerable<RealEstateAgentModelUncheckedCreateWithoutSpecialized_fieldInput>>
    connectOrCreate?: Enumerable<RealEstateAgentModelCreateOrConnectWithoutSpecialized_fieldInput>
    upsert?: Enumerable<RealEstateAgentModelUpsertWithWhereUniqueWithoutSpecialized_fieldInput>
    createMany?: RealEstateAgentModelCreateManySpecialized_fieldInputEnvelope
    set?: Enumerable<RealEstateAgentModelWhereUniqueInput>
    disconnect?: Enumerable<RealEstateAgentModelWhereUniqueInput>
    delete?: Enumerable<RealEstateAgentModelWhereUniqueInput>
    connect?: Enumerable<RealEstateAgentModelWhereUniqueInput>
    update?: Enumerable<RealEstateAgentModelUpdateWithWhereUniqueWithoutSpecialized_fieldInput>
    updateMany?: Enumerable<RealEstateAgentModelUpdateManyWithWhereWithoutSpecialized_fieldInput>
    deleteMany?: Enumerable<RealEstateAgentModelScalarWhereInput>
  }

  export type BusinessUserModelCreateNestedOneWithoutRatesInput = {
    create?: XOR<BusinessUserModelCreateWithoutRatesInput, BusinessUserModelUncheckedCreateWithoutRatesInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutRatesInput
    connect?: BusinessUserModelWhereUniqueInput
  }

  export type CustomerModelCreateNestedOneWithoutRatesInput = {
    create?: XOR<CustomerModelCreateWithoutRatesInput, CustomerModelUncheckedCreateWithoutRatesInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutRatesInput
    connect?: CustomerModelWhereUniqueInput
  }

  export type BusinessRateCategoryModelCreateNestedOneWithoutRatesInput = {
    create?: XOR<BusinessRateCategoryModelCreateWithoutRatesInput, BusinessRateCategoryModelUncheckedCreateWithoutRatesInput>
    connectOrCreate?: BusinessRateCategoryModelCreateOrConnectWithoutRatesInput
    connect?: BusinessRateCategoryModelWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BusinessUserModelUpdateOneRequiredWithoutRatesNestedInput = {
    create?: XOR<BusinessUserModelCreateWithoutRatesInput, BusinessUserModelUncheckedCreateWithoutRatesInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutRatesInput
    upsert?: BusinessUserModelUpsertWithoutRatesInput
    connect?: BusinessUserModelWhereUniqueInput
    update?: XOR<BusinessUserModelUpdateWithoutRatesInput, BusinessUserModelUncheckedUpdateWithoutRatesInput>
  }

  export type CustomerModelUpdateOneRequiredWithoutRatesNestedInput = {
    create?: XOR<CustomerModelCreateWithoutRatesInput, CustomerModelUncheckedCreateWithoutRatesInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutRatesInput
    upsert?: CustomerModelUpsertWithoutRatesInput
    connect?: CustomerModelWhereUniqueInput
    update?: XOR<CustomerModelUpdateWithoutRatesInput, CustomerModelUncheckedUpdateWithoutRatesInput>
  }

  export type BusinessRateCategoryModelUpdateOneRequiredWithoutRatesNestedInput = {
    create?: XOR<BusinessRateCategoryModelCreateWithoutRatesInput, BusinessRateCategoryModelUncheckedCreateWithoutRatesInput>
    connectOrCreate?: BusinessRateCategoryModelCreateOrConnectWithoutRatesInput
    upsert?: BusinessRateCategoryModelUpsertWithoutRatesInput
    connect?: BusinessRateCategoryModelWhereUniqueInput
    update?: XOR<BusinessRateCategoryModelUpdateWithoutRatesInput, BusinessRateCategoryModelUncheckedUpdateWithoutRatesInput>
  }

  export type BusinessRateModelCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<BusinessRateModelCreateWithoutCategoryInput>, Enumerable<BusinessRateModelUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<BusinessRateModelCreateOrConnectWithoutCategoryInput>
    createMany?: BusinessRateModelCreateManyCategoryInputEnvelope
    connect?: Enumerable<BusinessRateModelWhereUniqueInput>
  }

  export type BusinessRateModelUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<BusinessRateModelCreateWithoutCategoryInput>, Enumerable<BusinessRateModelUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<BusinessRateModelCreateOrConnectWithoutCategoryInput>
    createMany?: BusinessRateModelCreateManyCategoryInputEnvelope
    connect?: Enumerable<BusinessRateModelWhereUniqueInput>
  }

  export type BusinessRateModelUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<BusinessRateModelCreateWithoutCategoryInput>, Enumerable<BusinessRateModelUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<BusinessRateModelCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<BusinessRateModelUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: BusinessRateModelCreateManyCategoryInputEnvelope
    set?: Enumerable<BusinessRateModelWhereUniqueInput>
    disconnect?: Enumerable<BusinessRateModelWhereUniqueInput>
    delete?: Enumerable<BusinessRateModelWhereUniqueInput>
    connect?: Enumerable<BusinessRateModelWhereUniqueInput>
    update?: Enumerable<BusinessRateModelUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<BusinessRateModelUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<BusinessRateModelScalarWhereInput>
  }

  export type BusinessRateModelUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<BusinessRateModelCreateWithoutCategoryInput>, Enumerable<BusinessRateModelUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<BusinessRateModelCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<BusinessRateModelUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: BusinessRateModelCreateManyCategoryInputEnvelope
    set?: Enumerable<BusinessRateModelWhereUniqueInput>
    disconnect?: Enumerable<BusinessRateModelWhereUniqueInput>
    delete?: Enumerable<BusinessRateModelWhereUniqueInput>
    connect?: Enumerable<BusinessRateModelWhereUniqueInput>
    update?: Enumerable<BusinessRateModelUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<BusinessRateModelUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<BusinessRateModelScalarWhereInput>
  }

  export type BusinessUserModelCreateNestedOneWithoutReviewsInput = {
    create?: XOR<BusinessUserModelCreateWithoutReviewsInput, BusinessUserModelUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutReviewsInput
    connect?: BusinessUserModelWhereUniqueInput
  }

  export type CustomerModelCreateNestedOneWithoutReviewsInput = {
    create?: XOR<CustomerModelCreateWithoutReviewsInput, CustomerModelUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutReviewsInput
    connect?: CustomerModelWhereUniqueInput
  }

  export type BusinessUserModelUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<BusinessUserModelCreateWithoutReviewsInput, BusinessUserModelUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutReviewsInput
    upsert?: BusinessUserModelUpsertWithoutReviewsInput
    connect?: BusinessUserModelWhereUniqueInput
    update?: XOR<BusinessUserModelUpdateWithoutReviewsInput, BusinessUserModelUncheckedUpdateWithoutReviewsInput>
  }

  export type CustomerModelUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<CustomerModelCreateWithoutReviewsInput, CustomerModelUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutReviewsInput
    upsert?: CustomerModelUpsertWithoutReviewsInput
    connect?: CustomerModelWhereUniqueInput
    update?: XOR<CustomerModelUpdateWithoutReviewsInput, CustomerModelUncheckedUpdateWithoutReviewsInput>
  }

  export type BoardArticleModelCreateNestedManyWithoutBoardInput = {
    create?: XOR<Enumerable<BoardArticleModelCreateWithoutBoardInput>, Enumerable<BoardArticleModelUncheckedCreateWithoutBoardInput>>
    connectOrCreate?: Enumerable<BoardArticleModelCreateOrConnectWithoutBoardInput>
    createMany?: BoardArticleModelCreateManyBoardInputEnvelope
    connect?: Enumerable<BoardArticleModelWhereUniqueInput>
  }

  export type BoardArticleModelUncheckedCreateNestedManyWithoutBoardInput = {
    create?: XOR<Enumerable<BoardArticleModelCreateWithoutBoardInput>, Enumerable<BoardArticleModelUncheckedCreateWithoutBoardInput>>
    connectOrCreate?: Enumerable<BoardArticleModelCreateOrConnectWithoutBoardInput>
    createMany?: BoardArticleModelCreateManyBoardInputEnvelope
    connect?: Enumerable<BoardArticleModelWhereUniqueInput>
  }

  export type BoardArticleModelUpdateManyWithoutBoardNestedInput = {
    create?: XOR<Enumerable<BoardArticleModelCreateWithoutBoardInput>, Enumerable<BoardArticleModelUncheckedCreateWithoutBoardInput>>
    connectOrCreate?: Enumerable<BoardArticleModelCreateOrConnectWithoutBoardInput>
    upsert?: Enumerable<BoardArticleModelUpsertWithWhereUniqueWithoutBoardInput>
    createMany?: BoardArticleModelCreateManyBoardInputEnvelope
    set?: Enumerable<BoardArticleModelWhereUniqueInput>
    disconnect?: Enumerable<BoardArticleModelWhereUniqueInput>
    delete?: Enumerable<BoardArticleModelWhereUniqueInput>
    connect?: Enumerable<BoardArticleModelWhereUniqueInput>
    update?: Enumerable<BoardArticleModelUpdateWithWhereUniqueWithoutBoardInput>
    updateMany?: Enumerable<BoardArticleModelUpdateManyWithWhereWithoutBoardInput>
    deleteMany?: Enumerable<BoardArticleModelScalarWhereInput>
  }

  export type BoardArticleModelUncheckedUpdateManyWithoutBoardNestedInput = {
    create?: XOR<Enumerable<BoardArticleModelCreateWithoutBoardInput>, Enumerable<BoardArticleModelUncheckedCreateWithoutBoardInput>>
    connectOrCreate?: Enumerable<BoardArticleModelCreateOrConnectWithoutBoardInput>
    upsert?: Enumerable<BoardArticleModelUpsertWithWhereUniqueWithoutBoardInput>
    createMany?: BoardArticleModelCreateManyBoardInputEnvelope
    set?: Enumerable<BoardArticleModelWhereUniqueInput>
    disconnect?: Enumerable<BoardArticleModelWhereUniqueInput>
    delete?: Enumerable<BoardArticleModelWhereUniqueInput>
    connect?: Enumerable<BoardArticleModelWhereUniqueInput>
    update?: Enumerable<BoardArticleModelUpdateWithWhereUniqueWithoutBoardInput>
    updateMany?: Enumerable<BoardArticleModelUpdateManyWithWhereWithoutBoardInput>
    deleteMany?: Enumerable<BoardArticleModelScalarWhereInput>
  }

  export type UserModelCreateNestedOneWithoutBoard_articlesInput = {
    create?: XOR<UserModelCreateWithoutBoard_articlesInput, UserModelUncheckedCreateWithoutBoard_articlesInput>
    connectOrCreate?: UserModelCreateOrConnectWithoutBoard_articlesInput
    connect?: UserModelWhereUniqueInput
  }

  export type BoardModelCreateNestedOneWithoutArticlesInput = {
    create?: XOR<BoardModelCreateWithoutArticlesInput, BoardModelUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: BoardModelCreateOrConnectWithoutArticlesInput
    connect?: BoardModelWhereUniqueInput
  }

  export type BoardArticleContentModelCreateNestedManyWithoutArticleInput = {
    create?: XOR<Enumerable<BoardArticleContentModelCreateWithoutArticleInput>, Enumerable<BoardArticleContentModelUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<BoardArticleContentModelCreateOrConnectWithoutArticleInput>
    createMany?: BoardArticleContentModelCreateManyArticleInputEnvelope
    connect?: Enumerable<BoardArticleContentModelWhereUniqueInput>
  }

  export type BoardCommentModelCreateNestedManyWithoutArticleInput = {
    create?: XOR<Enumerable<BoardCommentModelCreateWithoutArticleInput>, Enumerable<BoardCommentModelUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<BoardCommentModelCreateOrConnectWithoutArticleInput>
    createMany?: BoardCommentModelCreateManyArticleInputEnvelope
    connect?: Enumerable<BoardCommentModelWhereUniqueInput>
  }

  export type BoardArticleContentModelUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<Enumerable<BoardArticleContentModelCreateWithoutArticleInput>, Enumerable<BoardArticleContentModelUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<BoardArticleContentModelCreateOrConnectWithoutArticleInput>
    createMany?: BoardArticleContentModelCreateManyArticleInputEnvelope
    connect?: Enumerable<BoardArticleContentModelWhereUniqueInput>
  }

  export type BoardCommentModelUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<Enumerable<BoardCommentModelCreateWithoutArticleInput>, Enumerable<BoardCommentModelUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<BoardCommentModelCreateOrConnectWithoutArticleInput>
    createMany?: BoardCommentModelCreateManyArticleInputEnvelope
    connect?: Enumerable<BoardCommentModelWhereUniqueInput>
  }

  export type UserModelUpdateOneRequiredWithoutBoard_articlesNestedInput = {
    create?: XOR<UserModelCreateWithoutBoard_articlesInput, UserModelUncheckedCreateWithoutBoard_articlesInput>
    connectOrCreate?: UserModelCreateOrConnectWithoutBoard_articlesInput
    upsert?: UserModelUpsertWithoutBoard_articlesInput
    connect?: UserModelWhereUniqueInput
    update?: XOR<UserModelUpdateWithoutBoard_articlesInput, UserModelUncheckedUpdateWithoutBoard_articlesInput>
  }

  export type BoardModelUpdateOneRequiredWithoutArticlesNestedInput = {
    create?: XOR<BoardModelCreateWithoutArticlesInput, BoardModelUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: BoardModelCreateOrConnectWithoutArticlesInput
    upsert?: BoardModelUpsertWithoutArticlesInput
    connect?: BoardModelWhereUniqueInput
    update?: XOR<BoardModelUpdateWithoutArticlesInput, BoardModelUncheckedUpdateWithoutArticlesInput>
  }

  export type BoardArticleContentModelUpdateManyWithoutArticleNestedInput = {
    create?: XOR<Enumerable<BoardArticleContentModelCreateWithoutArticleInput>, Enumerable<BoardArticleContentModelUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<BoardArticleContentModelCreateOrConnectWithoutArticleInput>
    upsert?: Enumerable<BoardArticleContentModelUpsertWithWhereUniqueWithoutArticleInput>
    createMany?: BoardArticleContentModelCreateManyArticleInputEnvelope
    set?: Enumerable<BoardArticleContentModelWhereUniqueInput>
    disconnect?: Enumerable<BoardArticleContentModelWhereUniqueInput>
    delete?: Enumerable<BoardArticleContentModelWhereUniqueInput>
    connect?: Enumerable<BoardArticleContentModelWhereUniqueInput>
    update?: Enumerable<BoardArticleContentModelUpdateWithWhereUniqueWithoutArticleInput>
    updateMany?: Enumerable<BoardArticleContentModelUpdateManyWithWhereWithoutArticleInput>
    deleteMany?: Enumerable<BoardArticleContentModelScalarWhereInput>
  }

  export type BoardCommentModelUpdateManyWithoutArticleNestedInput = {
    create?: XOR<Enumerable<BoardCommentModelCreateWithoutArticleInput>, Enumerable<BoardCommentModelUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<BoardCommentModelCreateOrConnectWithoutArticleInput>
    upsert?: Enumerable<BoardCommentModelUpsertWithWhereUniqueWithoutArticleInput>
    createMany?: BoardCommentModelCreateManyArticleInputEnvelope
    set?: Enumerable<BoardCommentModelWhereUniqueInput>
    disconnect?: Enumerable<BoardCommentModelWhereUniqueInput>
    delete?: Enumerable<BoardCommentModelWhereUniqueInput>
    connect?: Enumerable<BoardCommentModelWhereUniqueInput>
    update?: Enumerable<BoardCommentModelUpdateWithWhereUniqueWithoutArticleInput>
    updateMany?: Enumerable<BoardCommentModelUpdateManyWithWhereWithoutArticleInput>
    deleteMany?: Enumerable<BoardCommentModelScalarWhereInput>
  }

  export type BoardArticleContentModelUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<Enumerable<BoardArticleContentModelCreateWithoutArticleInput>, Enumerable<BoardArticleContentModelUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<BoardArticleContentModelCreateOrConnectWithoutArticleInput>
    upsert?: Enumerable<BoardArticleContentModelUpsertWithWhereUniqueWithoutArticleInput>
    createMany?: BoardArticleContentModelCreateManyArticleInputEnvelope
    set?: Enumerable<BoardArticleContentModelWhereUniqueInput>
    disconnect?: Enumerable<BoardArticleContentModelWhereUniqueInput>
    delete?: Enumerable<BoardArticleContentModelWhereUniqueInput>
    connect?: Enumerable<BoardArticleContentModelWhereUniqueInput>
    update?: Enumerable<BoardArticleContentModelUpdateWithWhereUniqueWithoutArticleInput>
    updateMany?: Enumerable<BoardArticleContentModelUpdateManyWithWhereWithoutArticleInput>
    deleteMany?: Enumerable<BoardArticleContentModelScalarWhereInput>
  }

  export type BoardCommentModelUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<Enumerable<BoardCommentModelCreateWithoutArticleInput>, Enumerable<BoardCommentModelUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<BoardCommentModelCreateOrConnectWithoutArticleInput>
    upsert?: Enumerable<BoardCommentModelUpsertWithWhereUniqueWithoutArticleInput>
    createMany?: BoardCommentModelCreateManyArticleInputEnvelope
    set?: Enumerable<BoardCommentModelWhereUniqueInput>
    disconnect?: Enumerable<BoardCommentModelWhereUniqueInput>
    delete?: Enumerable<BoardCommentModelWhereUniqueInput>
    connect?: Enumerable<BoardCommentModelWhereUniqueInput>
    update?: Enumerable<BoardCommentModelUpdateWithWhereUniqueWithoutArticleInput>
    updateMany?: Enumerable<BoardCommentModelUpdateManyWithWhereWithoutArticleInput>
    deleteMany?: Enumerable<BoardCommentModelScalarWhereInput>
  }

  export type BoardArticleModelCreateNestedOneWithoutContentsInput = {
    create?: XOR<BoardArticleModelCreateWithoutContentsInput, BoardArticleModelUncheckedCreateWithoutContentsInput>
    connectOrCreate?: BoardArticleModelCreateOrConnectWithoutContentsInput
    connect?: BoardArticleModelWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoardArticleModelUpdateOneRequiredWithoutContentsNestedInput = {
    create?: XOR<BoardArticleModelCreateWithoutContentsInput, BoardArticleModelUncheckedCreateWithoutContentsInput>
    connectOrCreate?: BoardArticleModelCreateOrConnectWithoutContentsInput
    upsert?: BoardArticleModelUpsertWithoutContentsInput
    connect?: BoardArticleModelWhereUniqueInput
    update?: XOR<BoardArticleModelUpdateWithoutContentsInput, BoardArticleModelUncheckedUpdateWithoutContentsInput>
  }

  export type UserModelCreateNestedOneWithoutBoard_commentsInput = {
    create?: XOR<UserModelCreateWithoutBoard_commentsInput, UserModelUncheckedCreateWithoutBoard_commentsInput>
    connectOrCreate?: UserModelCreateOrConnectWithoutBoard_commentsInput
    connect?: UserModelWhereUniqueInput
  }

  export type BoardArticleModelCreateNestedOneWithoutCommentsInput = {
    create?: XOR<BoardArticleModelCreateWithoutCommentsInput, BoardArticleModelUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: BoardArticleModelCreateOrConnectWithoutCommentsInput
    connect?: BoardArticleModelWhereUniqueInput
  }

  export type BoardCommentContentModelCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<BoardCommentContentModelCreateWithoutCommentInput>, Enumerable<BoardCommentContentModelUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<BoardCommentContentModelCreateOrConnectWithoutCommentInput>
    createMany?: BoardCommentContentModelCreateManyCommentInputEnvelope
    connect?: Enumerable<BoardCommentContentModelWhereUniqueInput>
  }

  export type BoardCommentContentModelUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<BoardCommentContentModelCreateWithoutCommentInput>, Enumerable<BoardCommentContentModelUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<BoardCommentContentModelCreateOrConnectWithoutCommentInput>
    createMany?: BoardCommentContentModelCreateManyCommentInputEnvelope
    connect?: Enumerable<BoardCommentContentModelWhereUniqueInput>
  }

  export type UserModelUpdateOneRequiredWithoutBoard_commentsNestedInput = {
    create?: XOR<UserModelCreateWithoutBoard_commentsInput, UserModelUncheckedCreateWithoutBoard_commentsInput>
    connectOrCreate?: UserModelCreateOrConnectWithoutBoard_commentsInput
    upsert?: UserModelUpsertWithoutBoard_commentsInput
    connect?: UserModelWhereUniqueInput
    update?: XOR<UserModelUpdateWithoutBoard_commentsInput, UserModelUncheckedUpdateWithoutBoard_commentsInput>
  }

  export type BoardArticleModelUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<BoardArticleModelCreateWithoutCommentsInput, BoardArticleModelUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: BoardArticleModelCreateOrConnectWithoutCommentsInput
    upsert?: BoardArticleModelUpsertWithoutCommentsInput
    connect?: BoardArticleModelWhereUniqueInput
    update?: XOR<BoardArticleModelUpdateWithoutCommentsInput, BoardArticleModelUncheckedUpdateWithoutCommentsInput>
  }

  export type BoardCommentContentModelUpdateManyWithoutCommentNestedInput = {
    create?: XOR<Enumerable<BoardCommentContentModelCreateWithoutCommentInput>, Enumerable<BoardCommentContentModelUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<BoardCommentContentModelCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<BoardCommentContentModelUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: BoardCommentContentModelCreateManyCommentInputEnvelope
    set?: Enumerable<BoardCommentContentModelWhereUniqueInput>
    disconnect?: Enumerable<BoardCommentContentModelWhereUniqueInput>
    delete?: Enumerable<BoardCommentContentModelWhereUniqueInput>
    connect?: Enumerable<BoardCommentContentModelWhereUniqueInput>
    update?: Enumerable<BoardCommentContentModelUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<BoardCommentContentModelUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<BoardCommentContentModelScalarWhereInput>
  }

  export type BoardCommentContentModelUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<Enumerable<BoardCommentContentModelCreateWithoutCommentInput>, Enumerable<BoardCommentContentModelUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<BoardCommentContentModelCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<BoardCommentContentModelUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: BoardCommentContentModelCreateManyCommentInputEnvelope
    set?: Enumerable<BoardCommentContentModelWhereUniqueInput>
    disconnect?: Enumerable<BoardCommentContentModelWhereUniqueInput>
    delete?: Enumerable<BoardCommentContentModelWhereUniqueInput>
    connect?: Enumerable<BoardCommentContentModelWhereUniqueInput>
    update?: Enumerable<BoardCommentContentModelUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<BoardCommentContentModelUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<BoardCommentContentModelScalarWhereInput>
  }

  export type BoardCommentModelCreateNestedOneWithoutContentsInput = {
    create?: XOR<BoardCommentModelCreateWithoutContentsInput, BoardCommentModelUncheckedCreateWithoutContentsInput>
    connectOrCreate?: BoardCommentModelCreateOrConnectWithoutContentsInput
    connect?: BoardCommentModelWhereUniqueInput
  }

  export type BoardCommentModelUpdateOneRequiredWithoutContentsNestedInput = {
    create?: XOR<BoardCommentModelCreateWithoutContentsInput, BoardCommentModelUncheckedCreateWithoutContentsInput>
    connectOrCreate?: BoardCommentModelCreateOrConnectWithoutContentsInput
    upsert?: BoardCommentModelUpsertWithoutContentsInput
    connect?: BoardCommentModelWhereUniqueInput
    update?: XOR<BoardCommentModelUpdateWithoutContentsInput, BoardCommentModelUncheckedUpdateWithoutContentsInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type BusinessUserModelCreateWithoutAuthenticationsInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    user: UserModelCreateNestedOneWithoutBusiness_userInput
    real_estate_agent?: RealEstateAgentModelCreateNestedOneWithoutBusinessInput
    home_care_company?: HomeCareCompanyModelCreateNestedOneWithoutBusinessInput
    rates?: BusinessRateModelCreateNestedManyWithoutRateeInput
    reviews?: BusinessReviewModelCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelUncheckedCreateWithoutAuthenticationsInput = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    real_estate_agent?: RealEstateAgentModelUncheckedCreateNestedOneWithoutBusinessInput
    home_care_company?: HomeCareCompanyModelUncheckedCreateNestedOneWithoutBusinessInput
    rates?: BusinessRateModelUncheckedCreateNestedManyWithoutRateeInput
    reviews?: BusinessReviewModelUncheckedCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelCreateOrConnectWithoutAuthenticationsInput = {
    where: BusinessUserModelWhereUniqueInput
    create: XOR<BusinessUserModelCreateWithoutAuthenticationsInput, BusinessUserModelUncheckedCreateWithoutAuthenticationsInput>
  }

  export type CustomerModelCreateWithoutAuthenticationsInput = {
    birth?: string | null
    gender?: string | null
    user: UserModelCreateNestedOneWithoutCustomerInput
    rates?: BusinessRateModelCreateNestedManyWithoutRaterInput
    reviews?: BusinessReviewModelCreateNestedManyWithoutReviewerInput
  }

  export type CustomerModelUncheckedCreateWithoutAuthenticationsInput = {
    id: string
    birth?: string | null
    gender?: string | null
    rates?: BusinessRateModelUncheckedCreateNestedManyWithoutRaterInput
    reviews?: BusinessReviewModelUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type CustomerModelCreateOrConnectWithoutAuthenticationsInput = {
    where: CustomerModelWhereUniqueInput
    create: XOR<CustomerModelCreateWithoutAuthenticationsInput, CustomerModelUncheckedCreateWithoutAuthenticationsInput>
  }

  export type BusinessUserModelUpsertWithoutAuthenticationsInput = {
    update: XOR<BusinessUserModelUpdateWithoutAuthenticationsInput, BusinessUserModelUncheckedUpdateWithoutAuthenticationsInput>
    create: XOR<BusinessUserModelCreateWithoutAuthenticationsInput, BusinessUserModelUncheckedCreateWithoutAuthenticationsInput>
  }

  export type BusinessUserModelUpdateWithoutAuthenticationsInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    user?: UserModelUpdateOneRequiredWithoutBusiness_userNestedInput
    real_estate_agent?: RealEstateAgentModelUpdateOneWithoutBusinessNestedInput
    home_care_company?: HomeCareCompanyModelUpdateOneWithoutBusinessNestedInput
    rates?: BusinessRateModelUpdateManyWithoutRateeNestedInput
    reviews?: BusinessReviewModelUpdateManyWithoutRevieweeNestedInput
  }

  export type BusinessUserModelUncheckedUpdateWithoutAuthenticationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    real_estate_agent?: RealEstateAgentModelUncheckedUpdateOneWithoutBusinessNestedInput
    home_care_company?: HomeCareCompanyModelUncheckedUpdateOneWithoutBusinessNestedInput
    rates?: BusinessRateModelUncheckedUpdateManyWithoutRateeNestedInput
    reviews?: BusinessReviewModelUncheckedUpdateManyWithoutRevieweeNestedInput
  }

  export type CustomerModelUpsertWithoutAuthenticationsInput = {
    update: XOR<CustomerModelUpdateWithoutAuthenticationsInput, CustomerModelUncheckedUpdateWithoutAuthenticationsInput>
    create: XOR<CustomerModelCreateWithoutAuthenticationsInput, CustomerModelUncheckedCreateWithoutAuthenticationsInput>
  }

  export type CustomerModelUpdateWithoutAuthenticationsInput = {
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserModelUpdateOneRequiredWithoutCustomerNestedInput
    rates?: BusinessRateModelUpdateManyWithoutRaterNestedInput
    reviews?: BusinessReviewModelUpdateManyWithoutReviewerNestedInput
  }

  export type CustomerModelUncheckedUpdateWithoutAuthenticationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    rates?: BusinessRateModelUncheckedUpdateManyWithoutRaterNestedInput
    reviews?: BusinessReviewModelUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type CustomerModelCreateWithoutUserInput = {
    birth?: string | null
    gender?: string | null
    authentications?: AuthenticationModelCreateNestedManyWithoutCustomerInput
    rates?: BusinessRateModelCreateNestedManyWithoutRaterInput
    reviews?: BusinessReviewModelCreateNestedManyWithoutReviewerInput
  }

  export type CustomerModelUncheckedCreateWithoutUserInput = {
    birth?: string | null
    gender?: string | null
    authentications?: AuthenticationModelUncheckedCreateNestedManyWithoutCustomerInput
    rates?: BusinessRateModelUncheckedCreateNestedManyWithoutRaterInput
    reviews?: BusinessReviewModelUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type CustomerModelCreateOrConnectWithoutUserInput = {
    where: CustomerModelWhereUniqueInput
    create: XOR<CustomerModelCreateWithoutUserInput, CustomerModelUncheckedCreateWithoutUserInput>
  }

  export type BusinessUserModelCreateWithoutUserInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    authentications?: AuthenticationModelCreateNestedManyWithoutBusiness_userInput
    real_estate_agent?: RealEstateAgentModelCreateNestedOneWithoutBusinessInput
    home_care_company?: HomeCareCompanyModelCreateNestedOneWithoutBusinessInput
    rates?: BusinessRateModelCreateNestedManyWithoutRateeInput
    reviews?: BusinessReviewModelCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelUncheckedCreateWithoutUserInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    authentications?: AuthenticationModelUncheckedCreateNestedManyWithoutBusiness_userInput
    real_estate_agent?: RealEstateAgentModelUncheckedCreateNestedOneWithoutBusinessInput
    home_care_company?: HomeCareCompanyModelUncheckedCreateNestedOneWithoutBusinessInput
    rates?: BusinessRateModelUncheckedCreateNestedManyWithoutRateeInput
    reviews?: BusinessReviewModelUncheckedCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelCreateOrConnectWithoutUserInput = {
    where: BusinessUserModelWhereUniqueInput
    create: XOR<BusinessUserModelCreateWithoutUserInput, BusinessUserModelUncheckedCreateWithoutUserInput>
  }

  export type BoardArticleModelCreateWithoutAuthorInput = {
    id: string
    title: string
    board: BoardModelCreateNestedOneWithoutArticlesInput
    contents?: BoardArticleContentModelCreateNestedManyWithoutArticleInput
    comments?: BoardCommentModelCreateNestedManyWithoutArticleInput
  }

  export type BoardArticleModelUncheckedCreateWithoutAuthorInput = {
    id: string
    title: string
    board_id: string
    contents?: BoardArticleContentModelUncheckedCreateNestedManyWithoutArticleInput
    comments?: BoardCommentModelUncheckedCreateNestedManyWithoutArticleInput
  }

  export type BoardArticleModelCreateOrConnectWithoutAuthorInput = {
    where: BoardArticleModelWhereUniqueInput
    create: XOR<BoardArticleModelCreateWithoutAuthorInput, BoardArticleModelUncheckedCreateWithoutAuthorInput>
  }

  export type BoardArticleModelCreateManyAuthorInputEnvelope = {
    data: Enumerable<BoardArticleModelCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type BoardCommentModelCreateWithoutAuthorInput = {
    id: string
    article: BoardArticleModelCreateNestedOneWithoutCommentsInput
    contents?: BoardCommentContentModelCreateNestedManyWithoutCommentInput
  }

  export type BoardCommentModelUncheckedCreateWithoutAuthorInput = {
    id: string
    article_id: string
    contents?: BoardCommentContentModelUncheckedCreateNestedManyWithoutCommentInput
  }

  export type BoardCommentModelCreateOrConnectWithoutAuthorInput = {
    where: BoardCommentModelWhereUniqueInput
    create: XOR<BoardCommentModelCreateWithoutAuthorInput, BoardCommentModelUncheckedCreateWithoutAuthorInput>
  }

  export type BoardCommentModelCreateManyAuthorInputEnvelope = {
    data: Enumerable<BoardCommentModelCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type CustomerModelUpsertWithoutUserInput = {
    update: XOR<CustomerModelUpdateWithoutUserInput, CustomerModelUncheckedUpdateWithoutUserInput>
    create: XOR<CustomerModelCreateWithoutUserInput, CustomerModelUncheckedCreateWithoutUserInput>
  }

  export type CustomerModelUpdateWithoutUserInput = {
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    authentications?: AuthenticationModelUpdateManyWithoutCustomerNestedInput
    rates?: BusinessRateModelUpdateManyWithoutRaterNestedInput
    reviews?: BusinessReviewModelUpdateManyWithoutReviewerNestedInput
  }

  export type CustomerModelUncheckedUpdateWithoutUserInput = {
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    authentications?: AuthenticationModelUncheckedUpdateManyWithoutCustomerNestedInput
    rates?: BusinessRateModelUncheckedUpdateManyWithoutRaterNestedInput
    reviews?: BusinessReviewModelUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type BusinessUserModelUpsertWithoutUserInput = {
    update: XOR<BusinessUserModelUpdateWithoutUserInput, BusinessUserModelUncheckedUpdateWithoutUserInput>
    create: XOR<BusinessUserModelCreateWithoutUserInput, BusinessUserModelUncheckedCreateWithoutUserInput>
  }

  export type BusinessUserModelUpdateWithoutUserInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    authentications?: AuthenticationModelUpdateManyWithoutBusiness_userNestedInput
    real_estate_agent?: RealEstateAgentModelUpdateOneWithoutBusinessNestedInput
    home_care_company?: HomeCareCompanyModelUpdateOneWithoutBusinessNestedInput
    rates?: BusinessRateModelUpdateManyWithoutRateeNestedInput
    reviews?: BusinessReviewModelUpdateManyWithoutRevieweeNestedInput
  }

  export type BusinessUserModelUncheckedUpdateWithoutUserInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    authentications?: AuthenticationModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    real_estate_agent?: RealEstateAgentModelUncheckedUpdateOneWithoutBusinessNestedInput
    home_care_company?: HomeCareCompanyModelUncheckedUpdateOneWithoutBusinessNestedInput
    rates?: BusinessRateModelUncheckedUpdateManyWithoutRateeNestedInput
    reviews?: BusinessReviewModelUncheckedUpdateManyWithoutRevieweeNestedInput
  }

  export type BoardArticleModelUpsertWithWhereUniqueWithoutAuthorInput = {
    where: BoardArticleModelWhereUniqueInput
    update: XOR<BoardArticleModelUpdateWithoutAuthorInput, BoardArticleModelUncheckedUpdateWithoutAuthorInput>
    create: XOR<BoardArticleModelCreateWithoutAuthorInput, BoardArticleModelUncheckedCreateWithoutAuthorInput>
  }

  export type BoardArticleModelUpdateWithWhereUniqueWithoutAuthorInput = {
    where: BoardArticleModelWhereUniqueInput
    data: XOR<BoardArticleModelUpdateWithoutAuthorInput, BoardArticleModelUncheckedUpdateWithoutAuthorInput>
  }

  export type BoardArticleModelUpdateManyWithWhereWithoutAuthorInput = {
    where: BoardArticleModelScalarWhereInput
    data: XOR<BoardArticleModelUpdateManyMutationInput, BoardArticleModelUncheckedUpdateManyWithoutBoard_articlesInput>
  }

  export type BoardArticleModelScalarWhereInput = {
    AND?: Enumerable<BoardArticleModelScalarWhereInput>
    OR?: Enumerable<BoardArticleModelScalarWhereInput>
    NOT?: Enumerable<BoardArticleModelScalarWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    author_id?: StringFilter | string
    board_id?: StringFilter | string
  }

  export type BoardCommentModelUpsertWithWhereUniqueWithoutAuthorInput = {
    where: BoardCommentModelWhereUniqueInput
    update: XOR<BoardCommentModelUpdateWithoutAuthorInput, BoardCommentModelUncheckedUpdateWithoutAuthorInput>
    create: XOR<BoardCommentModelCreateWithoutAuthorInput, BoardCommentModelUncheckedCreateWithoutAuthorInput>
  }

  export type BoardCommentModelUpdateWithWhereUniqueWithoutAuthorInput = {
    where: BoardCommentModelWhereUniqueInput
    data: XOR<BoardCommentModelUpdateWithoutAuthorInput, BoardCommentModelUncheckedUpdateWithoutAuthorInput>
  }

  export type BoardCommentModelUpdateManyWithWhereWithoutAuthorInput = {
    where: BoardCommentModelScalarWhereInput
    data: XOR<BoardCommentModelUpdateManyMutationInput, BoardCommentModelUncheckedUpdateManyWithoutBoard_commentsInput>
  }

  export type BoardCommentModelScalarWhereInput = {
    AND?: Enumerable<BoardCommentModelScalarWhereInput>
    OR?: Enumerable<BoardCommentModelScalarWhereInput>
    NOT?: Enumerable<BoardCommentModelScalarWhereInput>
    id?: StringFilter | string
    author_id?: StringFilter | string
    article_id?: StringFilter | string
  }

  export type UserModelCreateWithoutCustomerInput = {
    id: string
    name: string
    email?: string | null
    email_verified: boolean
    phone?: string | null
    phone_verified: boolean
    address_first?: string | null
    address_second?: string | null
    profile_image?: string | null
    business_user?: BusinessUserModelCreateNestedOneWithoutUserInput
    board_articles?: BoardArticleModelCreateNestedManyWithoutAuthorInput
    board_comments?: BoardCommentModelCreateNestedManyWithoutAuthorInput
  }

  export type UserModelUncheckedCreateWithoutCustomerInput = {
    id: string
    name: string
    email?: string | null
    email_verified: boolean
    phone?: string | null
    phone_verified: boolean
    address_first?: string | null
    address_second?: string | null
    profile_image?: string | null
    business_user?: BusinessUserModelUncheckedCreateNestedOneWithoutUserInput
    board_articles?: BoardArticleModelUncheckedCreateNestedManyWithoutAuthorInput
    board_comments?: BoardCommentModelUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserModelCreateOrConnectWithoutCustomerInput = {
    where: UserModelWhereUniqueInput
    create: XOR<UserModelCreateWithoutCustomerInput, UserModelUncheckedCreateWithoutCustomerInput>
  }

  export type AuthenticationModelCreateWithoutCustomerInput = {
    id: string
    oauth_sub: string
    oauth_type: string
    business_user?: BusinessUserModelCreateNestedOneWithoutAuthenticationsInput
  }

  export type AuthenticationModelUncheckedCreateWithoutCustomerInput = {
    id: string
    oauth_sub: string
    oauth_type: string
    business_user_id?: string | null
  }

  export type AuthenticationModelCreateOrConnectWithoutCustomerInput = {
    where: AuthenticationModelWhereUniqueInput
    create: XOR<AuthenticationModelCreateWithoutCustomerInput, AuthenticationModelUncheckedCreateWithoutCustomerInput>
  }

  export type AuthenticationModelCreateManyCustomerInputEnvelope = {
    data: Enumerable<AuthenticationModelCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type BusinessRateModelCreateWithoutRaterInput = {
    id: string
    rate: number
    ratee: BusinessUserModelCreateNestedOneWithoutRatesInput
    category: BusinessRateCategoryModelCreateNestedOneWithoutRatesInput
  }

  export type BusinessRateModelUncheckedCreateWithoutRaterInput = {
    id: string
    category_id: string
    ratee_id: string
    rate: number
  }

  export type BusinessRateModelCreateOrConnectWithoutRaterInput = {
    where: BusinessRateModelWhereUniqueInput
    create: XOR<BusinessRateModelCreateWithoutRaterInput, BusinessRateModelUncheckedCreateWithoutRaterInput>
  }

  export type BusinessRateModelCreateManyRaterInputEnvelope = {
    data: Enumerable<BusinessRateModelCreateManyRaterInput>
    skipDuplicates?: boolean
  }

  export type BusinessReviewModelCreateWithoutReviewerInput = {
    id: string
    review: string
    reviewee: BusinessUserModelCreateNestedOneWithoutReviewsInput
  }

  export type BusinessReviewModelUncheckedCreateWithoutReviewerInput = {
    id: string
    reviewee_id: string
    review: string
  }

  export type BusinessReviewModelCreateOrConnectWithoutReviewerInput = {
    where: BusinessReviewModelWhereUniqueInput
    create: XOR<BusinessReviewModelCreateWithoutReviewerInput, BusinessReviewModelUncheckedCreateWithoutReviewerInput>
  }

  export type BusinessReviewModelCreateManyReviewerInputEnvelope = {
    data: Enumerable<BusinessReviewModelCreateManyReviewerInput>
    skipDuplicates?: boolean
  }

  export type UserModelUpsertWithoutCustomerInput = {
    update: XOR<UserModelUpdateWithoutCustomerInput, UserModelUncheckedUpdateWithoutCustomerInput>
    create: XOR<UserModelCreateWithoutCustomerInput, UserModelUncheckedCreateWithoutCustomerInput>
  }

  export type UserModelUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    business_user?: BusinessUserModelUpdateOneWithoutUserNestedInput
    board_articles?: BoardArticleModelUpdateManyWithoutAuthorNestedInput
    board_comments?: BoardCommentModelUpdateManyWithoutAuthorNestedInput
  }

  export type UserModelUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    business_user?: BusinessUserModelUncheckedUpdateOneWithoutUserNestedInput
    board_articles?: BoardArticleModelUncheckedUpdateManyWithoutAuthorNestedInput
    board_comments?: BoardCommentModelUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type AuthenticationModelUpsertWithWhereUniqueWithoutCustomerInput = {
    where: AuthenticationModelWhereUniqueInput
    update: XOR<AuthenticationModelUpdateWithoutCustomerInput, AuthenticationModelUncheckedUpdateWithoutCustomerInput>
    create: XOR<AuthenticationModelCreateWithoutCustomerInput, AuthenticationModelUncheckedCreateWithoutCustomerInput>
  }

  export type AuthenticationModelUpdateWithWhereUniqueWithoutCustomerInput = {
    where: AuthenticationModelWhereUniqueInput
    data: XOR<AuthenticationModelUpdateWithoutCustomerInput, AuthenticationModelUncheckedUpdateWithoutCustomerInput>
  }

  export type AuthenticationModelUpdateManyWithWhereWithoutCustomerInput = {
    where: AuthenticationModelScalarWhereInput
    data: XOR<AuthenticationModelUpdateManyMutationInput, AuthenticationModelUncheckedUpdateManyWithoutAuthenticationsInput>
  }

  export type AuthenticationModelScalarWhereInput = {
    AND?: Enumerable<AuthenticationModelScalarWhereInput>
    OR?: Enumerable<AuthenticationModelScalarWhereInput>
    NOT?: Enumerable<AuthenticationModelScalarWhereInput>
    id?: StringFilter | string
    oauth_sub?: StringFilter | string
    oauth_type?: StringFilter | string
    business_user_id?: StringNullableFilter | string | null
    customer_id?: StringNullableFilter | string | null
  }

  export type BusinessRateModelUpsertWithWhereUniqueWithoutRaterInput = {
    where: BusinessRateModelWhereUniqueInput
    update: XOR<BusinessRateModelUpdateWithoutRaterInput, BusinessRateModelUncheckedUpdateWithoutRaterInput>
    create: XOR<BusinessRateModelCreateWithoutRaterInput, BusinessRateModelUncheckedCreateWithoutRaterInput>
  }

  export type BusinessRateModelUpdateWithWhereUniqueWithoutRaterInput = {
    where: BusinessRateModelWhereUniqueInput
    data: XOR<BusinessRateModelUpdateWithoutRaterInput, BusinessRateModelUncheckedUpdateWithoutRaterInput>
  }

  export type BusinessRateModelUpdateManyWithWhereWithoutRaterInput = {
    where: BusinessRateModelScalarWhereInput
    data: XOR<BusinessRateModelUpdateManyMutationInput, BusinessRateModelUncheckedUpdateManyWithoutRatesInput>
  }

  export type BusinessRateModelScalarWhereInput = {
    AND?: Enumerable<BusinessRateModelScalarWhereInput>
    OR?: Enumerable<BusinessRateModelScalarWhereInput>
    NOT?: Enumerable<BusinessRateModelScalarWhereInput>
    id?: StringFilter | string
    category_id?: StringFilter | string
    ratee_id?: StringFilter | string
    rater_id?: StringFilter | string
    rate?: IntFilter | number
  }

  export type BusinessReviewModelUpsertWithWhereUniqueWithoutReviewerInput = {
    where: BusinessReviewModelWhereUniqueInput
    update: XOR<BusinessReviewModelUpdateWithoutReviewerInput, BusinessReviewModelUncheckedUpdateWithoutReviewerInput>
    create: XOR<BusinessReviewModelCreateWithoutReviewerInput, BusinessReviewModelUncheckedCreateWithoutReviewerInput>
  }

  export type BusinessReviewModelUpdateWithWhereUniqueWithoutReviewerInput = {
    where: BusinessReviewModelWhereUniqueInput
    data: XOR<BusinessReviewModelUpdateWithoutReviewerInput, BusinessReviewModelUncheckedUpdateWithoutReviewerInput>
  }

  export type BusinessReviewModelUpdateManyWithWhereWithoutReviewerInput = {
    where: BusinessReviewModelScalarWhereInput
    data: XOR<BusinessReviewModelUpdateManyMutationInput, BusinessReviewModelUncheckedUpdateManyWithoutReviewsInput>
  }

  export type BusinessReviewModelScalarWhereInput = {
    AND?: Enumerable<BusinessReviewModelScalarWhereInput>
    OR?: Enumerable<BusinessReviewModelScalarWhereInput>
    NOT?: Enumerable<BusinessReviewModelScalarWhereInput>
    id?: StringFilter | string
    reviewee_id?: StringFilter | string
    reviewer_id?: StringFilter | string
    review?: StringFilter | string
  }

  export type UserModelCreateWithoutBusiness_userInput = {
    id: string
    name: string
    email?: string | null
    email_verified: boolean
    phone?: string | null
    phone_verified: boolean
    address_first?: string | null
    address_second?: string | null
    profile_image?: string | null
    customer?: CustomerModelCreateNestedOneWithoutUserInput
    board_articles?: BoardArticleModelCreateNestedManyWithoutAuthorInput
    board_comments?: BoardCommentModelCreateNestedManyWithoutAuthorInput
  }

  export type UserModelUncheckedCreateWithoutBusiness_userInput = {
    id: string
    name: string
    email?: string | null
    email_verified: boolean
    phone?: string | null
    phone_verified: boolean
    address_first?: string | null
    address_second?: string | null
    profile_image?: string | null
    customer?: CustomerModelUncheckedCreateNestedOneWithoutUserInput
    board_articles?: BoardArticleModelUncheckedCreateNestedManyWithoutAuthorInput
    board_comments?: BoardCommentModelUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserModelCreateOrConnectWithoutBusiness_userInput = {
    where: UserModelWhereUniqueInput
    create: XOR<UserModelCreateWithoutBusiness_userInput, UserModelUncheckedCreateWithoutBusiness_userInput>
  }

  export type AuthenticationModelCreateWithoutBusiness_userInput = {
    id: string
    oauth_sub: string
    oauth_type: string
    customer?: CustomerModelCreateNestedOneWithoutAuthenticationsInput
  }

  export type AuthenticationModelUncheckedCreateWithoutBusiness_userInput = {
    id: string
    oauth_sub: string
    oauth_type: string
    customer_id?: string | null
  }

  export type AuthenticationModelCreateOrConnectWithoutBusiness_userInput = {
    where: AuthenticationModelWhereUniqueInput
    create: XOR<AuthenticationModelCreateWithoutBusiness_userInput, AuthenticationModelUncheckedCreateWithoutBusiness_userInput>
  }

  export type AuthenticationModelCreateManyBusiness_userInputEnvelope = {
    data: Enumerable<AuthenticationModelCreateManyBusiness_userInput>
    skipDuplicates?: boolean
  }

  export type RealEstateAgentModelCreateWithoutBusinessInput = {
    is_licensed: boolean
    real_estate_num: string
    real_estate_name: string
    real_estate_phone: string
    licensed_agent_name: string
    specialized_field?: RealEstateSpecializedSubFieldModelCreateNestedOneWithoutReal_estate_agentsInput
    properties?: RealEstatePropertyModelCreateNestedManyWithoutAgentInput
  }

  export type RealEstateAgentModelUncheckedCreateWithoutBusinessInput = {
    is_licensed: boolean
    real_estate_num: string
    real_estate_name: string
    real_estate_phone: string
    licensed_agent_name: string
    specialized_field_id?: string | null
    properties?: RealEstatePropertyModelUncheckedCreateNestedManyWithoutAgentInput
  }

  export type RealEstateAgentModelCreateOrConnectWithoutBusinessInput = {
    where: RealEstateAgentModelWhereUniqueInput
    create: XOR<RealEstateAgentModelCreateWithoutBusinessInput, RealEstateAgentModelUncheckedCreateWithoutBusinessInput>
  }

  export type HomeCareCompanyModelCreateWithoutBusinessInput = {
    business_registration_num: string
    specialized_field?: HomeCareSpecializedSubFieldModelCreateNestedOneWithoutHome_care_companiesInput
    introduction_images?: HomeCareIntroductionImageModelCreateNestedManyWithoutCompanyInput
  }

  export type HomeCareCompanyModelUncheckedCreateWithoutBusinessInput = {
    business_registration_num: string
    specialized_field_id?: string | null
    introduction_images?: HomeCareIntroductionImageModelUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type HomeCareCompanyModelCreateOrConnectWithoutBusinessInput = {
    where: HomeCareCompanyModelWhereUniqueInput
    create: XOR<HomeCareCompanyModelCreateWithoutBusinessInput, HomeCareCompanyModelUncheckedCreateWithoutBusinessInput>
  }

  export type BusinessRateModelCreateWithoutRateeInput = {
    id: string
    rate: number
    rater: CustomerModelCreateNestedOneWithoutRatesInput
    category: BusinessRateCategoryModelCreateNestedOneWithoutRatesInput
  }

  export type BusinessRateModelUncheckedCreateWithoutRateeInput = {
    id: string
    category_id: string
    rater_id: string
    rate: number
  }

  export type BusinessRateModelCreateOrConnectWithoutRateeInput = {
    where: BusinessRateModelWhereUniqueInput
    create: XOR<BusinessRateModelCreateWithoutRateeInput, BusinessRateModelUncheckedCreateWithoutRateeInput>
  }

  export type BusinessRateModelCreateManyRateeInputEnvelope = {
    data: Enumerable<BusinessRateModelCreateManyRateeInput>
    skipDuplicates?: boolean
  }

  export type BusinessReviewModelCreateWithoutRevieweeInput = {
    id: string
    review: string
    reviewer: CustomerModelCreateNestedOneWithoutReviewsInput
  }

  export type BusinessReviewModelUncheckedCreateWithoutRevieweeInput = {
    id: string
    reviewer_id: string
    review: string
  }

  export type BusinessReviewModelCreateOrConnectWithoutRevieweeInput = {
    where: BusinessReviewModelWhereUniqueInput
    create: XOR<BusinessReviewModelCreateWithoutRevieweeInput, BusinessReviewModelUncheckedCreateWithoutRevieweeInput>
  }

  export type BusinessReviewModelCreateManyRevieweeInputEnvelope = {
    data: Enumerable<BusinessReviewModelCreateManyRevieweeInput>
    skipDuplicates?: boolean
  }

  export type UserModelUpsertWithoutBusiness_userInput = {
    update: XOR<UserModelUpdateWithoutBusiness_userInput, UserModelUncheckedUpdateWithoutBusiness_userInput>
    create: XOR<UserModelCreateWithoutBusiness_userInput, UserModelUncheckedCreateWithoutBusiness_userInput>
  }

  export type UserModelUpdateWithoutBusiness_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerModelUpdateOneWithoutUserNestedInput
    board_articles?: BoardArticleModelUpdateManyWithoutAuthorNestedInput
    board_comments?: BoardCommentModelUpdateManyWithoutAuthorNestedInput
  }

  export type UserModelUncheckedUpdateWithoutBusiness_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerModelUncheckedUpdateOneWithoutUserNestedInput
    board_articles?: BoardArticleModelUncheckedUpdateManyWithoutAuthorNestedInput
    board_comments?: BoardCommentModelUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type AuthenticationModelUpsertWithWhereUniqueWithoutBusiness_userInput = {
    where: AuthenticationModelWhereUniqueInput
    update: XOR<AuthenticationModelUpdateWithoutBusiness_userInput, AuthenticationModelUncheckedUpdateWithoutBusiness_userInput>
    create: XOR<AuthenticationModelCreateWithoutBusiness_userInput, AuthenticationModelUncheckedCreateWithoutBusiness_userInput>
  }

  export type AuthenticationModelUpdateWithWhereUniqueWithoutBusiness_userInput = {
    where: AuthenticationModelWhereUniqueInput
    data: XOR<AuthenticationModelUpdateWithoutBusiness_userInput, AuthenticationModelUncheckedUpdateWithoutBusiness_userInput>
  }

  export type AuthenticationModelUpdateManyWithWhereWithoutBusiness_userInput = {
    where: AuthenticationModelScalarWhereInput
    data: XOR<AuthenticationModelUpdateManyMutationInput, AuthenticationModelUncheckedUpdateManyWithoutAuthenticationsInput>
  }

  export type RealEstateAgentModelUpsertWithoutBusinessInput = {
    update: XOR<RealEstateAgentModelUpdateWithoutBusinessInput, RealEstateAgentModelUncheckedUpdateWithoutBusinessInput>
    create: XOR<RealEstateAgentModelCreateWithoutBusinessInput, RealEstateAgentModelUncheckedCreateWithoutBusinessInput>
  }

  export type RealEstateAgentModelUpdateWithoutBusinessInput = {
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    real_estate_num?: StringFieldUpdateOperationsInput | string
    real_estate_name?: StringFieldUpdateOperationsInput | string
    real_estate_phone?: StringFieldUpdateOperationsInput | string
    licensed_agent_name?: StringFieldUpdateOperationsInput | string
    specialized_field?: RealEstateSpecializedSubFieldModelUpdateOneWithoutReal_estate_agentsNestedInput
    properties?: RealEstatePropertyModelUpdateManyWithoutAgentNestedInput
  }

  export type RealEstateAgentModelUncheckedUpdateWithoutBusinessInput = {
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    real_estate_num?: StringFieldUpdateOperationsInput | string
    real_estate_name?: StringFieldUpdateOperationsInput | string
    real_estate_phone?: StringFieldUpdateOperationsInput | string
    licensed_agent_name?: StringFieldUpdateOperationsInput | string
    specialized_field_id?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: RealEstatePropertyModelUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type HomeCareCompanyModelUpsertWithoutBusinessInput = {
    update: XOR<HomeCareCompanyModelUpdateWithoutBusinessInput, HomeCareCompanyModelUncheckedUpdateWithoutBusinessInput>
    create: XOR<HomeCareCompanyModelCreateWithoutBusinessInput, HomeCareCompanyModelUncheckedCreateWithoutBusinessInput>
  }

  export type HomeCareCompanyModelUpdateWithoutBusinessInput = {
    business_registration_num?: StringFieldUpdateOperationsInput | string
    specialized_field?: HomeCareSpecializedSubFieldModelUpdateOneWithoutHome_care_companiesNestedInput
    introduction_images?: HomeCareIntroductionImageModelUpdateManyWithoutCompanyNestedInput
  }

  export type HomeCareCompanyModelUncheckedUpdateWithoutBusinessInput = {
    business_registration_num?: StringFieldUpdateOperationsInput | string
    specialized_field_id?: NullableStringFieldUpdateOperationsInput | string | null
    introduction_images?: HomeCareIntroductionImageModelUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type BusinessRateModelUpsertWithWhereUniqueWithoutRateeInput = {
    where: BusinessRateModelWhereUniqueInput
    update: XOR<BusinessRateModelUpdateWithoutRateeInput, BusinessRateModelUncheckedUpdateWithoutRateeInput>
    create: XOR<BusinessRateModelCreateWithoutRateeInput, BusinessRateModelUncheckedCreateWithoutRateeInput>
  }

  export type BusinessRateModelUpdateWithWhereUniqueWithoutRateeInput = {
    where: BusinessRateModelWhereUniqueInput
    data: XOR<BusinessRateModelUpdateWithoutRateeInput, BusinessRateModelUncheckedUpdateWithoutRateeInput>
  }

  export type BusinessRateModelUpdateManyWithWhereWithoutRateeInput = {
    where: BusinessRateModelScalarWhereInput
    data: XOR<BusinessRateModelUpdateManyMutationInput, BusinessRateModelUncheckedUpdateManyWithoutRatesInput>
  }

  export type BusinessReviewModelUpsertWithWhereUniqueWithoutRevieweeInput = {
    where: BusinessReviewModelWhereUniqueInput
    update: XOR<BusinessReviewModelUpdateWithoutRevieweeInput, BusinessReviewModelUncheckedUpdateWithoutRevieweeInput>
    create: XOR<BusinessReviewModelCreateWithoutRevieweeInput, BusinessReviewModelUncheckedCreateWithoutRevieweeInput>
  }

  export type BusinessReviewModelUpdateWithWhereUniqueWithoutRevieweeInput = {
    where: BusinessReviewModelWhereUniqueInput
    data: XOR<BusinessReviewModelUpdateWithoutRevieweeInput, BusinessReviewModelUncheckedUpdateWithoutRevieweeInput>
  }

  export type BusinessReviewModelUpdateManyWithWhereWithoutRevieweeInput = {
    where: BusinessReviewModelScalarWhereInput
    data: XOR<BusinessReviewModelUpdateManyMutationInput, BusinessReviewModelUncheckedUpdateManyWithoutReviewsInput>
  }

  export type BusinessUserModelCreateWithoutReal_estate_agentInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    user: UserModelCreateNestedOneWithoutBusiness_userInput
    authentications?: AuthenticationModelCreateNestedManyWithoutBusiness_userInput
    home_care_company?: HomeCareCompanyModelCreateNestedOneWithoutBusinessInput
    rates?: BusinessRateModelCreateNestedManyWithoutRateeInput
    reviews?: BusinessReviewModelCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelUncheckedCreateWithoutReal_estate_agentInput = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    authentications?: AuthenticationModelUncheckedCreateNestedManyWithoutBusiness_userInput
    home_care_company?: HomeCareCompanyModelUncheckedCreateNestedOneWithoutBusinessInput
    rates?: BusinessRateModelUncheckedCreateNestedManyWithoutRateeInput
    reviews?: BusinessReviewModelUncheckedCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelCreateOrConnectWithoutReal_estate_agentInput = {
    where: BusinessUserModelWhereUniqueInput
    create: XOR<BusinessUserModelCreateWithoutReal_estate_agentInput, BusinessUserModelUncheckedCreateWithoutReal_estate_agentInput>
  }

  export type RealEstateSpecializedSubFieldModelCreateWithoutReal_estate_agentsInput = {
    id: string
    name: string
    super: RealEstateSpecializedSuperFieldModelCreateNestedOneWithoutSubInput
  }

  export type RealEstateSpecializedSubFieldModelUncheckedCreateWithoutReal_estate_agentsInput = {
    id: string
    name: string
    super_id: string
  }

  export type RealEstateSpecializedSubFieldModelCreateOrConnectWithoutReal_estate_agentsInput = {
    where: RealEstateSpecializedSubFieldModelWhereUniqueInput
    create: XOR<RealEstateSpecializedSubFieldModelCreateWithoutReal_estate_agentsInput, RealEstateSpecializedSubFieldModelUncheckedCreateWithoutReal_estate_agentsInput>
  }

  export type RealEstatePropertyModelCreateWithoutAgentInput = {
    id: string
    name: string
    main_image_url: string
  }

  export type RealEstatePropertyModelUncheckedCreateWithoutAgentInput = {
    id: string
    name: string
    main_image_url: string
  }

  export type RealEstatePropertyModelCreateOrConnectWithoutAgentInput = {
    where: RealEstatePropertyModelWhereUniqueInput
    create: XOR<RealEstatePropertyModelCreateWithoutAgentInput, RealEstatePropertyModelUncheckedCreateWithoutAgentInput>
  }

  export type RealEstatePropertyModelCreateManyAgentInputEnvelope = {
    data: Enumerable<RealEstatePropertyModelCreateManyAgentInput>
    skipDuplicates?: boolean
  }

  export type BusinessUserModelUpsertWithoutReal_estate_agentInput = {
    update: XOR<BusinessUserModelUpdateWithoutReal_estate_agentInput, BusinessUserModelUncheckedUpdateWithoutReal_estate_agentInput>
    create: XOR<BusinessUserModelCreateWithoutReal_estate_agentInput, BusinessUserModelUncheckedCreateWithoutReal_estate_agentInput>
  }

  export type BusinessUserModelUpdateWithoutReal_estate_agentInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    user?: UserModelUpdateOneRequiredWithoutBusiness_userNestedInput
    authentications?: AuthenticationModelUpdateManyWithoutBusiness_userNestedInput
    home_care_company?: HomeCareCompanyModelUpdateOneWithoutBusinessNestedInput
    rates?: BusinessRateModelUpdateManyWithoutRateeNestedInput
    reviews?: BusinessReviewModelUpdateManyWithoutRevieweeNestedInput
  }

  export type BusinessUserModelUncheckedUpdateWithoutReal_estate_agentInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    authentications?: AuthenticationModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    home_care_company?: HomeCareCompanyModelUncheckedUpdateOneWithoutBusinessNestedInput
    rates?: BusinessRateModelUncheckedUpdateManyWithoutRateeNestedInput
    reviews?: BusinessReviewModelUncheckedUpdateManyWithoutRevieweeNestedInput
  }

  export type RealEstateSpecializedSubFieldModelUpsertWithoutReal_estate_agentsInput = {
    update: XOR<RealEstateSpecializedSubFieldModelUpdateWithoutReal_estate_agentsInput, RealEstateSpecializedSubFieldModelUncheckedUpdateWithoutReal_estate_agentsInput>
    create: XOR<RealEstateSpecializedSubFieldModelCreateWithoutReal_estate_agentsInput, RealEstateSpecializedSubFieldModelUncheckedCreateWithoutReal_estate_agentsInput>
  }

  export type RealEstateSpecializedSubFieldModelUpdateWithoutReal_estate_agentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    super?: RealEstateSpecializedSuperFieldModelUpdateOneRequiredWithoutSubNestedInput
  }

  export type RealEstateSpecializedSubFieldModelUncheckedUpdateWithoutReal_estate_agentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    super_id?: StringFieldUpdateOperationsInput | string
  }

  export type RealEstatePropertyModelUpsertWithWhereUniqueWithoutAgentInput = {
    where: RealEstatePropertyModelWhereUniqueInput
    update: XOR<RealEstatePropertyModelUpdateWithoutAgentInput, RealEstatePropertyModelUncheckedUpdateWithoutAgentInput>
    create: XOR<RealEstatePropertyModelCreateWithoutAgentInput, RealEstatePropertyModelUncheckedCreateWithoutAgentInput>
  }

  export type RealEstatePropertyModelUpdateWithWhereUniqueWithoutAgentInput = {
    where: RealEstatePropertyModelWhereUniqueInput
    data: XOR<RealEstatePropertyModelUpdateWithoutAgentInput, RealEstatePropertyModelUncheckedUpdateWithoutAgentInput>
  }

  export type RealEstatePropertyModelUpdateManyWithWhereWithoutAgentInput = {
    where: RealEstatePropertyModelScalarWhereInput
    data: XOR<RealEstatePropertyModelUpdateManyMutationInput, RealEstatePropertyModelUncheckedUpdateManyWithoutPropertiesInput>
  }

  export type RealEstatePropertyModelScalarWhereInput = {
    AND?: Enumerable<RealEstatePropertyModelScalarWhereInput>
    OR?: Enumerable<RealEstatePropertyModelScalarWhereInput>
    NOT?: Enumerable<RealEstatePropertyModelScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    main_image_url?: StringFilter | string
    agent_id?: StringFilter | string
  }

  export type BusinessUserModelCreateWithoutHome_care_companyInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    user: UserModelCreateNestedOneWithoutBusiness_userInput
    authentications?: AuthenticationModelCreateNestedManyWithoutBusiness_userInput
    real_estate_agent?: RealEstateAgentModelCreateNestedOneWithoutBusinessInput
    rates?: BusinessRateModelCreateNestedManyWithoutRateeInput
    reviews?: BusinessReviewModelCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelUncheckedCreateWithoutHome_care_companyInput = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    authentications?: AuthenticationModelUncheckedCreateNestedManyWithoutBusiness_userInput
    real_estate_agent?: RealEstateAgentModelUncheckedCreateNestedOneWithoutBusinessInput
    rates?: BusinessRateModelUncheckedCreateNestedManyWithoutRateeInput
    reviews?: BusinessReviewModelUncheckedCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelCreateOrConnectWithoutHome_care_companyInput = {
    where: BusinessUserModelWhereUniqueInput
    create: XOR<BusinessUserModelCreateWithoutHome_care_companyInput, BusinessUserModelUncheckedCreateWithoutHome_care_companyInput>
  }

  export type HomeCareSpecializedSubFieldModelCreateWithoutHome_care_companiesInput = {
    id: string
    name: string
    super: HomeCareSpecializedSuperFieldModelCreateNestedOneWithoutSubInput
  }

  export type HomeCareSpecializedSubFieldModelUncheckedCreateWithoutHome_care_companiesInput = {
    id: string
    name: string
    super_id: string
  }

  export type HomeCareSpecializedSubFieldModelCreateOrConnectWithoutHome_care_companiesInput = {
    where: HomeCareSpecializedSubFieldModelWhereUniqueInput
    create: XOR<HomeCareSpecializedSubFieldModelCreateWithoutHome_care_companiesInput, HomeCareSpecializedSubFieldModelUncheckedCreateWithoutHome_care_companiesInput>
  }

  export type HomeCareIntroductionImageModelCreateWithoutCompanyInput = {
    id: string
    image_url: string
  }

  export type HomeCareIntroductionImageModelUncheckedCreateWithoutCompanyInput = {
    id: string
    image_url: string
  }

  export type HomeCareIntroductionImageModelCreateOrConnectWithoutCompanyInput = {
    where: HomeCareIntroductionImageModelWhereUniqueInput
    create: XOR<HomeCareIntroductionImageModelCreateWithoutCompanyInput, HomeCareIntroductionImageModelUncheckedCreateWithoutCompanyInput>
  }

  export type HomeCareIntroductionImageModelCreateManyCompanyInputEnvelope = {
    data: Enumerable<HomeCareIntroductionImageModelCreateManyCompanyInput>
    skipDuplicates?: boolean
  }

  export type BusinessUserModelUpsertWithoutHome_care_companyInput = {
    update: XOR<BusinessUserModelUpdateWithoutHome_care_companyInput, BusinessUserModelUncheckedUpdateWithoutHome_care_companyInput>
    create: XOR<BusinessUserModelCreateWithoutHome_care_companyInput, BusinessUserModelUncheckedCreateWithoutHome_care_companyInput>
  }

  export type BusinessUserModelUpdateWithoutHome_care_companyInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    user?: UserModelUpdateOneRequiredWithoutBusiness_userNestedInput
    authentications?: AuthenticationModelUpdateManyWithoutBusiness_userNestedInput
    real_estate_agent?: RealEstateAgentModelUpdateOneWithoutBusinessNestedInput
    rates?: BusinessRateModelUpdateManyWithoutRateeNestedInput
    reviews?: BusinessReviewModelUpdateManyWithoutRevieweeNestedInput
  }

  export type BusinessUserModelUncheckedUpdateWithoutHome_care_companyInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    authentications?: AuthenticationModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    real_estate_agent?: RealEstateAgentModelUncheckedUpdateOneWithoutBusinessNestedInput
    rates?: BusinessRateModelUncheckedUpdateManyWithoutRateeNestedInput
    reviews?: BusinessReviewModelUncheckedUpdateManyWithoutRevieweeNestedInput
  }

  export type HomeCareSpecializedSubFieldModelUpsertWithoutHome_care_companiesInput = {
    update: XOR<HomeCareSpecializedSubFieldModelUpdateWithoutHome_care_companiesInput, HomeCareSpecializedSubFieldModelUncheckedUpdateWithoutHome_care_companiesInput>
    create: XOR<HomeCareSpecializedSubFieldModelCreateWithoutHome_care_companiesInput, HomeCareSpecializedSubFieldModelUncheckedCreateWithoutHome_care_companiesInput>
  }

  export type HomeCareSpecializedSubFieldModelUpdateWithoutHome_care_companiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    super?: HomeCareSpecializedSuperFieldModelUpdateOneRequiredWithoutSubNestedInput
  }

  export type HomeCareSpecializedSubFieldModelUncheckedUpdateWithoutHome_care_companiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    super_id?: StringFieldUpdateOperationsInput | string
  }

  export type HomeCareIntroductionImageModelUpsertWithWhereUniqueWithoutCompanyInput = {
    where: HomeCareIntroductionImageModelWhereUniqueInput
    update: XOR<HomeCareIntroductionImageModelUpdateWithoutCompanyInput, HomeCareIntroductionImageModelUncheckedUpdateWithoutCompanyInput>
    create: XOR<HomeCareIntroductionImageModelCreateWithoutCompanyInput, HomeCareIntroductionImageModelUncheckedCreateWithoutCompanyInput>
  }

  export type HomeCareIntroductionImageModelUpdateWithWhereUniqueWithoutCompanyInput = {
    where: HomeCareIntroductionImageModelWhereUniqueInput
    data: XOR<HomeCareIntroductionImageModelUpdateWithoutCompanyInput, HomeCareIntroductionImageModelUncheckedUpdateWithoutCompanyInput>
  }

  export type HomeCareIntroductionImageModelUpdateManyWithWhereWithoutCompanyInput = {
    where: HomeCareIntroductionImageModelScalarWhereInput
    data: XOR<HomeCareIntroductionImageModelUpdateManyMutationInput, HomeCareIntroductionImageModelUncheckedUpdateManyWithoutIntroduction_imagesInput>
  }

  export type HomeCareIntroductionImageModelScalarWhereInput = {
    AND?: Enumerable<HomeCareIntroductionImageModelScalarWhereInput>
    OR?: Enumerable<HomeCareIntroductionImageModelScalarWhereInput>
    NOT?: Enumerable<HomeCareIntroductionImageModelScalarWhereInput>
    id?: StringFilter | string
    image_url?: StringFilter | string
    company_id?: StringFilter | string
  }

  export type HomeCareCompanyModelCreateWithoutIntroduction_imagesInput = {
    business_registration_num: string
    business: BusinessUserModelCreateNestedOneWithoutHome_care_companyInput
    specialized_field?: HomeCareSpecializedSubFieldModelCreateNestedOneWithoutHome_care_companiesInput
  }

  export type HomeCareCompanyModelUncheckedCreateWithoutIntroduction_imagesInput = {
    id: string
    business_registration_num: string
    specialized_field_id?: string | null
  }

  export type HomeCareCompanyModelCreateOrConnectWithoutIntroduction_imagesInput = {
    where: HomeCareCompanyModelWhereUniqueInput
    create: XOR<HomeCareCompanyModelCreateWithoutIntroduction_imagesInput, HomeCareCompanyModelUncheckedCreateWithoutIntroduction_imagesInput>
  }

  export type HomeCareCompanyModelUpsertWithoutIntroduction_imagesInput = {
    update: XOR<HomeCareCompanyModelUpdateWithoutIntroduction_imagesInput, HomeCareCompanyModelUncheckedUpdateWithoutIntroduction_imagesInput>
    create: XOR<HomeCareCompanyModelCreateWithoutIntroduction_imagesInput, HomeCareCompanyModelUncheckedCreateWithoutIntroduction_imagesInput>
  }

  export type HomeCareCompanyModelUpdateWithoutIntroduction_imagesInput = {
    business_registration_num?: StringFieldUpdateOperationsInput | string
    business?: BusinessUserModelUpdateOneRequiredWithoutHome_care_companyNestedInput
    specialized_field?: HomeCareSpecializedSubFieldModelUpdateOneWithoutHome_care_companiesNestedInput
  }

  export type HomeCareCompanyModelUncheckedUpdateWithoutIntroduction_imagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    business_registration_num?: StringFieldUpdateOperationsInput | string
    specialized_field_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RealEstateAgentModelCreateWithoutPropertiesInput = {
    is_licensed: boolean
    real_estate_num: string
    real_estate_name: string
    real_estate_phone: string
    licensed_agent_name: string
    business: BusinessUserModelCreateNestedOneWithoutReal_estate_agentInput
    specialized_field?: RealEstateSpecializedSubFieldModelCreateNestedOneWithoutReal_estate_agentsInput
  }

  export type RealEstateAgentModelUncheckedCreateWithoutPropertiesInput = {
    id: string
    is_licensed: boolean
    real_estate_num: string
    real_estate_name: string
    real_estate_phone: string
    licensed_agent_name: string
    specialized_field_id?: string | null
  }

  export type RealEstateAgentModelCreateOrConnectWithoutPropertiesInput = {
    where: RealEstateAgentModelWhereUniqueInput
    create: XOR<RealEstateAgentModelCreateWithoutPropertiesInput, RealEstateAgentModelUncheckedCreateWithoutPropertiesInput>
  }

  export type RealEstateAgentModelUpsertWithoutPropertiesInput = {
    update: XOR<RealEstateAgentModelUpdateWithoutPropertiesInput, RealEstateAgentModelUncheckedUpdateWithoutPropertiesInput>
    create: XOR<RealEstateAgentModelCreateWithoutPropertiesInput, RealEstateAgentModelUncheckedCreateWithoutPropertiesInput>
  }

  export type RealEstateAgentModelUpdateWithoutPropertiesInput = {
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    real_estate_num?: StringFieldUpdateOperationsInput | string
    real_estate_name?: StringFieldUpdateOperationsInput | string
    real_estate_phone?: StringFieldUpdateOperationsInput | string
    licensed_agent_name?: StringFieldUpdateOperationsInput | string
    business?: BusinessUserModelUpdateOneRequiredWithoutReal_estate_agentNestedInput
    specialized_field?: RealEstateSpecializedSubFieldModelUpdateOneWithoutReal_estate_agentsNestedInput
  }

  export type RealEstateAgentModelUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    real_estate_num?: StringFieldUpdateOperationsInput | string
    real_estate_name?: StringFieldUpdateOperationsInput | string
    real_estate_phone?: StringFieldUpdateOperationsInput | string
    licensed_agent_name?: StringFieldUpdateOperationsInput | string
    specialized_field_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HomeCareSpecializedSubFieldModelCreateWithoutSuperInput = {
    id: string
    name: string
    home_care_companies?: HomeCareCompanyModelCreateNestedManyWithoutSpecialized_fieldInput
  }

  export type HomeCareSpecializedSubFieldModelUncheckedCreateWithoutSuperInput = {
    id: string
    name: string
    home_care_companies?: HomeCareCompanyModelUncheckedCreateNestedManyWithoutSpecialized_fieldInput
  }

  export type HomeCareSpecializedSubFieldModelCreateOrConnectWithoutSuperInput = {
    where: HomeCareSpecializedSubFieldModelWhereUniqueInput
    create: XOR<HomeCareSpecializedSubFieldModelCreateWithoutSuperInput, HomeCareSpecializedSubFieldModelUncheckedCreateWithoutSuperInput>
  }

  export type HomeCareSpecializedSubFieldModelCreateManySuperInputEnvelope = {
    data: Enumerable<HomeCareSpecializedSubFieldModelCreateManySuperInput>
    skipDuplicates?: boolean
  }

  export type HomeCareSpecializedSubFieldModelUpsertWithWhereUniqueWithoutSuperInput = {
    where: HomeCareSpecializedSubFieldModelWhereUniqueInput
    update: XOR<HomeCareSpecializedSubFieldModelUpdateWithoutSuperInput, HomeCareSpecializedSubFieldModelUncheckedUpdateWithoutSuperInput>
    create: XOR<HomeCareSpecializedSubFieldModelCreateWithoutSuperInput, HomeCareSpecializedSubFieldModelUncheckedCreateWithoutSuperInput>
  }

  export type HomeCareSpecializedSubFieldModelUpdateWithWhereUniqueWithoutSuperInput = {
    where: HomeCareSpecializedSubFieldModelWhereUniqueInput
    data: XOR<HomeCareSpecializedSubFieldModelUpdateWithoutSuperInput, HomeCareSpecializedSubFieldModelUncheckedUpdateWithoutSuperInput>
  }

  export type HomeCareSpecializedSubFieldModelUpdateManyWithWhereWithoutSuperInput = {
    where: HomeCareSpecializedSubFieldModelScalarWhereInput
    data: XOR<HomeCareSpecializedSubFieldModelUpdateManyMutationInput, HomeCareSpecializedSubFieldModelUncheckedUpdateManyWithoutSubInput>
  }

  export type HomeCareSpecializedSubFieldModelScalarWhereInput = {
    AND?: Enumerable<HomeCareSpecializedSubFieldModelScalarWhereInput>
    OR?: Enumerable<HomeCareSpecializedSubFieldModelScalarWhereInput>
    NOT?: Enumerable<HomeCareSpecializedSubFieldModelScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    super_id?: StringFilter | string
  }

  export type HomeCareSpecializedSuperFieldModelCreateWithoutSubInput = {
    id: string
    name: string
  }

  export type HomeCareSpecializedSuperFieldModelUncheckedCreateWithoutSubInput = {
    id: string
    name: string
  }

  export type HomeCareSpecializedSuperFieldModelCreateOrConnectWithoutSubInput = {
    where: HomeCareSpecializedSuperFieldModelWhereUniqueInput
    create: XOR<HomeCareSpecializedSuperFieldModelCreateWithoutSubInput, HomeCareSpecializedSuperFieldModelUncheckedCreateWithoutSubInput>
  }

  export type HomeCareCompanyModelCreateWithoutSpecialized_fieldInput = {
    business_registration_num: string
    business: BusinessUserModelCreateNestedOneWithoutHome_care_companyInput
    introduction_images?: HomeCareIntroductionImageModelCreateNestedManyWithoutCompanyInput
  }

  export type HomeCareCompanyModelUncheckedCreateWithoutSpecialized_fieldInput = {
    id: string
    business_registration_num: string
    introduction_images?: HomeCareIntroductionImageModelUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type HomeCareCompanyModelCreateOrConnectWithoutSpecialized_fieldInput = {
    where: HomeCareCompanyModelWhereUniqueInput
    create: XOR<HomeCareCompanyModelCreateWithoutSpecialized_fieldInput, HomeCareCompanyModelUncheckedCreateWithoutSpecialized_fieldInput>
  }

  export type HomeCareCompanyModelCreateManySpecialized_fieldInputEnvelope = {
    data: Enumerable<HomeCareCompanyModelCreateManySpecialized_fieldInput>
    skipDuplicates?: boolean
  }

  export type HomeCareSpecializedSuperFieldModelUpsertWithoutSubInput = {
    update: XOR<HomeCareSpecializedSuperFieldModelUpdateWithoutSubInput, HomeCareSpecializedSuperFieldModelUncheckedUpdateWithoutSubInput>
    create: XOR<HomeCareSpecializedSuperFieldModelCreateWithoutSubInput, HomeCareSpecializedSuperFieldModelUncheckedCreateWithoutSubInput>
  }

  export type HomeCareSpecializedSuperFieldModelUpdateWithoutSubInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type HomeCareSpecializedSuperFieldModelUncheckedUpdateWithoutSubInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type HomeCareCompanyModelUpsertWithWhereUniqueWithoutSpecialized_fieldInput = {
    where: HomeCareCompanyModelWhereUniqueInput
    update: XOR<HomeCareCompanyModelUpdateWithoutSpecialized_fieldInput, HomeCareCompanyModelUncheckedUpdateWithoutSpecialized_fieldInput>
    create: XOR<HomeCareCompanyModelCreateWithoutSpecialized_fieldInput, HomeCareCompanyModelUncheckedCreateWithoutSpecialized_fieldInput>
  }

  export type HomeCareCompanyModelUpdateWithWhereUniqueWithoutSpecialized_fieldInput = {
    where: HomeCareCompanyModelWhereUniqueInput
    data: XOR<HomeCareCompanyModelUpdateWithoutSpecialized_fieldInput, HomeCareCompanyModelUncheckedUpdateWithoutSpecialized_fieldInput>
  }

  export type HomeCareCompanyModelUpdateManyWithWhereWithoutSpecialized_fieldInput = {
    where: HomeCareCompanyModelScalarWhereInput
    data: XOR<HomeCareCompanyModelUpdateManyMutationInput, HomeCareCompanyModelUncheckedUpdateManyWithoutHome_care_companiesInput>
  }

  export type HomeCareCompanyModelScalarWhereInput = {
    AND?: Enumerable<HomeCareCompanyModelScalarWhereInput>
    OR?: Enumerable<HomeCareCompanyModelScalarWhereInput>
    NOT?: Enumerable<HomeCareCompanyModelScalarWhereInput>
    id?: StringFilter | string
    business_registration_num?: StringFilter | string
    specialized_field_id?: StringNullableFilter | string | null
  }

  export type RealEstateSpecializedSubFieldModelCreateWithoutSuperInput = {
    id: string
    name: string
    real_estate_agents?: RealEstateAgentModelCreateNestedManyWithoutSpecialized_fieldInput
  }

  export type RealEstateSpecializedSubFieldModelUncheckedCreateWithoutSuperInput = {
    id: string
    name: string
    real_estate_agents?: RealEstateAgentModelUncheckedCreateNestedManyWithoutSpecialized_fieldInput
  }

  export type RealEstateSpecializedSubFieldModelCreateOrConnectWithoutSuperInput = {
    where: RealEstateSpecializedSubFieldModelWhereUniqueInput
    create: XOR<RealEstateSpecializedSubFieldModelCreateWithoutSuperInput, RealEstateSpecializedSubFieldModelUncheckedCreateWithoutSuperInput>
  }

  export type RealEstateSpecializedSubFieldModelCreateManySuperInputEnvelope = {
    data: Enumerable<RealEstateSpecializedSubFieldModelCreateManySuperInput>
    skipDuplicates?: boolean
  }

  export type RealEstateSpecializedSubFieldModelUpsertWithWhereUniqueWithoutSuperInput = {
    where: RealEstateSpecializedSubFieldModelWhereUniqueInput
    update: XOR<RealEstateSpecializedSubFieldModelUpdateWithoutSuperInput, RealEstateSpecializedSubFieldModelUncheckedUpdateWithoutSuperInput>
    create: XOR<RealEstateSpecializedSubFieldModelCreateWithoutSuperInput, RealEstateSpecializedSubFieldModelUncheckedCreateWithoutSuperInput>
  }

  export type RealEstateSpecializedSubFieldModelUpdateWithWhereUniqueWithoutSuperInput = {
    where: RealEstateSpecializedSubFieldModelWhereUniqueInput
    data: XOR<RealEstateSpecializedSubFieldModelUpdateWithoutSuperInput, RealEstateSpecializedSubFieldModelUncheckedUpdateWithoutSuperInput>
  }

  export type RealEstateSpecializedSubFieldModelUpdateManyWithWhereWithoutSuperInput = {
    where: RealEstateSpecializedSubFieldModelScalarWhereInput
    data: XOR<RealEstateSpecializedSubFieldModelUpdateManyMutationInput, RealEstateSpecializedSubFieldModelUncheckedUpdateManyWithoutSubInput>
  }

  export type RealEstateSpecializedSubFieldModelScalarWhereInput = {
    AND?: Enumerable<RealEstateSpecializedSubFieldModelScalarWhereInput>
    OR?: Enumerable<RealEstateSpecializedSubFieldModelScalarWhereInput>
    NOT?: Enumerable<RealEstateSpecializedSubFieldModelScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    super_id?: StringFilter | string
  }

  export type RealEstateSpecializedSuperFieldModelCreateWithoutSubInput = {
    id: string
    name: string
  }

  export type RealEstateSpecializedSuperFieldModelUncheckedCreateWithoutSubInput = {
    id: string
    name: string
  }

  export type RealEstateSpecializedSuperFieldModelCreateOrConnectWithoutSubInput = {
    where: RealEstateSpecializedSuperFieldModelWhereUniqueInput
    create: XOR<RealEstateSpecializedSuperFieldModelCreateWithoutSubInput, RealEstateSpecializedSuperFieldModelUncheckedCreateWithoutSubInput>
  }

  export type RealEstateAgentModelCreateWithoutSpecialized_fieldInput = {
    is_licensed: boolean
    real_estate_num: string
    real_estate_name: string
    real_estate_phone: string
    licensed_agent_name: string
    business: BusinessUserModelCreateNestedOneWithoutReal_estate_agentInput
    properties?: RealEstatePropertyModelCreateNestedManyWithoutAgentInput
  }

  export type RealEstateAgentModelUncheckedCreateWithoutSpecialized_fieldInput = {
    id: string
    is_licensed: boolean
    real_estate_num: string
    real_estate_name: string
    real_estate_phone: string
    licensed_agent_name: string
    properties?: RealEstatePropertyModelUncheckedCreateNestedManyWithoutAgentInput
  }

  export type RealEstateAgentModelCreateOrConnectWithoutSpecialized_fieldInput = {
    where: RealEstateAgentModelWhereUniqueInput
    create: XOR<RealEstateAgentModelCreateWithoutSpecialized_fieldInput, RealEstateAgentModelUncheckedCreateWithoutSpecialized_fieldInput>
  }

  export type RealEstateAgentModelCreateManySpecialized_fieldInputEnvelope = {
    data: Enumerable<RealEstateAgentModelCreateManySpecialized_fieldInput>
    skipDuplicates?: boolean
  }

  export type RealEstateSpecializedSuperFieldModelUpsertWithoutSubInput = {
    update: XOR<RealEstateSpecializedSuperFieldModelUpdateWithoutSubInput, RealEstateSpecializedSuperFieldModelUncheckedUpdateWithoutSubInput>
    create: XOR<RealEstateSpecializedSuperFieldModelCreateWithoutSubInput, RealEstateSpecializedSuperFieldModelUncheckedCreateWithoutSubInput>
  }

  export type RealEstateSpecializedSuperFieldModelUpdateWithoutSubInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RealEstateSpecializedSuperFieldModelUncheckedUpdateWithoutSubInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RealEstateAgentModelUpsertWithWhereUniqueWithoutSpecialized_fieldInput = {
    where: RealEstateAgentModelWhereUniqueInput
    update: XOR<RealEstateAgentModelUpdateWithoutSpecialized_fieldInput, RealEstateAgentModelUncheckedUpdateWithoutSpecialized_fieldInput>
    create: XOR<RealEstateAgentModelCreateWithoutSpecialized_fieldInput, RealEstateAgentModelUncheckedCreateWithoutSpecialized_fieldInput>
  }

  export type RealEstateAgentModelUpdateWithWhereUniqueWithoutSpecialized_fieldInput = {
    where: RealEstateAgentModelWhereUniqueInput
    data: XOR<RealEstateAgentModelUpdateWithoutSpecialized_fieldInput, RealEstateAgentModelUncheckedUpdateWithoutSpecialized_fieldInput>
  }

  export type RealEstateAgentModelUpdateManyWithWhereWithoutSpecialized_fieldInput = {
    where: RealEstateAgentModelScalarWhereInput
    data: XOR<RealEstateAgentModelUpdateManyMutationInput, RealEstateAgentModelUncheckedUpdateManyWithoutReal_estate_agentsInput>
  }

  export type RealEstateAgentModelScalarWhereInput = {
    AND?: Enumerable<RealEstateAgentModelScalarWhereInput>
    OR?: Enumerable<RealEstateAgentModelScalarWhereInput>
    NOT?: Enumerable<RealEstateAgentModelScalarWhereInput>
    id?: StringFilter | string
    is_licensed?: BoolFilter | boolean
    real_estate_num?: StringFilter | string
    real_estate_name?: StringFilter | string
    real_estate_phone?: StringFilter | string
    licensed_agent_name?: StringFilter | string
    specialized_field_id?: StringNullableFilter | string | null
  }

  export type BusinessUserModelCreateWithoutRatesInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    user: UserModelCreateNestedOneWithoutBusiness_userInput
    authentications?: AuthenticationModelCreateNestedManyWithoutBusiness_userInput
    real_estate_agent?: RealEstateAgentModelCreateNestedOneWithoutBusinessInput
    home_care_company?: HomeCareCompanyModelCreateNestedOneWithoutBusinessInput
    reviews?: BusinessReviewModelCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelUncheckedCreateWithoutRatesInput = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    authentications?: AuthenticationModelUncheckedCreateNestedManyWithoutBusiness_userInput
    real_estate_agent?: RealEstateAgentModelUncheckedCreateNestedOneWithoutBusinessInput
    home_care_company?: HomeCareCompanyModelUncheckedCreateNestedOneWithoutBusinessInput
    reviews?: BusinessReviewModelUncheckedCreateNestedManyWithoutRevieweeInput
  }

  export type BusinessUserModelCreateOrConnectWithoutRatesInput = {
    where: BusinessUserModelWhereUniqueInput
    create: XOR<BusinessUserModelCreateWithoutRatesInput, BusinessUserModelUncheckedCreateWithoutRatesInput>
  }

  export type CustomerModelCreateWithoutRatesInput = {
    birth?: string | null
    gender?: string | null
    user: UserModelCreateNestedOneWithoutCustomerInput
    authentications?: AuthenticationModelCreateNestedManyWithoutCustomerInput
    reviews?: BusinessReviewModelCreateNestedManyWithoutReviewerInput
  }

  export type CustomerModelUncheckedCreateWithoutRatesInput = {
    id: string
    birth?: string | null
    gender?: string | null
    authentications?: AuthenticationModelUncheckedCreateNestedManyWithoutCustomerInput
    reviews?: BusinessReviewModelUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type CustomerModelCreateOrConnectWithoutRatesInput = {
    where: CustomerModelWhereUniqueInput
    create: XOR<CustomerModelCreateWithoutRatesInput, CustomerModelUncheckedCreateWithoutRatesInput>
  }

  export type BusinessRateCategoryModelCreateWithoutRatesInput = {
    id: string
    name: string
  }

  export type BusinessRateCategoryModelUncheckedCreateWithoutRatesInput = {
    id: string
    name: string
  }

  export type BusinessRateCategoryModelCreateOrConnectWithoutRatesInput = {
    where: BusinessRateCategoryModelWhereUniqueInput
    create: XOR<BusinessRateCategoryModelCreateWithoutRatesInput, BusinessRateCategoryModelUncheckedCreateWithoutRatesInput>
  }

  export type BusinessUserModelUpsertWithoutRatesInput = {
    update: XOR<BusinessUserModelUpdateWithoutRatesInput, BusinessUserModelUncheckedUpdateWithoutRatesInput>
    create: XOR<BusinessUserModelCreateWithoutRatesInput, BusinessUserModelUncheckedCreateWithoutRatesInput>
  }

  export type BusinessUserModelUpdateWithoutRatesInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    user?: UserModelUpdateOneRequiredWithoutBusiness_userNestedInput
    authentications?: AuthenticationModelUpdateManyWithoutBusiness_userNestedInput
    real_estate_agent?: RealEstateAgentModelUpdateOneWithoutBusinessNestedInput
    home_care_company?: HomeCareCompanyModelUpdateOneWithoutBusinessNestedInput
    reviews?: BusinessReviewModelUpdateManyWithoutRevieweeNestedInput
  }

  export type BusinessUserModelUncheckedUpdateWithoutRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    authentications?: AuthenticationModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    real_estate_agent?: RealEstateAgentModelUncheckedUpdateOneWithoutBusinessNestedInput
    home_care_company?: HomeCareCompanyModelUncheckedUpdateOneWithoutBusinessNestedInput
    reviews?: BusinessReviewModelUncheckedUpdateManyWithoutRevieweeNestedInput
  }

  export type CustomerModelUpsertWithoutRatesInput = {
    update: XOR<CustomerModelUpdateWithoutRatesInput, CustomerModelUncheckedUpdateWithoutRatesInput>
    create: XOR<CustomerModelCreateWithoutRatesInput, CustomerModelUncheckedCreateWithoutRatesInput>
  }

  export type CustomerModelUpdateWithoutRatesInput = {
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserModelUpdateOneRequiredWithoutCustomerNestedInput
    authentications?: AuthenticationModelUpdateManyWithoutCustomerNestedInput
    reviews?: BusinessReviewModelUpdateManyWithoutReviewerNestedInput
  }

  export type CustomerModelUncheckedUpdateWithoutRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    authentications?: AuthenticationModelUncheckedUpdateManyWithoutCustomerNestedInput
    reviews?: BusinessReviewModelUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type BusinessRateCategoryModelUpsertWithoutRatesInput = {
    update: XOR<BusinessRateCategoryModelUpdateWithoutRatesInput, BusinessRateCategoryModelUncheckedUpdateWithoutRatesInput>
    create: XOR<BusinessRateCategoryModelCreateWithoutRatesInput, BusinessRateCategoryModelUncheckedCreateWithoutRatesInput>
  }

  export type BusinessRateCategoryModelUpdateWithoutRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessRateCategoryModelUncheckedUpdateWithoutRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessRateModelCreateWithoutCategoryInput = {
    id: string
    rate: number
    ratee: BusinessUserModelCreateNestedOneWithoutRatesInput
    rater: CustomerModelCreateNestedOneWithoutRatesInput
  }

  export type BusinessRateModelUncheckedCreateWithoutCategoryInput = {
    id: string
    ratee_id: string
    rater_id: string
    rate: number
  }

  export type BusinessRateModelCreateOrConnectWithoutCategoryInput = {
    where: BusinessRateModelWhereUniqueInput
    create: XOR<BusinessRateModelCreateWithoutCategoryInput, BusinessRateModelUncheckedCreateWithoutCategoryInput>
  }

  export type BusinessRateModelCreateManyCategoryInputEnvelope = {
    data: Enumerable<BusinessRateModelCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type BusinessRateModelUpsertWithWhereUniqueWithoutCategoryInput = {
    where: BusinessRateModelWhereUniqueInput
    update: XOR<BusinessRateModelUpdateWithoutCategoryInput, BusinessRateModelUncheckedUpdateWithoutCategoryInput>
    create: XOR<BusinessRateModelCreateWithoutCategoryInput, BusinessRateModelUncheckedCreateWithoutCategoryInput>
  }

  export type BusinessRateModelUpdateWithWhereUniqueWithoutCategoryInput = {
    where: BusinessRateModelWhereUniqueInput
    data: XOR<BusinessRateModelUpdateWithoutCategoryInput, BusinessRateModelUncheckedUpdateWithoutCategoryInput>
  }

  export type BusinessRateModelUpdateManyWithWhereWithoutCategoryInput = {
    where: BusinessRateModelScalarWhereInput
    data: XOR<BusinessRateModelUpdateManyMutationInput, BusinessRateModelUncheckedUpdateManyWithoutRatesInput>
  }

  export type BusinessUserModelCreateWithoutReviewsInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    user: UserModelCreateNestedOneWithoutBusiness_userInput
    authentications?: AuthenticationModelCreateNestedManyWithoutBusiness_userInput
    real_estate_agent?: RealEstateAgentModelCreateNestedOneWithoutBusinessInput
    home_care_company?: HomeCareCompanyModelCreateNestedOneWithoutBusinessInput
    rates?: BusinessRateModelCreateNestedManyWithoutRateeInput
  }

  export type BusinessUserModelUncheckedCreateWithoutReviewsInput = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    authentications?: AuthenticationModelUncheckedCreateNestedManyWithoutBusiness_userInput
    real_estate_agent?: RealEstateAgentModelUncheckedCreateNestedOneWithoutBusinessInput
    home_care_company?: HomeCareCompanyModelUncheckedCreateNestedOneWithoutBusinessInput
    rates?: BusinessRateModelUncheckedCreateNestedManyWithoutRateeInput
  }

  export type BusinessUserModelCreateOrConnectWithoutReviewsInput = {
    where: BusinessUserModelWhereUniqueInput
    create: XOR<BusinessUserModelCreateWithoutReviewsInput, BusinessUserModelUncheckedCreateWithoutReviewsInput>
  }

  export type CustomerModelCreateWithoutReviewsInput = {
    birth?: string | null
    gender?: string | null
    user: UserModelCreateNestedOneWithoutCustomerInput
    authentications?: AuthenticationModelCreateNestedManyWithoutCustomerInput
    rates?: BusinessRateModelCreateNestedManyWithoutRaterInput
  }

  export type CustomerModelUncheckedCreateWithoutReviewsInput = {
    id: string
    birth?: string | null
    gender?: string | null
    authentications?: AuthenticationModelUncheckedCreateNestedManyWithoutCustomerInput
    rates?: BusinessRateModelUncheckedCreateNestedManyWithoutRaterInput
  }

  export type CustomerModelCreateOrConnectWithoutReviewsInput = {
    where: CustomerModelWhereUniqueInput
    create: XOR<CustomerModelCreateWithoutReviewsInput, CustomerModelUncheckedCreateWithoutReviewsInput>
  }

  export type BusinessUserModelUpsertWithoutReviewsInput = {
    update: XOR<BusinessUserModelUpdateWithoutReviewsInput, BusinessUserModelUncheckedUpdateWithoutReviewsInput>
    create: XOR<BusinessUserModelCreateWithoutReviewsInput, BusinessUserModelUncheckedCreateWithoutReviewsInput>
  }

  export type BusinessUserModelUpdateWithoutReviewsInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    user?: UserModelUpdateOneRequiredWithoutBusiness_userNestedInput
    authentications?: AuthenticationModelUpdateManyWithoutBusiness_userNestedInput
    real_estate_agent?: RealEstateAgentModelUpdateOneWithoutBusinessNestedInput
    home_care_company?: HomeCareCompanyModelUpdateOneWithoutBusinessNestedInput
    rates?: BusinessRateModelUpdateManyWithoutRateeNestedInput
  }

  export type BusinessUserModelUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    authentications?: AuthenticationModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    real_estate_agent?: RealEstateAgentModelUncheckedUpdateOneWithoutBusinessNestedInput
    home_care_company?: HomeCareCompanyModelUncheckedUpdateOneWithoutBusinessNestedInput
    rates?: BusinessRateModelUncheckedUpdateManyWithoutRateeNestedInput
  }

  export type CustomerModelUpsertWithoutReviewsInput = {
    update: XOR<CustomerModelUpdateWithoutReviewsInput, CustomerModelUncheckedUpdateWithoutReviewsInput>
    create: XOR<CustomerModelCreateWithoutReviewsInput, CustomerModelUncheckedCreateWithoutReviewsInput>
  }

  export type CustomerModelUpdateWithoutReviewsInput = {
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserModelUpdateOneRequiredWithoutCustomerNestedInput
    authentications?: AuthenticationModelUpdateManyWithoutCustomerNestedInput
    rates?: BusinessRateModelUpdateManyWithoutRaterNestedInput
  }

  export type CustomerModelUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    authentications?: AuthenticationModelUncheckedUpdateManyWithoutCustomerNestedInput
    rates?: BusinessRateModelUncheckedUpdateManyWithoutRaterNestedInput
  }

  export type BoardArticleModelCreateWithoutBoardInput = {
    id: string
    title: string
    author: UserModelCreateNestedOneWithoutBoard_articlesInput
    contents?: BoardArticleContentModelCreateNestedManyWithoutArticleInput
    comments?: BoardCommentModelCreateNestedManyWithoutArticleInput
  }

  export type BoardArticleModelUncheckedCreateWithoutBoardInput = {
    id: string
    title: string
    author_id: string
    contents?: BoardArticleContentModelUncheckedCreateNestedManyWithoutArticleInput
    comments?: BoardCommentModelUncheckedCreateNestedManyWithoutArticleInput
  }

  export type BoardArticleModelCreateOrConnectWithoutBoardInput = {
    where: BoardArticleModelWhereUniqueInput
    create: XOR<BoardArticleModelCreateWithoutBoardInput, BoardArticleModelUncheckedCreateWithoutBoardInput>
  }

  export type BoardArticleModelCreateManyBoardInputEnvelope = {
    data: Enumerable<BoardArticleModelCreateManyBoardInput>
    skipDuplicates?: boolean
  }

  export type BoardArticleModelUpsertWithWhereUniqueWithoutBoardInput = {
    where: BoardArticleModelWhereUniqueInput
    update: XOR<BoardArticleModelUpdateWithoutBoardInput, BoardArticleModelUncheckedUpdateWithoutBoardInput>
    create: XOR<BoardArticleModelCreateWithoutBoardInput, BoardArticleModelUncheckedCreateWithoutBoardInput>
  }

  export type BoardArticleModelUpdateWithWhereUniqueWithoutBoardInput = {
    where: BoardArticleModelWhereUniqueInput
    data: XOR<BoardArticleModelUpdateWithoutBoardInput, BoardArticleModelUncheckedUpdateWithoutBoardInput>
  }

  export type BoardArticleModelUpdateManyWithWhereWithoutBoardInput = {
    where: BoardArticleModelScalarWhereInput
    data: XOR<BoardArticleModelUpdateManyMutationInput, BoardArticleModelUncheckedUpdateManyWithoutArticlesInput>
  }

  export type UserModelCreateWithoutBoard_articlesInput = {
    id: string
    name: string
    email?: string | null
    email_verified: boolean
    phone?: string | null
    phone_verified: boolean
    address_first?: string | null
    address_second?: string | null
    profile_image?: string | null
    customer?: CustomerModelCreateNestedOneWithoutUserInput
    business_user?: BusinessUserModelCreateNestedOneWithoutUserInput
    board_comments?: BoardCommentModelCreateNestedManyWithoutAuthorInput
  }

  export type UserModelUncheckedCreateWithoutBoard_articlesInput = {
    id: string
    name: string
    email?: string | null
    email_verified: boolean
    phone?: string | null
    phone_verified: boolean
    address_first?: string | null
    address_second?: string | null
    profile_image?: string | null
    customer?: CustomerModelUncheckedCreateNestedOneWithoutUserInput
    business_user?: BusinessUserModelUncheckedCreateNestedOneWithoutUserInput
    board_comments?: BoardCommentModelUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserModelCreateOrConnectWithoutBoard_articlesInput = {
    where: UserModelWhereUniqueInput
    create: XOR<UserModelCreateWithoutBoard_articlesInput, UserModelUncheckedCreateWithoutBoard_articlesInput>
  }

  export type BoardModelCreateWithoutArticlesInput = {
    id: string
    name: string
  }

  export type BoardModelUncheckedCreateWithoutArticlesInput = {
    id: string
    name: string
  }

  export type BoardModelCreateOrConnectWithoutArticlesInput = {
    where: BoardModelWhereUniqueInput
    create: XOR<BoardModelCreateWithoutArticlesInput, BoardModelUncheckedCreateWithoutArticlesInput>
  }

  export type BoardArticleContentModelCreateWithoutArticleInput = {
    id: string
    text: string
    created_at: Date | string
  }

  export type BoardArticleContentModelUncheckedCreateWithoutArticleInput = {
    id: string
    text: string
    created_at: Date | string
  }

  export type BoardArticleContentModelCreateOrConnectWithoutArticleInput = {
    where: BoardArticleContentModelWhereUniqueInput
    create: XOR<BoardArticleContentModelCreateWithoutArticleInput, BoardArticleContentModelUncheckedCreateWithoutArticleInput>
  }

  export type BoardArticleContentModelCreateManyArticleInputEnvelope = {
    data: Enumerable<BoardArticleContentModelCreateManyArticleInput>
    skipDuplicates?: boolean
  }

  export type BoardCommentModelCreateWithoutArticleInput = {
    id: string
    author: UserModelCreateNestedOneWithoutBoard_commentsInput
    contents?: BoardCommentContentModelCreateNestedManyWithoutCommentInput
  }

  export type BoardCommentModelUncheckedCreateWithoutArticleInput = {
    id: string
    author_id: string
    contents?: BoardCommentContentModelUncheckedCreateNestedManyWithoutCommentInput
  }

  export type BoardCommentModelCreateOrConnectWithoutArticleInput = {
    where: BoardCommentModelWhereUniqueInput
    create: XOR<BoardCommentModelCreateWithoutArticleInput, BoardCommentModelUncheckedCreateWithoutArticleInput>
  }

  export type BoardCommentModelCreateManyArticleInputEnvelope = {
    data: Enumerable<BoardCommentModelCreateManyArticleInput>
    skipDuplicates?: boolean
  }

  export type UserModelUpsertWithoutBoard_articlesInput = {
    update: XOR<UserModelUpdateWithoutBoard_articlesInput, UserModelUncheckedUpdateWithoutBoard_articlesInput>
    create: XOR<UserModelCreateWithoutBoard_articlesInput, UserModelUncheckedCreateWithoutBoard_articlesInput>
  }

  export type UserModelUpdateWithoutBoard_articlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerModelUpdateOneWithoutUserNestedInput
    business_user?: BusinessUserModelUpdateOneWithoutUserNestedInput
    board_comments?: BoardCommentModelUpdateManyWithoutAuthorNestedInput
  }

  export type UserModelUncheckedUpdateWithoutBoard_articlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerModelUncheckedUpdateOneWithoutUserNestedInput
    business_user?: BusinessUserModelUncheckedUpdateOneWithoutUserNestedInput
    board_comments?: BoardCommentModelUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type BoardModelUpsertWithoutArticlesInput = {
    update: XOR<BoardModelUpdateWithoutArticlesInput, BoardModelUncheckedUpdateWithoutArticlesInput>
    create: XOR<BoardModelCreateWithoutArticlesInput, BoardModelUncheckedCreateWithoutArticlesInput>
  }

  export type BoardModelUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BoardModelUncheckedUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BoardArticleContentModelUpsertWithWhereUniqueWithoutArticleInput = {
    where: BoardArticleContentModelWhereUniqueInput
    update: XOR<BoardArticleContentModelUpdateWithoutArticleInput, BoardArticleContentModelUncheckedUpdateWithoutArticleInput>
    create: XOR<BoardArticleContentModelCreateWithoutArticleInput, BoardArticleContentModelUncheckedCreateWithoutArticleInput>
  }

  export type BoardArticleContentModelUpdateWithWhereUniqueWithoutArticleInput = {
    where: BoardArticleContentModelWhereUniqueInput
    data: XOR<BoardArticleContentModelUpdateWithoutArticleInput, BoardArticleContentModelUncheckedUpdateWithoutArticleInput>
  }

  export type BoardArticleContentModelUpdateManyWithWhereWithoutArticleInput = {
    where: BoardArticleContentModelScalarWhereInput
    data: XOR<BoardArticleContentModelUpdateManyMutationInput, BoardArticleContentModelUncheckedUpdateManyWithoutContentsInput>
  }

  export type BoardArticleContentModelScalarWhereInput = {
    AND?: Enumerable<BoardArticleContentModelScalarWhereInput>
    OR?: Enumerable<BoardArticleContentModelScalarWhereInput>
    NOT?: Enumerable<BoardArticleContentModelScalarWhereInput>
    id?: StringFilter | string
    text?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    article_id?: StringFilter | string
  }

  export type BoardCommentModelUpsertWithWhereUniqueWithoutArticleInput = {
    where: BoardCommentModelWhereUniqueInput
    update: XOR<BoardCommentModelUpdateWithoutArticleInput, BoardCommentModelUncheckedUpdateWithoutArticleInput>
    create: XOR<BoardCommentModelCreateWithoutArticleInput, BoardCommentModelUncheckedCreateWithoutArticleInput>
  }

  export type BoardCommentModelUpdateWithWhereUniqueWithoutArticleInput = {
    where: BoardCommentModelWhereUniqueInput
    data: XOR<BoardCommentModelUpdateWithoutArticleInput, BoardCommentModelUncheckedUpdateWithoutArticleInput>
  }

  export type BoardCommentModelUpdateManyWithWhereWithoutArticleInput = {
    where: BoardCommentModelScalarWhereInput
    data: XOR<BoardCommentModelUpdateManyMutationInput, BoardCommentModelUncheckedUpdateManyWithoutCommentsInput>
  }

  export type BoardArticleModelCreateWithoutContentsInput = {
    id: string
    title: string
    author: UserModelCreateNestedOneWithoutBoard_articlesInput
    board: BoardModelCreateNestedOneWithoutArticlesInput
    comments?: BoardCommentModelCreateNestedManyWithoutArticleInput
  }

  export type BoardArticleModelUncheckedCreateWithoutContentsInput = {
    id: string
    title: string
    author_id: string
    board_id: string
    comments?: BoardCommentModelUncheckedCreateNestedManyWithoutArticleInput
  }

  export type BoardArticleModelCreateOrConnectWithoutContentsInput = {
    where: BoardArticleModelWhereUniqueInput
    create: XOR<BoardArticleModelCreateWithoutContentsInput, BoardArticleModelUncheckedCreateWithoutContentsInput>
  }

  export type BoardArticleModelUpsertWithoutContentsInput = {
    update: XOR<BoardArticleModelUpdateWithoutContentsInput, BoardArticleModelUncheckedUpdateWithoutContentsInput>
    create: XOR<BoardArticleModelCreateWithoutContentsInput, BoardArticleModelUncheckedCreateWithoutContentsInput>
  }

  export type BoardArticleModelUpdateWithoutContentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: UserModelUpdateOneRequiredWithoutBoard_articlesNestedInput
    board?: BoardModelUpdateOneRequiredWithoutArticlesNestedInput
    comments?: BoardCommentModelUpdateManyWithoutArticleNestedInput
  }

  export type BoardArticleModelUncheckedUpdateWithoutContentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
    board_id?: StringFieldUpdateOperationsInput | string
    comments?: BoardCommentModelUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type UserModelCreateWithoutBoard_commentsInput = {
    id: string
    name: string
    email?: string | null
    email_verified: boolean
    phone?: string | null
    phone_verified: boolean
    address_first?: string | null
    address_second?: string | null
    profile_image?: string | null
    customer?: CustomerModelCreateNestedOneWithoutUserInput
    business_user?: BusinessUserModelCreateNestedOneWithoutUserInput
    board_articles?: BoardArticleModelCreateNestedManyWithoutAuthorInput
  }

  export type UserModelUncheckedCreateWithoutBoard_commentsInput = {
    id: string
    name: string
    email?: string | null
    email_verified: boolean
    phone?: string | null
    phone_verified: boolean
    address_first?: string | null
    address_second?: string | null
    profile_image?: string | null
    customer?: CustomerModelUncheckedCreateNestedOneWithoutUserInput
    business_user?: BusinessUserModelUncheckedCreateNestedOneWithoutUserInput
    board_articles?: BoardArticleModelUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserModelCreateOrConnectWithoutBoard_commentsInput = {
    where: UserModelWhereUniqueInput
    create: XOR<UserModelCreateWithoutBoard_commentsInput, UserModelUncheckedCreateWithoutBoard_commentsInput>
  }

  export type BoardArticleModelCreateWithoutCommentsInput = {
    id: string
    title: string
    author: UserModelCreateNestedOneWithoutBoard_articlesInput
    board: BoardModelCreateNestedOneWithoutArticlesInput
    contents?: BoardArticleContentModelCreateNestedManyWithoutArticleInput
  }

  export type BoardArticleModelUncheckedCreateWithoutCommentsInput = {
    id: string
    title: string
    author_id: string
    board_id: string
    contents?: BoardArticleContentModelUncheckedCreateNestedManyWithoutArticleInput
  }

  export type BoardArticleModelCreateOrConnectWithoutCommentsInput = {
    where: BoardArticleModelWhereUniqueInput
    create: XOR<BoardArticleModelCreateWithoutCommentsInput, BoardArticleModelUncheckedCreateWithoutCommentsInput>
  }

  export type BoardCommentContentModelCreateWithoutCommentInput = {
    id: string
    text: string
    created_at: Date | string
  }

  export type BoardCommentContentModelUncheckedCreateWithoutCommentInput = {
    id: string
    text: string
    created_at: Date | string
  }

  export type BoardCommentContentModelCreateOrConnectWithoutCommentInput = {
    where: BoardCommentContentModelWhereUniqueInput
    create: XOR<BoardCommentContentModelCreateWithoutCommentInput, BoardCommentContentModelUncheckedCreateWithoutCommentInput>
  }

  export type BoardCommentContentModelCreateManyCommentInputEnvelope = {
    data: Enumerable<BoardCommentContentModelCreateManyCommentInput>
    skipDuplicates?: boolean
  }

  export type UserModelUpsertWithoutBoard_commentsInput = {
    update: XOR<UserModelUpdateWithoutBoard_commentsInput, UserModelUncheckedUpdateWithoutBoard_commentsInput>
    create: XOR<UserModelCreateWithoutBoard_commentsInput, UserModelUncheckedCreateWithoutBoard_commentsInput>
  }

  export type UserModelUpdateWithoutBoard_commentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerModelUpdateOneWithoutUserNestedInput
    business_user?: BusinessUserModelUpdateOneWithoutUserNestedInput
    board_articles?: BoardArticleModelUpdateManyWithoutAuthorNestedInput
  }

  export type UserModelUncheckedUpdateWithoutBoard_commentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone_verified?: BoolFieldUpdateOperationsInput | boolean
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerModelUncheckedUpdateOneWithoutUserNestedInput
    business_user?: BusinessUserModelUncheckedUpdateOneWithoutUserNestedInput
    board_articles?: BoardArticleModelUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type BoardArticleModelUpsertWithoutCommentsInput = {
    update: XOR<BoardArticleModelUpdateWithoutCommentsInput, BoardArticleModelUncheckedUpdateWithoutCommentsInput>
    create: XOR<BoardArticleModelCreateWithoutCommentsInput, BoardArticleModelUncheckedCreateWithoutCommentsInput>
  }

  export type BoardArticleModelUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: UserModelUpdateOneRequiredWithoutBoard_articlesNestedInput
    board?: BoardModelUpdateOneRequiredWithoutArticlesNestedInput
    contents?: BoardArticleContentModelUpdateManyWithoutArticleNestedInput
  }

  export type BoardArticleModelUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
    board_id?: StringFieldUpdateOperationsInput | string
    contents?: BoardArticleContentModelUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type BoardCommentContentModelUpsertWithWhereUniqueWithoutCommentInput = {
    where: BoardCommentContentModelWhereUniqueInput
    update: XOR<BoardCommentContentModelUpdateWithoutCommentInput, BoardCommentContentModelUncheckedUpdateWithoutCommentInput>
    create: XOR<BoardCommentContentModelCreateWithoutCommentInput, BoardCommentContentModelUncheckedCreateWithoutCommentInput>
  }

  export type BoardCommentContentModelUpdateWithWhereUniqueWithoutCommentInput = {
    where: BoardCommentContentModelWhereUniqueInput
    data: XOR<BoardCommentContentModelUpdateWithoutCommentInput, BoardCommentContentModelUncheckedUpdateWithoutCommentInput>
  }

  export type BoardCommentContentModelUpdateManyWithWhereWithoutCommentInput = {
    where: BoardCommentContentModelScalarWhereInput
    data: XOR<BoardCommentContentModelUpdateManyMutationInput, BoardCommentContentModelUncheckedUpdateManyWithoutContentsInput>
  }

  export type BoardCommentContentModelScalarWhereInput = {
    AND?: Enumerable<BoardCommentContentModelScalarWhereInput>
    OR?: Enumerable<BoardCommentContentModelScalarWhereInput>
    NOT?: Enumerable<BoardCommentContentModelScalarWhereInput>
    id?: StringFilter | string
    text?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    comment_id?: StringFilter | string
  }

  export type BoardCommentModelCreateWithoutContentsInput = {
    id: string
    author: UserModelCreateNestedOneWithoutBoard_commentsInput
    article: BoardArticleModelCreateNestedOneWithoutCommentsInput
  }

  export type BoardCommentModelUncheckedCreateWithoutContentsInput = {
    id: string
    author_id: string
    article_id: string
  }

  export type BoardCommentModelCreateOrConnectWithoutContentsInput = {
    where: BoardCommentModelWhereUniqueInput
    create: XOR<BoardCommentModelCreateWithoutContentsInput, BoardCommentModelUncheckedCreateWithoutContentsInput>
  }

  export type BoardCommentModelUpsertWithoutContentsInput = {
    update: XOR<BoardCommentModelUpdateWithoutContentsInput, BoardCommentModelUncheckedUpdateWithoutContentsInput>
    create: XOR<BoardCommentModelCreateWithoutContentsInput, BoardCommentModelUncheckedCreateWithoutContentsInput>
  }

  export type BoardCommentModelUpdateWithoutContentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    author?: UserModelUpdateOneRequiredWithoutBoard_commentsNestedInput
    article?: BoardArticleModelUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type BoardCommentModelUncheckedUpdateWithoutContentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
    article_id?: StringFieldUpdateOperationsInput | string
  }

  export type BoardArticleModelCreateManyAuthorInput = {
    id: string
    title: string
    board_id: string
  }

  export type BoardCommentModelCreateManyAuthorInput = {
    id: string
    article_id: string
  }

  export type BoardArticleModelUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    board?: BoardModelUpdateOneRequiredWithoutArticlesNestedInput
    contents?: BoardArticleContentModelUpdateManyWithoutArticleNestedInput
    comments?: BoardCommentModelUpdateManyWithoutArticleNestedInput
  }

  export type BoardArticleModelUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    board_id?: StringFieldUpdateOperationsInput | string
    contents?: BoardArticleContentModelUncheckedUpdateManyWithoutArticleNestedInput
    comments?: BoardCommentModelUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type BoardArticleModelUncheckedUpdateManyWithoutBoard_articlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    board_id?: StringFieldUpdateOperationsInput | string
  }

  export type BoardCommentModelUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    article?: BoardArticleModelUpdateOneRequiredWithoutCommentsNestedInput
    contents?: BoardCommentContentModelUpdateManyWithoutCommentNestedInput
  }

  export type BoardCommentModelUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    article_id?: StringFieldUpdateOperationsInput | string
    contents?: BoardCommentContentModelUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type BoardCommentModelUncheckedUpdateManyWithoutBoard_commentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    article_id?: StringFieldUpdateOperationsInput | string
  }

  export type AuthenticationModelCreateManyCustomerInput = {
    id: string
    oauth_sub: string
    oauth_type: string
    business_user_id?: string | null
  }

  export type BusinessRateModelCreateManyRaterInput = {
    id: string
    category_id: string
    ratee_id: string
    rate: number
  }

  export type BusinessReviewModelCreateManyReviewerInput = {
    id: string
    reviewee_id: string
    review: string
  }

  export type AuthenticationModelUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    oauth_sub?: StringFieldUpdateOperationsInput | string
    oauth_type?: StringFieldUpdateOperationsInput | string
    business_user?: BusinessUserModelUpdateOneWithoutAuthenticationsNestedInput
  }

  export type AuthenticationModelUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    oauth_sub?: StringFieldUpdateOperationsInput | string
    oauth_type?: StringFieldUpdateOperationsInput | string
    business_user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuthenticationModelUncheckedUpdateManyWithoutAuthenticationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    oauth_sub?: StringFieldUpdateOperationsInput | string
    oauth_type?: StringFieldUpdateOperationsInput | string
    business_user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusinessRateModelUpdateWithoutRaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    rate?: IntFieldUpdateOperationsInput | number
    ratee?: BusinessUserModelUpdateOneRequiredWithoutRatesNestedInput
    category?: BusinessRateCategoryModelUpdateOneRequiredWithoutRatesNestedInput
  }

  export type BusinessRateModelUncheckedUpdateWithoutRaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_id?: StringFieldUpdateOperationsInput | string
    ratee_id?: StringFieldUpdateOperationsInput | string
    rate?: IntFieldUpdateOperationsInput | number
  }

  export type BusinessRateModelUncheckedUpdateManyWithoutRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_id?: StringFieldUpdateOperationsInput | string
    ratee_id?: StringFieldUpdateOperationsInput | string
    rate?: IntFieldUpdateOperationsInput | number
  }

  export type BusinessReviewModelUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    review?: StringFieldUpdateOperationsInput | string
    reviewee?: BusinessUserModelUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type BusinessReviewModelUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewee_id?: StringFieldUpdateOperationsInput | string
    review?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessReviewModelUncheckedUpdateManyWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewee_id?: StringFieldUpdateOperationsInput | string
    review?: StringFieldUpdateOperationsInput | string
  }

  export type AuthenticationModelCreateManyBusiness_userInput = {
    id: string
    oauth_sub: string
    oauth_type: string
    customer_id?: string | null
  }

  export type BusinessRateModelCreateManyRateeInput = {
    id: string
    category_id: string
    rater_id: string
    rate: number
  }

  export type BusinessReviewModelCreateManyRevieweeInput = {
    id: string
    reviewer_id: string
    review: string
  }

  export type AuthenticationModelUpdateWithoutBusiness_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    oauth_sub?: StringFieldUpdateOperationsInput | string
    oauth_type?: StringFieldUpdateOperationsInput | string
    customer?: CustomerModelUpdateOneWithoutAuthenticationsNestedInput
  }

  export type AuthenticationModelUncheckedUpdateWithoutBusiness_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    oauth_sub?: StringFieldUpdateOperationsInput | string
    oauth_type?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusinessRateModelUpdateWithoutRateeInput = {
    id?: StringFieldUpdateOperationsInput | string
    rate?: IntFieldUpdateOperationsInput | number
    rater?: CustomerModelUpdateOneRequiredWithoutRatesNestedInput
    category?: BusinessRateCategoryModelUpdateOneRequiredWithoutRatesNestedInput
  }

  export type BusinessRateModelUncheckedUpdateWithoutRateeInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_id?: StringFieldUpdateOperationsInput | string
    rater_id?: StringFieldUpdateOperationsInput | string
    rate?: IntFieldUpdateOperationsInput | number
  }

  export type BusinessReviewModelUpdateWithoutRevieweeInput = {
    id?: StringFieldUpdateOperationsInput | string
    review?: StringFieldUpdateOperationsInput | string
    reviewer?: CustomerModelUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type BusinessReviewModelUncheckedUpdateWithoutRevieweeInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewer_id?: StringFieldUpdateOperationsInput | string
    review?: StringFieldUpdateOperationsInput | string
  }

  export type RealEstatePropertyModelCreateManyAgentInput = {
    id: string
    name: string
    main_image_url: string
  }

  export type RealEstatePropertyModelUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
  }

  export type RealEstatePropertyModelUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
  }

  export type RealEstatePropertyModelUncheckedUpdateManyWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
  }

  export type HomeCareIntroductionImageModelCreateManyCompanyInput = {
    id: string
    image_url: string
  }

  export type HomeCareIntroductionImageModelUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type HomeCareIntroductionImageModelUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type HomeCareIntroductionImageModelUncheckedUpdateManyWithoutIntroduction_imagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type HomeCareSpecializedSubFieldModelCreateManySuperInput = {
    id: string
    name: string
  }

  export type HomeCareSpecializedSubFieldModelUpdateWithoutSuperInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    home_care_companies?: HomeCareCompanyModelUpdateManyWithoutSpecialized_fieldNestedInput
  }

  export type HomeCareSpecializedSubFieldModelUncheckedUpdateWithoutSuperInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    home_care_companies?: HomeCareCompanyModelUncheckedUpdateManyWithoutSpecialized_fieldNestedInput
  }

  export type HomeCareSpecializedSubFieldModelUncheckedUpdateManyWithoutSubInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type HomeCareCompanyModelCreateManySpecialized_fieldInput = {
    id: string
    business_registration_num: string
  }

  export type HomeCareCompanyModelUpdateWithoutSpecialized_fieldInput = {
    business_registration_num?: StringFieldUpdateOperationsInput | string
    business?: BusinessUserModelUpdateOneRequiredWithoutHome_care_companyNestedInput
    introduction_images?: HomeCareIntroductionImageModelUpdateManyWithoutCompanyNestedInput
  }

  export type HomeCareCompanyModelUncheckedUpdateWithoutSpecialized_fieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    business_registration_num?: StringFieldUpdateOperationsInput | string
    introduction_images?: HomeCareIntroductionImageModelUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type HomeCareCompanyModelUncheckedUpdateManyWithoutHome_care_companiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    business_registration_num?: StringFieldUpdateOperationsInput | string
  }

  export type RealEstateSpecializedSubFieldModelCreateManySuperInput = {
    id: string
    name: string
  }

  export type RealEstateSpecializedSubFieldModelUpdateWithoutSuperInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    real_estate_agents?: RealEstateAgentModelUpdateManyWithoutSpecialized_fieldNestedInput
  }

  export type RealEstateSpecializedSubFieldModelUncheckedUpdateWithoutSuperInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    real_estate_agents?: RealEstateAgentModelUncheckedUpdateManyWithoutSpecialized_fieldNestedInput
  }

  export type RealEstateSpecializedSubFieldModelUncheckedUpdateManyWithoutSubInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RealEstateAgentModelCreateManySpecialized_fieldInput = {
    id: string
    is_licensed: boolean
    real_estate_num: string
    real_estate_name: string
    real_estate_phone: string
    licensed_agent_name: string
  }

  export type RealEstateAgentModelUpdateWithoutSpecialized_fieldInput = {
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    real_estate_num?: StringFieldUpdateOperationsInput | string
    real_estate_name?: StringFieldUpdateOperationsInput | string
    real_estate_phone?: StringFieldUpdateOperationsInput | string
    licensed_agent_name?: StringFieldUpdateOperationsInput | string
    business?: BusinessUserModelUpdateOneRequiredWithoutReal_estate_agentNestedInput
    properties?: RealEstatePropertyModelUpdateManyWithoutAgentNestedInput
  }

  export type RealEstateAgentModelUncheckedUpdateWithoutSpecialized_fieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    real_estate_num?: StringFieldUpdateOperationsInput | string
    real_estate_name?: StringFieldUpdateOperationsInput | string
    real_estate_phone?: StringFieldUpdateOperationsInput | string
    licensed_agent_name?: StringFieldUpdateOperationsInput | string
    properties?: RealEstatePropertyModelUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type RealEstateAgentModelUncheckedUpdateManyWithoutReal_estate_agentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    real_estate_num?: StringFieldUpdateOperationsInput | string
    real_estate_name?: StringFieldUpdateOperationsInput | string
    real_estate_phone?: StringFieldUpdateOperationsInput | string
    licensed_agent_name?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessRateModelCreateManyCategoryInput = {
    id: string
    ratee_id: string
    rater_id: string
    rate: number
  }

  export type BusinessRateModelUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    rate?: IntFieldUpdateOperationsInput | number
    ratee?: BusinessUserModelUpdateOneRequiredWithoutRatesNestedInput
    rater?: CustomerModelUpdateOneRequiredWithoutRatesNestedInput
  }

  export type BusinessRateModelUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    ratee_id?: StringFieldUpdateOperationsInput | string
    rater_id?: StringFieldUpdateOperationsInput | string
    rate?: IntFieldUpdateOperationsInput | number
  }

  export type BoardArticleModelCreateManyBoardInput = {
    id: string
    title: string
    author_id: string
  }

  export type BoardArticleModelUpdateWithoutBoardInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: UserModelUpdateOneRequiredWithoutBoard_articlesNestedInput
    contents?: BoardArticleContentModelUpdateManyWithoutArticleNestedInput
    comments?: BoardCommentModelUpdateManyWithoutArticleNestedInput
  }

  export type BoardArticleModelUncheckedUpdateWithoutBoardInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
    contents?: BoardArticleContentModelUncheckedUpdateManyWithoutArticleNestedInput
    comments?: BoardCommentModelUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type BoardArticleModelUncheckedUpdateManyWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
  }

  export type BoardArticleContentModelCreateManyArticleInput = {
    id: string
    text: string
    created_at: Date | string
  }

  export type BoardCommentModelCreateManyArticleInput = {
    id: string
    author_id: string
  }

  export type BoardArticleContentModelUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardArticleContentModelUncheckedUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardArticleContentModelUncheckedUpdateManyWithoutContentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardCommentModelUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    author?: UserModelUpdateOneRequiredWithoutBoard_commentsNestedInput
    contents?: BoardCommentContentModelUpdateManyWithoutCommentNestedInput
  }

  export type BoardCommentModelUncheckedUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
    contents?: BoardCommentContentModelUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type BoardCommentModelUncheckedUpdateManyWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
  }

  export type BoardCommentContentModelCreateManyCommentInput = {
    id: string
    text: string
    created_at: Date | string
  }

  export type BoardCommentContentModelUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardCommentContentModelUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardCommentContentModelUncheckedUpdateManyWithoutContentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}