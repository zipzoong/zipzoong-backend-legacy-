
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type REPropertyModelPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    re_agent: REAgentModelPayload<ExtArgs>
    categories: REPropertyCategoryModelPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    name: string
    main_image_url: string
    re_agent_id: string
    is_visible: boolean
  }, ExtArgs["result"]["rEPropertyModel"]>
  composites: {}
}

/**
 * Model REPropertyModel
 * 
 */
export type REPropertyModel = runtime.Types.DefaultSelection<REPropertyModelPayload>
export type REPropertyCategoryModelPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    re_property: REPropertyModelPayload<ExtArgs>
    sub_category: REPropertySubCategoryModelPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    re_property_id: string
    sub_category_id: string
  }, ExtArgs["result"]["rEPropertyCategoryModel"]>
  composites: {}
}

/**
 * Model REPropertyCategoryModel
 * 
 */
export type REPropertyCategoryModel = runtime.Types.DefaultSelection<REPropertyCategoryModelPayload>
export type REPropertySubCategoryModelPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    middle_category: REPropertyMiddleCategoryModelPayload<ExtArgs>
    property_categories: REPropertyCategoryModelPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    name: string
    middle_category_id: string
  }, ExtArgs["result"]["rEPropertySubCategoryModel"]>
  composites: {}
}

/**
 * Model REPropertySubCategoryModel
 * 
 */
export type REPropertySubCategoryModel = runtime.Types.DefaultSelection<REPropertySubCategoryModelPayload>
export type REPropertyMiddleCategoryModelPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    super_category: REPropertySuperCategoryModelPayload<ExtArgs>
    sub_categories: REPropertySubCategoryModelPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    name: string
    super_category_id: string
  }, ExtArgs["result"]["rEPropertyMiddleCategoryModel"]>
  composites: {}
}

/**
 * Model REPropertyMiddleCategoryModel
 * 
 */
export type REPropertyMiddleCategoryModel = runtime.Types.DefaultSelection<REPropertyMiddleCategoryModelPayload>
export type REPropertySuperCategoryModelPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    middle_categories: REPropertyMiddleCategoryModelPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    name: string
  }, ExtArgs["result"]["rEPropertySuperCategoryModel"]>
  composites: {}
}

/**
 * Model REPropertySuperCategoryModel
 * 
 */
export type REPropertySuperCategoryModel = runtime.Types.DefaultSelection<REPropertySuperCategoryModelPayload>
export type AgreementModelPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    acceptances: AgreementAcceptanceModelPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    title: string
    content: string
    is_required: boolean
    target_type: AgreementTargetType
  }, ExtArgs["result"]["agreementModel"]>
  composites: {}
}

/**
 * Model AgreementModel
 * 
 */
export type AgreementModel = runtime.Types.DefaultSelection<AgreementModelPayload>
export type AgreementAcceptanceModelPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user: UserModelPayload<ExtArgs>
    agreement: AgreementModelPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    user_id: string
    agreement_id: string
  }, ExtArgs["result"]["agreementAcceptanceModel"]>
  composites: {}
}

/**
 * Model AgreementAcceptanceModel
 * 
 */
export type AgreementAcceptanceModel = runtime.Types.DefaultSelection<AgreementAcceptanceModelPayload>
export type ServiceSubCategoryModelPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    super_category: ServiceSuperCategoryModelPayload<ExtArgs>
    expertises: SubExpertiseModelPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    name: string
    super_category_id: string
  }, ExtArgs["result"]["serviceSubCategoryModel"]>
  composites: {}
}

/**
 * Model ServiceSubCategoryModel
 * 
 */
export type ServiceSubCategoryModel = runtime.Types.DefaultSelection<ServiceSubCategoryModelPayload>
export type ServiceSuperCategoryModelPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    sub_categories: ServiceSubCategoryModelPayload<ExtArgs>[]
    focus_care_checks: ZipzoongCareServiceCheckModelPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    name: string
    type: ServiceType
  }, ExtArgs["result"]["serviceSuperCategoryModel"]>
  composites: {}
}

/**
 * Model ServiceSuperCategoryModel
 * 
 */
export type ServiceSuperCategoryModel = runtime.Types.DefaultSelection<ServiceSuperCategoryModelPayload>
export type ZipzoongCareRequestModelPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    requester: CustomerModelPayload<ExtArgs>
    consultation_time_checks: ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>[]
    service_checks: ZipzoongCareServiceCheckModelPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    care_start_date: Date
    care_end_date: Date
    detail: string
    status: ZipzoongCareStatus
    requester_id: string
  }, ExtArgs["result"]["zipzoongCareRequestModel"]>
  composites: {}
}

/**
 * Model ZipzoongCareRequestModel
 * 
 */
export type ZipzoongCareRequestModel = runtime.Types.DefaultSelection<ZipzoongCareRequestModelPayload>
export type ZipzoongCareServiceCheckModelPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    service_super_category: ServiceSuperCategoryModelPayload<ExtArgs>
    request: ZipzoongCareRequestModelPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    service_super_category_id: string
    request_id: string
  }, ExtArgs["result"]["zipzoongCareServiceCheckModel"]>
  composites: {}
}

/**
 * Model ZipzoongCareServiceCheckModel
 * 
 */
export type ZipzoongCareServiceCheckModel = runtime.Types.DefaultSelection<ZipzoongCareServiceCheckModelPayload>
export type ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    request: ZipzoongCareRequestModelPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    start_time: Date
    end_time: Date
    request_id: string
  }, ExtArgs["result"]["zipzoongCareConsultationTimeCheckModel"]>
  composites: {}
}

/**
 * Model ZipzoongCareConsultationTimeCheckModel
 * 
 */
export type ZipzoongCareConsultationTimeCheckModel = runtime.Types.DefaultSelection<ZipzoongCareConsultationTimeCheckModelPayload>
export type UserModelPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    customer: CustomerModelPayload<ExtArgs> | null
    business_user: BusinessUserModelPayload<ExtArgs> | null
    agreement_acceptances: AgreementAcceptanceModelPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    name: string
    email: string | null
  }, ExtArgs["result"]["userModel"]>
  composites: {}
}

/**
 * Model UserModel
 * 
 */
export type UserModel = runtime.Types.DefaultSelection<UserModelPayload>
export type CustomerModelPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    base: UserModelPayload<ExtArgs>
    oauth_accounts: OauthAccountModelPayload<ExtArgs>[]
    zipzoong_care_requests: ZipzoongCareRequestModelPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    birth: string | null
    gender: GenderType | null
    phone: string | null
    address_first: string | null
    address_second: string | null
    profile_image_url: string | null
  }, ExtArgs["result"]["customerModel"]>
  composites: {}
}

/**
 * Model CustomerModel
 * 
 */
export type CustomerModel = runtime.Types.DefaultSelection<CustomerModelPayload>
export type BusinessUserModelPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    base: UserModelPayload<ExtArgs>
    re_agent: REAgentModelPayload<ExtArgs> | null
    hs_provider: HSProviderModelPayload<ExtArgs> | null
    certification_images: BusinessCertificationImageModelPayload<ExtArgs>[]
    sub_expertises: SubExpertiseModelPayload<ExtArgs>[]
    oauth_accounts: OauthAccountModelPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second: string | null
    profile_image_url: string
  }, ExtArgs["result"]["businessUserModel"]>
  composites: {}
}

/**
 * Model BusinessUserModel
 * 
 */
export type BusinessUserModel = runtime.Types.DefaultSelection<BusinessUserModelPayload>
export type SubExpertiseModelPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    sub_category: ServiceSubCategoryModelPayload<ExtArgs>
    business_user: BusinessUserModelPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    sub_category_id: string
    business_user_id: string
  }, ExtArgs["result"]["subExpertiseModel"]>
  composites: {}
}

/**
 * Model SubExpertiseModel
 * 
 */
export type SubExpertiseModel = runtime.Types.DefaultSelection<SubExpertiseModelPayload>
export type REAgentModelPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    base: BusinessUserModelPayload<ExtArgs>
    properties: REPropertyModelPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    is_licensed: boolean
    re_num: string
    re_name: string
    re_phone: string
    re_licensed_agent_name: string
  }, ExtArgs["result"]["rEAgentModel"]>
  composites: {}
}

/**
 * Model REAgentModel
 * 
 */
export type REAgentModel = runtime.Types.DefaultSelection<REAgentModelPayload>
export type HSProviderModelPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    base: BusinessUserModelPayload<ExtArgs>
    example_images: HSExampleImageModelPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    business_registration_num: string
  }, ExtArgs["result"]["hSProviderModel"]>
  composites: {}
}

/**
 * Model HSProviderModel
 * 
 */
export type HSProviderModel = runtime.Types.DefaultSelection<HSProviderModelPayload>
export type BusinessCertificationImageModelPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    business_user: BusinessUserModelPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    business_user_id: string
    url: string
  }, ExtArgs["result"]["businessCertificationImageModel"]>
  composites: {}
}

/**
 * Model BusinessCertificationImageModel
 * 
 */
export type BusinessCertificationImageModel = runtime.Types.DefaultSelection<BusinessCertificationImageModelPayload>
export type HSExampleImageModelPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    hs_provider: HSProviderModelPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    hs_provider_id: string
    url: string
    is_visible: boolean
  }, ExtArgs["result"]["hSExampleImageModel"]>
  composites: {}
}

/**
 * Model HSExampleImageModel
 * 
 */
export type HSExampleImageModel = runtime.Types.DefaultSelection<HSExampleImageModelPayload>
export type OauthAccountModelPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    business_user: BusinessUserModelPayload<ExtArgs> | null
    customer: CustomerModelPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    oauth_type: OauthType
    oauth_sub: string
    business_user_id: string | null
    customer_id: string | null
    name: string | null
    email: string | null
    phone: string | null
    profile_image_url: string | null
    birth: string | null
    gender: GenderType | null
    address_first: string | null
    address_second: string | null
  }, ExtArgs["result"]["oauthAccountModel"]>
  composites: {}
}

/**
 * Model OauthAccountModel
 * 
 */
export type OauthAccountModel = runtime.Types.DefaultSelection<OauthAccountModelPayload>
export type PhoneVerificationModelPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    phone: string
    code: string
    request_id: string
    is_verified: boolean
  }, ExtArgs["result"]["phoneVerificationModel"]>
  composites: {}
}

/**
 * Model PhoneVerificationModel
 * 
 */
export type PhoneVerificationModel = runtime.Types.DefaultSelection<PhoneVerificationModelPayload>

/**
 * Enums
 */

export const AgreementTargetType: {
  all: 'all',
  customer: 'customer',
  business: 'business',
  HS: 'HS',
  RE: 'RE'
};

export type AgreementTargetType = (typeof AgreementTargetType)[keyof typeof AgreementTargetType]


export const ServiceType: {
  HS: 'HS',
  RE: 'RE'
};

export type ServiceType = (typeof ServiceType)[keyof typeof ServiceType]


export const ZipzoongCareStatus: {
  pending: 'pending',
  caring: 'caring',
  cared: 'cared',
  cancelled: 'cancelled'
};

export type ZipzoongCareStatus = (typeof ZipzoongCareStatus)[keyof typeof ZipzoongCareStatus]


export const GenderType: {
  female: 'female',
  male: 'male',
  other: 'other'
};

export type GenderType = (typeof GenderType)[keyof typeof GenderType]


export const OauthType: {
  kakao: 'kakao',
  naver: 'naver'
};

export type OauthType = (typeof OauthType)[keyof typeof OauthType]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more REPropertyModels
 * const rEPropertyModels = await prisma.rEPropertyModel.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more REPropertyModels
   * const rEPropertyModels = await prisma.rEPropertyModel.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.rEPropertyModel`: Exposes CRUD operations for the **REPropertyModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more REPropertyModels
    * const rEPropertyModels = await prisma.rEPropertyModel.findMany()
    * ```
    */
  get rEPropertyModel(): Prisma.REPropertyModelDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.rEPropertyCategoryModel`: Exposes CRUD operations for the **REPropertyCategoryModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more REPropertyCategoryModels
    * const rEPropertyCategoryModels = await prisma.rEPropertyCategoryModel.findMany()
    * ```
    */
  get rEPropertyCategoryModel(): Prisma.REPropertyCategoryModelDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.rEPropertySubCategoryModel`: Exposes CRUD operations for the **REPropertySubCategoryModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more REPropertySubCategoryModels
    * const rEPropertySubCategoryModels = await prisma.rEPropertySubCategoryModel.findMany()
    * ```
    */
  get rEPropertySubCategoryModel(): Prisma.REPropertySubCategoryModelDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.rEPropertyMiddleCategoryModel`: Exposes CRUD operations for the **REPropertyMiddleCategoryModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more REPropertyMiddleCategoryModels
    * const rEPropertyMiddleCategoryModels = await prisma.rEPropertyMiddleCategoryModel.findMany()
    * ```
    */
  get rEPropertyMiddleCategoryModel(): Prisma.REPropertyMiddleCategoryModelDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.rEPropertySuperCategoryModel`: Exposes CRUD operations for the **REPropertySuperCategoryModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more REPropertySuperCategoryModels
    * const rEPropertySuperCategoryModels = await prisma.rEPropertySuperCategoryModel.findMany()
    * ```
    */
  get rEPropertySuperCategoryModel(): Prisma.REPropertySuperCategoryModelDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.agreementModel`: Exposes CRUD operations for the **AgreementModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgreementModels
    * const agreementModels = await prisma.agreementModel.findMany()
    * ```
    */
  get agreementModel(): Prisma.AgreementModelDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.agreementAcceptanceModel`: Exposes CRUD operations for the **AgreementAcceptanceModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgreementAcceptanceModels
    * const agreementAcceptanceModels = await prisma.agreementAcceptanceModel.findMany()
    * ```
    */
  get agreementAcceptanceModel(): Prisma.AgreementAcceptanceModelDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.serviceSubCategoryModel`: Exposes CRUD operations for the **ServiceSubCategoryModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceSubCategoryModels
    * const serviceSubCategoryModels = await prisma.serviceSubCategoryModel.findMany()
    * ```
    */
  get serviceSubCategoryModel(): Prisma.ServiceSubCategoryModelDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.serviceSuperCategoryModel`: Exposes CRUD operations for the **ServiceSuperCategoryModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceSuperCategoryModels
    * const serviceSuperCategoryModels = await prisma.serviceSuperCategoryModel.findMany()
    * ```
    */
  get serviceSuperCategoryModel(): Prisma.ServiceSuperCategoryModelDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.zipzoongCareRequestModel`: Exposes CRUD operations for the **ZipzoongCareRequestModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ZipzoongCareRequestModels
    * const zipzoongCareRequestModels = await prisma.zipzoongCareRequestModel.findMany()
    * ```
    */
  get zipzoongCareRequestModel(): Prisma.ZipzoongCareRequestModelDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.zipzoongCareServiceCheckModel`: Exposes CRUD operations for the **ZipzoongCareServiceCheckModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ZipzoongCareServiceCheckModels
    * const zipzoongCareServiceCheckModels = await prisma.zipzoongCareServiceCheckModel.findMany()
    * ```
    */
  get zipzoongCareServiceCheckModel(): Prisma.ZipzoongCareServiceCheckModelDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.zipzoongCareConsultationTimeCheckModel`: Exposes CRUD operations for the **ZipzoongCareConsultationTimeCheckModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ZipzoongCareConsultationTimeCheckModels
    * const zipzoongCareConsultationTimeCheckModels = await prisma.zipzoongCareConsultationTimeCheckModel.findMany()
    * ```
    */
  get zipzoongCareConsultationTimeCheckModel(): Prisma.ZipzoongCareConsultationTimeCheckModelDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.userModel`: Exposes CRUD operations for the **UserModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserModels
    * const userModels = await prisma.userModel.findMany()
    * ```
    */
  get userModel(): Prisma.UserModelDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.customerModel`: Exposes CRUD operations for the **CustomerModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerModels
    * const customerModels = await prisma.customerModel.findMany()
    * ```
    */
  get customerModel(): Prisma.CustomerModelDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.businessUserModel`: Exposes CRUD operations for the **BusinessUserModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessUserModels
    * const businessUserModels = await prisma.businessUserModel.findMany()
    * ```
    */
  get businessUserModel(): Prisma.BusinessUserModelDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.subExpertiseModel`: Exposes CRUD operations for the **SubExpertiseModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubExpertiseModels
    * const subExpertiseModels = await prisma.subExpertiseModel.findMany()
    * ```
    */
  get subExpertiseModel(): Prisma.SubExpertiseModelDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.rEAgentModel`: Exposes CRUD operations for the **REAgentModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more REAgentModels
    * const rEAgentModels = await prisma.rEAgentModel.findMany()
    * ```
    */
  get rEAgentModel(): Prisma.REAgentModelDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.hSProviderModel`: Exposes CRUD operations for the **HSProviderModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HSProviderModels
    * const hSProviderModels = await prisma.hSProviderModel.findMany()
    * ```
    */
  get hSProviderModel(): Prisma.HSProviderModelDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.businessCertificationImageModel`: Exposes CRUD operations for the **BusinessCertificationImageModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessCertificationImageModels
    * const businessCertificationImageModels = await prisma.businessCertificationImageModel.findMany()
    * ```
    */
  get businessCertificationImageModel(): Prisma.BusinessCertificationImageModelDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.hSExampleImageModel`: Exposes CRUD operations for the **HSExampleImageModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HSExampleImageModels
    * const hSExampleImageModels = await prisma.hSExampleImageModel.findMany()
    * ```
    */
  get hSExampleImageModel(): Prisma.HSExampleImageModelDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.oauthAccountModel`: Exposes CRUD operations for the **OauthAccountModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OauthAccountModels
    * const oauthAccountModels = await prisma.oauthAccountModel.findMany()
    * ```
    */
  get oauthAccountModel(): Prisma.OauthAccountModelDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.phoneVerificationModel`: Exposes CRUD operations for the **PhoneVerificationModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhoneVerificationModels
    * const phoneVerificationModels = await prisma.phoneVerificationModel.findMany()
    * ```
    */
  get phoneVerificationModel(): Prisma.PhoneVerificationModelDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.16.1
   * Query Engine version: b20ead4d3ab9e78ac112966e242ded703f4a052c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    REPropertyModel: 'REPropertyModel',
    REPropertyCategoryModel: 'REPropertyCategoryModel',
    REPropertySubCategoryModel: 'REPropertySubCategoryModel',
    REPropertyMiddleCategoryModel: 'REPropertyMiddleCategoryModel',
    REPropertySuperCategoryModel: 'REPropertySuperCategoryModel',
    AgreementModel: 'AgreementModel',
    AgreementAcceptanceModel: 'AgreementAcceptanceModel',
    ServiceSubCategoryModel: 'ServiceSubCategoryModel',
    ServiceSuperCategoryModel: 'ServiceSuperCategoryModel',
    ZipzoongCareRequestModel: 'ZipzoongCareRequestModel',
    ZipzoongCareServiceCheckModel: 'ZipzoongCareServiceCheckModel',
    ZipzoongCareConsultationTimeCheckModel: 'ZipzoongCareConsultationTimeCheckModel',
    UserModel: 'UserModel',
    CustomerModel: 'CustomerModel',
    BusinessUserModel: 'BusinessUserModel',
    SubExpertiseModel: 'SubExpertiseModel',
    REAgentModel: 'REAgentModel',
    HSProviderModel: 'HSProviderModel',
    BusinessCertificationImageModel: 'BusinessCertificationImageModel',
    HSExampleImageModel: 'HSExampleImageModel',
    OauthAccountModel: 'OauthAccountModel',
    PhoneVerificationModel: 'PhoneVerificationModel'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    database?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'rEPropertyModel' | 'rEPropertyCategoryModel' | 'rEPropertySubCategoryModel' | 'rEPropertyMiddleCategoryModel' | 'rEPropertySuperCategoryModel' | 'agreementModel' | 'agreementAcceptanceModel' | 'serviceSubCategoryModel' | 'serviceSuperCategoryModel' | 'zipzoongCareRequestModel' | 'zipzoongCareServiceCheckModel' | 'zipzoongCareConsultationTimeCheckModel' | 'userModel' | 'customerModel' | 'businessUserModel' | 'subExpertiseModel' | 'rEAgentModel' | 'hSProviderModel' | 'businessCertificationImageModel' | 'hSExampleImageModel' | 'oauthAccountModel' | 'phoneVerificationModel'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      REPropertyModel: {
        operations: {
          findUnique: {
            args: Prisma.REPropertyModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyModelPayload> | null
            payload: REPropertyModelPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.REPropertyModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyModelPayload>
            payload: REPropertyModelPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.REPropertyModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyModelPayload> | null
            payload: REPropertyModelPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.REPropertyModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyModelPayload>
            payload: REPropertyModelPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.REPropertyModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyModelPayload>[]
            payload: REPropertyModelPayload<ExtArgs>
          }
          create: {
            args: Prisma.REPropertyModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyModelPayload>
            payload: REPropertyModelPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.REPropertyModelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: REPropertyModelPayload<ExtArgs>
          }
          delete: {
            args: Prisma.REPropertyModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyModelPayload>
            payload: REPropertyModelPayload<ExtArgs>
          }
          update: {
            args: Prisma.REPropertyModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyModelPayload>
            payload: REPropertyModelPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.REPropertyModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: REPropertyModelPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.REPropertyModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: REPropertyModelPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.REPropertyModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyModelPayload>
            payload: REPropertyModelPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.REPropertyModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateREPropertyModel>
            payload: REPropertyModelPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.REPropertyModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<REPropertyModelGroupByOutputType>[]
            payload: REPropertyModelPayload<ExtArgs>
          }
          count: {
            args: Prisma.REPropertyModelCountArgs<ExtArgs>,
            result: $Utils.Optional<REPropertyModelCountAggregateOutputType> | number
            payload: REPropertyModelPayload<ExtArgs>
          }
        }
      }
      REPropertyCategoryModel: {
        operations: {
          findUnique: {
            args: Prisma.REPropertyCategoryModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyCategoryModelPayload> | null
            payload: REPropertyCategoryModelPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.REPropertyCategoryModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyCategoryModelPayload>
            payload: REPropertyCategoryModelPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.REPropertyCategoryModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyCategoryModelPayload> | null
            payload: REPropertyCategoryModelPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.REPropertyCategoryModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyCategoryModelPayload>
            payload: REPropertyCategoryModelPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.REPropertyCategoryModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyCategoryModelPayload>[]
            payload: REPropertyCategoryModelPayload<ExtArgs>
          }
          create: {
            args: Prisma.REPropertyCategoryModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyCategoryModelPayload>
            payload: REPropertyCategoryModelPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.REPropertyCategoryModelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: REPropertyCategoryModelPayload<ExtArgs>
          }
          delete: {
            args: Prisma.REPropertyCategoryModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyCategoryModelPayload>
            payload: REPropertyCategoryModelPayload<ExtArgs>
          }
          update: {
            args: Prisma.REPropertyCategoryModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyCategoryModelPayload>
            payload: REPropertyCategoryModelPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.REPropertyCategoryModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: REPropertyCategoryModelPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.REPropertyCategoryModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: REPropertyCategoryModelPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.REPropertyCategoryModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyCategoryModelPayload>
            payload: REPropertyCategoryModelPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.REPropertyCategoryModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateREPropertyCategoryModel>
            payload: REPropertyCategoryModelPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.REPropertyCategoryModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<REPropertyCategoryModelGroupByOutputType>[]
            payload: REPropertyCategoryModelPayload<ExtArgs>
          }
          count: {
            args: Prisma.REPropertyCategoryModelCountArgs<ExtArgs>,
            result: $Utils.Optional<REPropertyCategoryModelCountAggregateOutputType> | number
            payload: REPropertyCategoryModelPayload<ExtArgs>
          }
        }
      }
      REPropertySubCategoryModel: {
        operations: {
          findUnique: {
            args: Prisma.REPropertySubCategoryModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertySubCategoryModelPayload> | null
            payload: REPropertySubCategoryModelPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.REPropertySubCategoryModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertySubCategoryModelPayload>
            payload: REPropertySubCategoryModelPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.REPropertySubCategoryModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertySubCategoryModelPayload> | null
            payload: REPropertySubCategoryModelPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.REPropertySubCategoryModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertySubCategoryModelPayload>
            payload: REPropertySubCategoryModelPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.REPropertySubCategoryModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertySubCategoryModelPayload>[]
            payload: REPropertySubCategoryModelPayload<ExtArgs>
          }
          create: {
            args: Prisma.REPropertySubCategoryModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertySubCategoryModelPayload>
            payload: REPropertySubCategoryModelPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.REPropertySubCategoryModelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: REPropertySubCategoryModelPayload<ExtArgs>
          }
          delete: {
            args: Prisma.REPropertySubCategoryModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertySubCategoryModelPayload>
            payload: REPropertySubCategoryModelPayload<ExtArgs>
          }
          update: {
            args: Prisma.REPropertySubCategoryModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertySubCategoryModelPayload>
            payload: REPropertySubCategoryModelPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.REPropertySubCategoryModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: REPropertySubCategoryModelPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.REPropertySubCategoryModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: REPropertySubCategoryModelPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.REPropertySubCategoryModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertySubCategoryModelPayload>
            payload: REPropertySubCategoryModelPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.REPropertySubCategoryModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateREPropertySubCategoryModel>
            payload: REPropertySubCategoryModelPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.REPropertySubCategoryModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<REPropertySubCategoryModelGroupByOutputType>[]
            payload: REPropertySubCategoryModelPayload<ExtArgs>
          }
          count: {
            args: Prisma.REPropertySubCategoryModelCountArgs<ExtArgs>,
            result: $Utils.Optional<REPropertySubCategoryModelCountAggregateOutputType> | number
            payload: REPropertySubCategoryModelPayload<ExtArgs>
          }
        }
      }
      REPropertyMiddleCategoryModel: {
        operations: {
          findUnique: {
            args: Prisma.REPropertyMiddleCategoryModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyMiddleCategoryModelPayload> | null
            payload: REPropertyMiddleCategoryModelPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.REPropertyMiddleCategoryModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyMiddleCategoryModelPayload>
            payload: REPropertyMiddleCategoryModelPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.REPropertyMiddleCategoryModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyMiddleCategoryModelPayload> | null
            payload: REPropertyMiddleCategoryModelPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.REPropertyMiddleCategoryModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyMiddleCategoryModelPayload>
            payload: REPropertyMiddleCategoryModelPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.REPropertyMiddleCategoryModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyMiddleCategoryModelPayload>[]
            payload: REPropertyMiddleCategoryModelPayload<ExtArgs>
          }
          create: {
            args: Prisma.REPropertyMiddleCategoryModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyMiddleCategoryModelPayload>
            payload: REPropertyMiddleCategoryModelPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.REPropertyMiddleCategoryModelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: REPropertyMiddleCategoryModelPayload<ExtArgs>
          }
          delete: {
            args: Prisma.REPropertyMiddleCategoryModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyMiddleCategoryModelPayload>
            payload: REPropertyMiddleCategoryModelPayload<ExtArgs>
          }
          update: {
            args: Prisma.REPropertyMiddleCategoryModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyMiddleCategoryModelPayload>
            payload: REPropertyMiddleCategoryModelPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.REPropertyMiddleCategoryModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: REPropertyMiddleCategoryModelPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.REPropertyMiddleCategoryModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: REPropertyMiddleCategoryModelPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.REPropertyMiddleCategoryModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertyMiddleCategoryModelPayload>
            payload: REPropertyMiddleCategoryModelPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.REPropertyMiddleCategoryModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateREPropertyMiddleCategoryModel>
            payload: REPropertyMiddleCategoryModelPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.REPropertyMiddleCategoryModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<REPropertyMiddleCategoryModelGroupByOutputType>[]
            payload: REPropertyMiddleCategoryModelPayload<ExtArgs>
          }
          count: {
            args: Prisma.REPropertyMiddleCategoryModelCountArgs<ExtArgs>,
            result: $Utils.Optional<REPropertyMiddleCategoryModelCountAggregateOutputType> | number
            payload: REPropertyMiddleCategoryModelPayload<ExtArgs>
          }
        }
      }
      REPropertySuperCategoryModel: {
        operations: {
          findUnique: {
            args: Prisma.REPropertySuperCategoryModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertySuperCategoryModelPayload> | null
            payload: REPropertySuperCategoryModelPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.REPropertySuperCategoryModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertySuperCategoryModelPayload>
            payload: REPropertySuperCategoryModelPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.REPropertySuperCategoryModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertySuperCategoryModelPayload> | null
            payload: REPropertySuperCategoryModelPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.REPropertySuperCategoryModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertySuperCategoryModelPayload>
            payload: REPropertySuperCategoryModelPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.REPropertySuperCategoryModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertySuperCategoryModelPayload>[]
            payload: REPropertySuperCategoryModelPayload<ExtArgs>
          }
          create: {
            args: Prisma.REPropertySuperCategoryModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertySuperCategoryModelPayload>
            payload: REPropertySuperCategoryModelPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.REPropertySuperCategoryModelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: REPropertySuperCategoryModelPayload<ExtArgs>
          }
          delete: {
            args: Prisma.REPropertySuperCategoryModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertySuperCategoryModelPayload>
            payload: REPropertySuperCategoryModelPayload<ExtArgs>
          }
          update: {
            args: Prisma.REPropertySuperCategoryModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertySuperCategoryModelPayload>
            payload: REPropertySuperCategoryModelPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.REPropertySuperCategoryModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: REPropertySuperCategoryModelPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.REPropertySuperCategoryModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: REPropertySuperCategoryModelPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.REPropertySuperCategoryModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REPropertySuperCategoryModelPayload>
            payload: REPropertySuperCategoryModelPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.REPropertySuperCategoryModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateREPropertySuperCategoryModel>
            payload: REPropertySuperCategoryModelPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.REPropertySuperCategoryModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<REPropertySuperCategoryModelGroupByOutputType>[]
            payload: REPropertySuperCategoryModelPayload<ExtArgs>
          }
          count: {
            args: Prisma.REPropertySuperCategoryModelCountArgs<ExtArgs>,
            result: $Utils.Optional<REPropertySuperCategoryModelCountAggregateOutputType> | number
            payload: REPropertySuperCategoryModelPayload<ExtArgs>
          }
        }
      }
      AgreementModel: {
        operations: {
          findUnique: {
            args: Prisma.AgreementModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementModelPayload> | null
            payload: AgreementModelPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.AgreementModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementModelPayload>
            payload: AgreementModelPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.AgreementModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementModelPayload> | null
            payload: AgreementModelPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.AgreementModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementModelPayload>
            payload: AgreementModelPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.AgreementModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementModelPayload>[]
            payload: AgreementModelPayload<ExtArgs>
          }
          create: {
            args: Prisma.AgreementModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementModelPayload>
            payload: AgreementModelPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.AgreementModelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: AgreementModelPayload<ExtArgs>
          }
          delete: {
            args: Prisma.AgreementModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementModelPayload>
            payload: AgreementModelPayload<ExtArgs>
          }
          update: {
            args: Prisma.AgreementModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementModelPayload>
            payload: AgreementModelPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.AgreementModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: AgreementModelPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.AgreementModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: AgreementModelPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.AgreementModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementModelPayload>
            payload: AgreementModelPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.AgreementModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAgreementModel>
            payload: AgreementModelPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.AgreementModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AgreementModelGroupByOutputType>[]
            payload: AgreementModelPayload<ExtArgs>
          }
          count: {
            args: Prisma.AgreementModelCountArgs<ExtArgs>,
            result: $Utils.Optional<AgreementModelCountAggregateOutputType> | number
            payload: AgreementModelPayload<ExtArgs>
          }
        }
      }
      AgreementAcceptanceModel: {
        operations: {
          findUnique: {
            args: Prisma.AgreementAcceptanceModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementAcceptanceModelPayload> | null
            payload: AgreementAcceptanceModelPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.AgreementAcceptanceModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementAcceptanceModelPayload>
            payload: AgreementAcceptanceModelPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.AgreementAcceptanceModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementAcceptanceModelPayload> | null
            payload: AgreementAcceptanceModelPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.AgreementAcceptanceModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementAcceptanceModelPayload>
            payload: AgreementAcceptanceModelPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.AgreementAcceptanceModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementAcceptanceModelPayload>[]
            payload: AgreementAcceptanceModelPayload<ExtArgs>
          }
          create: {
            args: Prisma.AgreementAcceptanceModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementAcceptanceModelPayload>
            payload: AgreementAcceptanceModelPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.AgreementAcceptanceModelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: AgreementAcceptanceModelPayload<ExtArgs>
          }
          delete: {
            args: Prisma.AgreementAcceptanceModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementAcceptanceModelPayload>
            payload: AgreementAcceptanceModelPayload<ExtArgs>
          }
          update: {
            args: Prisma.AgreementAcceptanceModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementAcceptanceModelPayload>
            payload: AgreementAcceptanceModelPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.AgreementAcceptanceModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: AgreementAcceptanceModelPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.AgreementAcceptanceModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: AgreementAcceptanceModelPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.AgreementAcceptanceModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementAcceptanceModelPayload>
            payload: AgreementAcceptanceModelPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.AgreementAcceptanceModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAgreementAcceptanceModel>
            payload: AgreementAcceptanceModelPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.AgreementAcceptanceModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AgreementAcceptanceModelGroupByOutputType>[]
            payload: AgreementAcceptanceModelPayload<ExtArgs>
          }
          count: {
            args: Prisma.AgreementAcceptanceModelCountArgs<ExtArgs>,
            result: $Utils.Optional<AgreementAcceptanceModelCountAggregateOutputType> | number
            payload: AgreementAcceptanceModelPayload<ExtArgs>
          }
        }
      }
      ServiceSubCategoryModel: {
        operations: {
          findUnique: {
            args: Prisma.ServiceSubCategoryModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubCategoryModelPayload> | null
            payload: ServiceSubCategoryModelPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceSubCategoryModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubCategoryModelPayload>
            payload: ServiceSubCategoryModelPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.ServiceSubCategoryModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubCategoryModelPayload> | null
            payload: ServiceSubCategoryModelPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.ServiceSubCategoryModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubCategoryModelPayload>
            payload: ServiceSubCategoryModelPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.ServiceSubCategoryModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubCategoryModelPayload>[]
            payload: ServiceSubCategoryModelPayload<ExtArgs>
          }
          create: {
            args: Prisma.ServiceSubCategoryModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubCategoryModelPayload>
            payload: ServiceSubCategoryModelPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.ServiceSubCategoryModelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ServiceSubCategoryModelPayload<ExtArgs>
          }
          delete: {
            args: Prisma.ServiceSubCategoryModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubCategoryModelPayload>
            payload: ServiceSubCategoryModelPayload<ExtArgs>
          }
          update: {
            args: Prisma.ServiceSubCategoryModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubCategoryModelPayload>
            payload: ServiceSubCategoryModelPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.ServiceSubCategoryModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ServiceSubCategoryModelPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.ServiceSubCategoryModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ServiceSubCategoryModelPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.ServiceSubCategoryModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSubCategoryModelPayload>
            payload: ServiceSubCategoryModelPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.ServiceSubCategoryModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServiceSubCategoryModel>
            payload: ServiceSubCategoryModelPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.ServiceSubCategoryModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServiceSubCategoryModelGroupByOutputType>[]
            payload: ServiceSubCategoryModelPayload<ExtArgs>
          }
          count: {
            args: Prisma.ServiceSubCategoryModelCountArgs<ExtArgs>,
            result: $Utils.Optional<ServiceSubCategoryModelCountAggregateOutputType> | number
            payload: ServiceSubCategoryModelPayload<ExtArgs>
          }
        }
      }
      ServiceSuperCategoryModel: {
        operations: {
          findUnique: {
            args: Prisma.ServiceSuperCategoryModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSuperCategoryModelPayload> | null
            payload: ServiceSuperCategoryModelPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceSuperCategoryModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSuperCategoryModelPayload>
            payload: ServiceSuperCategoryModelPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.ServiceSuperCategoryModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSuperCategoryModelPayload> | null
            payload: ServiceSuperCategoryModelPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.ServiceSuperCategoryModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSuperCategoryModelPayload>
            payload: ServiceSuperCategoryModelPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.ServiceSuperCategoryModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSuperCategoryModelPayload>[]
            payload: ServiceSuperCategoryModelPayload<ExtArgs>
          }
          create: {
            args: Prisma.ServiceSuperCategoryModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSuperCategoryModelPayload>
            payload: ServiceSuperCategoryModelPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.ServiceSuperCategoryModelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ServiceSuperCategoryModelPayload<ExtArgs>
          }
          delete: {
            args: Prisma.ServiceSuperCategoryModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSuperCategoryModelPayload>
            payload: ServiceSuperCategoryModelPayload<ExtArgs>
          }
          update: {
            args: Prisma.ServiceSuperCategoryModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSuperCategoryModelPayload>
            payload: ServiceSuperCategoryModelPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.ServiceSuperCategoryModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ServiceSuperCategoryModelPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.ServiceSuperCategoryModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ServiceSuperCategoryModelPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.ServiceSuperCategoryModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ServiceSuperCategoryModelPayload>
            payload: ServiceSuperCategoryModelPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.ServiceSuperCategoryModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServiceSuperCategoryModel>
            payload: ServiceSuperCategoryModelPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.ServiceSuperCategoryModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServiceSuperCategoryModelGroupByOutputType>[]
            payload: ServiceSuperCategoryModelPayload<ExtArgs>
          }
          count: {
            args: Prisma.ServiceSuperCategoryModelCountArgs<ExtArgs>,
            result: $Utils.Optional<ServiceSuperCategoryModelCountAggregateOutputType> | number
            payload: ServiceSuperCategoryModelPayload<ExtArgs>
          }
        }
      }
      ZipzoongCareRequestModel: {
        operations: {
          findUnique: {
            args: Prisma.ZipzoongCareRequestModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareRequestModelPayload> | null
            payload: ZipzoongCareRequestModelPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.ZipzoongCareRequestModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareRequestModelPayload>
            payload: ZipzoongCareRequestModelPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.ZipzoongCareRequestModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareRequestModelPayload> | null
            payload: ZipzoongCareRequestModelPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.ZipzoongCareRequestModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareRequestModelPayload>
            payload: ZipzoongCareRequestModelPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.ZipzoongCareRequestModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareRequestModelPayload>[]
            payload: ZipzoongCareRequestModelPayload<ExtArgs>
          }
          create: {
            args: Prisma.ZipzoongCareRequestModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareRequestModelPayload>
            payload: ZipzoongCareRequestModelPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.ZipzoongCareRequestModelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ZipzoongCareRequestModelPayload<ExtArgs>
          }
          delete: {
            args: Prisma.ZipzoongCareRequestModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareRequestModelPayload>
            payload: ZipzoongCareRequestModelPayload<ExtArgs>
          }
          update: {
            args: Prisma.ZipzoongCareRequestModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareRequestModelPayload>
            payload: ZipzoongCareRequestModelPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.ZipzoongCareRequestModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ZipzoongCareRequestModelPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.ZipzoongCareRequestModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ZipzoongCareRequestModelPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.ZipzoongCareRequestModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareRequestModelPayload>
            payload: ZipzoongCareRequestModelPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.ZipzoongCareRequestModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZipzoongCareRequestModel>
            payload: ZipzoongCareRequestModelPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.ZipzoongCareRequestModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ZipzoongCareRequestModelGroupByOutputType>[]
            payload: ZipzoongCareRequestModelPayload<ExtArgs>
          }
          count: {
            args: Prisma.ZipzoongCareRequestModelCountArgs<ExtArgs>,
            result: $Utils.Optional<ZipzoongCareRequestModelCountAggregateOutputType> | number
            payload: ZipzoongCareRequestModelPayload<ExtArgs>
          }
        }
      }
      ZipzoongCareServiceCheckModel: {
        operations: {
          findUnique: {
            args: Prisma.ZipzoongCareServiceCheckModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareServiceCheckModelPayload> | null
            payload: ZipzoongCareServiceCheckModelPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.ZipzoongCareServiceCheckModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareServiceCheckModelPayload>
            payload: ZipzoongCareServiceCheckModelPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.ZipzoongCareServiceCheckModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareServiceCheckModelPayload> | null
            payload: ZipzoongCareServiceCheckModelPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.ZipzoongCareServiceCheckModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareServiceCheckModelPayload>
            payload: ZipzoongCareServiceCheckModelPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.ZipzoongCareServiceCheckModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareServiceCheckModelPayload>[]
            payload: ZipzoongCareServiceCheckModelPayload<ExtArgs>
          }
          create: {
            args: Prisma.ZipzoongCareServiceCheckModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareServiceCheckModelPayload>
            payload: ZipzoongCareServiceCheckModelPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.ZipzoongCareServiceCheckModelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ZipzoongCareServiceCheckModelPayload<ExtArgs>
          }
          delete: {
            args: Prisma.ZipzoongCareServiceCheckModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareServiceCheckModelPayload>
            payload: ZipzoongCareServiceCheckModelPayload<ExtArgs>
          }
          update: {
            args: Prisma.ZipzoongCareServiceCheckModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareServiceCheckModelPayload>
            payload: ZipzoongCareServiceCheckModelPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.ZipzoongCareServiceCheckModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ZipzoongCareServiceCheckModelPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.ZipzoongCareServiceCheckModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ZipzoongCareServiceCheckModelPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.ZipzoongCareServiceCheckModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareServiceCheckModelPayload>
            payload: ZipzoongCareServiceCheckModelPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.ZipzoongCareServiceCheckModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZipzoongCareServiceCheckModel>
            payload: ZipzoongCareServiceCheckModelPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.ZipzoongCareServiceCheckModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ZipzoongCareServiceCheckModelGroupByOutputType>[]
            payload: ZipzoongCareServiceCheckModelPayload<ExtArgs>
          }
          count: {
            args: Prisma.ZipzoongCareServiceCheckModelCountArgs<ExtArgs>,
            result: $Utils.Optional<ZipzoongCareServiceCheckModelCountAggregateOutputType> | number
            payload: ZipzoongCareServiceCheckModelPayload<ExtArgs>
          }
        }
      }
      ZipzoongCareConsultationTimeCheckModel: {
        operations: {
          findUnique: {
            args: Prisma.ZipzoongCareConsultationTimeCheckModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareConsultationTimeCheckModelPayload> | null
            payload: ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.ZipzoongCareConsultationTimeCheckModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareConsultationTimeCheckModelPayload>
            payload: ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.ZipzoongCareConsultationTimeCheckModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareConsultationTimeCheckModelPayload> | null
            payload: ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.ZipzoongCareConsultationTimeCheckModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareConsultationTimeCheckModelPayload>
            payload: ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.ZipzoongCareConsultationTimeCheckModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareConsultationTimeCheckModelPayload>[]
            payload: ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>
          }
          create: {
            args: Prisma.ZipzoongCareConsultationTimeCheckModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareConsultationTimeCheckModelPayload>
            payload: ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.ZipzoongCareConsultationTimeCheckModelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>
          }
          delete: {
            args: Prisma.ZipzoongCareConsultationTimeCheckModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareConsultationTimeCheckModelPayload>
            payload: ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>
          }
          update: {
            args: Prisma.ZipzoongCareConsultationTimeCheckModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareConsultationTimeCheckModelPayload>
            payload: ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.ZipzoongCareConsultationTimeCheckModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.ZipzoongCareConsultationTimeCheckModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.ZipzoongCareConsultationTimeCheckModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ZipzoongCareConsultationTimeCheckModelPayload>
            payload: ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.ZipzoongCareConsultationTimeCheckModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZipzoongCareConsultationTimeCheckModel>
            payload: ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.ZipzoongCareConsultationTimeCheckModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ZipzoongCareConsultationTimeCheckModelGroupByOutputType>[]
            payload: ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>
          }
          count: {
            args: Prisma.ZipzoongCareConsultationTimeCheckModelCountArgs<ExtArgs>,
            result: $Utils.Optional<ZipzoongCareConsultationTimeCheckModelCountAggregateOutputType> | number
            payload: ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>
          }
        }
      }
      UserModel: {
        operations: {
          findUnique: {
            args: Prisma.UserModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserModelPayload> | null
            payload: UserModelPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.UserModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserModelPayload>
            payload: UserModelPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.UserModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserModelPayload> | null
            payload: UserModelPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.UserModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserModelPayload>
            payload: UserModelPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.UserModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserModelPayload>[]
            payload: UserModelPayload<ExtArgs>
          }
          create: {
            args: Prisma.UserModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserModelPayload>
            payload: UserModelPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.UserModelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: UserModelPayload<ExtArgs>
          }
          delete: {
            args: Prisma.UserModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserModelPayload>
            payload: UserModelPayload<ExtArgs>
          }
          update: {
            args: Prisma.UserModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserModelPayload>
            payload: UserModelPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.UserModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: UserModelPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.UserModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: UserModelPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.UserModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserModelPayload>
            payload: UserModelPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.UserModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserModel>
            payload: UserModelPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.UserModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserModelGroupByOutputType>[]
            payload: UserModelPayload<ExtArgs>
          }
          count: {
            args: Prisma.UserModelCountArgs<ExtArgs>,
            result: $Utils.Optional<UserModelCountAggregateOutputType> | number
            payload: UserModelPayload<ExtArgs>
          }
        }
      }
      CustomerModel: {
        operations: {
          findUnique: {
            args: Prisma.CustomerModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CustomerModelPayload> | null
            payload: CustomerModelPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CustomerModelPayload>
            payload: CustomerModelPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.CustomerModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CustomerModelPayload> | null
            payload: CustomerModelPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.CustomerModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CustomerModelPayload>
            payload: CustomerModelPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.CustomerModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CustomerModelPayload>[]
            payload: CustomerModelPayload<ExtArgs>
          }
          create: {
            args: Prisma.CustomerModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CustomerModelPayload>
            payload: CustomerModelPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.CustomerModelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: CustomerModelPayload<ExtArgs>
          }
          delete: {
            args: Prisma.CustomerModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CustomerModelPayload>
            payload: CustomerModelPayload<ExtArgs>
          }
          update: {
            args: Prisma.CustomerModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CustomerModelPayload>
            payload: CustomerModelPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.CustomerModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: CustomerModelPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.CustomerModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: CustomerModelPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.CustomerModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CustomerModelPayload>
            payload: CustomerModelPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.CustomerModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCustomerModel>
            payload: CustomerModelPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.CustomerModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CustomerModelGroupByOutputType>[]
            payload: CustomerModelPayload<ExtArgs>
          }
          count: {
            args: Prisma.CustomerModelCountArgs<ExtArgs>,
            result: $Utils.Optional<CustomerModelCountAggregateOutputType> | number
            payload: CustomerModelPayload<ExtArgs>
          }
        }
      }
      BusinessUserModel: {
        operations: {
          findUnique: {
            args: Prisma.BusinessUserModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessUserModelPayload> | null
            payload: BusinessUserModelPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessUserModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessUserModelPayload>
            payload: BusinessUserModelPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.BusinessUserModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessUserModelPayload> | null
            payload: BusinessUserModelPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.BusinessUserModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessUserModelPayload>
            payload: BusinessUserModelPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.BusinessUserModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessUserModelPayload>[]
            payload: BusinessUserModelPayload<ExtArgs>
          }
          create: {
            args: Prisma.BusinessUserModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessUserModelPayload>
            payload: BusinessUserModelPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.BusinessUserModelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: BusinessUserModelPayload<ExtArgs>
          }
          delete: {
            args: Prisma.BusinessUserModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessUserModelPayload>
            payload: BusinessUserModelPayload<ExtArgs>
          }
          update: {
            args: Prisma.BusinessUserModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessUserModelPayload>
            payload: BusinessUserModelPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.BusinessUserModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: BusinessUserModelPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.BusinessUserModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: BusinessUserModelPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.BusinessUserModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessUserModelPayload>
            payload: BusinessUserModelPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.BusinessUserModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBusinessUserModel>
            payload: BusinessUserModelPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.BusinessUserModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BusinessUserModelGroupByOutputType>[]
            payload: BusinessUserModelPayload<ExtArgs>
          }
          count: {
            args: Prisma.BusinessUserModelCountArgs<ExtArgs>,
            result: $Utils.Optional<BusinessUserModelCountAggregateOutputType> | number
            payload: BusinessUserModelPayload<ExtArgs>
          }
        }
      }
      SubExpertiseModel: {
        operations: {
          findUnique: {
            args: Prisma.SubExpertiseModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubExpertiseModelPayload> | null
            payload: SubExpertiseModelPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.SubExpertiseModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubExpertiseModelPayload>
            payload: SubExpertiseModelPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.SubExpertiseModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubExpertiseModelPayload> | null
            payload: SubExpertiseModelPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.SubExpertiseModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubExpertiseModelPayload>
            payload: SubExpertiseModelPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.SubExpertiseModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubExpertiseModelPayload>[]
            payload: SubExpertiseModelPayload<ExtArgs>
          }
          create: {
            args: Prisma.SubExpertiseModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubExpertiseModelPayload>
            payload: SubExpertiseModelPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.SubExpertiseModelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: SubExpertiseModelPayload<ExtArgs>
          }
          delete: {
            args: Prisma.SubExpertiseModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubExpertiseModelPayload>
            payload: SubExpertiseModelPayload<ExtArgs>
          }
          update: {
            args: Prisma.SubExpertiseModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubExpertiseModelPayload>
            payload: SubExpertiseModelPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.SubExpertiseModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: SubExpertiseModelPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.SubExpertiseModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: SubExpertiseModelPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.SubExpertiseModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubExpertiseModelPayload>
            payload: SubExpertiseModelPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.SubExpertiseModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSubExpertiseModel>
            payload: SubExpertiseModelPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.SubExpertiseModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SubExpertiseModelGroupByOutputType>[]
            payload: SubExpertiseModelPayload<ExtArgs>
          }
          count: {
            args: Prisma.SubExpertiseModelCountArgs<ExtArgs>,
            result: $Utils.Optional<SubExpertiseModelCountAggregateOutputType> | number
            payload: SubExpertiseModelPayload<ExtArgs>
          }
        }
      }
      REAgentModel: {
        operations: {
          findUnique: {
            args: Prisma.REAgentModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REAgentModelPayload> | null
            payload: REAgentModelPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.REAgentModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REAgentModelPayload>
            payload: REAgentModelPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.REAgentModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REAgentModelPayload> | null
            payload: REAgentModelPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.REAgentModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REAgentModelPayload>
            payload: REAgentModelPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.REAgentModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REAgentModelPayload>[]
            payload: REAgentModelPayload<ExtArgs>
          }
          create: {
            args: Prisma.REAgentModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REAgentModelPayload>
            payload: REAgentModelPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.REAgentModelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: REAgentModelPayload<ExtArgs>
          }
          delete: {
            args: Prisma.REAgentModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REAgentModelPayload>
            payload: REAgentModelPayload<ExtArgs>
          }
          update: {
            args: Prisma.REAgentModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REAgentModelPayload>
            payload: REAgentModelPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.REAgentModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: REAgentModelPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.REAgentModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: REAgentModelPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.REAgentModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<REAgentModelPayload>
            payload: REAgentModelPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.REAgentModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateREAgentModel>
            payload: REAgentModelPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.REAgentModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<REAgentModelGroupByOutputType>[]
            payload: REAgentModelPayload<ExtArgs>
          }
          count: {
            args: Prisma.REAgentModelCountArgs<ExtArgs>,
            result: $Utils.Optional<REAgentModelCountAggregateOutputType> | number
            payload: REAgentModelPayload<ExtArgs>
          }
        }
      }
      HSProviderModel: {
        operations: {
          findUnique: {
            args: Prisma.HSProviderModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HSProviderModelPayload> | null
            payload: HSProviderModelPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.HSProviderModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HSProviderModelPayload>
            payload: HSProviderModelPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.HSProviderModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HSProviderModelPayload> | null
            payload: HSProviderModelPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.HSProviderModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HSProviderModelPayload>
            payload: HSProviderModelPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.HSProviderModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HSProviderModelPayload>[]
            payload: HSProviderModelPayload<ExtArgs>
          }
          create: {
            args: Prisma.HSProviderModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HSProviderModelPayload>
            payload: HSProviderModelPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.HSProviderModelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: HSProviderModelPayload<ExtArgs>
          }
          delete: {
            args: Prisma.HSProviderModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HSProviderModelPayload>
            payload: HSProviderModelPayload<ExtArgs>
          }
          update: {
            args: Prisma.HSProviderModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HSProviderModelPayload>
            payload: HSProviderModelPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.HSProviderModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: HSProviderModelPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.HSProviderModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: HSProviderModelPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.HSProviderModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HSProviderModelPayload>
            payload: HSProviderModelPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.HSProviderModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHSProviderModel>
            payload: HSProviderModelPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.HSProviderModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HSProviderModelGroupByOutputType>[]
            payload: HSProviderModelPayload<ExtArgs>
          }
          count: {
            args: Prisma.HSProviderModelCountArgs<ExtArgs>,
            result: $Utils.Optional<HSProviderModelCountAggregateOutputType> | number
            payload: HSProviderModelPayload<ExtArgs>
          }
        }
      }
      BusinessCertificationImageModel: {
        operations: {
          findUnique: {
            args: Prisma.BusinessCertificationImageModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessCertificationImageModelPayload> | null
            payload: BusinessCertificationImageModelPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessCertificationImageModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessCertificationImageModelPayload>
            payload: BusinessCertificationImageModelPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.BusinessCertificationImageModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessCertificationImageModelPayload> | null
            payload: BusinessCertificationImageModelPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.BusinessCertificationImageModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessCertificationImageModelPayload>
            payload: BusinessCertificationImageModelPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.BusinessCertificationImageModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessCertificationImageModelPayload>[]
            payload: BusinessCertificationImageModelPayload<ExtArgs>
          }
          create: {
            args: Prisma.BusinessCertificationImageModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessCertificationImageModelPayload>
            payload: BusinessCertificationImageModelPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.BusinessCertificationImageModelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: BusinessCertificationImageModelPayload<ExtArgs>
          }
          delete: {
            args: Prisma.BusinessCertificationImageModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessCertificationImageModelPayload>
            payload: BusinessCertificationImageModelPayload<ExtArgs>
          }
          update: {
            args: Prisma.BusinessCertificationImageModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessCertificationImageModelPayload>
            payload: BusinessCertificationImageModelPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.BusinessCertificationImageModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: BusinessCertificationImageModelPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.BusinessCertificationImageModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: BusinessCertificationImageModelPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.BusinessCertificationImageModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusinessCertificationImageModelPayload>
            payload: BusinessCertificationImageModelPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.BusinessCertificationImageModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBusinessCertificationImageModel>
            payload: BusinessCertificationImageModelPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.BusinessCertificationImageModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BusinessCertificationImageModelGroupByOutputType>[]
            payload: BusinessCertificationImageModelPayload<ExtArgs>
          }
          count: {
            args: Prisma.BusinessCertificationImageModelCountArgs<ExtArgs>,
            result: $Utils.Optional<BusinessCertificationImageModelCountAggregateOutputType> | number
            payload: BusinessCertificationImageModelPayload<ExtArgs>
          }
        }
      }
      HSExampleImageModel: {
        operations: {
          findUnique: {
            args: Prisma.HSExampleImageModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HSExampleImageModelPayload> | null
            payload: HSExampleImageModelPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.HSExampleImageModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HSExampleImageModelPayload>
            payload: HSExampleImageModelPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.HSExampleImageModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HSExampleImageModelPayload> | null
            payload: HSExampleImageModelPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.HSExampleImageModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HSExampleImageModelPayload>
            payload: HSExampleImageModelPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.HSExampleImageModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HSExampleImageModelPayload>[]
            payload: HSExampleImageModelPayload<ExtArgs>
          }
          create: {
            args: Prisma.HSExampleImageModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HSExampleImageModelPayload>
            payload: HSExampleImageModelPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.HSExampleImageModelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: HSExampleImageModelPayload<ExtArgs>
          }
          delete: {
            args: Prisma.HSExampleImageModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HSExampleImageModelPayload>
            payload: HSExampleImageModelPayload<ExtArgs>
          }
          update: {
            args: Prisma.HSExampleImageModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HSExampleImageModelPayload>
            payload: HSExampleImageModelPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.HSExampleImageModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: HSExampleImageModelPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.HSExampleImageModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: HSExampleImageModelPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.HSExampleImageModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HSExampleImageModelPayload>
            payload: HSExampleImageModelPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.HSExampleImageModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHSExampleImageModel>
            payload: HSExampleImageModelPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.HSExampleImageModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HSExampleImageModelGroupByOutputType>[]
            payload: HSExampleImageModelPayload<ExtArgs>
          }
          count: {
            args: Prisma.HSExampleImageModelCountArgs<ExtArgs>,
            result: $Utils.Optional<HSExampleImageModelCountAggregateOutputType> | number
            payload: HSExampleImageModelPayload<ExtArgs>
          }
        }
      }
      OauthAccountModel: {
        operations: {
          findUnique: {
            args: Prisma.OauthAccountModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OauthAccountModelPayload> | null
            payload: OauthAccountModelPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.OauthAccountModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OauthAccountModelPayload>
            payload: OauthAccountModelPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.OauthAccountModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OauthAccountModelPayload> | null
            payload: OauthAccountModelPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.OauthAccountModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OauthAccountModelPayload>
            payload: OauthAccountModelPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.OauthAccountModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OauthAccountModelPayload>[]
            payload: OauthAccountModelPayload<ExtArgs>
          }
          create: {
            args: Prisma.OauthAccountModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OauthAccountModelPayload>
            payload: OauthAccountModelPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.OauthAccountModelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: OauthAccountModelPayload<ExtArgs>
          }
          delete: {
            args: Prisma.OauthAccountModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OauthAccountModelPayload>
            payload: OauthAccountModelPayload<ExtArgs>
          }
          update: {
            args: Prisma.OauthAccountModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OauthAccountModelPayload>
            payload: OauthAccountModelPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.OauthAccountModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: OauthAccountModelPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.OauthAccountModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: OauthAccountModelPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.OauthAccountModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OauthAccountModelPayload>
            payload: OauthAccountModelPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.OauthAccountModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOauthAccountModel>
            payload: OauthAccountModelPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.OauthAccountModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OauthAccountModelGroupByOutputType>[]
            payload: OauthAccountModelPayload<ExtArgs>
          }
          count: {
            args: Prisma.OauthAccountModelCountArgs<ExtArgs>,
            result: $Utils.Optional<OauthAccountModelCountAggregateOutputType> | number
            payload: OauthAccountModelPayload<ExtArgs>
          }
        }
      }
      PhoneVerificationModel: {
        operations: {
          findUnique: {
            args: Prisma.PhoneVerificationModelFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PhoneVerificationModelPayload> | null
            payload: PhoneVerificationModelPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.PhoneVerificationModelFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PhoneVerificationModelPayload>
            payload: PhoneVerificationModelPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.PhoneVerificationModelFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PhoneVerificationModelPayload> | null
            payload: PhoneVerificationModelPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.PhoneVerificationModelFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PhoneVerificationModelPayload>
            payload: PhoneVerificationModelPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.PhoneVerificationModelFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PhoneVerificationModelPayload>[]
            payload: PhoneVerificationModelPayload<ExtArgs>
          }
          create: {
            args: Prisma.PhoneVerificationModelCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PhoneVerificationModelPayload>
            payload: PhoneVerificationModelPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.PhoneVerificationModelCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: PhoneVerificationModelPayload<ExtArgs>
          }
          delete: {
            args: Prisma.PhoneVerificationModelDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PhoneVerificationModelPayload>
            payload: PhoneVerificationModelPayload<ExtArgs>
          }
          update: {
            args: Prisma.PhoneVerificationModelUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PhoneVerificationModelPayload>
            payload: PhoneVerificationModelPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.PhoneVerificationModelDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: PhoneVerificationModelPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.PhoneVerificationModelUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: PhoneVerificationModelPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.PhoneVerificationModelUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PhoneVerificationModelPayload>
            payload: PhoneVerificationModelPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.PhoneVerificationModelAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePhoneVerificationModel>
            payload: PhoneVerificationModelPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.PhoneVerificationModelGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PhoneVerificationModelGroupByOutputType>[]
            payload: PhoneVerificationModelPayload<ExtArgs>
          }
          count: {
            args: Prisma.PhoneVerificationModelCountArgs<ExtArgs>,
            result: $Utils.Optional<PhoneVerificationModelCountAggregateOutputType> | number
            payload: PhoneVerificationModelPayload<ExtArgs>
          }
        }
      }
    }
  } & {
    other: {
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
          payload: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
          payload: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
          payload: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
          payload: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type REPropertyModelCountOutputType
   */


  export type REPropertyModelCountOutputType = {
    categories: number
  }

  export type REPropertyModelCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    categories?: boolean | REPropertyModelCountOutputTypeCountCategoriesArgs
  }

  // Custom InputTypes

  /**
   * REPropertyModelCountOutputType without action
   */
  export type REPropertyModelCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyModelCountOutputType
     */
    select?: REPropertyModelCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * REPropertyModelCountOutputType without action
   */
  export type REPropertyModelCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: REPropertyCategoryModelWhereInput
  }



  /**
   * Count Type REPropertySubCategoryModelCountOutputType
   */


  export type REPropertySubCategoryModelCountOutputType = {
    property_categories: number
  }

  export type REPropertySubCategoryModelCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    property_categories?: boolean | REPropertySubCategoryModelCountOutputTypeCountProperty_categoriesArgs
  }

  // Custom InputTypes

  /**
   * REPropertySubCategoryModelCountOutputType without action
   */
  export type REPropertySubCategoryModelCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertySubCategoryModelCountOutputType
     */
    select?: REPropertySubCategoryModelCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * REPropertySubCategoryModelCountOutputType without action
   */
  export type REPropertySubCategoryModelCountOutputTypeCountProperty_categoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: REPropertyCategoryModelWhereInput
  }



  /**
   * Count Type REPropertyMiddleCategoryModelCountOutputType
   */


  export type REPropertyMiddleCategoryModelCountOutputType = {
    sub_categories: number
  }

  export type REPropertyMiddleCategoryModelCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    sub_categories?: boolean | REPropertyMiddleCategoryModelCountOutputTypeCountSub_categoriesArgs
  }

  // Custom InputTypes

  /**
   * REPropertyMiddleCategoryModelCountOutputType without action
   */
  export type REPropertyMiddleCategoryModelCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyMiddleCategoryModelCountOutputType
     */
    select?: REPropertyMiddleCategoryModelCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * REPropertyMiddleCategoryModelCountOutputType without action
   */
  export type REPropertyMiddleCategoryModelCountOutputTypeCountSub_categoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: REPropertySubCategoryModelWhereInput
  }



  /**
   * Count Type REPropertySuperCategoryModelCountOutputType
   */


  export type REPropertySuperCategoryModelCountOutputType = {
    middle_categories: number
  }

  export type REPropertySuperCategoryModelCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    middle_categories?: boolean | REPropertySuperCategoryModelCountOutputTypeCountMiddle_categoriesArgs
  }

  // Custom InputTypes

  /**
   * REPropertySuperCategoryModelCountOutputType without action
   */
  export type REPropertySuperCategoryModelCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertySuperCategoryModelCountOutputType
     */
    select?: REPropertySuperCategoryModelCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * REPropertySuperCategoryModelCountOutputType without action
   */
  export type REPropertySuperCategoryModelCountOutputTypeCountMiddle_categoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: REPropertyMiddleCategoryModelWhereInput
  }



  /**
   * Count Type AgreementModelCountOutputType
   */


  export type AgreementModelCountOutputType = {
    acceptances: number
  }

  export type AgreementModelCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    acceptances?: boolean | AgreementModelCountOutputTypeCountAcceptancesArgs
  }

  // Custom InputTypes

  /**
   * AgreementModelCountOutputType without action
   */
  export type AgreementModelCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementModelCountOutputType
     */
    select?: AgreementModelCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AgreementModelCountOutputType without action
   */
  export type AgreementModelCountOutputTypeCountAcceptancesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AgreementAcceptanceModelWhereInput
  }



  /**
   * Count Type ServiceSubCategoryModelCountOutputType
   */


  export type ServiceSubCategoryModelCountOutputType = {
    expertises: number
  }

  export type ServiceSubCategoryModelCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    expertises?: boolean | ServiceSubCategoryModelCountOutputTypeCountExpertisesArgs
  }

  // Custom InputTypes

  /**
   * ServiceSubCategoryModelCountOutputType without action
   */
  export type ServiceSubCategoryModelCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubCategoryModelCountOutputType
     */
    select?: ServiceSubCategoryModelCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ServiceSubCategoryModelCountOutputType without action
   */
  export type ServiceSubCategoryModelCountOutputTypeCountExpertisesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SubExpertiseModelWhereInput
  }



  /**
   * Count Type ServiceSuperCategoryModelCountOutputType
   */


  export type ServiceSuperCategoryModelCountOutputType = {
    sub_categories: number
    focus_care_checks: number
  }

  export type ServiceSuperCategoryModelCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    sub_categories?: boolean | ServiceSuperCategoryModelCountOutputTypeCountSub_categoriesArgs
    focus_care_checks?: boolean | ServiceSuperCategoryModelCountOutputTypeCountFocus_care_checksArgs
  }

  // Custom InputTypes

  /**
   * ServiceSuperCategoryModelCountOutputType without action
   */
  export type ServiceSuperCategoryModelCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSuperCategoryModelCountOutputType
     */
    select?: ServiceSuperCategoryModelCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ServiceSuperCategoryModelCountOutputType without action
   */
  export type ServiceSuperCategoryModelCountOutputTypeCountSub_categoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceSubCategoryModelWhereInput
  }


  /**
   * ServiceSuperCategoryModelCountOutputType without action
   */
  export type ServiceSuperCategoryModelCountOutputTypeCountFocus_care_checksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ZipzoongCareServiceCheckModelWhereInput
  }



  /**
   * Count Type ZipzoongCareRequestModelCountOutputType
   */


  export type ZipzoongCareRequestModelCountOutputType = {
    consultation_time_checks: number
    service_checks: number
  }

  export type ZipzoongCareRequestModelCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    consultation_time_checks?: boolean | ZipzoongCareRequestModelCountOutputTypeCountConsultation_time_checksArgs
    service_checks?: boolean | ZipzoongCareRequestModelCountOutputTypeCountService_checksArgs
  }

  // Custom InputTypes

  /**
   * ZipzoongCareRequestModelCountOutputType without action
   */
  export type ZipzoongCareRequestModelCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareRequestModelCountOutputType
     */
    select?: ZipzoongCareRequestModelCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ZipzoongCareRequestModelCountOutputType without action
   */
  export type ZipzoongCareRequestModelCountOutputTypeCountConsultation_time_checksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ZipzoongCareConsultationTimeCheckModelWhereInput
  }


  /**
   * ZipzoongCareRequestModelCountOutputType without action
   */
  export type ZipzoongCareRequestModelCountOutputTypeCountService_checksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ZipzoongCareServiceCheckModelWhereInput
  }



  /**
   * Count Type UserModelCountOutputType
   */


  export type UserModelCountOutputType = {
    agreement_acceptances: number
  }

  export type UserModelCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    agreement_acceptances?: boolean | UserModelCountOutputTypeCountAgreement_acceptancesArgs
  }

  // Custom InputTypes

  /**
   * UserModelCountOutputType without action
   */
  export type UserModelCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModelCountOutputType
     */
    select?: UserModelCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserModelCountOutputType without action
   */
  export type UserModelCountOutputTypeCountAgreement_acceptancesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AgreementAcceptanceModelWhereInput
  }



  /**
   * Count Type CustomerModelCountOutputType
   */


  export type CustomerModelCountOutputType = {
    oauth_accounts: number
    zipzoong_care_requests: number
  }

  export type CustomerModelCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    oauth_accounts?: boolean | CustomerModelCountOutputTypeCountOauth_accountsArgs
    zipzoong_care_requests?: boolean | CustomerModelCountOutputTypeCountZipzoong_care_requestsArgs
  }

  // Custom InputTypes

  /**
   * CustomerModelCountOutputType without action
   */
  export type CustomerModelCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerModelCountOutputType
     */
    select?: CustomerModelCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CustomerModelCountOutputType without action
   */
  export type CustomerModelCountOutputTypeCountOauth_accountsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OauthAccountModelWhereInput
  }


  /**
   * CustomerModelCountOutputType without action
   */
  export type CustomerModelCountOutputTypeCountZipzoong_care_requestsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ZipzoongCareRequestModelWhereInput
  }



  /**
   * Count Type BusinessUserModelCountOutputType
   */


  export type BusinessUserModelCountOutputType = {
    certification_images: number
    sub_expertises: number
    oauth_accounts: number
  }

  export type BusinessUserModelCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    certification_images?: boolean | BusinessUserModelCountOutputTypeCountCertification_imagesArgs
    sub_expertises?: boolean | BusinessUserModelCountOutputTypeCountSub_expertisesArgs
    oauth_accounts?: boolean | BusinessUserModelCountOutputTypeCountOauth_accountsArgs
  }

  // Custom InputTypes

  /**
   * BusinessUserModelCountOutputType without action
   */
  export type BusinessUserModelCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUserModelCountOutputType
     */
    select?: BusinessUserModelCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BusinessUserModelCountOutputType without action
   */
  export type BusinessUserModelCountOutputTypeCountCertification_imagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BusinessCertificationImageModelWhereInput
  }


  /**
   * BusinessUserModelCountOutputType without action
   */
  export type BusinessUserModelCountOutputTypeCountSub_expertisesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SubExpertiseModelWhereInput
  }


  /**
   * BusinessUserModelCountOutputType without action
   */
  export type BusinessUserModelCountOutputTypeCountOauth_accountsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OauthAccountModelWhereInput
  }



  /**
   * Count Type REAgentModelCountOutputType
   */


  export type REAgentModelCountOutputType = {
    properties: number
  }

  export type REAgentModelCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    properties?: boolean | REAgentModelCountOutputTypeCountPropertiesArgs
  }

  // Custom InputTypes

  /**
   * REAgentModelCountOutputType without action
   */
  export type REAgentModelCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REAgentModelCountOutputType
     */
    select?: REAgentModelCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * REAgentModelCountOutputType without action
   */
  export type REAgentModelCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: REPropertyModelWhereInput
  }



  /**
   * Count Type HSProviderModelCountOutputType
   */


  export type HSProviderModelCountOutputType = {
    example_images: number
  }

  export type HSProviderModelCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    example_images?: boolean | HSProviderModelCountOutputTypeCountExample_imagesArgs
  }

  // Custom InputTypes

  /**
   * HSProviderModelCountOutputType without action
   */
  export type HSProviderModelCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HSProviderModelCountOutputType
     */
    select?: HSProviderModelCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * HSProviderModelCountOutputType without action
   */
  export type HSProviderModelCountOutputTypeCountExample_imagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: HSExampleImageModelWhereInput
  }



  /**
   * Models
   */

  /**
   * Model REPropertyModel
   */


  export type AggregateREPropertyModel = {
    _count: REPropertyModelCountAggregateOutputType | null
    _min: REPropertyModelMinAggregateOutputType | null
    _max: REPropertyModelMaxAggregateOutputType | null
  }

  export type REPropertyModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    main_image_url: string | null
    re_agent_id: string | null
    is_visible: boolean | null
  }

  export type REPropertyModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    main_image_url: string | null
    re_agent_id: string | null
    is_visible: boolean | null
  }

  export type REPropertyModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    name: number
    main_image_url: number
    re_agent_id: number
    is_visible: number
    _all: number
  }


  export type REPropertyModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    main_image_url?: true
    re_agent_id?: true
    is_visible?: true
  }

  export type REPropertyModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    main_image_url?: true
    re_agent_id?: true
    is_visible?: true
  }

  export type REPropertyModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    main_image_url?: true
    re_agent_id?: true
    is_visible?: true
    _all?: true
  }

  export type REPropertyModelAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which REPropertyModel to aggregate.
     */
    where?: REPropertyModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertyModels to fetch.
     */
    orderBy?: Enumerable<REPropertyModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: REPropertyModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertyModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertyModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned REPropertyModels
    **/
    _count?: true | REPropertyModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: REPropertyModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: REPropertyModelMaxAggregateInputType
  }

  export type GetREPropertyModelAggregateType<T extends REPropertyModelAggregateArgs> = {
        [P in keyof T & keyof AggregateREPropertyModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateREPropertyModel[P]>
      : GetScalarType<T[P], AggregateREPropertyModel[P]>
  }




  export type REPropertyModelGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: REPropertyModelWhereInput
    orderBy?: Enumerable<REPropertyModelOrderByWithAggregationInput>
    by: REPropertyModelScalarFieldEnum[]
    having?: REPropertyModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: REPropertyModelCountAggregateInputType | true
    _min?: REPropertyModelMinAggregateInputType
    _max?: REPropertyModelMaxAggregateInputType
  }


  export type REPropertyModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    name: string
    main_image_url: string
    re_agent_id: string
    is_visible: boolean
    _count: REPropertyModelCountAggregateOutputType | null
    _min: REPropertyModelMinAggregateOutputType | null
    _max: REPropertyModelMaxAggregateOutputType | null
  }

  type GetREPropertyModelGroupByPayload<T extends REPropertyModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<REPropertyModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof REPropertyModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], REPropertyModelGroupByOutputType[P]>
            : GetScalarType<T[P], REPropertyModelGroupByOutputType[P]>
        }
      >
    >


  export type REPropertyModelSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    name?: boolean
    main_image_url?: boolean
    re_agent_id?: boolean
    is_visible?: boolean
    re_agent?: boolean | REAgentModelArgs<ExtArgs>
    categories?: boolean | REPropertyModel$categoriesArgs<ExtArgs>
    _count?: boolean | REPropertyModelCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["rEPropertyModel"]>

  export type REPropertyModelSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    name?: boolean
    main_image_url?: boolean
    re_agent_id?: boolean
    is_visible?: boolean
  }

  export type REPropertyModelInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    re_agent?: boolean | REAgentModelArgs<ExtArgs>
    categories?: boolean | REPropertyModel$categoriesArgs<ExtArgs>
    _count?: boolean | REPropertyModelCountOutputTypeArgs<ExtArgs>
  }


  type REPropertyModelGetPayload<S extends boolean | null | undefined | REPropertyModelArgs> = $Types.GetResult<REPropertyModelPayload, S>

  type REPropertyModelCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<REPropertyModelFindManyArgs, 'select' | 'include'> & {
      select?: REPropertyModelCountAggregateInputType | true
    }

  export interface REPropertyModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['REPropertyModel'], meta: { name: 'REPropertyModel' } }
    /**
     * Find zero or one REPropertyModel that matches the filter.
     * @param {REPropertyModelFindUniqueArgs} args - Arguments to find a REPropertyModel
     * @example
     * // Get one REPropertyModel
     * const rEPropertyModel = await prisma.rEPropertyModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends REPropertyModelFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, REPropertyModelFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'REPropertyModel'> extends True ? Prisma__REPropertyModelClient<$Types.GetResult<REPropertyModelPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__REPropertyModelClient<$Types.GetResult<REPropertyModelPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one REPropertyModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {REPropertyModelFindUniqueOrThrowArgs} args - Arguments to find a REPropertyModel
     * @example
     * // Get one REPropertyModel
     * const rEPropertyModel = await prisma.rEPropertyModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends REPropertyModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertyModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__REPropertyModelClient<$Types.GetResult<REPropertyModelPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first REPropertyModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyModelFindFirstArgs} args - Arguments to find a REPropertyModel
     * @example
     * // Get one REPropertyModel
     * const rEPropertyModel = await prisma.rEPropertyModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends REPropertyModelFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, REPropertyModelFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'REPropertyModel'> extends True ? Prisma__REPropertyModelClient<$Types.GetResult<REPropertyModelPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__REPropertyModelClient<$Types.GetResult<REPropertyModelPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first REPropertyModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyModelFindFirstOrThrowArgs} args - Arguments to find a REPropertyModel
     * @example
     * // Get one REPropertyModel
     * const rEPropertyModel = await prisma.rEPropertyModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends REPropertyModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertyModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__REPropertyModelClient<$Types.GetResult<REPropertyModelPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more REPropertyModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all REPropertyModels
     * const rEPropertyModels = await prisma.rEPropertyModel.findMany()
     * 
     * // Get first 10 REPropertyModels
     * const rEPropertyModels = await prisma.rEPropertyModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rEPropertyModelWithIdOnly = await prisma.rEPropertyModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends REPropertyModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertyModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<REPropertyModelPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a REPropertyModel.
     * @param {REPropertyModelCreateArgs} args - Arguments to create a REPropertyModel.
     * @example
     * // Create one REPropertyModel
     * const REPropertyModel = await prisma.rEPropertyModel.create({
     *   data: {
     *     // ... data to create a REPropertyModel
     *   }
     * })
     * 
    **/
    create<T extends REPropertyModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertyModelCreateArgs<ExtArgs>>
    ): Prisma__REPropertyModelClient<$Types.GetResult<REPropertyModelPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many REPropertyModels.
     *     @param {REPropertyModelCreateManyArgs} args - Arguments to create many REPropertyModels.
     *     @example
     *     // Create many REPropertyModels
     *     const rEPropertyModel = await prisma.rEPropertyModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends REPropertyModelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertyModelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a REPropertyModel.
     * @param {REPropertyModelDeleteArgs} args - Arguments to delete one REPropertyModel.
     * @example
     * // Delete one REPropertyModel
     * const REPropertyModel = await prisma.rEPropertyModel.delete({
     *   where: {
     *     // ... filter to delete one REPropertyModel
     *   }
     * })
     * 
    **/
    delete<T extends REPropertyModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertyModelDeleteArgs<ExtArgs>>
    ): Prisma__REPropertyModelClient<$Types.GetResult<REPropertyModelPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one REPropertyModel.
     * @param {REPropertyModelUpdateArgs} args - Arguments to update one REPropertyModel.
     * @example
     * // Update one REPropertyModel
     * const rEPropertyModel = await prisma.rEPropertyModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends REPropertyModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertyModelUpdateArgs<ExtArgs>>
    ): Prisma__REPropertyModelClient<$Types.GetResult<REPropertyModelPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more REPropertyModels.
     * @param {REPropertyModelDeleteManyArgs} args - Arguments to filter REPropertyModels to delete.
     * @example
     * // Delete a few REPropertyModels
     * const { count } = await prisma.rEPropertyModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends REPropertyModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertyModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more REPropertyModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many REPropertyModels
     * const rEPropertyModel = await prisma.rEPropertyModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends REPropertyModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertyModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one REPropertyModel.
     * @param {REPropertyModelUpsertArgs} args - Arguments to update or create a REPropertyModel.
     * @example
     * // Update or create a REPropertyModel
     * const rEPropertyModel = await prisma.rEPropertyModel.upsert({
     *   create: {
     *     // ... data to create a REPropertyModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the REPropertyModel we want to update
     *   }
     * })
    **/
    upsert<T extends REPropertyModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertyModelUpsertArgs<ExtArgs>>
    ): Prisma__REPropertyModelClient<$Types.GetResult<REPropertyModelPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of REPropertyModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyModelCountArgs} args - Arguments to filter REPropertyModels to count.
     * @example
     * // Count the number of REPropertyModels
     * const count = await prisma.rEPropertyModel.count({
     *   where: {
     *     // ... the filter for the REPropertyModels we want to count
     *   }
     * })
    **/
    count<T extends REPropertyModelCountArgs>(
      args?: Subset<T, REPropertyModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], REPropertyModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a REPropertyModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends REPropertyModelAggregateArgs>(args: Subset<T, REPropertyModelAggregateArgs>): Prisma.PrismaPromise<GetREPropertyModelAggregateType<T>>

    /**
     * Group by REPropertyModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends REPropertyModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: REPropertyModelGroupByArgs['orderBy'] }
        : { orderBy?: REPropertyModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, REPropertyModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetREPropertyModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for REPropertyModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__REPropertyModelClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    re_agent<T extends REAgentModelArgs<ExtArgs> = {}>(args?: Subset<T, REAgentModelArgs<ExtArgs>>): Prisma__REAgentModelClient<$Types.GetResult<REAgentModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    categories<T extends REPropertyModel$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, REPropertyModel$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<REPropertyCategoryModelPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * REPropertyModel base type for findUnique actions
   */
  export type REPropertyModelFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyModel
     */
    select?: REPropertyModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertyModel to fetch.
     */
    where: REPropertyModelWhereUniqueInput
  }

  /**
   * REPropertyModel findUnique
   */
  export interface REPropertyModelFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends REPropertyModelFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * REPropertyModel findUniqueOrThrow
   */
  export type REPropertyModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyModel
     */
    select?: REPropertyModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertyModel to fetch.
     */
    where: REPropertyModelWhereUniqueInput
  }


  /**
   * REPropertyModel base type for findFirst actions
   */
  export type REPropertyModelFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyModel
     */
    select?: REPropertyModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertyModel to fetch.
     */
    where?: REPropertyModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertyModels to fetch.
     */
    orderBy?: Enumerable<REPropertyModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REPropertyModels.
     */
    cursor?: REPropertyModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertyModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertyModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REPropertyModels.
     */
    distinct?: Enumerable<REPropertyModelScalarFieldEnum>
  }

  /**
   * REPropertyModel findFirst
   */
  export interface REPropertyModelFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends REPropertyModelFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * REPropertyModel findFirstOrThrow
   */
  export type REPropertyModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyModel
     */
    select?: REPropertyModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertyModel to fetch.
     */
    where?: REPropertyModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertyModels to fetch.
     */
    orderBy?: Enumerable<REPropertyModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REPropertyModels.
     */
    cursor?: REPropertyModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertyModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertyModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REPropertyModels.
     */
    distinct?: Enumerable<REPropertyModelScalarFieldEnum>
  }


  /**
   * REPropertyModel findMany
   */
  export type REPropertyModelFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyModel
     */
    select?: REPropertyModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertyModels to fetch.
     */
    where?: REPropertyModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertyModels to fetch.
     */
    orderBy?: Enumerable<REPropertyModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing REPropertyModels.
     */
    cursor?: REPropertyModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertyModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertyModels.
     */
    skip?: number
    distinct?: Enumerable<REPropertyModelScalarFieldEnum>
  }


  /**
   * REPropertyModel create
   */
  export type REPropertyModelCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyModel
     */
    select?: REPropertyModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyModelInclude<ExtArgs> | null
    /**
     * The data needed to create a REPropertyModel.
     */
    data: XOR<REPropertyModelCreateInput, REPropertyModelUncheckedCreateInput>
  }


  /**
   * REPropertyModel createMany
   */
  export type REPropertyModelCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many REPropertyModels.
     */
    data: Enumerable<REPropertyModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * REPropertyModel update
   */
  export type REPropertyModelUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyModel
     */
    select?: REPropertyModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyModelInclude<ExtArgs> | null
    /**
     * The data needed to update a REPropertyModel.
     */
    data: XOR<REPropertyModelUpdateInput, REPropertyModelUncheckedUpdateInput>
    /**
     * Choose, which REPropertyModel to update.
     */
    where: REPropertyModelWhereUniqueInput
  }


  /**
   * REPropertyModel updateMany
   */
  export type REPropertyModelUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update REPropertyModels.
     */
    data: XOR<REPropertyModelUpdateManyMutationInput, REPropertyModelUncheckedUpdateManyInput>
    /**
     * Filter which REPropertyModels to update
     */
    where?: REPropertyModelWhereInput
  }


  /**
   * REPropertyModel upsert
   */
  export type REPropertyModelUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyModel
     */
    select?: REPropertyModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyModelInclude<ExtArgs> | null
    /**
     * The filter to search for the REPropertyModel to update in case it exists.
     */
    where: REPropertyModelWhereUniqueInput
    /**
     * In case the REPropertyModel found by the `where` argument doesn't exist, create a new REPropertyModel with this data.
     */
    create: XOR<REPropertyModelCreateInput, REPropertyModelUncheckedCreateInput>
    /**
     * In case the REPropertyModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<REPropertyModelUpdateInput, REPropertyModelUncheckedUpdateInput>
  }


  /**
   * REPropertyModel delete
   */
  export type REPropertyModelDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyModel
     */
    select?: REPropertyModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyModelInclude<ExtArgs> | null
    /**
     * Filter which REPropertyModel to delete.
     */
    where: REPropertyModelWhereUniqueInput
  }


  /**
   * REPropertyModel deleteMany
   */
  export type REPropertyModelDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which REPropertyModels to delete
     */
    where?: REPropertyModelWhereInput
  }


  /**
   * REPropertyModel.categories
   */
  export type REPropertyModel$categoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyCategoryModel
     */
    select?: REPropertyCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyCategoryModelInclude<ExtArgs> | null
    where?: REPropertyCategoryModelWhereInput
    orderBy?: Enumerable<REPropertyCategoryModelOrderByWithRelationInput>
    cursor?: REPropertyCategoryModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<REPropertyCategoryModelScalarFieldEnum>
  }


  /**
   * REPropertyModel without action
   */
  export type REPropertyModelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyModel
     */
    select?: REPropertyModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyModelInclude<ExtArgs> | null
  }



  /**
   * Model REPropertyCategoryModel
   */


  export type AggregateREPropertyCategoryModel = {
    _count: REPropertyCategoryModelCountAggregateOutputType | null
    _min: REPropertyCategoryModelMinAggregateOutputType | null
    _max: REPropertyCategoryModelMaxAggregateOutputType | null
  }

  export type REPropertyCategoryModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    re_property_id: string | null
    sub_category_id: string | null
  }

  export type REPropertyCategoryModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    re_property_id: string | null
    sub_category_id: string | null
  }

  export type REPropertyCategoryModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    re_property_id: number
    sub_category_id: number
    _all: number
  }


  export type REPropertyCategoryModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    re_property_id?: true
    sub_category_id?: true
  }

  export type REPropertyCategoryModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    re_property_id?: true
    sub_category_id?: true
  }

  export type REPropertyCategoryModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    re_property_id?: true
    sub_category_id?: true
    _all?: true
  }

  export type REPropertyCategoryModelAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which REPropertyCategoryModel to aggregate.
     */
    where?: REPropertyCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertyCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertyCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: REPropertyCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertyCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertyCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned REPropertyCategoryModels
    **/
    _count?: true | REPropertyCategoryModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: REPropertyCategoryModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: REPropertyCategoryModelMaxAggregateInputType
  }

  export type GetREPropertyCategoryModelAggregateType<T extends REPropertyCategoryModelAggregateArgs> = {
        [P in keyof T & keyof AggregateREPropertyCategoryModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateREPropertyCategoryModel[P]>
      : GetScalarType<T[P], AggregateREPropertyCategoryModel[P]>
  }




  export type REPropertyCategoryModelGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: REPropertyCategoryModelWhereInput
    orderBy?: Enumerable<REPropertyCategoryModelOrderByWithAggregationInput>
    by: REPropertyCategoryModelScalarFieldEnum[]
    having?: REPropertyCategoryModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: REPropertyCategoryModelCountAggregateInputType | true
    _min?: REPropertyCategoryModelMinAggregateInputType
    _max?: REPropertyCategoryModelMaxAggregateInputType
  }


  export type REPropertyCategoryModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    re_property_id: string
    sub_category_id: string
    _count: REPropertyCategoryModelCountAggregateOutputType | null
    _min: REPropertyCategoryModelMinAggregateOutputType | null
    _max: REPropertyCategoryModelMaxAggregateOutputType | null
  }

  type GetREPropertyCategoryModelGroupByPayload<T extends REPropertyCategoryModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<REPropertyCategoryModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof REPropertyCategoryModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], REPropertyCategoryModelGroupByOutputType[P]>
            : GetScalarType<T[P], REPropertyCategoryModelGroupByOutputType[P]>
        }
      >
    >


  export type REPropertyCategoryModelSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    re_property_id?: boolean
    sub_category_id?: boolean
    re_property?: boolean | REPropertyModelArgs<ExtArgs>
    sub_category?: boolean | REPropertySubCategoryModelArgs<ExtArgs>
  }, ExtArgs["result"]["rEPropertyCategoryModel"]>

  export type REPropertyCategoryModelSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    re_property_id?: boolean
    sub_category_id?: boolean
  }

  export type REPropertyCategoryModelInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    re_property?: boolean | REPropertyModelArgs<ExtArgs>
    sub_category?: boolean | REPropertySubCategoryModelArgs<ExtArgs>
  }


  type REPropertyCategoryModelGetPayload<S extends boolean | null | undefined | REPropertyCategoryModelArgs> = $Types.GetResult<REPropertyCategoryModelPayload, S>

  type REPropertyCategoryModelCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<REPropertyCategoryModelFindManyArgs, 'select' | 'include'> & {
      select?: REPropertyCategoryModelCountAggregateInputType | true
    }

  export interface REPropertyCategoryModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['REPropertyCategoryModel'], meta: { name: 'REPropertyCategoryModel' } }
    /**
     * Find zero or one REPropertyCategoryModel that matches the filter.
     * @param {REPropertyCategoryModelFindUniqueArgs} args - Arguments to find a REPropertyCategoryModel
     * @example
     * // Get one REPropertyCategoryModel
     * const rEPropertyCategoryModel = await prisma.rEPropertyCategoryModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends REPropertyCategoryModelFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, REPropertyCategoryModelFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'REPropertyCategoryModel'> extends True ? Prisma__REPropertyCategoryModelClient<$Types.GetResult<REPropertyCategoryModelPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__REPropertyCategoryModelClient<$Types.GetResult<REPropertyCategoryModelPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one REPropertyCategoryModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {REPropertyCategoryModelFindUniqueOrThrowArgs} args - Arguments to find a REPropertyCategoryModel
     * @example
     * // Get one REPropertyCategoryModel
     * const rEPropertyCategoryModel = await prisma.rEPropertyCategoryModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends REPropertyCategoryModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertyCategoryModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__REPropertyCategoryModelClient<$Types.GetResult<REPropertyCategoryModelPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first REPropertyCategoryModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyCategoryModelFindFirstArgs} args - Arguments to find a REPropertyCategoryModel
     * @example
     * // Get one REPropertyCategoryModel
     * const rEPropertyCategoryModel = await prisma.rEPropertyCategoryModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends REPropertyCategoryModelFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, REPropertyCategoryModelFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'REPropertyCategoryModel'> extends True ? Prisma__REPropertyCategoryModelClient<$Types.GetResult<REPropertyCategoryModelPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__REPropertyCategoryModelClient<$Types.GetResult<REPropertyCategoryModelPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first REPropertyCategoryModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyCategoryModelFindFirstOrThrowArgs} args - Arguments to find a REPropertyCategoryModel
     * @example
     * // Get one REPropertyCategoryModel
     * const rEPropertyCategoryModel = await prisma.rEPropertyCategoryModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends REPropertyCategoryModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertyCategoryModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__REPropertyCategoryModelClient<$Types.GetResult<REPropertyCategoryModelPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more REPropertyCategoryModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyCategoryModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all REPropertyCategoryModels
     * const rEPropertyCategoryModels = await prisma.rEPropertyCategoryModel.findMany()
     * 
     * // Get first 10 REPropertyCategoryModels
     * const rEPropertyCategoryModels = await prisma.rEPropertyCategoryModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rEPropertyCategoryModelWithIdOnly = await prisma.rEPropertyCategoryModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends REPropertyCategoryModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertyCategoryModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<REPropertyCategoryModelPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a REPropertyCategoryModel.
     * @param {REPropertyCategoryModelCreateArgs} args - Arguments to create a REPropertyCategoryModel.
     * @example
     * // Create one REPropertyCategoryModel
     * const REPropertyCategoryModel = await prisma.rEPropertyCategoryModel.create({
     *   data: {
     *     // ... data to create a REPropertyCategoryModel
     *   }
     * })
     * 
    **/
    create<T extends REPropertyCategoryModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertyCategoryModelCreateArgs<ExtArgs>>
    ): Prisma__REPropertyCategoryModelClient<$Types.GetResult<REPropertyCategoryModelPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many REPropertyCategoryModels.
     *     @param {REPropertyCategoryModelCreateManyArgs} args - Arguments to create many REPropertyCategoryModels.
     *     @example
     *     // Create many REPropertyCategoryModels
     *     const rEPropertyCategoryModel = await prisma.rEPropertyCategoryModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends REPropertyCategoryModelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertyCategoryModelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a REPropertyCategoryModel.
     * @param {REPropertyCategoryModelDeleteArgs} args - Arguments to delete one REPropertyCategoryModel.
     * @example
     * // Delete one REPropertyCategoryModel
     * const REPropertyCategoryModel = await prisma.rEPropertyCategoryModel.delete({
     *   where: {
     *     // ... filter to delete one REPropertyCategoryModel
     *   }
     * })
     * 
    **/
    delete<T extends REPropertyCategoryModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertyCategoryModelDeleteArgs<ExtArgs>>
    ): Prisma__REPropertyCategoryModelClient<$Types.GetResult<REPropertyCategoryModelPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one REPropertyCategoryModel.
     * @param {REPropertyCategoryModelUpdateArgs} args - Arguments to update one REPropertyCategoryModel.
     * @example
     * // Update one REPropertyCategoryModel
     * const rEPropertyCategoryModel = await prisma.rEPropertyCategoryModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends REPropertyCategoryModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertyCategoryModelUpdateArgs<ExtArgs>>
    ): Prisma__REPropertyCategoryModelClient<$Types.GetResult<REPropertyCategoryModelPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more REPropertyCategoryModels.
     * @param {REPropertyCategoryModelDeleteManyArgs} args - Arguments to filter REPropertyCategoryModels to delete.
     * @example
     * // Delete a few REPropertyCategoryModels
     * const { count } = await prisma.rEPropertyCategoryModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends REPropertyCategoryModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertyCategoryModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more REPropertyCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyCategoryModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many REPropertyCategoryModels
     * const rEPropertyCategoryModel = await prisma.rEPropertyCategoryModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends REPropertyCategoryModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertyCategoryModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one REPropertyCategoryModel.
     * @param {REPropertyCategoryModelUpsertArgs} args - Arguments to update or create a REPropertyCategoryModel.
     * @example
     * // Update or create a REPropertyCategoryModel
     * const rEPropertyCategoryModel = await prisma.rEPropertyCategoryModel.upsert({
     *   create: {
     *     // ... data to create a REPropertyCategoryModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the REPropertyCategoryModel we want to update
     *   }
     * })
    **/
    upsert<T extends REPropertyCategoryModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertyCategoryModelUpsertArgs<ExtArgs>>
    ): Prisma__REPropertyCategoryModelClient<$Types.GetResult<REPropertyCategoryModelPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of REPropertyCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyCategoryModelCountArgs} args - Arguments to filter REPropertyCategoryModels to count.
     * @example
     * // Count the number of REPropertyCategoryModels
     * const count = await prisma.rEPropertyCategoryModel.count({
     *   where: {
     *     // ... the filter for the REPropertyCategoryModels we want to count
     *   }
     * })
    **/
    count<T extends REPropertyCategoryModelCountArgs>(
      args?: Subset<T, REPropertyCategoryModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], REPropertyCategoryModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a REPropertyCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyCategoryModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends REPropertyCategoryModelAggregateArgs>(args: Subset<T, REPropertyCategoryModelAggregateArgs>): Prisma.PrismaPromise<GetREPropertyCategoryModelAggregateType<T>>

    /**
     * Group by REPropertyCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyCategoryModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends REPropertyCategoryModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: REPropertyCategoryModelGroupByArgs['orderBy'] }
        : { orderBy?: REPropertyCategoryModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, REPropertyCategoryModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetREPropertyCategoryModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for REPropertyCategoryModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__REPropertyCategoryModelClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    re_property<T extends REPropertyModelArgs<ExtArgs> = {}>(args?: Subset<T, REPropertyModelArgs<ExtArgs>>): Prisma__REPropertyModelClient<$Types.GetResult<REPropertyModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    sub_category<T extends REPropertySubCategoryModelArgs<ExtArgs> = {}>(args?: Subset<T, REPropertySubCategoryModelArgs<ExtArgs>>): Prisma__REPropertySubCategoryModelClient<$Types.GetResult<REPropertySubCategoryModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * REPropertyCategoryModel base type for findUnique actions
   */
  export type REPropertyCategoryModelFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyCategoryModel
     */
    select?: REPropertyCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertyCategoryModel to fetch.
     */
    where: REPropertyCategoryModelWhereUniqueInput
  }

  /**
   * REPropertyCategoryModel findUnique
   */
  export interface REPropertyCategoryModelFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends REPropertyCategoryModelFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * REPropertyCategoryModel findUniqueOrThrow
   */
  export type REPropertyCategoryModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyCategoryModel
     */
    select?: REPropertyCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertyCategoryModel to fetch.
     */
    where: REPropertyCategoryModelWhereUniqueInput
  }


  /**
   * REPropertyCategoryModel base type for findFirst actions
   */
  export type REPropertyCategoryModelFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyCategoryModel
     */
    select?: REPropertyCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertyCategoryModel to fetch.
     */
    where?: REPropertyCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertyCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertyCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REPropertyCategoryModels.
     */
    cursor?: REPropertyCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertyCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertyCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REPropertyCategoryModels.
     */
    distinct?: Enumerable<REPropertyCategoryModelScalarFieldEnum>
  }

  /**
   * REPropertyCategoryModel findFirst
   */
  export interface REPropertyCategoryModelFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends REPropertyCategoryModelFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * REPropertyCategoryModel findFirstOrThrow
   */
  export type REPropertyCategoryModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyCategoryModel
     */
    select?: REPropertyCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertyCategoryModel to fetch.
     */
    where?: REPropertyCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertyCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertyCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REPropertyCategoryModels.
     */
    cursor?: REPropertyCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertyCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertyCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REPropertyCategoryModels.
     */
    distinct?: Enumerable<REPropertyCategoryModelScalarFieldEnum>
  }


  /**
   * REPropertyCategoryModel findMany
   */
  export type REPropertyCategoryModelFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyCategoryModel
     */
    select?: REPropertyCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertyCategoryModels to fetch.
     */
    where?: REPropertyCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertyCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertyCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing REPropertyCategoryModels.
     */
    cursor?: REPropertyCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertyCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertyCategoryModels.
     */
    skip?: number
    distinct?: Enumerable<REPropertyCategoryModelScalarFieldEnum>
  }


  /**
   * REPropertyCategoryModel create
   */
  export type REPropertyCategoryModelCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyCategoryModel
     */
    select?: REPropertyCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyCategoryModelInclude<ExtArgs> | null
    /**
     * The data needed to create a REPropertyCategoryModel.
     */
    data: XOR<REPropertyCategoryModelCreateInput, REPropertyCategoryModelUncheckedCreateInput>
  }


  /**
   * REPropertyCategoryModel createMany
   */
  export type REPropertyCategoryModelCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many REPropertyCategoryModels.
     */
    data: Enumerable<REPropertyCategoryModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * REPropertyCategoryModel update
   */
  export type REPropertyCategoryModelUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyCategoryModel
     */
    select?: REPropertyCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyCategoryModelInclude<ExtArgs> | null
    /**
     * The data needed to update a REPropertyCategoryModel.
     */
    data: XOR<REPropertyCategoryModelUpdateInput, REPropertyCategoryModelUncheckedUpdateInput>
    /**
     * Choose, which REPropertyCategoryModel to update.
     */
    where: REPropertyCategoryModelWhereUniqueInput
  }


  /**
   * REPropertyCategoryModel updateMany
   */
  export type REPropertyCategoryModelUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update REPropertyCategoryModels.
     */
    data: XOR<REPropertyCategoryModelUpdateManyMutationInput, REPropertyCategoryModelUncheckedUpdateManyInput>
    /**
     * Filter which REPropertyCategoryModels to update
     */
    where?: REPropertyCategoryModelWhereInput
  }


  /**
   * REPropertyCategoryModel upsert
   */
  export type REPropertyCategoryModelUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyCategoryModel
     */
    select?: REPropertyCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyCategoryModelInclude<ExtArgs> | null
    /**
     * The filter to search for the REPropertyCategoryModel to update in case it exists.
     */
    where: REPropertyCategoryModelWhereUniqueInput
    /**
     * In case the REPropertyCategoryModel found by the `where` argument doesn't exist, create a new REPropertyCategoryModel with this data.
     */
    create: XOR<REPropertyCategoryModelCreateInput, REPropertyCategoryModelUncheckedCreateInput>
    /**
     * In case the REPropertyCategoryModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<REPropertyCategoryModelUpdateInput, REPropertyCategoryModelUncheckedUpdateInput>
  }


  /**
   * REPropertyCategoryModel delete
   */
  export type REPropertyCategoryModelDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyCategoryModel
     */
    select?: REPropertyCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyCategoryModelInclude<ExtArgs> | null
    /**
     * Filter which REPropertyCategoryModel to delete.
     */
    where: REPropertyCategoryModelWhereUniqueInput
  }


  /**
   * REPropertyCategoryModel deleteMany
   */
  export type REPropertyCategoryModelDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which REPropertyCategoryModels to delete
     */
    where?: REPropertyCategoryModelWhereInput
  }


  /**
   * REPropertyCategoryModel without action
   */
  export type REPropertyCategoryModelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyCategoryModel
     */
    select?: REPropertyCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyCategoryModelInclude<ExtArgs> | null
  }



  /**
   * Model REPropertySubCategoryModel
   */


  export type AggregateREPropertySubCategoryModel = {
    _count: REPropertySubCategoryModelCountAggregateOutputType | null
    _min: REPropertySubCategoryModelMinAggregateOutputType | null
    _max: REPropertySubCategoryModelMaxAggregateOutputType | null
  }

  export type REPropertySubCategoryModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    middle_category_id: string | null
  }

  export type REPropertySubCategoryModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    middle_category_id: string | null
  }

  export type REPropertySubCategoryModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    name: number
    middle_category_id: number
    _all: number
  }


  export type REPropertySubCategoryModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    middle_category_id?: true
  }

  export type REPropertySubCategoryModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    middle_category_id?: true
  }

  export type REPropertySubCategoryModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    middle_category_id?: true
    _all?: true
  }

  export type REPropertySubCategoryModelAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which REPropertySubCategoryModel to aggregate.
     */
    where?: REPropertySubCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertySubCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertySubCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: REPropertySubCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertySubCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertySubCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned REPropertySubCategoryModels
    **/
    _count?: true | REPropertySubCategoryModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: REPropertySubCategoryModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: REPropertySubCategoryModelMaxAggregateInputType
  }

  export type GetREPropertySubCategoryModelAggregateType<T extends REPropertySubCategoryModelAggregateArgs> = {
        [P in keyof T & keyof AggregateREPropertySubCategoryModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateREPropertySubCategoryModel[P]>
      : GetScalarType<T[P], AggregateREPropertySubCategoryModel[P]>
  }




  export type REPropertySubCategoryModelGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: REPropertySubCategoryModelWhereInput
    orderBy?: Enumerable<REPropertySubCategoryModelOrderByWithAggregationInput>
    by: REPropertySubCategoryModelScalarFieldEnum[]
    having?: REPropertySubCategoryModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: REPropertySubCategoryModelCountAggregateInputType | true
    _min?: REPropertySubCategoryModelMinAggregateInputType
    _max?: REPropertySubCategoryModelMaxAggregateInputType
  }


  export type REPropertySubCategoryModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    name: string
    middle_category_id: string
    _count: REPropertySubCategoryModelCountAggregateOutputType | null
    _min: REPropertySubCategoryModelMinAggregateOutputType | null
    _max: REPropertySubCategoryModelMaxAggregateOutputType | null
  }

  type GetREPropertySubCategoryModelGroupByPayload<T extends REPropertySubCategoryModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<REPropertySubCategoryModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof REPropertySubCategoryModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], REPropertySubCategoryModelGroupByOutputType[P]>
            : GetScalarType<T[P], REPropertySubCategoryModelGroupByOutputType[P]>
        }
      >
    >


  export type REPropertySubCategoryModelSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    name?: boolean
    middle_category_id?: boolean
    middle_category?: boolean | REPropertyMiddleCategoryModelArgs<ExtArgs>
    property_categories?: boolean | REPropertySubCategoryModel$property_categoriesArgs<ExtArgs>
    _count?: boolean | REPropertySubCategoryModelCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["rEPropertySubCategoryModel"]>

  export type REPropertySubCategoryModelSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    name?: boolean
    middle_category_id?: boolean
  }

  export type REPropertySubCategoryModelInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    middle_category?: boolean | REPropertyMiddleCategoryModelArgs<ExtArgs>
    property_categories?: boolean | REPropertySubCategoryModel$property_categoriesArgs<ExtArgs>
    _count?: boolean | REPropertySubCategoryModelCountOutputTypeArgs<ExtArgs>
  }


  type REPropertySubCategoryModelGetPayload<S extends boolean | null | undefined | REPropertySubCategoryModelArgs> = $Types.GetResult<REPropertySubCategoryModelPayload, S>

  type REPropertySubCategoryModelCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<REPropertySubCategoryModelFindManyArgs, 'select' | 'include'> & {
      select?: REPropertySubCategoryModelCountAggregateInputType | true
    }

  export interface REPropertySubCategoryModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['REPropertySubCategoryModel'], meta: { name: 'REPropertySubCategoryModel' } }
    /**
     * Find zero or one REPropertySubCategoryModel that matches the filter.
     * @param {REPropertySubCategoryModelFindUniqueArgs} args - Arguments to find a REPropertySubCategoryModel
     * @example
     * // Get one REPropertySubCategoryModel
     * const rEPropertySubCategoryModel = await prisma.rEPropertySubCategoryModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends REPropertySubCategoryModelFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, REPropertySubCategoryModelFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'REPropertySubCategoryModel'> extends True ? Prisma__REPropertySubCategoryModelClient<$Types.GetResult<REPropertySubCategoryModelPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__REPropertySubCategoryModelClient<$Types.GetResult<REPropertySubCategoryModelPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one REPropertySubCategoryModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {REPropertySubCategoryModelFindUniqueOrThrowArgs} args - Arguments to find a REPropertySubCategoryModel
     * @example
     * // Get one REPropertySubCategoryModel
     * const rEPropertySubCategoryModel = await prisma.rEPropertySubCategoryModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends REPropertySubCategoryModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertySubCategoryModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__REPropertySubCategoryModelClient<$Types.GetResult<REPropertySubCategoryModelPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first REPropertySubCategoryModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySubCategoryModelFindFirstArgs} args - Arguments to find a REPropertySubCategoryModel
     * @example
     * // Get one REPropertySubCategoryModel
     * const rEPropertySubCategoryModel = await prisma.rEPropertySubCategoryModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends REPropertySubCategoryModelFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, REPropertySubCategoryModelFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'REPropertySubCategoryModel'> extends True ? Prisma__REPropertySubCategoryModelClient<$Types.GetResult<REPropertySubCategoryModelPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__REPropertySubCategoryModelClient<$Types.GetResult<REPropertySubCategoryModelPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first REPropertySubCategoryModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySubCategoryModelFindFirstOrThrowArgs} args - Arguments to find a REPropertySubCategoryModel
     * @example
     * // Get one REPropertySubCategoryModel
     * const rEPropertySubCategoryModel = await prisma.rEPropertySubCategoryModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends REPropertySubCategoryModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertySubCategoryModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__REPropertySubCategoryModelClient<$Types.GetResult<REPropertySubCategoryModelPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more REPropertySubCategoryModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySubCategoryModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all REPropertySubCategoryModels
     * const rEPropertySubCategoryModels = await prisma.rEPropertySubCategoryModel.findMany()
     * 
     * // Get first 10 REPropertySubCategoryModels
     * const rEPropertySubCategoryModels = await prisma.rEPropertySubCategoryModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rEPropertySubCategoryModelWithIdOnly = await prisma.rEPropertySubCategoryModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends REPropertySubCategoryModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertySubCategoryModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<REPropertySubCategoryModelPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a REPropertySubCategoryModel.
     * @param {REPropertySubCategoryModelCreateArgs} args - Arguments to create a REPropertySubCategoryModel.
     * @example
     * // Create one REPropertySubCategoryModel
     * const REPropertySubCategoryModel = await prisma.rEPropertySubCategoryModel.create({
     *   data: {
     *     // ... data to create a REPropertySubCategoryModel
     *   }
     * })
     * 
    **/
    create<T extends REPropertySubCategoryModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertySubCategoryModelCreateArgs<ExtArgs>>
    ): Prisma__REPropertySubCategoryModelClient<$Types.GetResult<REPropertySubCategoryModelPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many REPropertySubCategoryModels.
     *     @param {REPropertySubCategoryModelCreateManyArgs} args - Arguments to create many REPropertySubCategoryModels.
     *     @example
     *     // Create many REPropertySubCategoryModels
     *     const rEPropertySubCategoryModel = await prisma.rEPropertySubCategoryModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends REPropertySubCategoryModelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertySubCategoryModelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a REPropertySubCategoryModel.
     * @param {REPropertySubCategoryModelDeleteArgs} args - Arguments to delete one REPropertySubCategoryModel.
     * @example
     * // Delete one REPropertySubCategoryModel
     * const REPropertySubCategoryModel = await prisma.rEPropertySubCategoryModel.delete({
     *   where: {
     *     // ... filter to delete one REPropertySubCategoryModel
     *   }
     * })
     * 
    **/
    delete<T extends REPropertySubCategoryModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertySubCategoryModelDeleteArgs<ExtArgs>>
    ): Prisma__REPropertySubCategoryModelClient<$Types.GetResult<REPropertySubCategoryModelPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one REPropertySubCategoryModel.
     * @param {REPropertySubCategoryModelUpdateArgs} args - Arguments to update one REPropertySubCategoryModel.
     * @example
     * // Update one REPropertySubCategoryModel
     * const rEPropertySubCategoryModel = await prisma.rEPropertySubCategoryModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends REPropertySubCategoryModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertySubCategoryModelUpdateArgs<ExtArgs>>
    ): Prisma__REPropertySubCategoryModelClient<$Types.GetResult<REPropertySubCategoryModelPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more REPropertySubCategoryModels.
     * @param {REPropertySubCategoryModelDeleteManyArgs} args - Arguments to filter REPropertySubCategoryModels to delete.
     * @example
     * // Delete a few REPropertySubCategoryModels
     * const { count } = await prisma.rEPropertySubCategoryModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends REPropertySubCategoryModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertySubCategoryModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more REPropertySubCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySubCategoryModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many REPropertySubCategoryModels
     * const rEPropertySubCategoryModel = await prisma.rEPropertySubCategoryModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends REPropertySubCategoryModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertySubCategoryModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one REPropertySubCategoryModel.
     * @param {REPropertySubCategoryModelUpsertArgs} args - Arguments to update or create a REPropertySubCategoryModel.
     * @example
     * // Update or create a REPropertySubCategoryModel
     * const rEPropertySubCategoryModel = await prisma.rEPropertySubCategoryModel.upsert({
     *   create: {
     *     // ... data to create a REPropertySubCategoryModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the REPropertySubCategoryModel we want to update
     *   }
     * })
    **/
    upsert<T extends REPropertySubCategoryModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertySubCategoryModelUpsertArgs<ExtArgs>>
    ): Prisma__REPropertySubCategoryModelClient<$Types.GetResult<REPropertySubCategoryModelPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of REPropertySubCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySubCategoryModelCountArgs} args - Arguments to filter REPropertySubCategoryModels to count.
     * @example
     * // Count the number of REPropertySubCategoryModels
     * const count = await prisma.rEPropertySubCategoryModel.count({
     *   where: {
     *     // ... the filter for the REPropertySubCategoryModels we want to count
     *   }
     * })
    **/
    count<T extends REPropertySubCategoryModelCountArgs>(
      args?: Subset<T, REPropertySubCategoryModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], REPropertySubCategoryModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a REPropertySubCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySubCategoryModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends REPropertySubCategoryModelAggregateArgs>(args: Subset<T, REPropertySubCategoryModelAggregateArgs>): Prisma.PrismaPromise<GetREPropertySubCategoryModelAggregateType<T>>

    /**
     * Group by REPropertySubCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySubCategoryModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends REPropertySubCategoryModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: REPropertySubCategoryModelGroupByArgs['orderBy'] }
        : { orderBy?: REPropertySubCategoryModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, REPropertySubCategoryModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetREPropertySubCategoryModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for REPropertySubCategoryModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__REPropertySubCategoryModelClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    middle_category<T extends REPropertyMiddleCategoryModelArgs<ExtArgs> = {}>(args?: Subset<T, REPropertyMiddleCategoryModelArgs<ExtArgs>>): Prisma__REPropertyMiddleCategoryModelClient<$Types.GetResult<REPropertyMiddleCategoryModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    property_categories<T extends REPropertySubCategoryModel$property_categoriesArgs<ExtArgs> = {}>(args?: Subset<T, REPropertySubCategoryModel$property_categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<REPropertyCategoryModelPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * REPropertySubCategoryModel base type for findUnique actions
   */
  export type REPropertySubCategoryModelFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertySubCategoryModel
     */
    select?: REPropertySubCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySubCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertySubCategoryModel to fetch.
     */
    where: REPropertySubCategoryModelWhereUniqueInput
  }

  /**
   * REPropertySubCategoryModel findUnique
   */
  export interface REPropertySubCategoryModelFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends REPropertySubCategoryModelFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * REPropertySubCategoryModel findUniqueOrThrow
   */
  export type REPropertySubCategoryModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertySubCategoryModel
     */
    select?: REPropertySubCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySubCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertySubCategoryModel to fetch.
     */
    where: REPropertySubCategoryModelWhereUniqueInput
  }


  /**
   * REPropertySubCategoryModel base type for findFirst actions
   */
  export type REPropertySubCategoryModelFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertySubCategoryModel
     */
    select?: REPropertySubCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySubCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertySubCategoryModel to fetch.
     */
    where?: REPropertySubCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertySubCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertySubCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REPropertySubCategoryModels.
     */
    cursor?: REPropertySubCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertySubCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertySubCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REPropertySubCategoryModels.
     */
    distinct?: Enumerable<REPropertySubCategoryModelScalarFieldEnum>
  }

  /**
   * REPropertySubCategoryModel findFirst
   */
  export interface REPropertySubCategoryModelFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends REPropertySubCategoryModelFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * REPropertySubCategoryModel findFirstOrThrow
   */
  export type REPropertySubCategoryModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertySubCategoryModel
     */
    select?: REPropertySubCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySubCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertySubCategoryModel to fetch.
     */
    where?: REPropertySubCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertySubCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertySubCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REPropertySubCategoryModels.
     */
    cursor?: REPropertySubCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertySubCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertySubCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REPropertySubCategoryModels.
     */
    distinct?: Enumerable<REPropertySubCategoryModelScalarFieldEnum>
  }


  /**
   * REPropertySubCategoryModel findMany
   */
  export type REPropertySubCategoryModelFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertySubCategoryModel
     */
    select?: REPropertySubCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySubCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertySubCategoryModels to fetch.
     */
    where?: REPropertySubCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertySubCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertySubCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing REPropertySubCategoryModels.
     */
    cursor?: REPropertySubCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertySubCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertySubCategoryModels.
     */
    skip?: number
    distinct?: Enumerable<REPropertySubCategoryModelScalarFieldEnum>
  }


  /**
   * REPropertySubCategoryModel create
   */
  export type REPropertySubCategoryModelCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertySubCategoryModel
     */
    select?: REPropertySubCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySubCategoryModelInclude<ExtArgs> | null
    /**
     * The data needed to create a REPropertySubCategoryModel.
     */
    data: XOR<REPropertySubCategoryModelCreateInput, REPropertySubCategoryModelUncheckedCreateInput>
  }


  /**
   * REPropertySubCategoryModel createMany
   */
  export type REPropertySubCategoryModelCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many REPropertySubCategoryModels.
     */
    data: Enumerable<REPropertySubCategoryModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * REPropertySubCategoryModel update
   */
  export type REPropertySubCategoryModelUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertySubCategoryModel
     */
    select?: REPropertySubCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySubCategoryModelInclude<ExtArgs> | null
    /**
     * The data needed to update a REPropertySubCategoryModel.
     */
    data: XOR<REPropertySubCategoryModelUpdateInput, REPropertySubCategoryModelUncheckedUpdateInput>
    /**
     * Choose, which REPropertySubCategoryModel to update.
     */
    where: REPropertySubCategoryModelWhereUniqueInput
  }


  /**
   * REPropertySubCategoryModel updateMany
   */
  export type REPropertySubCategoryModelUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update REPropertySubCategoryModels.
     */
    data: XOR<REPropertySubCategoryModelUpdateManyMutationInput, REPropertySubCategoryModelUncheckedUpdateManyInput>
    /**
     * Filter which REPropertySubCategoryModels to update
     */
    where?: REPropertySubCategoryModelWhereInput
  }


  /**
   * REPropertySubCategoryModel upsert
   */
  export type REPropertySubCategoryModelUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertySubCategoryModel
     */
    select?: REPropertySubCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySubCategoryModelInclude<ExtArgs> | null
    /**
     * The filter to search for the REPropertySubCategoryModel to update in case it exists.
     */
    where: REPropertySubCategoryModelWhereUniqueInput
    /**
     * In case the REPropertySubCategoryModel found by the `where` argument doesn't exist, create a new REPropertySubCategoryModel with this data.
     */
    create: XOR<REPropertySubCategoryModelCreateInput, REPropertySubCategoryModelUncheckedCreateInput>
    /**
     * In case the REPropertySubCategoryModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<REPropertySubCategoryModelUpdateInput, REPropertySubCategoryModelUncheckedUpdateInput>
  }


  /**
   * REPropertySubCategoryModel delete
   */
  export type REPropertySubCategoryModelDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertySubCategoryModel
     */
    select?: REPropertySubCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySubCategoryModelInclude<ExtArgs> | null
    /**
     * Filter which REPropertySubCategoryModel to delete.
     */
    where: REPropertySubCategoryModelWhereUniqueInput
  }


  /**
   * REPropertySubCategoryModel deleteMany
   */
  export type REPropertySubCategoryModelDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which REPropertySubCategoryModels to delete
     */
    where?: REPropertySubCategoryModelWhereInput
  }


  /**
   * REPropertySubCategoryModel.property_categories
   */
  export type REPropertySubCategoryModel$property_categoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyCategoryModel
     */
    select?: REPropertyCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyCategoryModelInclude<ExtArgs> | null
    where?: REPropertyCategoryModelWhereInput
    orderBy?: Enumerable<REPropertyCategoryModelOrderByWithRelationInput>
    cursor?: REPropertyCategoryModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<REPropertyCategoryModelScalarFieldEnum>
  }


  /**
   * REPropertySubCategoryModel without action
   */
  export type REPropertySubCategoryModelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertySubCategoryModel
     */
    select?: REPropertySubCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySubCategoryModelInclude<ExtArgs> | null
  }



  /**
   * Model REPropertyMiddleCategoryModel
   */


  export type AggregateREPropertyMiddleCategoryModel = {
    _count: REPropertyMiddleCategoryModelCountAggregateOutputType | null
    _min: REPropertyMiddleCategoryModelMinAggregateOutputType | null
    _max: REPropertyMiddleCategoryModelMaxAggregateOutputType | null
  }

  export type REPropertyMiddleCategoryModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    super_category_id: string | null
  }

  export type REPropertyMiddleCategoryModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    super_category_id: string | null
  }

  export type REPropertyMiddleCategoryModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    name: number
    super_category_id: number
    _all: number
  }


  export type REPropertyMiddleCategoryModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    super_category_id?: true
  }

  export type REPropertyMiddleCategoryModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    super_category_id?: true
  }

  export type REPropertyMiddleCategoryModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    super_category_id?: true
    _all?: true
  }

  export type REPropertyMiddleCategoryModelAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which REPropertyMiddleCategoryModel to aggregate.
     */
    where?: REPropertyMiddleCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertyMiddleCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertyMiddleCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: REPropertyMiddleCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertyMiddleCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertyMiddleCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned REPropertyMiddleCategoryModels
    **/
    _count?: true | REPropertyMiddleCategoryModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: REPropertyMiddleCategoryModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: REPropertyMiddleCategoryModelMaxAggregateInputType
  }

  export type GetREPropertyMiddleCategoryModelAggregateType<T extends REPropertyMiddleCategoryModelAggregateArgs> = {
        [P in keyof T & keyof AggregateREPropertyMiddleCategoryModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateREPropertyMiddleCategoryModel[P]>
      : GetScalarType<T[P], AggregateREPropertyMiddleCategoryModel[P]>
  }




  export type REPropertyMiddleCategoryModelGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: REPropertyMiddleCategoryModelWhereInput
    orderBy?: Enumerable<REPropertyMiddleCategoryModelOrderByWithAggregationInput>
    by: REPropertyMiddleCategoryModelScalarFieldEnum[]
    having?: REPropertyMiddleCategoryModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: REPropertyMiddleCategoryModelCountAggregateInputType | true
    _min?: REPropertyMiddleCategoryModelMinAggregateInputType
    _max?: REPropertyMiddleCategoryModelMaxAggregateInputType
  }


  export type REPropertyMiddleCategoryModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    name: string
    super_category_id: string
    _count: REPropertyMiddleCategoryModelCountAggregateOutputType | null
    _min: REPropertyMiddleCategoryModelMinAggregateOutputType | null
    _max: REPropertyMiddleCategoryModelMaxAggregateOutputType | null
  }

  type GetREPropertyMiddleCategoryModelGroupByPayload<T extends REPropertyMiddleCategoryModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<REPropertyMiddleCategoryModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof REPropertyMiddleCategoryModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], REPropertyMiddleCategoryModelGroupByOutputType[P]>
            : GetScalarType<T[P], REPropertyMiddleCategoryModelGroupByOutputType[P]>
        }
      >
    >


  export type REPropertyMiddleCategoryModelSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    name?: boolean
    super_category_id?: boolean
    super_category?: boolean | REPropertySuperCategoryModelArgs<ExtArgs>
    sub_categories?: boolean | REPropertyMiddleCategoryModel$sub_categoriesArgs<ExtArgs>
    _count?: boolean | REPropertyMiddleCategoryModelCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["rEPropertyMiddleCategoryModel"]>

  export type REPropertyMiddleCategoryModelSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    name?: boolean
    super_category_id?: boolean
  }

  export type REPropertyMiddleCategoryModelInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    super_category?: boolean | REPropertySuperCategoryModelArgs<ExtArgs>
    sub_categories?: boolean | REPropertyMiddleCategoryModel$sub_categoriesArgs<ExtArgs>
    _count?: boolean | REPropertyMiddleCategoryModelCountOutputTypeArgs<ExtArgs>
  }


  type REPropertyMiddleCategoryModelGetPayload<S extends boolean | null | undefined | REPropertyMiddleCategoryModelArgs> = $Types.GetResult<REPropertyMiddleCategoryModelPayload, S>

  type REPropertyMiddleCategoryModelCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<REPropertyMiddleCategoryModelFindManyArgs, 'select' | 'include'> & {
      select?: REPropertyMiddleCategoryModelCountAggregateInputType | true
    }

  export interface REPropertyMiddleCategoryModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['REPropertyMiddleCategoryModel'], meta: { name: 'REPropertyMiddleCategoryModel' } }
    /**
     * Find zero or one REPropertyMiddleCategoryModel that matches the filter.
     * @param {REPropertyMiddleCategoryModelFindUniqueArgs} args - Arguments to find a REPropertyMiddleCategoryModel
     * @example
     * // Get one REPropertyMiddleCategoryModel
     * const rEPropertyMiddleCategoryModel = await prisma.rEPropertyMiddleCategoryModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends REPropertyMiddleCategoryModelFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, REPropertyMiddleCategoryModelFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'REPropertyMiddleCategoryModel'> extends True ? Prisma__REPropertyMiddleCategoryModelClient<$Types.GetResult<REPropertyMiddleCategoryModelPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__REPropertyMiddleCategoryModelClient<$Types.GetResult<REPropertyMiddleCategoryModelPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one REPropertyMiddleCategoryModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {REPropertyMiddleCategoryModelFindUniqueOrThrowArgs} args - Arguments to find a REPropertyMiddleCategoryModel
     * @example
     * // Get one REPropertyMiddleCategoryModel
     * const rEPropertyMiddleCategoryModel = await prisma.rEPropertyMiddleCategoryModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends REPropertyMiddleCategoryModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertyMiddleCategoryModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__REPropertyMiddleCategoryModelClient<$Types.GetResult<REPropertyMiddleCategoryModelPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first REPropertyMiddleCategoryModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyMiddleCategoryModelFindFirstArgs} args - Arguments to find a REPropertyMiddleCategoryModel
     * @example
     * // Get one REPropertyMiddleCategoryModel
     * const rEPropertyMiddleCategoryModel = await prisma.rEPropertyMiddleCategoryModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends REPropertyMiddleCategoryModelFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, REPropertyMiddleCategoryModelFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'REPropertyMiddleCategoryModel'> extends True ? Prisma__REPropertyMiddleCategoryModelClient<$Types.GetResult<REPropertyMiddleCategoryModelPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__REPropertyMiddleCategoryModelClient<$Types.GetResult<REPropertyMiddleCategoryModelPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first REPropertyMiddleCategoryModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyMiddleCategoryModelFindFirstOrThrowArgs} args - Arguments to find a REPropertyMiddleCategoryModel
     * @example
     * // Get one REPropertyMiddleCategoryModel
     * const rEPropertyMiddleCategoryModel = await prisma.rEPropertyMiddleCategoryModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends REPropertyMiddleCategoryModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertyMiddleCategoryModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__REPropertyMiddleCategoryModelClient<$Types.GetResult<REPropertyMiddleCategoryModelPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more REPropertyMiddleCategoryModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyMiddleCategoryModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all REPropertyMiddleCategoryModels
     * const rEPropertyMiddleCategoryModels = await prisma.rEPropertyMiddleCategoryModel.findMany()
     * 
     * // Get first 10 REPropertyMiddleCategoryModels
     * const rEPropertyMiddleCategoryModels = await prisma.rEPropertyMiddleCategoryModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rEPropertyMiddleCategoryModelWithIdOnly = await prisma.rEPropertyMiddleCategoryModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends REPropertyMiddleCategoryModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertyMiddleCategoryModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<REPropertyMiddleCategoryModelPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a REPropertyMiddleCategoryModel.
     * @param {REPropertyMiddleCategoryModelCreateArgs} args - Arguments to create a REPropertyMiddleCategoryModel.
     * @example
     * // Create one REPropertyMiddleCategoryModel
     * const REPropertyMiddleCategoryModel = await prisma.rEPropertyMiddleCategoryModel.create({
     *   data: {
     *     // ... data to create a REPropertyMiddleCategoryModel
     *   }
     * })
     * 
    **/
    create<T extends REPropertyMiddleCategoryModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertyMiddleCategoryModelCreateArgs<ExtArgs>>
    ): Prisma__REPropertyMiddleCategoryModelClient<$Types.GetResult<REPropertyMiddleCategoryModelPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many REPropertyMiddleCategoryModels.
     *     @param {REPropertyMiddleCategoryModelCreateManyArgs} args - Arguments to create many REPropertyMiddleCategoryModels.
     *     @example
     *     // Create many REPropertyMiddleCategoryModels
     *     const rEPropertyMiddleCategoryModel = await prisma.rEPropertyMiddleCategoryModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends REPropertyMiddleCategoryModelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertyMiddleCategoryModelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a REPropertyMiddleCategoryModel.
     * @param {REPropertyMiddleCategoryModelDeleteArgs} args - Arguments to delete one REPropertyMiddleCategoryModel.
     * @example
     * // Delete one REPropertyMiddleCategoryModel
     * const REPropertyMiddleCategoryModel = await prisma.rEPropertyMiddleCategoryModel.delete({
     *   where: {
     *     // ... filter to delete one REPropertyMiddleCategoryModel
     *   }
     * })
     * 
    **/
    delete<T extends REPropertyMiddleCategoryModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertyMiddleCategoryModelDeleteArgs<ExtArgs>>
    ): Prisma__REPropertyMiddleCategoryModelClient<$Types.GetResult<REPropertyMiddleCategoryModelPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one REPropertyMiddleCategoryModel.
     * @param {REPropertyMiddleCategoryModelUpdateArgs} args - Arguments to update one REPropertyMiddleCategoryModel.
     * @example
     * // Update one REPropertyMiddleCategoryModel
     * const rEPropertyMiddleCategoryModel = await prisma.rEPropertyMiddleCategoryModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends REPropertyMiddleCategoryModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertyMiddleCategoryModelUpdateArgs<ExtArgs>>
    ): Prisma__REPropertyMiddleCategoryModelClient<$Types.GetResult<REPropertyMiddleCategoryModelPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more REPropertyMiddleCategoryModels.
     * @param {REPropertyMiddleCategoryModelDeleteManyArgs} args - Arguments to filter REPropertyMiddleCategoryModels to delete.
     * @example
     * // Delete a few REPropertyMiddleCategoryModels
     * const { count } = await prisma.rEPropertyMiddleCategoryModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends REPropertyMiddleCategoryModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertyMiddleCategoryModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more REPropertyMiddleCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyMiddleCategoryModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many REPropertyMiddleCategoryModels
     * const rEPropertyMiddleCategoryModel = await prisma.rEPropertyMiddleCategoryModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends REPropertyMiddleCategoryModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertyMiddleCategoryModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one REPropertyMiddleCategoryModel.
     * @param {REPropertyMiddleCategoryModelUpsertArgs} args - Arguments to update or create a REPropertyMiddleCategoryModel.
     * @example
     * // Update or create a REPropertyMiddleCategoryModel
     * const rEPropertyMiddleCategoryModel = await prisma.rEPropertyMiddleCategoryModel.upsert({
     *   create: {
     *     // ... data to create a REPropertyMiddleCategoryModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the REPropertyMiddleCategoryModel we want to update
     *   }
     * })
    **/
    upsert<T extends REPropertyMiddleCategoryModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertyMiddleCategoryModelUpsertArgs<ExtArgs>>
    ): Prisma__REPropertyMiddleCategoryModelClient<$Types.GetResult<REPropertyMiddleCategoryModelPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of REPropertyMiddleCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyMiddleCategoryModelCountArgs} args - Arguments to filter REPropertyMiddleCategoryModels to count.
     * @example
     * // Count the number of REPropertyMiddleCategoryModels
     * const count = await prisma.rEPropertyMiddleCategoryModel.count({
     *   where: {
     *     // ... the filter for the REPropertyMiddleCategoryModels we want to count
     *   }
     * })
    **/
    count<T extends REPropertyMiddleCategoryModelCountArgs>(
      args?: Subset<T, REPropertyMiddleCategoryModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], REPropertyMiddleCategoryModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a REPropertyMiddleCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyMiddleCategoryModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends REPropertyMiddleCategoryModelAggregateArgs>(args: Subset<T, REPropertyMiddleCategoryModelAggregateArgs>): Prisma.PrismaPromise<GetREPropertyMiddleCategoryModelAggregateType<T>>

    /**
     * Group by REPropertyMiddleCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertyMiddleCategoryModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends REPropertyMiddleCategoryModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: REPropertyMiddleCategoryModelGroupByArgs['orderBy'] }
        : { orderBy?: REPropertyMiddleCategoryModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, REPropertyMiddleCategoryModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetREPropertyMiddleCategoryModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for REPropertyMiddleCategoryModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__REPropertyMiddleCategoryModelClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    super_category<T extends REPropertySuperCategoryModelArgs<ExtArgs> = {}>(args?: Subset<T, REPropertySuperCategoryModelArgs<ExtArgs>>): Prisma__REPropertySuperCategoryModelClient<$Types.GetResult<REPropertySuperCategoryModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    sub_categories<T extends REPropertyMiddleCategoryModel$sub_categoriesArgs<ExtArgs> = {}>(args?: Subset<T, REPropertyMiddleCategoryModel$sub_categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<REPropertySubCategoryModelPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * REPropertyMiddleCategoryModel base type for findUnique actions
   */
  export type REPropertyMiddleCategoryModelFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyMiddleCategoryModel
     */
    select?: REPropertyMiddleCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyMiddleCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertyMiddleCategoryModel to fetch.
     */
    where: REPropertyMiddleCategoryModelWhereUniqueInput
  }

  /**
   * REPropertyMiddleCategoryModel findUnique
   */
  export interface REPropertyMiddleCategoryModelFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends REPropertyMiddleCategoryModelFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * REPropertyMiddleCategoryModel findUniqueOrThrow
   */
  export type REPropertyMiddleCategoryModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyMiddleCategoryModel
     */
    select?: REPropertyMiddleCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyMiddleCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertyMiddleCategoryModel to fetch.
     */
    where: REPropertyMiddleCategoryModelWhereUniqueInput
  }


  /**
   * REPropertyMiddleCategoryModel base type for findFirst actions
   */
  export type REPropertyMiddleCategoryModelFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyMiddleCategoryModel
     */
    select?: REPropertyMiddleCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyMiddleCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertyMiddleCategoryModel to fetch.
     */
    where?: REPropertyMiddleCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertyMiddleCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertyMiddleCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REPropertyMiddleCategoryModels.
     */
    cursor?: REPropertyMiddleCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertyMiddleCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertyMiddleCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REPropertyMiddleCategoryModels.
     */
    distinct?: Enumerable<REPropertyMiddleCategoryModelScalarFieldEnum>
  }

  /**
   * REPropertyMiddleCategoryModel findFirst
   */
  export interface REPropertyMiddleCategoryModelFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends REPropertyMiddleCategoryModelFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * REPropertyMiddleCategoryModel findFirstOrThrow
   */
  export type REPropertyMiddleCategoryModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyMiddleCategoryModel
     */
    select?: REPropertyMiddleCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyMiddleCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertyMiddleCategoryModel to fetch.
     */
    where?: REPropertyMiddleCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertyMiddleCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertyMiddleCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REPropertyMiddleCategoryModels.
     */
    cursor?: REPropertyMiddleCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertyMiddleCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertyMiddleCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REPropertyMiddleCategoryModels.
     */
    distinct?: Enumerable<REPropertyMiddleCategoryModelScalarFieldEnum>
  }


  /**
   * REPropertyMiddleCategoryModel findMany
   */
  export type REPropertyMiddleCategoryModelFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyMiddleCategoryModel
     */
    select?: REPropertyMiddleCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyMiddleCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertyMiddleCategoryModels to fetch.
     */
    where?: REPropertyMiddleCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertyMiddleCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertyMiddleCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing REPropertyMiddleCategoryModels.
     */
    cursor?: REPropertyMiddleCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertyMiddleCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertyMiddleCategoryModels.
     */
    skip?: number
    distinct?: Enumerable<REPropertyMiddleCategoryModelScalarFieldEnum>
  }


  /**
   * REPropertyMiddleCategoryModel create
   */
  export type REPropertyMiddleCategoryModelCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyMiddleCategoryModel
     */
    select?: REPropertyMiddleCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyMiddleCategoryModelInclude<ExtArgs> | null
    /**
     * The data needed to create a REPropertyMiddleCategoryModel.
     */
    data: XOR<REPropertyMiddleCategoryModelCreateInput, REPropertyMiddleCategoryModelUncheckedCreateInput>
  }


  /**
   * REPropertyMiddleCategoryModel createMany
   */
  export type REPropertyMiddleCategoryModelCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many REPropertyMiddleCategoryModels.
     */
    data: Enumerable<REPropertyMiddleCategoryModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * REPropertyMiddleCategoryModel update
   */
  export type REPropertyMiddleCategoryModelUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyMiddleCategoryModel
     */
    select?: REPropertyMiddleCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyMiddleCategoryModelInclude<ExtArgs> | null
    /**
     * The data needed to update a REPropertyMiddleCategoryModel.
     */
    data: XOR<REPropertyMiddleCategoryModelUpdateInput, REPropertyMiddleCategoryModelUncheckedUpdateInput>
    /**
     * Choose, which REPropertyMiddleCategoryModel to update.
     */
    where: REPropertyMiddleCategoryModelWhereUniqueInput
  }


  /**
   * REPropertyMiddleCategoryModel updateMany
   */
  export type REPropertyMiddleCategoryModelUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update REPropertyMiddleCategoryModels.
     */
    data: XOR<REPropertyMiddleCategoryModelUpdateManyMutationInput, REPropertyMiddleCategoryModelUncheckedUpdateManyInput>
    /**
     * Filter which REPropertyMiddleCategoryModels to update
     */
    where?: REPropertyMiddleCategoryModelWhereInput
  }


  /**
   * REPropertyMiddleCategoryModel upsert
   */
  export type REPropertyMiddleCategoryModelUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyMiddleCategoryModel
     */
    select?: REPropertyMiddleCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyMiddleCategoryModelInclude<ExtArgs> | null
    /**
     * The filter to search for the REPropertyMiddleCategoryModel to update in case it exists.
     */
    where: REPropertyMiddleCategoryModelWhereUniqueInput
    /**
     * In case the REPropertyMiddleCategoryModel found by the `where` argument doesn't exist, create a new REPropertyMiddleCategoryModel with this data.
     */
    create: XOR<REPropertyMiddleCategoryModelCreateInput, REPropertyMiddleCategoryModelUncheckedCreateInput>
    /**
     * In case the REPropertyMiddleCategoryModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<REPropertyMiddleCategoryModelUpdateInput, REPropertyMiddleCategoryModelUncheckedUpdateInput>
  }


  /**
   * REPropertyMiddleCategoryModel delete
   */
  export type REPropertyMiddleCategoryModelDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyMiddleCategoryModel
     */
    select?: REPropertyMiddleCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyMiddleCategoryModelInclude<ExtArgs> | null
    /**
     * Filter which REPropertyMiddleCategoryModel to delete.
     */
    where: REPropertyMiddleCategoryModelWhereUniqueInput
  }


  /**
   * REPropertyMiddleCategoryModel deleteMany
   */
  export type REPropertyMiddleCategoryModelDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which REPropertyMiddleCategoryModels to delete
     */
    where?: REPropertyMiddleCategoryModelWhereInput
  }


  /**
   * REPropertyMiddleCategoryModel.sub_categories
   */
  export type REPropertyMiddleCategoryModel$sub_categoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertySubCategoryModel
     */
    select?: REPropertySubCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySubCategoryModelInclude<ExtArgs> | null
    where?: REPropertySubCategoryModelWhereInput
    orderBy?: Enumerable<REPropertySubCategoryModelOrderByWithRelationInput>
    cursor?: REPropertySubCategoryModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<REPropertySubCategoryModelScalarFieldEnum>
  }


  /**
   * REPropertyMiddleCategoryModel without action
   */
  export type REPropertyMiddleCategoryModelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyMiddleCategoryModel
     */
    select?: REPropertyMiddleCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyMiddleCategoryModelInclude<ExtArgs> | null
  }



  /**
   * Model REPropertySuperCategoryModel
   */


  export type AggregateREPropertySuperCategoryModel = {
    _count: REPropertySuperCategoryModelCountAggregateOutputType | null
    _min: REPropertySuperCategoryModelMinAggregateOutputType | null
    _max: REPropertySuperCategoryModelMaxAggregateOutputType | null
  }

  export type REPropertySuperCategoryModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
  }

  export type REPropertySuperCategoryModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
  }

  export type REPropertySuperCategoryModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    name: number
    _all: number
  }


  export type REPropertySuperCategoryModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
  }

  export type REPropertySuperCategoryModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
  }

  export type REPropertySuperCategoryModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    _all?: true
  }

  export type REPropertySuperCategoryModelAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which REPropertySuperCategoryModel to aggregate.
     */
    where?: REPropertySuperCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertySuperCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertySuperCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: REPropertySuperCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertySuperCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertySuperCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned REPropertySuperCategoryModels
    **/
    _count?: true | REPropertySuperCategoryModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: REPropertySuperCategoryModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: REPropertySuperCategoryModelMaxAggregateInputType
  }

  export type GetREPropertySuperCategoryModelAggregateType<T extends REPropertySuperCategoryModelAggregateArgs> = {
        [P in keyof T & keyof AggregateREPropertySuperCategoryModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateREPropertySuperCategoryModel[P]>
      : GetScalarType<T[P], AggregateREPropertySuperCategoryModel[P]>
  }




  export type REPropertySuperCategoryModelGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: REPropertySuperCategoryModelWhereInput
    orderBy?: Enumerable<REPropertySuperCategoryModelOrderByWithAggregationInput>
    by: REPropertySuperCategoryModelScalarFieldEnum[]
    having?: REPropertySuperCategoryModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: REPropertySuperCategoryModelCountAggregateInputType | true
    _min?: REPropertySuperCategoryModelMinAggregateInputType
    _max?: REPropertySuperCategoryModelMaxAggregateInputType
  }


  export type REPropertySuperCategoryModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    name: string
    _count: REPropertySuperCategoryModelCountAggregateOutputType | null
    _min: REPropertySuperCategoryModelMinAggregateOutputType | null
    _max: REPropertySuperCategoryModelMaxAggregateOutputType | null
  }

  type GetREPropertySuperCategoryModelGroupByPayload<T extends REPropertySuperCategoryModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<REPropertySuperCategoryModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof REPropertySuperCategoryModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], REPropertySuperCategoryModelGroupByOutputType[P]>
            : GetScalarType<T[P], REPropertySuperCategoryModelGroupByOutputType[P]>
        }
      >
    >


  export type REPropertySuperCategoryModelSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    name?: boolean
    middle_categories?: boolean | REPropertySuperCategoryModel$middle_categoriesArgs<ExtArgs>
    _count?: boolean | REPropertySuperCategoryModelCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["rEPropertySuperCategoryModel"]>

  export type REPropertySuperCategoryModelSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    name?: boolean
  }

  export type REPropertySuperCategoryModelInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    middle_categories?: boolean | REPropertySuperCategoryModel$middle_categoriesArgs<ExtArgs>
    _count?: boolean | REPropertySuperCategoryModelCountOutputTypeArgs<ExtArgs>
  }


  type REPropertySuperCategoryModelGetPayload<S extends boolean | null | undefined | REPropertySuperCategoryModelArgs> = $Types.GetResult<REPropertySuperCategoryModelPayload, S>

  type REPropertySuperCategoryModelCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<REPropertySuperCategoryModelFindManyArgs, 'select' | 'include'> & {
      select?: REPropertySuperCategoryModelCountAggregateInputType | true
    }

  export interface REPropertySuperCategoryModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['REPropertySuperCategoryModel'], meta: { name: 'REPropertySuperCategoryModel' } }
    /**
     * Find zero or one REPropertySuperCategoryModel that matches the filter.
     * @param {REPropertySuperCategoryModelFindUniqueArgs} args - Arguments to find a REPropertySuperCategoryModel
     * @example
     * // Get one REPropertySuperCategoryModel
     * const rEPropertySuperCategoryModel = await prisma.rEPropertySuperCategoryModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends REPropertySuperCategoryModelFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, REPropertySuperCategoryModelFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'REPropertySuperCategoryModel'> extends True ? Prisma__REPropertySuperCategoryModelClient<$Types.GetResult<REPropertySuperCategoryModelPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__REPropertySuperCategoryModelClient<$Types.GetResult<REPropertySuperCategoryModelPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one REPropertySuperCategoryModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {REPropertySuperCategoryModelFindUniqueOrThrowArgs} args - Arguments to find a REPropertySuperCategoryModel
     * @example
     * // Get one REPropertySuperCategoryModel
     * const rEPropertySuperCategoryModel = await prisma.rEPropertySuperCategoryModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends REPropertySuperCategoryModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertySuperCategoryModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__REPropertySuperCategoryModelClient<$Types.GetResult<REPropertySuperCategoryModelPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first REPropertySuperCategoryModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySuperCategoryModelFindFirstArgs} args - Arguments to find a REPropertySuperCategoryModel
     * @example
     * // Get one REPropertySuperCategoryModel
     * const rEPropertySuperCategoryModel = await prisma.rEPropertySuperCategoryModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends REPropertySuperCategoryModelFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, REPropertySuperCategoryModelFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'REPropertySuperCategoryModel'> extends True ? Prisma__REPropertySuperCategoryModelClient<$Types.GetResult<REPropertySuperCategoryModelPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__REPropertySuperCategoryModelClient<$Types.GetResult<REPropertySuperCategoryModelPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first REPropertySuperCategoryModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySuperCategoryModelFindFirstOrThrowArgs} args - Arguments to find a REPropertySuperCategoryModel
     * @example
     * // Get one REPropertySuperCategoryModel
     * const rEPropertySuperCategoryModel = await prisma.rEPropertySuperCategoryModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends REPropertySuperCategoryModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertySuperCategoryModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__REPropertySuperCategoryModelClient<$Types.GetResult<REPropertySuperCategoryModelPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more REPropertySuperCategoryModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySuperCategoryModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all REPropertySuperCategoryModels
     * const rEPropertySuperCategoryModels = await prisma.rEPropertySuperCategoryModel.findMany()
     * 
     * // Get first 10 REPropertySuperCategoryModels
     * const rEPropertySuperCategoryModels = await prisma.rEPropertySuperCategoryModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rEPropertySuperCategoryModelWithIdOnly = await prisma.rEPropertySuperCategoryModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends REPropertySuperCategoryModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertySuperCategoryModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<REPropertySuperCategoryModelPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a REPropertySuperCategoryModel.
     * @param {REPropertySuperCategoryModelCreateArgs} args - Arguments to create a REPropertySuperCategoryModel.
     * @example
     * // Create one REPropertySuperCategoryModel
     * const REPropertySuperCategoryModel = await prisma.rEPropertySuperCategoryModel.create({
     *   data: {
     *     // ... data to create a REPropertySuperCategoryModel
     *   }
     * })
     * 
    **/
    create<T extends REPropertySuperCategoryModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertySuperCategoryModelCreateArgs<ExtArgs>>
    ): Prisma__REPropertySuperCategoryModelClient<$Types.GetResult<REPropertySuperCategoryModelPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many REPropertySuperCategoryModels.
     *     @param {REPropertySuperCategoryModelCreateManyArgs} args - Arguments to create many REPropertySuperCategoryModels.
     *     @example
     *     // Create many REPropertySuperCategoryModels
     *     const rEPropertySuperCategoryModel = await prisma.rEPropertySuperCategoryModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends REPropertySuperCategoryModelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertySuperCategoryModelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a REPropertySuperCategoryModel.
     * @param {REPropertySuperCategoryModelDeleteArgs} args - Arguments to delete one REPropertySuperCategoryModel.
     * @example
     * // Delete one REPropertySuperCategoryModel
     * const REPropertySuperCategoryModel = await prisma.rEPropertySuperCategoryModel.delete({
     *   where: {
     *     // ... filter to delete one REPropertySuperCategoryModel
     *   }
     * })
     * 
    **/
    delete<T extends REPropertySuperCategoryModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertySuperCategoryModelDeleteArgs<ExtArgs>>
    ): Prisma__REPropertySuperCategoryModelClient<$Types.GetResult<REPropertySuperCategoryModelPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one REPropertySuperCategoryModel.
     * @param {REPropertySuperCategoryModelUpdateArgs} args - Arguments to update one REPropertySuperCategoryModel.
     * @example
     * // Update one REPropertySuperCategoryModel
     * const rEPropertySuperCategoryModel = await prisma.rEPropertySuperCategoryModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends REPropertySuperCategoryModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertySuperCategoryModelUpdateArgs<ExtArgs>>
    ): Prisma__REPropertySuperCategoryModelClient<$Types.GetResult<REPropertySuperCategoryModelPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more REPropertySuperCategoryModels.
     * @param {REPropertySuperCategoryModelDeleteManyArgs} args - Arguments to filter REPropertySuperCategoryModels to delete.
     * @example
     * // Delete a few REPropertySuperCategoryModels
     * const { count } = await prisma.rEPropertySuperCategoryModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends REPropertySuperCategoryModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, REPropertySuperCategoryModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more REPropertySuperCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySuperCategoryModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many REPropertySuperCategoryModels
     * const rEPropertySuperCategoryModel = await prisma.rEPropertySuperCategoryModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends REPropertySuperCategoryModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertySuperCategoryModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one REPropertySuperCategoryModel.
     * @param {REPropertySuperCategoryModelUpsertArgs} args - Arguments to update or create a REPropertySuperCategoryModel.
     * @example
     * // Update or create a REPropertySuperCategoryModel
     * const rEPropertySuperCategoryModel = await prisma.rEPropertySuperCategoryModel.upsert({
     *   create: {
     *     // ... data to create a REPropertySuperCategoryModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the REPropertySuperCategoryModel we want to update
     *   }
     * })
    **/
    upsert<T extends REPropertySuperCategoryModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, REPropertySuperCategoryModelUpsertArgs<ExtArgs>>
    ): Prisma__REPropertySuperCategoryModelClient<$Types.GetResult<REPropertySuperCategoryModelPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of REPropertySuperCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySuperCategoryModelCountArgs} args - Arguments to filter REPropertySuperCategoryModels to count.
     * @example
     * // Count the number of REPropertySuperCategoryModels
     * const count = await prisma.rEPropertySuperCategoryModel.count({
     *   where: {
     *     // ... the filter for the REPropertySuperCategoryModels we want to count
     *   }
     * })
    **/
    count<T extends REPropertySuperCategoryModelCountArgs>(
      args?: Subset<T, REPropertySuperCategoryModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], REPropertySuperCategoryModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a REPropertySuperCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySuperCategoryModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends REPropertySuperCategoryModelAggregateArgs>(args: Subset<T, REPropertySuperCategoryModelAggregateArgs>): Prisma.PrismaPromise<GetREPropertySuperCategoryModelAggregateType<T>>

    /**
     * Group by REPropertySuperCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPropertySuperCategoryModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends REPropertySuperCategoryModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: REPropertySuperCategoryModelGroupByArgs['orderBy'] }
        : { orderBy?: REPropertySuperCategoryModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, REPropertySuperCategoryModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetREPropertySuperCategoryModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for REPropertySuperCategoryModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__REPropertySuperCategoryModelClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    middle_categories<T extends REPropertySuperCategoryModel$middle_categoriesArgs<ExtArgs> = {}>(args?: Subset<T, REPropertySuperCategoryModel$middle_categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<REPropertyMiddleCategoryModelPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * REPropertySuperCategoryModel base type for findUnique actions
   */
  export type REPropertySuperCategoryModelFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertySuperCategoryModel
     */
    select?: REPropertySuperCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySuperCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertySuperCategoryModel to fetch.
     */
    where: REPropertySuperCategoryModelWhereUniqueInput
  }

  /**
   * REPropertySuperCategoryModel findUnique
   */
  export interface REPropertySuperCategoryModelFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends REPropertySuperCategoryModelFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * REPropertySuperCategoryModel findUniqueOrThrow
   */
  export type REPropertySuperCategoryModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertySuperCategoryModel
     */
    select?: REPropertySuperCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySuperCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertySuperCategoryModel to fetch.
     */
    where: REPropertySuperCategoryModelWhereUniqueInput
  }


  /**
   * REPropertySuperCategoryModel base type for findFirst actions
   */
  export type REPropertySuperCategoryModelFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertySuperCategoryModel
     */
    select?: REPropertySuperCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySuperCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertySuperCategoryModel to fetch.
     */
    where?: REPropertySuperCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertySuperCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertySuperCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REPropertySuperCategoryModels.
     */
    cursor?: REPropertySuperCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertySuperCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertySuperCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REPropertySuperCategoryModels.
     */
    distinct?: Enumerable<REPropertySuperCategoryModelScalarFieldEnum>
  }

  /**
   * REPropertySuperCategoryModel findFirst
   */
  export interface REPropertySuperCategoryModelFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends REPropertySuperCategoryModelFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * REPropertySuperCategoryModel findFirstOrThrow
   */
  export type REPropertySuperCategoryModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertySuperCategoryModel
     */
    select?: REPropertySuperCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySuperCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertySuperCategoryModel to fetch.
     */
    where?: REPropertySuperCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertySuperCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertySuperCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REPropertySuperCategoryModels.
     */
    cursor?: REPropertySuperCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertySuperCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertySuperCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REPropertySuperCategoryModels.
     */
    distinct?: Enumerable<REPropertySuperCategoryModelScalarFieldEnum>
  }


  /**
   * REPropertySuperCategoryModel findMany
   */
  export type REPropertySuperCategoryModelFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertySuperCategoryModel
     */
    select?: REPropertySuperCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySuperCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which REPropertySuperCategoryModels to fetch.
     */
    where?: REPropertySuperCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPropertySuperCategoryModels to fetch.
     */
    orderBy?: Enumerable<REPropertySuperCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing REPropertySuperCategoryModels.
     */
    cursor?: REPropertySuperCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPropertySuperCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPropertySuperCategoryModels.
     */
    skip?: number
    distinct?: Enumerable<REPropertySuperCategoryModelScalarFieldEnum>
  }


  /**
   * REPropertySuperCategoryModel create
   */
  export type REPropertySuperCategoryModelCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertySuperCategoryModel
     */
    select?: REPropertySuperCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySuperCategoryModelInclude<ExtArgs> | null
    /**
     * The data needed to create a REPropertySuperCategoryModel.
     */
    data: XOR<REPropertySuperCategoryModelCreateInput, REPropertySuperCategoryModelUncheckedCreateInput>
  }


  /**
   * REPropertySuperCategoryModel createMany
   */
  export type REPropertySuperCategoryModelCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many REPropertySuperCategoryModels.
     */
    data: Enumerable<REPropertySuperCategoryModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * REPropertySuperCategoryModel update
   */
  export type REPropertySuperCategoryModelUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertySuperCategoryModel
     */
    select?: REPropertySuperCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySuperCategoryModelInclude<ExtArgs> | null
    /**
     * The data needed to update a REPropertySuperCategoryModel.
     */
    data: XOR<REPropertySuperCategoryModelUpdateInput, REPropertySuperCategoryModelUncheckedUpdateInput>
    /**
     * Choose, which REPropertySuperCategoryModel to update.
     */
    where: REPropertySuperCategoryModelWhereUniqueInput
  }


  /**
   * REPropertySuperCategoryModel updateMany
   */
  export type REPropertySuperCategoryModelUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update REPropertySuperCategoryModels.
     */
    data: XOR<REPropertySuperCategoryModelUpdateManyMutationInput, REPropertySuperCategoryModelUncheckedUpdateManyInput>
    /**
     * Filter which REPropertySuperCategoryModels to update
     */
    where?: REPropertySuperCategoryModelWhereInput
  }


  /**
   * REPropertySuperCategoryModel upsert
   */
  export type REPropertySuperCategoryModelUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertySuperCategoryModel
     */
    select?: REPropertySuperCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySuperCategoryModelInclude<ExtArgs> | null
    /**
     * The filter to search for the REPropertySuperCategoryModel to update in case it exists.
     */
    where: REPropertySuperCategoryModelWhereUniqueInput
    /**
     * In case the REPropertySuperCategoryModel found by the `where` argument doesn't exist, create a new REPropertySuperCategoryModel with this data.
     */
    create: XOR<REPropertySuperCategoryModelCreateInput, REPropertySuperCategoryModelUncheckedCreateInput>
    /**
     * In case the REPropertySuperCategoryModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<REPropertySuperCategoryModelUpdateInput, REPropertySuperCategoryModelUncheckedUpdateInput>
  }


  /**
   * REPropertySuperCategoryModel delete
   */
  export type REPropertySuperCategoryModelDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertySuperCategoryModel
     */
    select?: REPropertySuperCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySuperCategoryModelInclude<ExtArgs> | null
    /**
     * Filter which REPropertySuperCategoryModel to delete.
     */
    where: REPropertySuperCategoryModelWhereUniqueInput
  }


  /**
   * REPropertySuperCategoryModel deleteMany
   */
  export type REPropertySuperCategoryModelDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which REPropertySuperCategoryModels to delete
     */
    where?: REPropertySuperCategoryModelWhereInput
  }


  /**
   * REPropertySuperCategoryModel.middle_categories
   */
  export type REPropertySuperCategoryModel$middle_categoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyMiddleCategoryModel
     */
    select?: REPropertyMiddleCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyMiddleCategoryModelInclude<ExtArgs> | null
    where?: REPropertyMiddleCategoryModelWhereInput
    orderBy?: Enumerable<REPropertyMiddleCategoryModelOrderByWithRelationInput>
    cursor?: REPropertyMiddleCategoryModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<REPropertyMiddleCategoryModelScalarFieldEnum>
  }


  /**
   * REPropertySuperCategoryModel without action
   */
  export type REPropertySuperCategoryModelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertySuperCategoryModel
     */
    select?: REPropertySuperCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertySuperCategoryModelInclude<ExtArgs> | null
  }



  /**
   * Model AgreementModel
   */


  export type AggregateAgreementModel = {
    _count: AgreementModelCountAggregateOutputType | null
    _min: AgreementModelMinAggregateOutputType | null
    _max: AgreementModelMaxAggregateOutputType | null
  }

  export type AgreementModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    title: string | null
    content: string | null
    is_required: boolean | null
    target_type: AgreementTargetType | null
  }

  export type AgreementModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    title: string | null
    content: string | null
    is_required: boolean | null
    target_type: AgreementTargetType | null
  }

  export type AgreementModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    title: number
    content: number
    is_required: number
    target_type: number
    _all: number
  }


  export type AgreementModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    title?: true
    content?: true
    is_required?: true
    target_type?: true
  }

  export type AgreementModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    title?: true
    content?: true
    is_required?: true
    target_type?: true
  }

  export type AgreementModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    title?: true
    content?: true
    is_required?: true
    target_type?: true
    _all?: true
  }

  export type AgreementModelAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgreementModel to aggregate.
     */
    where?: AgreementModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementModels to fetch.
     */
    orderBy?: Enumerable<AgreementModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgreementModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgreementModels
    **/
    _count?: true | AgreementModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgreementModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgreementModelMaxAggregateInputType
  }

  export type GetAgreementModelAggregateType<T extends AgreementModelAggregateArgs> = {
        [P in keyof T & keyof AggregateAgreementModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgreementModel[P]>
      : GetScalarType<T[P], AggregateAgreementModel[P]>
  }




  export type AgreementModelGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AgreementModelWhereInput
    orderBy?: Enumerable<AgreementModelOrderByWithAggregationInput>
    by: AgreementModelScalarFieldEnum[]
    having?: AgreementModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgreementModelCountAggregateInputType | true
    _min?: AgreementModelMinAggregateInputType
    _max?: AgreementModelMaxAggregateInputType
  }


  export type AgreementModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    title: string
    content: string
    is_required: boolean
    target_type: AgreementTargetType
    _count: AgreementModelCountAggregateOutputType | null
    _min: AgreementModelMinAggregateOutputType | null
    _max: AgreementModelMaxAggregateOutputType | null
  }

  type GetAgreementModelGroupByPayload<T extends AgreementModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AgreementModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgreementModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgreementModelGroupByOutputType[P]>
            : GetScalarType<T[P], AgreementModelGroupByOutputType[P]>
        }
      >
    >


  export type AgreementModelSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    title?: boolean
    content?: boolean
    is_required?: boolean
    target_type?: boolean
    acceptances?: boolean | AgreementModel$acceptancesArgs<ExtArgs>
    _count?: boolean | AgreementModelCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["agreementModel"]>

  export type AgreementModelSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    title?: boolean
    content?: boolean
    is_required?: boolean
    target_type?: boolean
  }

  export type AgreementModelInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    acceptances?: boolean | AgreementModel$acceptancesArgs<ExtArgs>
    _count?: boolean | AgreementModelCountOutputTypeArgs<ExtArgs>
  }


  type AgreementModelGetPayload<S extends boolean | null | undefined | AgreementModelArgs> = $Types.GetResult<AgreementModelPayload, S>

  type AgreementModelCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AgreementModelFindManyArgs, 'select' | 'include'> & {
      select?: AgreementModelCountAggregateInputType | true
    }

  export interface AgreementModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgreementModel'], meta: { name: 'AgreementModel' } }
    /**
     * Find zero or one AgreementModel that matches the filter.
     * @param {AgreementModelFindUniqueArgs} args - Arguments to find a AgreementModel
     * @example
     * // Get one AgreementModel
     * const agreementModel = await prisma.agreementModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AgreementModelFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AgreementModelFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AgreementModel'> extends True ? Prisma__AgreementModelClient<$Types.GetResult<AgreementModelPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AgreementModelClient<$Types.GetResult<AgreementModelPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one AgreementModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AgreementModelFindUniqueOrThrowArgs} args - Arguments to find a AgreementModel
     * @example
     * // Get one AgreementModel
     * const agreementModel = await prisma.agreementModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AgreementModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgreementModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AgreementModelClient<$Types.GetResult<AgreementModelPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first AgreementModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementModelFindFirstArgs} args - Arguments to find a AgreementModel
     * @example
     * // Get one AgreementModel
     * const agreementModel = await prisma.agreementModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AgreementModelFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AgreementModelFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AgreementModel'> extends True ? Prisma__AgreementModelClient<$Types.GetResult<AgreementModelPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AgreementModelClient<$Types.GetResult<AgreementModelPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first AgreementModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementModelFindFirstOrThrowArgs} args - Arguments to find a AgreementModel
     * @example
     * // Get one AgreementModel
     * const agreementModel = await prisma.agreementModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AgreementModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgreementModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AgreementModelClient<$Types.GetResult<AgreementModelPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more AgreementModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgreementModels
     * const agreementModels = await prisma.agreementModel.findMany()
     * 
     * // Get first 10 AgreementModels
     * const agreementModels = await prisma.agreementModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agreementModelWithIdOnly = await prisma.agreementModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AgreementModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgreementModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AgreementModelPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a AgreementModel.
     * @param {AgreementModelCreateArgs} args - Arguments to create a AgreementModel.
     * @example
     * // Create one AgreementModel
     * const AgreementModel = await prisma.agreementModel.create({
     *   data: {
     *     // ... data to create a AgreementModel
     *   }
     * })
     * 
    **/
    create<T extends AgreementModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AgreementModelCreateArgs<ExtArgs>>
    ): Prisma__AgreementModelClient<$Types.GetResult<AgreementModelPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many AgreementModels.
     *     @param {AgreementModelCreateManyArgs} args - Arguments to create many AgreementModels.
     *     @example
     *     // Create many AgreementModels
     *     const agreementModel = await prisma.agreementModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AgreementModelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgreementModelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgreementModel.
     * @param {AgreementModelDeleteArgs} args - Arguments to delete one AgreementModel.
     * @example
     * // Delete one AgreementModel
     * const AgreementModel = await prisma.agreementModel.delete({
     *   where: {
     *     // ... filter to delete one AgreementModel
     *   }
     * })
     * 
    **/
    delete<T extends AgreementModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AgreementModelDeleteArgs<ExtArgs>>
    ): Prisma__AgreementModelClient<$Types.GetResult<AgreementModelPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one AgreementModel.
     * @param {AgreementModelUpdateArgs} args - Arguments to update one AgreementModel.
     * @example
     * // Update one AgreementModel
     * const agreementModel = await prisma.agreementModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AgreementModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AgreementModelUpdateArgs<ExtArgs>>
    ): Prisma__AgreementModelClient<$Types.GetResult<AgreementModelPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more AgreementModels.
     * @param {AgreementModelDeleteManyArgs} args - Arguments to filter AgreementModels to delete.
     * @example
     * // Delete a few AgreementModels
     * const { count } = await prisma.agreementModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AgreementModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgreementModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgreementModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgreementModels
     * const agreementModel = await prisma.agreementModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AgreementModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AgreementModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgreementModel.
     * @param {AgreementModelUpsertArgs} args - Arguments to update or create a AgreementModel.
     * @example
     * // Update or create a AgreementModel
     * const agreementModel = await prisma.agreementModel.upsert({
     *   create: {
     *     // ... data to create a AgreementModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgreementModel we want to update
     *   }
     * })
    **/
    upsert<T extends AgreementModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AgreementModelUpsertArgs<ExtArgs>>
    ): Prisma__AgreementModelClient<$Types.GetResult<AgreementModelPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of AgreementModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementModelCountArgs} args - Arguments to filter AgreementModels to count.
     * @example
     * // Count the number of AgreementModels
     * const count = await prisma.agreementModel.count({
     *   where: {
     *     // ... the filter for the AgreementModels we want to count
     *   }
     * })
    **/
    count<T extends AgreementModelCountArgs>(
      args?: Subset<T, AgreementModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgreementModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgreementModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgreementModelAggregateArgs>(args: Subset<T, AgreementModelAggregateArgs>): Prisma.PrismaPromise<GetAgreementModelAggregateType<T>>

    /**
     * Group by AgreementModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgreementModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgreementModelGroupByArgs['orderBy'] }
        : { orderBy?: AgreementModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgreementModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgreementModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AgreementModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AgreementModelClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    acceptances<T extends AgreementModel$acceptancesArgs<ExtArgs> = {}>(args?: Subset<T, AgreementModel$acceptancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AgreementAcceptanceModelPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AgreementModel base type for findUnique actions
   */
  export type AgreementModelFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementModel
     */
    select?: AgreementModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementModelInclude<ExtArgs> | null
    /**
     * Filter, which AgreementModel to fetch.
     */
    where: AgreementModelWhereUniqueInput
  }

  /**
   * AgreementModel findUnique
   */
  export interface AgreementModelFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AgreementModelFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AgreementModel findUniqueOrThrow
   */
  export type AgreementModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementModel
     */
    select?: AgreementModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementModelInclude<ExtArgs> | null
    /**
     * Filter, which AgreementModel to fetch.
     */
    where: AgreementModelWhereUniqueInput
  }


  /**
   * AgreementModel base type for findFirst actions
   */
  export type AgreementModelFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementModel
     */
    select?: AgreementModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementModelInclude<ExtArgs> | null
    /**
     * Filter, which AgreementModel to fetch.
     */
    where?: AgreementModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementModels to fetch.
     */
    orderBy?: Enumerable<AgreementModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgreementModels.
     */
    cursor?: AgreementModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgreementModels.
     */
    distinct?: Enumerable<AgreementModelScalarFieldEnum>
  }

  /**
   * AgreementModel findFirst
   */
  export interface AgreementModelFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AgreementModelFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AgreementModel findFirstOrThrow
   */
  export type AgreementModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementModel
     */
    select?: AgreementModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementModelInclude<ExtArgs> | null
    /**
     * Filter, which AgreementModel to fetch.
     */
    where?: AgreementModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementModels to fetch.
     */
    orderBy?: Enumerable<AgreementModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgreementModels.
     */
    cursor?: AgreementModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgreementModels.
     */
    distinct?: Enumerable<AgreementModelScalarFieldEnum>
  }


  /**
   * AgreementModel findMany
   */
  export type AgreementModelFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementModel
     */
    select?: AgreementModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementModelInclude<ExtArgs> | null
    /**
     * Filter, which AgreementModels to fetch.
     */
    where?: AgreementModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementModels to fetch.
     */
    orderBy?: Enumerable<AgreementModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgreementModels.
     */
    cursor?: AgreementModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementModels.
     */
    skip?: number
    distinct?: Enumerable<AgreementModelScalarFieldEnum>
  }


  /**
   * AgreementModel create
   */
  export type AgreementModelCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementModel
     */
    select?: AgreementModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementModelInclude<ExtArgs> | null
    /**
     * The data needed to create a AgreementModel.
     */
    data: XOR<AgreementModelCreateInput, AgreementModelUncheckedCreateInput>
  }


  /**
   * AgreementModel createMany
   */
  export type AgreementModelCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgreementModels.
     */
    data: Enumerable<AgreementModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AgreementModel update
   */
  export type AgreementModelUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementModel
     */
    select?: AgreementModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementModelInclude<ExtArgs> | null
    /**
     * The data needed to update a AgreementModel.
     */
    data: XOR<AgreementModelUpdateInput, AgreementModelUncheckedUpdateInput>
    /**
     * Choose, which AgreementModel to update.
     */
    where: AgreementModelWhereUniqueInput
  }


  /**
   * AgreementModel updateMany
   */
  export type AgreementModelUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgreementModels.
     */
    data: XOR<AgreementModelUpdateManyMutationInput, AgreementModelUncheckedUpdateManyInput>
    /**
     * Filter which AgreementModels to update
     */
    where?: AgreementModelWhereInput
  }


  /**
   * AgreementModel upsert
   */
  export type AgreementModelUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementModel
     */
    select?: AgreementModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementModelInclude<ExtArgs> | null
    /**
     * The filter to search for the AgreementModel to update in case it exists.
     */
    where: AgreementModelWhereUniqueInput
    /**
     * In case the AgreementModel found by the `where` argument doesn't exist, create a new AgreementModel with this data.
     */
    create: XOR<AgreementModelCreateInput, AgreementModelUncheckedCreateInput>
    /**
     * In case the AgreementModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgreementModelUpdateInput, AgreementModelUncheckedUpdateInput>
  }


  /**
   * AgreementModel delete
   */
  export type AgreementModelDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementModel
     */
    select?: AgreementModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementModelInclude<ExtArgs> | null
    /**
     * Filter which AgreementModel to delete.
     */
    where: AgreementModelWhereUniqueInput
  }


  /**
   * AgreementModel deleteMany
   */
  export type AgreementModelDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgreementModels to delete
     */
    where?: AgreementModelWhereInput
  }


  /**
   * AgreementModel.acceptances
   */
  export type AgreementModel$acceptancesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementAcceptanceModel
     */
    select?: AgreementAcceptanceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementAcceptanceModelInclude<ExtArgs> | null
    where?: AgreementAcceptanceModelWhereInput
    orderBy?: Enumerable<AgreementAcceptanceModelOrderByWithRelationInput>
    cursor?: AgreementAcceptanceModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AgreementAcceptanceModelScalarFieldEnum>
  }


  /**
   * AgreementModel without action
   */
  export type AgreementModelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementModel
     */
    select?: AgreementModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementModelInclude<ExtArgs> | null
  }



  /**
   * Model AgreementAcceptanceModel
   */


  export type AggregateAgreementAcceptanceModel = {
    _count: AgreementAcceptanceModelCountAggregateOutputType | null
    _min: AgreementAcceptanceModelMinAggregateOutputType | null
    _max: AgreementAcceptanceModelMaxAggregateOutputType | null
  }

  export type AgreementAcceptanceModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    user_id: string | null
    agreement_id: string | null
  }

  export type AgreementAcceptanceModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    user_id: string | null
    agreement_id: string | null
  }

  export type AgreementAcceptanceModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    user_id: number
    agreement_id: number
    _all: number
  }


  export type AgreementAcceptanceModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    user_id?: true
    agreement_id?: true
  }

  export type AgreementAcceptanceModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    user_id?: true
    agreement_id?: true
  }

  export type AgreementAcceptanceModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    user_id?: true
    agreement_id?: true
    _all?: true
  }

  export type AgreementAcceptanceModelAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgreementAcceptanceModel to aggregate.
     */
    where?: AgreementAcceptanceModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementAcceptanceModels to fetch.
     */
    orderBy?: Enumerable<AgreementAcceptanceModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgreementAcceptanceModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementAcceptanceModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementAcceptanceModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgreementAcceptanceModels
    **/
    _count?: true | AgreementAcceptanceModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgreementAcceptanceModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgreementAcceptanceModelMaxAggregateInputType
  }

  export type GetAgreementAcceptanceModelAggregateType<T extends AgreementAcceptanceModelAggregateArgs> = {
        [P in keyof T & keyof AggregateAgreementAcceptanceModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgreementAcceptanceModel[P]>
      : GetScalarType<T[P], AggregateAgreementAcceptanceModel[P]>
  }




  export type AgreementAcceptanceModelGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AgreementAcceptanceModelWhereInput
    orderBy?: Enumerable<AgreementAcceptanceModelOrderByWithAggregationInput>
    by: AgreementAcceptanceModelScalarFieldEnum[]
    having?: AgreementAcceptanceModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgreementAcceptanceModelCountAggregateInputType | true
    _min?: AgreementAcceptanceModelMinAggregateInputType
    _max?: AgreementAcceptanceModelMaxAggregateInputType
  }


  export type AgreementAcceptanceModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    user_id: string
    agreement_id: string
    _count: AgreementAcceptanceModelCountAggregateOutputType | null
    _min: AgreementAcceptanceModelMinAggregateOutputType | null
    _max: AgreementAcceptanceModelMaxAggregateOutputType | null
  }

  type GetAgreementAcceptanceModelGroupByPayload<T extends AgreementAcceptanceModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AgreementAcceptanceModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgreementAcceptanceModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgreementAcceptanceModelGroupByOutputType[P]>
            : GetScalarType<T[P], AgreementAcceptanceModelGroupByOutputType[P]>
        }
      >
    >


  export type AgreementAcceptanceModelSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    user_id?: boolean
    agreement_id?: boolean
    user?: boolean | UserModelArgs<ExtArgs>
    agreement?: boolean | AgreementModelArgs<ExtArgs>
  }, ExtArgs["result"]["agreementAcceptanceModel"]>

  export type AgreementAcceptanceModelSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    user_id?: boolean
    agreement_id?: boolean
  }

  export type AgreementAcceptanceModelInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserModelArgs<ExtArgs>
    agreement?: boolean | AgreementModelArgs<ExtArgs>
  }


  type AgreementAcceptanceModelGetPayload<S extends boolean | null | undefined | AgreementAcceptanceModelArgs> = $Types.GetResult<AgreementAcceptanceModelPayload, S>

  type AgreementAcceptanceModelCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AgreementAcceptanceModelFindManyArgs, 'select' | 'include'> & {
      select?: AgreementAcceptanceModelCountAggregateInputType | true
    }

  export interface AgreementAcceptanceModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgreementAcceptanceModel'], meta: { name: 'AgreementAcceptanceModel' } }
    /**
     * Find zero or one AgreementAcceptanceModel that matches the filter.
     * @param {AgreementAcceptanceModelFindUniqueArgs} args - Arguments to find a AgreementAcceptanceModel
     * @example
     * // Get one AgreementAcceptanceModel
     * const agreementAcceptanceModel = await prisma.agreementAcceptanceModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AgreementAcceptanceModelFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AgreementAcceptanceModelFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AgreementAcceptanceModel'> extends True ? Prisma__AgreementAcceptanceModelClient<$Types.GetResult<AgreementAcceptanceModelPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AgreementAcceptanceModelClient<$Types.GetResult<AgreementAcceptanceModelPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one AgreementAcceptanceModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AgreementAcceptanceModelFindUniqueOrThrowArgs} args - Arguments to find a AgreementAcceptanceModel
     * @example
     * // Get one AgreementAcceptanceModel
     * const agreementAcceptanceModel = await prisma.agreementAcceptanceModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AgreementAcceptanceModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgreementAcceptanceModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AgreementAcceptanceModelClient<$Types.GetResult<AgreementAcceptanceModelPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first AgreementAcceptanceModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementAcceptanceModelFindFirstArgs} args - Arguments to find a AgreementAcceptanceModel
     * @example
     * // Get one AgreementAcceptanceModel
     * const agreementAcceptanceModel = await prisma.agreementAcceptanceModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AgreementAcceptanceModelFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AgreementAcceptanceModelFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AgreementAcceptanceModel'> extends True ? Prisma__AgreementAcceptanceModelClient<$Types.GetResult<AgreementAcceptanceModelPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AgreementAcceptanceModelClient<$Types.GetResult<AgreementAcceptanceModelPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first AgreementAcceptanceModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementAcceptanceModelFindFirstOrThrowArgs} args - Arguments to find a AgreementAcceptanceModel
     * @example
     * // Get one AgreementAcceptanceModel
     * const agreementAcceptanceModel = await prisma.agreementAcceptanceModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AgreementAcceptanceModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgreementAcceptanceModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AgreementAcceptanceModelClient<$Types.GetResult<AgreementAcceptanceModelPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more AgreementAcceptanceModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementAcceptanceModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgreementAcceptanceModels
     * const agreementAcceptanceModels = await prisma.agreementAcceptanceModel.findMany()
     * 
     * // Get first 10 AgreementAcceptanceModels
     * const agreementAcceptanceModels = await prisma.agreementAcceptanceModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agreementAcceptanceModelWithIdOnly = await prisma.agreementAcceptanceModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AgreementAcceptanceModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgreementAcceptanceModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AgreementAcceptanceModelPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a AgreementAcceptanceModel.
     * @param {AgreementAcceptanceModelCreateArgs} args - Arguments to create a AgreementAcceptanceModel.
     * @example
     * // Create one AgreementAcceptanceModel
     * const AgreementAcceptanceModel = await prisma.agreementAcceptanceModel.create({
     *   data: {
     *     // ... data to create a AgreementAcceptanceModel
     *   }
     * })
     * 
    **/
    create<T extends AgreementAcceptanceModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AgreementAcceptanceModelCreateArgs<ExtArgs>>
    ): Prisma__AgreementAcceptanceModelClient<$Types.GetResult<AgreementAcceptanceModelPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many AgreementAcceptanceModels.
     *     @param {AgreementAcceptanceModelCreateManyArgs} args - Arguments to create many AgreementAcceptanceModels.
     *     @example
     *     // Create many AgreementAcceptanceModels
     *     const agreementAcceptanceModel = await prisma.agreementAcceptanceModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AgreementAcceptanceModelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgreementAcceptanceModelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgreementAcceptanceModel.
     * @param {AgreementAcceptanceModelDeleteArgs} args - Arguments to delete one AgreementAcceptanceModel.
     * @example
     * // Delete one AgreementAcceptanceModel
     * const AgreementAcceptanceModel = await prisma.agreementAcceptanceModel.delete({
     *   where: {
     *     // ... filter to delete one AgreementAcceptanceModel
     *   }
     * })
     * 
    **/
    delete<T extends AgreementAcceptanceModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AgreementAcceptanceModelDeleteArgs<ExtArgs>>
    ): Prisma__AgreementAcceptanceModelClient<$Types.GetResult<AgreementAcceptanceModelPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one AgreementAcceptanceModel.
     * @param {AgreementAcceptanceModelUpdateArgs} args - Arguments to update one AgreementAcceptanceModel.
     * @example
     * // Update one AgreementAcceptanceModel
     * const agreementAcceptanceModel = await prisma.agreementAcceptanceModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AgreementAcceptanceModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AgreementAcceptanceModelUpdateArgs<ExtArgs>>
    ): Prisma__AgreementAcceptanceModelClient<$Types.GetResult<AgreementAcceptanceModelPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more AgreementAcceptanceModels.
     * @param {AgreementAcceptanceModelDeleteManyArgs} args - Arguments to filter AgreementAcceptanceModels to delete.
     * @example
     * // Delete a few AgreementAcceptanceModels
     * const { count } = await prisma.agreementAcceptanceModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AgreementAcceptanceModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgreementAcceptanceModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgreementAcceptanceModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementAcceptanceModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgreementAcceptanceModels
     * const agreementAcceptanceModel = await prisma.agreementAcceptanceModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AgreementAcceptanceModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AgreementAcceptanceModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgreementAcceptanceModel.
     * @param {AgreementAcceptanceModelUpsertArgs} args - Arguments to update or create a AgreementAcceptanceModel.
     * @example
     * // Update or create a AgreementAcceptanceModel
     * const agreementAcceptanceModel = await prisma.agreementAcceptanceModel.upsert({
     *   create: {
     *     // ... data to create a AgreementAcceptanceModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgreementAcceptanceModel we want to update
     *   }
     * })
    **/
    upsert<T extends AgreementAcceptanceModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AgreementAcceptanceModelUpsertArgs<ExtArgs>>
    ): Prisma__AgreementAcceptanceModelClient<$Types.GetResult<AgreementAcceptanceModelPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of AgreementAcceptanceModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementAcceptanceModelCountArgs} args - Arguments to filter AgreementAcceptanceModels to count.
     * @example
     * // Count the number of AgreementAcceptanceModels
     * const count = await prisma.agreementAcceptanceModel.count({
     *   where: {
     *     // ... the filter for the AgreementAcceptanceModels we want to count
     *   }
     * })
    **/
    count<T extends AgreementAcceptanceModelCountArgs>(
      args?: Subset<T, AgreementAcceptanceModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgreementAcceptanceModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgreementAcceptanceModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementAcceptanceModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgreementAcceptanceModelAggregateArgs>(args: Subset<T, AgreementAcceptanceModelAggregateArgs>): Prisma.PrismaPromise<GetAgreementAcceptanceModelAggregateType<T>>

    /**
     * Group by AgreementAcceptanceModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementAcceptanceModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgreementAcceptanceModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgreementAcceptanceModelGroupByArgs['orderBy'] }
        : { orderBy?: AgreementAcceptanceModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgreementAcceptanceModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgreementAcceptanceModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AgreementAcceptanceModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AgreementAcceptanceModelClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserModelArgs<ExtArgs> = {}>(args?: Subset<T, UserModelArgs<ExtArgs>>): Prisma__UserModelClient<$Types.GetResult<UserModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    agreement<T extends AgreementModelArgs<ExtArgs> = {}>(args?: Subset<T, AgreementModelArgs<ExtArgs>>): Prisma__AgreementModelClient<$Types.GetResult<AgreementModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AgreementAcceptanceModel base type for findUnique actions
   */
  export type AgreementAcceptanceModelFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementAcceptanceModel
     */
    select?: AgreementAcceptanceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementAcceptanceModelInclude<ExtArgs> | null
    /**
     * Filter, which AgreementAcceptanceModel to fetch.
     */
    where: AgreementAcceptanceModelWhereUniqueInput
  }

  /**
   * AgreementAcceptanceModel findUnique
   */
  export interface AgreementAcceptanceModelFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AgreementAcceptanceModelFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AgreementAcceptanceModel findUniqueOrThrow
   */
  export type AgreementAcceptanceModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementAcceptanceModel
     */
    select?: AgreementAcceptanceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementAcceptanceModelInclude<ExtArgs> | null
    /**
     * Filter, which AgreementAcceptanceModel to fetch.
     */
    where: AgreementAcceptanceModelWhereUniqueInput
  }


  /**
   * AgreementAcceptanceModel base type for findFirst actions
   */
  export type AgreementAcceptanceModelFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementAcceptanceModel
     */
    select?: AgreementAcceptanceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementAcceptanceModelInclude<ExtArgs> | null
    /**
     * Filter, which AgreementAcceptanceModel to fetch.
     */
    where?: AgreementAcceptanceModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementAcceptanceModels to fetch.
     */
    orderBy?: Enumerable<AgreementAcceptanceModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgreementAcceptanceModels.
     */
    cursor?: AgreementAcceptanceModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementAcceptanceModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementAcceptanceModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgreementAcceptanceModels.
     */
    distinct?: Enumerable<AgreementAcceptanceModelScalarFieldEnum>
  }

  /**
   * AgreementAcceptanceModel findFirst
   */
  export interface AgreementAcceptanceModelFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AgreementAcceptanceModelFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AgreementAcceptanceModel findFirstOrThrow
   */
  export type AgreementAcceptanceModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementAcceptanceModel
     */
    select?: AgreementAcceptanceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementAcceptanceModelInclude<ExtArgs> | null
    /**
     * Filter, which AgreementAcceptanceModel to fetch.
     */
    where?: AgreementAcceptanceModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementAcceptanceModels to fetch.
     */
    orderBy?: Enumerable<AgreementAcceptanceModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgreementAcceptanceModels.
     */
    cursor?: AgreementAcceptanceModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementAcceptanceModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementAcceptanceModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgreementAcceptanceModels.
     */
    distinct?: Enumerable<AgreementAcceptanceModelScalarFieldEnum>
  }


  /**
   * AgreementAcceptanceModel findMany
   */
  export type AgreementAcceptanceModelFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementAcceptanceModel
     */
    select?: AgreementAcceptanceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementAcceptanceModelInclude<ExtArgs> | null
    /**
     * Filter, which AgreementAcceptanceModels to fetch.
     */
    where?: AgreementAcceptanceModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementAcceptanceModels to fetch.
     */
    orderBy?: Enumerable<AgreementAcceptanceModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgreementAcceptanceModels.
     */
    cursor?: AgreementAcceptanceModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementAcceptanceModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementAcceptanceModels.
     */
    skip?: number
    distinct?: Enumerable<AgreementAcceptanceModelScalarFieldEnum>
  }


  /**
   * AgreementAcceptanceModel create
   */
  export type AgreementAcceptanceModelCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementAcceptanceModel
     */
    select?: AgreementAcceptanceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementAcceptanceModelInclude<ExtArgs> | null
    /**
     * The data needed to create a AgreementAcceptanceModel.
     */
    data: XOR<AgreementAcceptanceModelCreateInput, AgreementAcceptanceModelUncheckedCreateInput>
  }


  /**
   * AgreementAcceptanceModel createMany
   */
  export type AgreementAcceptanceModelCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgreementAcceptanceModels.
     */
    data: Enumerable<AgreementAcceptanceModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AgreementAcceptanceModel update
   */
  export type AgreementAcceptanceModelUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementAcceptanceModel
     */
    select?: AgreementAcceptanceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementAcceptanceModelInclude<ExtArgs> | null
    /**
     * The data needed to update a AgreementAcceptanceModel.
     */
    data: XOR<AgreementAcceptanceModelUpdateInput, AgreementAcceptanceModelUncheckedUpdateInput>
    /**
     * Choose, which AgreementAcceptanceModel to update.
     */
    where: AgreementAcceptanceModelWhereUniqueInput
  }


  /**
   * AgreementAcceptanceModel updateMany
   */
  export type AgreementAcceptanceModelUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgreementAcceptanceModels.
     */
    data: XOR<AgreementAcceptanceModelUpdateManyMutationInput, AgreementAcceptanceModelUncheckedUpdateManyInput>
    /**
     * Filter which AgreementAcceptanceModels to update
     */
    where?: AgreementAcceptanceModelWhereInput
  }


  /**
   * AgreementAcceptanceModel upsert
   */
  export type AgreementAcceptanceModelUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementAcceptanceModel
     */
    select?: AgreementAcceptanceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementAcceptanceModelInclude<ExtArgs> | null
    /**
     * The filter to search for the AgreementAcceptanceModel to update in case it exists.
     */
    where: AgreementAcceptanceModelWhereUniqueInput
    /**
     * In case the AgreementAcceptanceModel found by the `where` argument doesn't exist, create a new AgreementAcceptanceModel with this data.
     */
    create: XOR<AgreementAcceptanceModelCreateInput, AgreementAcceptanceModelUncheckedCreateInput>
    /**
     * In case the AgreementAcceptanceModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgreementAcceptanceModelUpdateInput, AgreementAcceptanceModelUncheckedUpdateInput>
  }


  /**
   * AgreementAcceptanceModel delete
   */
  export type AgreementAcceptanceModelDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementAcceptanceModel
     */
    select?: AgreementAcceptanceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementAcceptanceModelInclude<ExtArgs> | null
    /**
     * Filter which AgreementAcceptanceModel to delete.
     */
    where: AgreementAcceptanceModelWhereUniqueInput
  }


  /**
   * AgreementAcceptanceModel deleteMany
   */
  export type AgreementAcceptanceModelDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgreementAcceptanceModels to delete
     */
    where?: AgreementAcceptanceModelWhereInput
  }


  /**
   * AgreementAcceptanceModel without action
   */
  export type AgreementAcceptanceModelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementAcceptanceModel
     */
    select?: AgreementAcceptanceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementAcceptanceModelInclude<ExtArgs> | null
  }



  /**
   * Model ServiceSubCategoryModel
   */


  export type AggregateServiceSubCategoryModel = {
    _count: ServiceSubCategoryModelCountAggregateOutputType | null
    _min: ServiceSubCategoryModelMinAggregateOutputType | null
    _max: ServiceSubCategoryModelMaxAggregateOutputType | null
  }

  export type ServiceSubCategoryModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    super_category_id: string | null
  }

  export type ServiceSubCategoryModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    super_category_id: string | null
  }

  export type ServiceSubCategoryModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    name: number
    super_category_id: number
    _all: number
  }


  export type ServiceSubCategoryModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    super_category_id?: true
  }

  export type ServiceSubCategoryModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    super_category_id?: true
  }

  export type ServiceSubCategoryModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    super_category_id?: true
    _all?: true
  }

  export type ServiceSubCategoryModelAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceSubCategoryModel to aggregate.
     */
    where?: ServiceSubCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSubCategoryModels to fetch.
     */
    orderBy?: Enumerable<ServiceSubCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceSubCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSubCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSubCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceSubCategoryModels
    **/
    _count?: true | ServiceSubCategoryModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceSubCategoryModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceSubCategoryModelMaxAggregateInputType
  }

  export type GetServiceSubCategoryModelAggregateType<T extends ServiceSubCategoryModelAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceSubCategoryModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceSubCategoryModel[P]>
      : GetScalarType<T[P], AggregateServiceSubCategoryModel[P]>
  }




  export type ServiceSubCategoryModelGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceSubCategoryModelWhereInput
    orderBy?: Enumerable<ServiceSubCategoryModelOrderByWithAggregationInput>
    by: ServiceSubCategoryModelScalarFieldEnum[]
    having?: ServiceSubCategoryModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceSubCategoryModelCountAggregateInputType | true
    _min?: ServiceSubCategoryModelMinAggregateInputType
    _max?: ServiceSubCategoryModelMaxAggregateInputType
  }


  export type ServiceSubCategoryModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    name: string
    super_category_id: string
    _count: ServiceSubCategoryModelCountAggregateOutputType | null
    _min: ServiceSubCategoryModelMinAggregateOutputType | null
    _max: ServiceSubCategoryModelMaxAggregateOutputType | null
  }

  type GetServiceSubCategoryModelGroupByPayload<T extends ServiceSubCategoryModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServiceSubCategoryModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceSubCategoryModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceSubCategoryModelGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceSubCategoryModelGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSubCategoryModelSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    name?: boolean
    super_category_id?: boolean
    super_category?: boolean | ServiceSuperCategoryModelArgs<ExtArgs>
    expertises?: boolean | ServiceSubCategoryModel$expertisesArgs<ExtArgs>
    _count?: boolean | ServiceSubCategoryModelCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["serviceSubCategoryModel"]>

  export type ServiceSubCategoryModelSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    name?: boolean
    super_category_id?: boolean
  }

  export type ServiceSubCategoryModelInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    super_category?: boolean | ServiceSuperCategoryModelArgs<ExtArgs>
    expertises?: boolean | ServiceSubCategoryModel$expertisesArgs<ExtArgs>
    _count?: boolean | ServiceSubCategoryModelCountOutputTypeArgs<ExtArgs>
  }


  type ServiceSubCategoryModelGetPayload<S extends boolean | null | undefined | ServiceSubCategoryModelArgs> = $Types.GetResult<ServiceSubCategoryModelPayload, S>

  type ServiceSubCategoryModelCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ServiceSubCategoryModelFindManyArgs, 'select' | 'include'> & {
      select?: ServiceSubCategoryModelCountAggregateInputType | true
    }

  export interface ServiceSubCategoryModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceSubCategoryModel'], meta: { name: 'ServiceSubCategoryModel' } }
    /**
     * Find zero or one ServiceSubCategoryModel that matches the filter.
     * @param {ServiceSubCategoryModelFindUniqueArgs} args - Arguments to find a ServiceSubCategoryModel
     * @example
     * // Get one ServiceSubCategoryModel
     * const serviceSubCategoryModel = await prisma.serviceSubCategoryModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceSubCategoryModelFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServiceSubCategoryModelFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ServiceSubCategoryModel'> extends True ? Prisma__ServiceSubCategoryModelClient<$Types.GetResult<ServiceSubCategoryModelPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ServiceSubCategoryModelClient<$Types.GetResult<ServiceSubCategoryModelPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ServiceSubCategoryModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServiceSubCategoryModelFindUniqueOrThrowArgs} args - Arguments to find a ServiceSubCategoryModel
     * @example
     * // Get one ServiceSubCategoryModel
     * const serviceSubCategoryModel = await prisma.serviceSubCategoryModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceSubCategoryModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceSubCategoryModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceSubCategoryModelClient<$Types.GetResult<ServiceSubCategoryModelPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ServiceSubCategoryModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubCategoryModelFindFirstArgs} args - Arguments to find a ServiceSubCategoryModel
     * @example
     * // Get one ServiceSubCategoryModel
     * const serviceSubCategoryModel = await prisma.serviceSubCategoryModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceSubCategoryModelFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServiceSubCategoryModelFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ServiceSubCategoryModel'> extends True ? Prisma__ServiceSubCategoryModelClient<$Types.GetResult<ServiceSubCategoryModelPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ServiceSubCategoryModelClient<$Types.GetResult<ServiceSubCategoryModelPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ServiceSubCategoryModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubCategoryModelFindFirstOrThrowArgs} args - Arguments to find a ServiceSubCategoryModel
     * @example
     * // Get one ServiceSubCategoryModel
     * const serviceSubCategoryModel = await prisma.serviceSubCategoryModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceSubCategoryModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceSubCategoryModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceSubCategoryModelClient<$Types.GetResult<ServiceSubCategoryModelPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ServiceSubCategoryModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubCategoryModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceSubCategoryModels
     * const serviceSubCategoryModels = await prisma.serviceSubCategoryModel.findMany()
     * 
     * // Get first 10 ServiceSubCategoryModels
     * const serviceSubCategoryModels = await prisma.serviceSubCategoryModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceSubCategoryModelWithIdOnly = await prisma.serviceSubCategoryModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceSubCategoryModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceSubCategoryModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ServiceSubCategoryModelPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ServiceSubCategoryModel.
     * @param {ServiceSubCategoryModelCreateArgs} args - Arguments to create a ServiceSubCategoryModel.
     * @example
     * // Create one ServiceSubCategoryModel
     * const ServiceSubCategoryModel = await prisma.serviceSubCategoryModel.create({
     *   data: {
     *     // ... data to create a ServiceSubCategoryModel
     *   }
     * })
     * 
    **/
    create<T extends ServiceSubCategoryModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceSubCategoryModelCreateArgs<ExtArgs>>
    ): Prisma__ServiceSubCategoryModelClient<$Types.GetResult<ServiceSubCategoryModelPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ServiceSubCategoryModels.
     *     @param {ServiceSubCategoryModelCreateManyArgs} args - Arguments to create many ServiceSubCategoryModels.
     *     @example
     *     // Create many ServiceSubCategoryModels
     *     const serviceSubCategoryModel = await prisma.serviceSubCategoryModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceSubCategoryModelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceSubCategoryModelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceSubCategoryModel.
     * @param {ServiceSubCategoryModelDeleteArgs} args - Arguments to delete one ServiceSubCategoryModel.
     * @example
     * // Delete one ServiceSubCategoryModel
     * const ServiceSubCategoryModel = await prisma.serviceSubCategoryModel.delete({
     *   where: {
     *     // ... filter to delete one ServiceSubCategoryModel
     *   }
     * })
     * 
    **/
    delete<T extends ServiceSubCategoryModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceSubCategoryModelDeleteArgs<ExtArgs>>
    ): Prisma__ServiceSubCategoryModelClient<$Types.GetResult<ServiceSubCategoryModelPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ServiceSubCategoryModel.
     * @param {ServiceSubCategoryModelUpdateArgs} args - Arguments to update one ServiceSubCategoryModel.
     * @example
     * // Update one ServiceSubCategoryModel
     * const serviceSubCategoryModel = await prisma.serviceSubCategoryModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceSubCategoryModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceSubCategoryModelUpdateArgs<ExtArgs>>
    ): Prisma__ServiceSubCategoryModelClient<$Types.GetResult<ServiceSubCategoryModelPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ServiceSubCategoryModels.
     * @param {ServiceSubCategoryModelDeleteManyArgs} args - Arguments to filter ServiceSubCategoryModels to delete.
     * @example
     * // Delete a few ServiceSubCategoryModels
     * const { count } = await prisma.serviceSubCategoryModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceSubCategoryModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceSubCategoryModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceSubCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubCategoryModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceSubCategoryModels
     * const serviceSubCategoryModel = await prisma.serviceSubCategoryModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceSubCategoryModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceSubCategoryModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceSubCategoryModel.
     * @param {ServiceSubCategoryModelUpsertArgs} args - Arguments to update or create a ServiceSubCategoryModel.
     * @example
     * // Update or create a ServiceSubCategoryModel
     * const serviceSubCategoryModel = await prisma.serviceSubCategoryModel.upsert({
     *   create: {
     *     // ... data to create a ServiceSubCategoryModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceSubCategoryModel we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceSubCategoryModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceSubCategoryModelUpsertArgs<ExtArgs>>
    ): Prisma__ServiceSubCategoryModelClient<$Types.GetResult<ServiceSubCategoryModelPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ServiceSubCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubCategoryModelCountArgs} args - Arguments to filter ServiceSubCategoryModels to count.
     * @example
     * // Count the number of ServiceSubCategoryModels
     * const count = await prisma.serviceSubCategoryModel.count({
     *   where: {
     *     // ... the filter for the ServiceSubCategoryModels we want to count
     *   }
     * })
    **/
    count<T extends ServiceSubCategoryModelCountArgs>(
      args?: Subset<T, ServiceSubCategoryModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceSubCategoryModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceSubCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubCategoryModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceSubCategoryModelAggregateArgs>(args: Subset<T, ServiceSubCategoryModelAggregateArgs>): Prisma.PrismaPromise<GetServiceSubCategoryModelAggregateType<T>>

    /**
     * Group by ServiceSubCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubCategoryModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceSubCategoryModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceSubCategoryModelGroupByArgs['orderBy'] }
        : { orderBy?: ServiceSubCategoryModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceSubCategoryModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceSubCategoryModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceSubCategoryModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServiceSubCategoryModelClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    super_category<T extends ServiceSuperCategoryModelArgs<ExtArgs> = {}>(args?: Subset<T, ServiceSuperCategoryModelArgs<ExtArgs>>): Prisma__ServiceSuperCategoryModelClient<$Types.GetResult<ServiceSuperCategoryModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    expertises<T extends ServiceSubCategoryModel$expertisesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceSubCategoryModel$expertisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<SubExpertiseModelPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ServiceSubCategoryModel base type for findUnique actions
   */
  export type ServiceSubCategoryModelFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubCategoryModel
     */
    select?: ServiceSubCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSubCategoryModel to fetch.
     */
    where: ServiceSubCategoryModelWhereUniqueInput
  }

  /**
   * ServiceSubCategoryModel findUnique
   */
  export interface ServiceSubCategoryModelFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceSubCategoryModelFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceSubCategoryModel findUniqueOrThrow
   */
  export type ServiceSubCategoryModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubCategoryModel
     */
    select?: ServiceSubCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSubCategoryModel to fetch.
     */
    where: ServiceSubCategoryModelWhereUniqueInput
  }


  /**
   * ServiceSubCategoryModel base type for findFirst actions
   */
  export type ServiceSubCategoryModelFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubCategoryModel
     */
    select?: ServiceSubCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSubCategoryModel to fetch.
     */
    where?: ServiceSubCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSubCategoryModels to fetch.
     */
    orderBy?: Enumerable<ServiceSubCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceSubCategoryModels.
     */
    cursor?: ServiceSubCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSubCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSubCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceSubCategoryModels.
     */
    distinct?: Enumerable<ServiceSubCategoryModelScalarFieldEnum>
  }

  /**
   * ServiceSubCategoryModel findFirst
   */
  export interface ServiceSubCategoryModelFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceSubCategoryModelFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceSubCategoryModel findFirstOrThrow
   */
  export type ServiceSubCategoryModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubCategoryModel
     */
    select?: ServiceSubCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSubCategoryModel to fetch.
     */
    where?: ServiceSubCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSubCategoryModels to fetch.
     */
    orderBy?: Enumerable<ServiceSubCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceSubCategoryModels.
     */
    cursor?: ServiceSubCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSubCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSubCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceSubCategoryModels.
     */
    distinct?: Enumerable<ServiceSubCategoryModelScalarFieldEnum>
  }


  /**
   * ServiceSubCategoryModel findMany
   */
  export type ServiceSubCategoryModelFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubCategoryModel
     */
    select?: ServiceSubCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSubCategoryModels to fetch.
     */
    where?: ServiceSubCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSubCategoryModels to fetch.
     */
    orderBy?: Enumerable<ServiceSubCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceSubCategoryModels.
     */
    cursor?: ServiceSubCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSubCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSubCategoryModels.
     */
    skip?: number
    distinct?: Enumerable<ServiceSubCategoryModelScalarFieldEnum>
  }


  /**
   * ServiceSubCategoryModel create
   */
  export type ServiceSubCategoryModelCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubCategoryModel
     */
    select?: ServiceSubCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubCategoryModelInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceSubCategoryModel.
     */
    data: XOR<ServiceSubCategoryModelCreateInput, ServiceSubCategoryModelUncheckedCreateInput>
  }


  /**
   * ServiceSubCategoryModel createMany
   */
  export type ServiceSubCategoryModelCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceSubCategoryModels.
     */
    data: Enumerable<ServiceSubCategoryModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ServiceSubCategoryModel update
   */
  export type ServiceSubCategoryModelUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubCategoryModel
     */
    select?: ServiceSubCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubCategoryModelInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceSubCategoryModel.
     */
    data: XOR<ServiceSubCategoryModelUpdateInput, ServiceSubCategoryModelUncheckedUpdateInput>
    /**
     * Choose, which ServiceSubCategoryModel to update.
     */
    where: ServiceSubCategoryModelWhereUniqueInput
  }


  /**
   * ServiceSubCategoryModel updateMany
   */
  export type ServiceSubCategoryModelUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceSubCategoryModels.
     */
    data: XOR<ServiceSubCategoryModelUpdateManyMutationInput, ServiceSubCategoryModelUncheckedUpdateManyInput>
    /**
     * Filter which ServiceSubCategoryModels to update
     */
    where?: ServiceSubCategoryModelWhereInput
  }


  /**
   * ServiceSubCategoryModel upsert
   */
  export type ServiceSubCategoryModelUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubCategoryModel
     */
    select?: ServiceSubCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubCategoryModelInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceSubCategoryModel to update in case it exists.
     */
    where: ServiceSubCategoryModelWhereUniqueInput
    /**
     * In case the ServiceSubCategoryModel found by the `where` argument doesn't exist, create a new ServiceSubCategoryModel with this data.
     */
    create: XOR<ServiceSubCategoryModelCreateInput, ServiceSubCategoryModelUncheckedCreateInput>
    /**
     * In case the ServiceSubCategoryModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceSubCategoryModelUpdateInput, ServiceSubCategoryModelUncheckedUpdateInput>
  }


  /**
   * ServiceSubCategoryModel delete
   */
  export type ServiceSubCategoryModelDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubCategoryModel
     */
    select?: ServiceSubCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubCategoryModelInclude<ExtArgs> | null
    /**
     * Filter which ServiceSubCategoryModel to delete.
     */
    where: ServiceSubCategoryModelWhereUniqueInput
  }


  /**
   * ServiceSubCategoryModel deleteMany
   */
  export type ServiceSubCategoryModelDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceSubCategoryModels to delete
     */
    where?: ServiceSubCategoryModelWhereInput
  }


  /**
   * ServiceSubCategoryModel.expertises
   */
  export type ServiceSubCategoryModel$expertisesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubExpertiseModel
     */
    select?: SubExpertiseModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubExpertiseModelInclude<ExtArgs> | null
    where?: SubExpertiseModelWhereInput
    orderBy?: Enumerable<SubExpertiseModelOrderByWithRelationInput>
    cursor?: SubExpertiseModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SubExpertiseModelScalarFieldEnum>
  }


  /**
   * ServiceSubCategoryModel without action
   */
  export type ServiceSubCategoryModelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubCategoryModel
     */
    select?: ServiceSubCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubCategoryModelInclude<ExtArgs> | null
  }



  /**
   * Model ServiceSuperCategoryModel
   */


  export type AggregateServiceSuperCategoryModel = {
    _count: ServiceSuperCategoryModelCountAggregateOutputType | null
    _min: ServiceSuperCategoryModelMinAggregateOutputType | null
    _max: ServiceSuperCategoryModelMaxAggregateOutputType | null
  }

  export type ServiceSuperCategoryModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    type: ServiceType | null
  }

  export type ServiceSuperCategoryModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    type: ServiceType | null
  }

  export type ServiceSuperCategoryModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    name: number
    type: number
    _all: number
  }


  export type ServiceSuperCategoryModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    type?: true
  }

  export type ServiceSuperCategoryModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    type?: true
  }

  export type ServiceSuperCategoryModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    type?: true
    _all?: true
  }

  export type ServiceSuperCategoryModelAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceSuperCategoryModel to aggregate.
     */
    where?: ServiceSuperCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSuperCategoryModels to fetch.
     */
    orderBy?: Enumerable<ServiceSuperCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceSuperCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSuperCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSuperCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceSuperCategoryModels
    **/
    _count?: true | ServiceSuperCategoryModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceSuperCategoryModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceSuperCategoryModelMaxAggregateInputType
  }

  export type GetServiceSuperCategoryModelAggregateType<T extends ServiceSuperCategoryModelAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceSuperCategoryModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceSuperCategoryModel[P]>
      : GetScalarType<T[P], AggregateServiceSuperCategoryModel[P]>
  }




  export type ServiceSuperCategoryModelGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ServiceSuperCategoryModelWhereInput
    orderBy?: Enumerable<ServiceSuperCategoryModelOrderByWithAggregationInput>
    by: ServiceSuperCategoryModelScalarFieldEnum[]
    having?: ServiceSuperCategoryModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceSuperCategoryModelCountAggregateInputType | true
    _min?: ServiceSuperCategoryModelMinAggregateInputType
    _max?: ServiceSuperCategoryModelMaxAggregateInputType
  }


  export type ServiceSuperCategoryModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    name: string
    type: ServiceType
    _count: ServiceSuperCategoryModelCountAggregateOutputType | null
    _min: ServiceSuperCategoryModelMinAggregateOutputType | null
    _max: ServiceSuperCategoryModelMaxAggregateOutputType | null
  }

  type GetServiceSuperCategoryModelGroupByPayload<T extends ServiceSuperCategoryModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServiceSuperCategoryModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceSuperCategoryModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceSuperCategoryModelGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceSuperCategoryModelGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSuperCategoryModelSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    name?: boolean
    type?: boolean
    sub_categories?: boolean | ServiceSuperCategoryModel$sub_categoriesArgs<ExtArgs>
    focus_care_checks?: boolean | ServiceSuperCategoryModel$focus_care_checksArgs<ExtArgs>
    _count?: boolean | ServiceSuperCategoryModelCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["serviceSuperCategoryModel"]>

  export type ServiceSuperCategoryModelSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    name?: boolean
    type?: boolean
  }

  export type ServiceSuperCategoryModelInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    sub_categories?: boolean | ServiceSuperCategoryModel$sub_categoriesArgs<ExtArgs>
    focus_care_checks?: boolean | ServiceSuperCategoryModel$focus_care_checksArgs<ExtArgs>
    _count?: boolean | ServiceSuperCategoryModelCountOutputTypeArgs<ExtArgs>
  }


  type ServiceSuperCategoryModelGetPayload<S extends boolean | null | undefined | ServiceSuperCategoryModelArgs> = $Types.GetResult<ServiceSuperCategoryModelPayload, S>

  type ServiceSuperCategoryModelCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ServiceSuperCategoryModelFindManyArgs, 'select' | 'include'> & {
      select?: ServiceSuperCategoryModelCountAggregateInputType | true
    }

  export interface ServiceSuperCategoryModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceSuperCategoryModel'], meta: { name: 'ServiceSuperCategoryModel' } }
    /**
     * Find zero or one ServiceSuperCategoryModel that matches the filter.
     * @param {ServiceSuperCategoryModelFindUniqueArgs} args - Arguments to find a ServiceSuperCategoryModel
     * @example
     * // Get one ServiceSuperCategoryModel
     * const serviceSuperCategoryModel = await prisma.serviceSuperCategoryModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceSuperCategoryModelFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServiceSuperCategoryModelFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ServiceSuperCategoryModel'> extends True ? Prisma__ServiceSuperCategoryModelClient<$Types.GetResult<ServiceSuperCategoryModelPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ServiceSuperCategoryModelClient<$Types.GetResult<ServiceSuperCategoryModelPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ServiceSuperCategoryModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServiceSuperCategoryModelFindUniqueOrThrowArgs} args - Arguments to find a ServiceSuperCategoryModel
     * @example
     * // Get one ServiceSuperCategoryModel
     * const serviceSuperCategoryModel = await prisma.serviceSuperCategoryModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceSuperCategoryModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceSuperCategoryModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceSuperCategoryModelClient<$Types.GetResult<ServiceSuperCategoryModelPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ServiceSuperCategoryModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSuperCategoryModelFindFirstArgs} args - Arguments to find a ServiceSuperCategoryModel
     * @example
     * // Get one ServiceSuperCategoryModel
     * const serviceSuperCategoryModel = await prisma.serviceSuperCategoryModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceSuperCategoryModelFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServiceSuperCategoryModelFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ServiceSuperCategoryModel'> extends True ? Prisma__ServiceSuperCategoryModelClient<$Types.GetResult<ServiceSuperCategoryModelPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ServiceSuperCategoryModelClient<$Types.GetResult<ServiceSuperCategoryModelPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ServiceSuperCategoryModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSuperCategoryModelFindFirstOrThrowArgs} args - Arguments to find a ServiceSuperCategoryModel
     * @example
     * // Get one ServiceSuperCategoryModel
     * const serviceSuperCategoryModel = await prisma.serviceSuperCategoryModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceSuperCategoryModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceSuperCategoryModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceSuperCategoryModelClient<$Types.GetResult<ServiceSuperCategoryModelPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ServiceSuperCategoryModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSuperCategoryModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceSuperCategoryModels
     * const serviceSuperCategoryModels = await prisma.serviceSuperCategoryModel.findMany()
     * 
     * // Get first 10 ServiceSuperCategoryModels
     * const serviceSuperCategoryModels = await prisma.serviceSuperCategoryModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceSuperCategoryModelWithIdOnly = await prisma.serviceSuperCategoryModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceSuperCategoryModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceSuperCategoryModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ServiceSuperCategoryModelPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ServiceSuperCategoryModel.
     * @param {ServiceSuperCategoryModelCreateArgs} args - Arguments to create a ServiceSuperCategoryModel.
     * @example
     * // Create one ServiceSuperCategoryModel
     * const ServiceSuperCategoryModel = await prisma.serviceSuperCategoryModel.create({
     *   data: {
     *     // ... data to create a ServiceSuperCategoryModel
     *   }
     * })
     * 
    **/
    create<T extends ServiceSuperCategoryModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceSuperCategoryModelCreateArgs<ExtArgs>>
    ): Prisma__ServiceSuperCategoryModelClient<$Types.GetResult<ServiceSuperCategoryModelPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ServiceSuperCategoryModels.
     *     @param {ServiceSuperCategoryModelCreateManyArgs} args - Arguments to create many ServiceSuperCategoryModels.
     *     @example
     *     // Create many ServiceSuperCategoryModels
     *     const serviceSuperCategoryModel = await prisma.serviceSuperCategoryModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceSuperCategoryModelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceSuperCategoryModelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceSuperCategoryModel.
     * @param {ServiceSuperCategoryModelDeleteArgs} args - Arguments to delete one ServiceSuperCategoryModel.
     * @example
     * // Delete one ServiceSuperCategoryModel
     * const ServiceSuperCategoryModel = await prisma.serviceSuperCategoryModel.delete({
     *   where: {
     *     // ... filter to delete one ServiceSuperCategoryModel
     *   }
     * })
     * 
    **/
    delete<T extends ServiceSuperCategoryModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceSuperCategoryModelDeleteArgs<ExtArgs>>
    ): Prisma__ServiceSuperCategoryModelClient<$Types.GetResult<ServiceSuperCategoryModelPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ServiceSuperCategoryModel.
     * @param {ServiceSuperCategoryModelUpdateArgs} args - Arguments to update one ServiceSuperCategoryModel.
     * @example
     * // Update one ServiceSuperCategoryModel
     * const serviceSuperCategoryModel = await prisma.serviceSuperCategoryModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceSuperCategoryModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceSuperCategoryModelUpdateArgs<ExtArgs>>
    ): Prisma__ServiceSuperCategoryModelClient<$Types.GetResult<ServiceSuperCategoryModelPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ServiceSuperCategoryModels.
     * @param {ServiceSuperCategoryModelDeleteManyArgs} args - Arguments to filter ServiceSuperCategoryModels to delete.
     * @example
     * // Delete a few ServiceSuperCategoryModels
     * const { count } = await prisma.serviceSuperCategoryModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceSuperCategoryModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceSuperCategoryModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceSuperCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSuperCategoryModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceSuperCategoryModels
     * const serviceSuperCategoryModel = await prisma.serviceSuperCategoryModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceSuperCategoryModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceSuperCategoryModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceSuperCategoryModel.
     * @param {ServiceSuperCategoryModelUpsertArgs} args - Arguments to update or create a ServiceSuperCategoryModel.
     * @example
     * // Update or create a ServiceSuperCategoryModel
     * const serviceSuperCategoryModel = await prisma.serviceSuperCategoryModel.upsert({
     *   create: {
     *     // ... data to create a ServiceSuperCategoryModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceSuperCategoryModel we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceSuperCategoryModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceSuperCategoryModelUpsertArgs<ExtArgs>>
    ): Prisma__ServiceSuperCategoryModelClient<$Types.GetResult<ServiceSuperCategoryModelPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ServiceSuperCategoryModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSuperCategoryModelCountArgs} args - Arguments to filter ServiceSuperCategoryModels to count.
     * @example
     * // Count the number of ServiceSuperCategoryModels
     * const count = await prisma.serviceSuperCategoryModel.count({
     *   where: {
     *     // ... the filter for the ServiceSuperCategoryModels we want to count
     *   }
     * })
    **/
    count<T extends ServiceSuperCategoryModelCountArgs>(
      args?: Subset<T, ServiceSuperCategoryModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceSuperCategoryModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceSuperCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSuperCategoryModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceSuperCategoryModelAggregateArgs>(args: Subset<T, ServiceSuperCategoryModelAggregateArgs>): Prisma.PrismaPromise<GetServiceSuperCategoryModelAggregateType<T>>

    /**
     * Group by ServiceSuperCategoryModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSuperCategoryModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceSuperCategoryModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceSuperCategoryModelGroupByArgs['orderBy'] }
        : { orderBy?: ServiceSuperCategoryModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceSuperCategoryModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceSuperCategoryModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceSuperCategoryModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServiceSuperCategoryModelClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    sub_categories<T extends ServiceSuperCategoryModel$sub_categoriesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceSuperCategoryModel$sub_categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ServiceSubCategoryModelPayload<ExtArgs>, T, 'findMany', never>| Null>;

    focus_care_checks<T extends ServiceSuperCategoryModel$focus_care_checksArgs<ExtArgs> = {}>(args?: Subset<T, ServiceSuperCategoryModel$focus_care_checksArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ZipzoongCareServiceCheckModelPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ServiceSuperCategoryModel base type for findUnique actions
   */
  export type ServiceSuperCategoryModelFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSuperCategoryModel
     */
    select?: ServiceSuperCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSuperCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSuperCategoryModel to fetch.
     */
    where: ServiceSuperCategoryModelWhereUniqueInput
  }

  /**
   * ServiceSuperCategoryModel findUnique
   */
  export interface ServiceSuperCategoryModelFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceSuperCategoryModelFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceSuperCategoryModel findUniqueOrThrow
   */
  export type ServiceSuperCategoryModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSuperCategoryModel
     */
    select?: ServiceSuperCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSuperCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSuperCategoryModel to fetch.
     */
    where: ServiceSuperCategoryModelWhereUniqueInput
  }


  /**
   * ServiceSuperCategoryModel base type for findFirst actions
   */
  export type ServiceSuperCategoryModelFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSuperCategoryModel
     */
    select?: ServiceSuperCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSuperCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSuperCategoryModel to fetch.
     */
    where?: ServiceSuperCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSuperCategoryModels to fetch.
     */
    orderBy?: Enumerable<ServiceSuperCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceSuperCategoryModels.
     */
    cursor?: ServiceSuperCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSuperCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSuperCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceSuperCategoryModels.
     */
    distinct?: Enumerable<ServiceSuperCategoryModelScalarFieldEnum>
  }

  /**
   * ServiceSuperCategoryModel findFirst
   */
  export interface ServiceSuperCategoryModelFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ServiceSuperCategoryModelFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceSuperCategoryModel findFirstOrThrow
   */
  export type ServiceSuperCategoryModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSuperCategoryModel
     */
    select?: ServiceSuperCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSuperCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSuperCategoryModel to fetch.
     */
    where?: ServiceSuperCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSuperCategoryModels to fetch.
     */
    orderBy?: Enumerable<ServiceSuperCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceSuperCategoryModels.
     */
    cursor?: ServiceSuperCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSuperCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSuperCategoryModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceSuperCategoryModels.
     */
    distinct?: Enumerable<ServiceSuperCategoryModelScalarFieldEnum>
  }


  /**
   * ServiceSuperCategoryModel findMany
   */
  export type ServiceSuperCategoryModelFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSuperCategoryModel
     */
    select?: ServiceSuperCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSuperCategoryModelInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSuperCategoryModels to fetch.
     */
    where?: ServiceSuperCategoryModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSuperCategoryModels to fetch.
     */
    orderBy?: Enumerable<ServiceSuperCategoryModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceSuperCategoryModels.
     */
    cursor?: ServiceSuperCategoryModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSuperCategoryModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSuperCategoryModels.
     */
    skip?: number
    distinct?: Enumerable<ServiceSuperCategoryModelScalarFieldEnum>
  }


  /**
   * ServiceSuperCategoryModel create
   */
  export type ServiceSuperCategoryModelCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSuperCategoryModel
     */
    select?: ServiceSuperCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSuperCategoryModelInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceSuperCategoryModel.
     */
    data: XOR<ServiceSuperCategoryModelCreateInput, ServiceSuperCategoryModelUncheckedCreateInput>
  }


  /**
   * ServiceSuperCategoryModel createMany
   */
  export type ServiceSuperCategoryModelCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceSuperCategoryModels.
     */
    data: Enumerable<ServiceSuperCategoryModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ServiceSuperCategoryModel update
   */
  export type ServiceSuperCategoryModelUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSuperCategoryModel
     */
    select?: ServiceSuperCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSuperCategoryModelInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceSuperCategoryModel.
     */
    data: XOR<ServiceSuperCategoryModelUpdateInput, ServiceSuperCategoryModelUncheckedUpdateInput>
    /**
     * Choose, which ServiceSuperCategoryModel to update.
     */
    where: ServiceSuperCategoryModelWhereUniqueInput
  }


  /**
   * ServiceSuperCategoryModel updateMany
   */
  export type ServiceSuperCategoryModelUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceSuperCategoryModels.
     */
    data: XOR<ServiceSuperCategoryModelUpdateManyMutationInput, ServiceSuperCategoryModelUncheckedUpdateManyInput>
    /**
     * Filter which ServiceSuperCategoryModels to update
     */
    where?: ServiceSuperCategoryModelWhereInput
  }


  /**
   * ServiceSuperCategoryModel upsert
   */
  export type ServiceSuperCategoryModelUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSuperCategoryModel
     */
    select?: ServiceSuperCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSuperCategoryModelInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceSuperCategoryModel to update in case it exists.
     */
    where: ServiceSuperCategoryModelWhereUniqueInput
    /**
     * In case the ServiceSuperCategoryModel found by the `where` argument doesn't exist, create a new ServiceSuperCategoryModel with this data.
     */
    create: XOR<ServiceSuperCategoryModelCreateInput, ServiceSuperCategoryModelUncheckedCreateInput>
    /**
     * In case the ServiceSuperCategoryModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceSuperCategoryModelUpdateInput, ServiceSuperCategoryModelUncheckedUpdateInput>
  }


  /**
   * ServiceSuperCategoryModel delete
   */
  export type ServiceSuperCategoryModelDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSuperCategoryModel
     */
    select?: ServiceSuperCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSuperCategoryModelInclude<ExtArgs> | null
    /**
     * Filter which ServiceSuperCategoryModel to delete.
     */
    where: ServiceSuperCategoryModelWhereUniqueInput
  }


  /**
   * ServiceSuperCategoryModel deleteMany
   */
  export type ServiceSuperCategoryModelDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceSuperCategoryModels to delete
     */
    where?: ServiceSuperCategoryModelWhereInput
  }


  /**
   * ServiceSuperCategoryModel.sub_categories
   */
  export type ServiceSuperCategoryModel$sub_categoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubCategoryModel
     */
    select?: ServiceSubCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSubCategoryModelInclude<ExtArgs> | null
    where?: ServiceSubCategoryModelWhereInput
    orderBy?: Enumerable<ServiceSubCategoryModelOrderByWithRelationInput>
    cursor?: ServiceSubCategoryModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ServiceSubCategoryModelScalarFieldEnum>
  }


  /**
   * ServiceSuperCategoryModel.focus_care_checks
   */
  export type ServiceSuperCategoryModel$focus_care_checksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareServiceCheckModel
     */
    select?: ZipzoongCareServiceCheckModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareServiceCheckModelInclude<ExtArgs> | null
    where?: ZipzoongCareServiceCheckModelWhereInput
    orderBy?: Enumerable<ZipzoongCareServiceCheckModelOrderByWithRelationInput>
    cursor?: ZipzoongCareServiceCheckModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ZipzoongCareServiceCheckModelScalarFieldEnum>
  }


  /**
   * ServiceSuperCategoryModel without action
   */
  export type ServiceSuperCategoryModelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSuperCategoryModel
     */
    select?: ServiceSuperCategoryModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceSuperCategoryModelInclude<ExtArgs> | null
  }



  /**
   * Model ZipzoongCareRequestModel
   */


  export type AggregateZipzoongCareRequestModel = {
    _count: ZipzoongCareRequestModelCountAggregateOutputType | null
    _min: ZipzoongCareRequestModelMinAggregateOutputType | null
    _max: ZipzoongCareRequestModelMaxAggregateOutputType | null
  }

  export type ZipzoongCareRequestModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    care_start_date: Date | null
    care_end_date: Date | null
    detail: string | null
    status: ZipzoongCareStatus | null
    requester_id: string | null
  }

  export type ZipzoongCareRequestModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    care_start_date: Date | null
    care_end_date: Date | null
    detail: string | null
    status: ZipzoongCareStatus | null
    requester_id: string | null
  }

  export type ZipzoongCareRequestModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    care_start_date: number
    care_end_date: number
    detail: number
    status: number
    requester_id: number
    _all: number
  }


  export type ZipzoongCareRequestModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    care_start_date?: true
    care_end_date?: true
    detail?: true
    status?: true
    requester_id?: true
  }

  export type ZipzoongCareRequestModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    care_start_date?: true
    care_end_date?: true
    detail?: true
    status?: true
    requester_id?: true
  }

  export type ZipzoongCareRequestModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    care_start_date?: true
    care_end_date?: true
    detail?: true
    status?: true
    requester_id?: true
    _all?: true
  }

  export type ZipzoongCareRequestModelAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZipzoongCareRequestModel to aggregate.
     */
    where?: ZipzoongCareRequestModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZipzoongCareRequestModels to fetch.
     */
    orderBy?: Enumerable<ZipzoongCareRequestModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZipzoongCareRequestModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZipzoongCareRequestModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZipzoongCareRequestModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ZipzoongCareRequestModels
    **/
    _count?: true | ZipzoongCareRequestModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZipzoongCareRequestModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZipzoongCareRequestModelMaxAggregateInputType
  }

  export type GetZipzoongCareRequestModelAggregateType<T extends ZipzoongCareRequestModelAggregateArgs> = {
        [P in keyof T & keyof AggregateZipzoongCareRequestModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZipzoongCareRequestModel[P]>
      : GetScalarType<T[P], AggregateZipzoongCareRequestModel[P]>
  }




  export type ZipzoongCareRequestModelGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ZipzoongCareRequestModelWhereInput
    orderBy?: Enumerable<ZipzoongCareRequestModelOrderByWithAggregationInput>
    by: ZipzoongCareRequestModelScalarFieldEnum[]
    having?: ZipzoongCareRequestModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZipzoongCareRequestModelCountAggregateInputType | true
    _min?: ZipzoongCareRequestModelMinAggregateInputType
    _max?: ZipzoongCareRequestModelMaxAggregateInputType
  }


  export type ZipzoongCareRequestModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    care_start_date: Date
    care_end_date: Date
    detail: string
    status: ZipzoongCareStatus
    requester_id: string
    _count: ZipzoongCareRequestModelCountAggregateOutputType | null
    _min: ZipzoongCareRequestModelMinAggregateOutputType | null
    _max: ZipzoongCareRequestModelMaxAggregateOutputType | null
  }

  type GetZipzoongCareRequestModelGroupByPayload<T extends ZipzoongCareRequestModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ZipzoongCareRequestModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZipzoongCareRequestModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZipzoongCareRequestModelGroupByOutputType[P]>
            : GetScalarType<T[P], ZipzoongCareRequestModelGroupByOutputType[P]>
        }
      >
    >


  export type ZipzoongCareRequestModelSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    care_start_date?: boolean
    care_end_date?: boolean
    detail?: boolean
    status?: boolean
    requester_id?: boolean
    requester?: boolean | CustomerModelArgs<ExtArgs>
    consultation_time_checks?: boolean | ZipzoongCareRequestModel$consultation_time_checksArgs<ExtArgs>
    service_checks?: boolean | ZipzoongCareRequestModel$service_checksArgs<ExtArgs>
    _count?: boolean | ZipzoongCareRequestModelCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["zipzoongCareRequestModel"]>

  export type ZipzoongCareRequestModelSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    care_start_date?: boolean
    care_end_date?: boolean
    detail?: boolean
    status?: boolean
    requester_id?: boolean
  }

  export type ZipzoongCareRequestModelInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    requester?: boolean | CustomerModelArgs<ExtArgs>
    consultation_time_checks?: boolean | ZipzoongCareRequestModel$consultation_time_checksArgs<ExtArgs>
    service_checks?: boolean | ZipzoongCareRequestModel$service_checksArgs<ExtArgs>
    _count?: boolean | ZipzoongCareRequestModelCountOutputTypeArgs<ExtArgs>
  }


  type ZipzoongCareRequestModelGetPayload<S extends boolean | null | undefined | ZipzoongCareRequestModelArgs> = $Types.GetResult<ZipzoongCareRequestModelPayload, S>

  type ZipzoongCareRequestModelCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ZipzoongCareRequestModelFindManyArgs, 'select' | 'include'> & {
      select?: ZipzoongCareRequestModelCountAggregateInputType | true
    }

  export interface ZipzoongCareRequestModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ZipzoongCareRequestModel'], meta: { name: 'ZipzoongCareRequestModel' } }
    /**
     * Find zero or one ZipzoongCareRequestModel that matches the filter.
     * @param {ZipzoongCareRequestModelFindUniqueArgs} args - Arguments to find a ZipzoongCareRequestModel
     * @example
     * // Get one ZipzoongCareRequestModel
     * const zipzoongCareRequestModel = await prisma.zipzoongCareRequestModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ZipzoongCareRequestModelFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ZipzoongCareRequestModelFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ZipzoongCareRequestModel'> extends True ? Prisma__ZipzoongCareRequestModelClient<$Types.GetResult<ZipzoongCareRequestModelPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ZipzoongCareRequestModelClient<$Types.GetResult<ZipzoongCareRequestModelPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ZipzoongCareRequestModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ZipzoongCareRequestModelFindUniqueOrThrowArgs} args - Arguments to find a ZipzoongCareRequestModel
     * @example
     * // Get one ZipzoongCareRequestModel
     * const zipzoongCareRequestModel = await prisma.zipzoongCareRequestModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ZipzoongCareRequestModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ZipzoongCareRequestModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ZipzoongCareRequestModelClient<$Types.GetResult<ZipzoongCareRequestModelPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ZipzoongCareRequestModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZipzoongCareRequestModelFindFirstArgs} args - Arguments to find a ZipzoongCareRequestModel
     * @example
     * // Get one ZipzoongCareRequestModel
     * const zipzoongCareRequestModel = await prisma.zipzoongCareRequestModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ZipzoongCareRequestModelFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ZipzoongCareRequestModelFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ZipzoongCareRequestModel'> extends True ? Prisma__ZipzoongCareRequestModelClient<$Types.GetResult<ZipzoongCareRequestModelPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ZipzoongCareRequestModelClient<$Types.GetResult<ZipzoongCareRequestModelPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ZipzoongCareRequestModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZipzoongCareRequestModelFindFirstOrThrowArgs} args - Arguments to find a ZipzoongCareRequestModel
     * @example
     * // Get one ZipzoongCareRequestModel
     * const zipzoongCareRequestModel = await prisma.zipzoongCareRequestModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ZipzoongCareRequestModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ZipzoongCareRequestModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ZipzoongCareRequestModelClient<$Types.GetResult<ZipzoongCareRequestModelPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ZipzoongCareRequestModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZipzoongCareRequestModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ZipzoongCareRequestModels
     * const zipzoongCareRequestModels = await prisma.zipzoongCareRequestModel.findMany()
     * 
     * // Get first 10 ZipzoongCareRequestModels
     * const zipzoongCareRequestModels = await prisma.zipzoongCareRequestModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zipzoongCareRequestModelWithIdOnly = await prisma.zipzoongCareRequestModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ZipzoongCareRequestModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ZipzoongCareRequestModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ZipzoongCareRequestModelPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ZipzoongCareRequestModel.
     * @param {ZipzoongCareRequestModelCreateArgs} args - Arguments to create a ZipzoongCareRequestModel.
     * @example
     * // Create one ZipzoongCareRequestModel
     * const ZipzoongCareRequestModel = await prisma.zipzoongCareRequestModel.create({
     *   data: {
     *     // ... data to create a ZipzoongCareRequestModel
     *   }
     * })
     * 
    **/
    create<T extends ZipzoongCareRequestModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ZipzoongCareRequestModelCreateArgs<ExtArgs>>
    ): Prisma__ZipzoongCareRequestModelClient<$Types.GetResult<ZipzoongCareRequestModelPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ZipzoongCareRequestModels.
     *     @param {ZipzoongCareRequestModelCreateManyArgs} args - Arguments to create many ZipzoongCareRequestModels.
     *     @example
     *     // Create many ZipzoongCareRequestModels
     *     const zipzoongCareRequestModel = await prisma.zipzoongCareRequestModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ZipzoongCareRequestModelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ZipzoongCareRequestModelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ZipzoongCareRequestModel.
     * @param {ZipzoongCareRequestModelDeleteArgs} args - Arguments to delete one ZipzoongCareRequestModel.
     * @example
     * // Delete one ZipzoongCareRequestModel
     * const ZipzoongCareRequestModel = await prisma.zipzoongCareRequestModel.delete({
     *   where: {
     *     // ... filter to delete one ZipzoongCareRequestModel
     *   }
     * })
     * 
    **/
    delete<T extends ZipzoongCareRequestModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ZipzoongCareRequestModelDeleteArgs<ExtArgs>>
    ): Prisma__ZipzoongCareRequestModelClient<$Types.GetResult<ZipzoongCareRequestModelPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ZipzoongCareRequestModel.
     * @param {ZipzoongCareRequestModelUpdateArgs} args - Arguments to update one ZipzoongCareRequestModel.
     * @example
     * // Update one ZipzoongCareRequestModel
     * const zipzoongCareRequestModel = await prisma.zipzoongCareRequestModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ZipzoongCareRequestModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ZipzoongCareRequestModelUpdateArgs<ExtArgs>>
    ): Prisma__ZipzoongCareRequestModelClient<$Types.GetResult<ZipzoongCareRequestModelPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ZipzoongCareRequestModels.
     * @param {ZipzoongCareRequestModelDeleteManyArgs} args - Arguments to filter ZipzoongCareRequestModels to delete.
     * @example
     * // Delete a few ZipzoongCareRequestModels
     * const { count } = await prisma.zipzoongCareRequestModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ZipzoongCareRequestModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ZipzoongCareRequestModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZipzoongCareRequestModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZipzoongCareRequestModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ZipzoongCareRequestModels
     * const zipzoongCareRequestModel = await prisma.zipzoongCareRequestModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ZipzoongCareRequestModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ZipzoongCareRequestModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ZipzoongCareRequestModel.
     * @param {ZipzoongCareRequestModelUpsertArgs} args - Arguments to update or create a ZipzoongCareRequestModel.
     * @example
     * // Update or create a ZipzoongCareRequestModel
     * const zipzoongCareRequestModel = await prisma.zipzoongCareRequestModel.upsert({
     *   create: {
     *     // ... data to create a ZipzoongCareRequestModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ZipzoongCareRequestModel we want to update
     *   }
     * })
    **/
    upsert<T extends ZipzoongCareRequestModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ZipzoongCareRequestModelUpsertArgs<ExtArgs>>
    ): Prisma__ZipzoongCareRequestModelClient<$Types.GetResult<ZipzoongCareRequestModelPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ZipzoongCareRequestModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZipzoongCareRequestModelCountArgs} args - Arguments to filter ZipzoongCareRequestModels to count.
     * @example
     * // Count the number of ZipzoongCareRequestModels
     * const count = await prisma.zipzoongCareRequestModel.count({
     *   where: {
     *     // ... the filter for the ZipzoongCareRequestModels we want to count
     *   }
     * })
    **/
    count<T extends ZipzoongCareRequestModelCountArgs>(
      args?: Subset<T, ZipzoongCareRequestModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZipzoongCareRequestModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ZipzoongCareRequestModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZipzoongCareRequestModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZipzoongCareRequestModelAggregateArgs>(args: Subset<T, ZipzoongCareRequestModelAggregateArgs>): Prisma.PrismaPromise<GetZipzoongCareRequestModelAggregateType<T>>

    /**
     * Group by ZipzoongCareRequestModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZipzoongCareRequestModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZipzoongCareRequestModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZipzoongCareRequestModelGroupByArgs['orderBy'] }
        : { orderBy?: ZipzoongCareRequestModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZipzoongCareRequestModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZipzoongCareRequestModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ZipzoongCareRequestModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ZipzoongCareRequestModelClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    requester<T extends CustomerModelArgs<ExtArgs> = {}>(args?: Subset<T, CustomerModelArgs<ExtArgs>>): Prisma__CustomerModelClient<$Types.GetResult<CustomerModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    consultation_time_checks<T extends ZipzoongCareRequestModel$consultation_time_checksArgs<ExtArgs> = {}>(args?: Subset<T, ZipzoongCareRequestModel$consultation_time_checksArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>, T, 'findMany', never>| Null>;

    service_checks<T extends ZipzoongCareRequestModel$service_checksArgs<ExtArgs> = {}>(args?: Subset<T, ZipzoongCareRequestModel$service_checksArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ZipzoongCareServiceCheckModelPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ZipzoongCareRequestModel base type for findUnique actions
   */
  export type ZipzoongCareRequestModelFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareRequestModel
     */
    select?: ZipzoongCareRequestModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareRequestModelInclude<ExtArgs> | null
    /**
     * Filter, which ZipzoongCareRequestModel to fetch.
     */
    where: ZipzoongCareRequestModelWhereUniqueInput
  }

  /**
   * ZipzoongCareRequestModel findUnique
   */
  export interface ZipzoongCareRequestModelFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ZipzoongCareRequestModelFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ZipzoongCareRequestModel findUniqueOrThrow
   */
  export type ZipzoongCareRequestModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareRequestModel
     */
    select?: ZipzoongCareRequestModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareRequestModelInclude<ExtArgs> | null
    /**
     * Filter, which ZipzoongCareRequestModel to fetch.
     */
    where: ZipzoongCareRequestModelWhereUniqueInput
  }


  /**
   * ZipzoongCareRequestModel base type for findFirst actions
   */
  export type ZipzoongCareRequestModelFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareRequestModel
     */
    select?: ZipzoongCareRequestModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareRequestModelInclude<ExtArgs> | null
    /**
     * Filter, which ZipzoongCareRequestModel to fetch.
     */
    where?: ZipzoongCareRequestModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZipzoongCareRequestModels to fetch.
     */
    orderBy?: Enumerable<ZipzoongCareRequestModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZipzoongCareRequestModels.
     */
    cursor?: ZipzoongCareRequestModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZipzoongCareRequestModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZipzoongCareRequestModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZipzoongCareRequestModels.
     */
    distinct?: Enumerable<ZipzoongCareRequestModelScalarFieldEnum>
  }

  /**
   * ZipzoongCareRequestModel findFirst
   */
  export interface ZipzoongCareRequestModelFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ZipzoongCareRequestModelFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ZipzoongCareRequestModel findFirstOrThrow
   */
  export type ZipzoongCareRequestModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareRequestModel
     */
    select?: ZipzoongCareRequestModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareRequestModelInclude<ExtArgs> | null
    /**
     * Filter, which ZipzoongCareRequestModel to fetch.
     */
    where?: ZipzoongCareRequestModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZipzoongCareRequestModels to fetch.
     */
    orderBy?: Enumerable<ZipzoongCareRequestModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZipzoongCareRequestModels.
     */
    cursor?: ZipzoongCareRequestModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZipzoongCareRequestModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZipzoongCareRequestModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZipzoongCareRequestModels.
     */
    distinct?: Enumerable<ZipzoongCareRequestModelScalarFieldEnum>
  }


  /**
   * ZipzoongCareRequestModel findMany
   */
  export type ZipzoongCareRequestModelFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareRequestModel
     */
    select?: ZipzoongCareRequestModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareRequestModelInclude<ExtArgs> | null
    /**
     * Filter, which ZipzoongCareRequestModels to fetch.
     */
    where?: ZipzoongCareRequestModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZipzoongCareRequestModels to fetch.
     */
    orderBy?: Enumerable<ZipzoongCareRequestModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ZipzoongCareRequestModels.
     */
    cursor?: ZipzoongCareRequestModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZipzoongCareRequestModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZipzoongCareRequestModels.
     */
    skip?: number
    distinct?: Enumerable<ZipzoongCareRequestModelScalarFieldEnum>
  }


  /**
   * ZipzoongCareRequestModel create
   */
  export type ZipzoongCareRequestModelCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareRequestModel
     */
    select?: ZipzoongCareRequestModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareRequestModelInclude<ExtArgs> | null
    /**
     * The data needed to create a ZipzoongCareRequestModel.
     */
    data: XOR<ZipzoongCareRequestModelCreateInput, ZipzoongCareRequestModelUncheckedCreateInput>
  }


  /**
   * ZipzoongCareRequestModel createMany
   */
  export type ZipzoongCareRequestModelCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ZipzoongCareRequestModels.
     */
    data: Enumerable<ZipzoongCareRequestModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ZipzoongCareRequestModel update
   */
  export type ZipzoongCareRequestModelUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareRequestModel
     */
    select?: ZipzoongCareRequestModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareRequestModelInclude<ExtArgs> | null
    /**
     * The data needed to update a ZipzoongCareRequestModel.
     */
    data: XOR<ZipzoongCareRequestModelUpdateInput, ZipzoongCareRequestModelUncheckedUpdateInput>
    /**
     * Choose, which ZipzoongCareRequestModel to update.
     */
    where: ZipzoongCareRequestModelWhereUniqueInput
  }


  /**
   * ZipzoongCareRequestModel updateMany
   */
  export type ZipzoongCareRequestModelUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ZipzoongCareRequestModels.
     */
    data: XOR<ZipzoongCareRequestModelUpdateManyMutationInput, ZipzoongCareRequestModelUncheckedUpdateManyInput>
    /**
     * Filter which ZipzoongCareRequestModels to update
     */
    where?: ZipzoongCareRequestModelWhereInput
  }


  /**
   * ZipzoongCareRequestModel upsert
   */
  export type ZipzoongCareRequestModelUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareRequestModel
     */
    select?: ZipzoongCareRequestModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareRequestModelInclude<ExtArgs> | null
    /**
     * The filter to search for the ZipzoongCareRequestModel to update in case it exists.
     */
    where: ZipzoongCareRequestModelWhereUniqueInput
    /**
     * In case the ZipzoongCareRequestModel found by the `where` argument doesn't exist, create a new ZipzoongCareRequestModel with this data.
     */
    create: XOR<ZipzoongCareRequestModelCreateInput, ZipzoongCareRequestModelUncheckedCreateInput>
    /**
     * In case the ZipzoongCareRequestModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZipzoongCareRequestModelUpdateInput, ZipzoongCareRequestModelUncheckedUpdateInput>
  }


  /**
   * ZipzoongCareRequestModel delete
   */
  export type ZipzoongCareRequestModelDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareRequestModel
     */
    select?: ZipzoongCareRequestModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareRequestModelInclude<ExtArgs> | null
    /**
     * Filter which ZipzoongCareRequestModel to delete.
     */
    where: ZipzoongCareRequestModelWhereUniqueInput
  }


  /**
   * ZipzoongCareRequestModel deleteMany
   */
  export type ZipzoongCareRequestModelDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZipzoongCareRequestModels to delete
     */
    where?: ZipzoongCareRequestModelWhereInput
  }


  /**
   * ZipzoongCareRequestModel.consultation_time_checks
   */
  export type ZipzoongCareRequestModel$consultation_time_checksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareConsultationTimeCheckModel
     */
    select?: ZipzoongCareConsultationTimeCheckModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareConsultationTimeCheckModelInclude<ExtArgs> | null
    where?: ZipzoongCareConsultationTimeCheckModelWhereInput
    orderBy?: Enumerable<ZipzoongCareConsultationTimeCheckModelOrderByWithRelationInput>
    cursor?: ZipzoongCareConsultationTimeCheckModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ZipzoongCareConsultationTimeCheckModelScalarFieldEnum>
  }


  /**
   * ZipzoongCareRequestModel.service_checks
   */
  export type ZipzoongCareRequestModel$service_checksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareServiceCheckModel
     */
    select?: ZipzoongCareServiceCheckModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareServiceCheckModelInclude<ExtArgs> | null
    where?: ZipzoongCareServiceCheckModelWhereInput
    orderBy?: Enumerable<ZipzoongCareServiceCheckModelOrderByWithRelationInput>
    cursor?: ZipzoongCareServiceCheckModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ZipzoongCareServiceCheckModelScalarFieldEnum>
  }


  /**
   * ZipzoongCareRequestModel without action
   */
  export type ZipzoongCareRequestModelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareRequestModel
     */
    select?: ZipzoongCareRequestModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareRequestModelInclude<ExtArgs> | null
  }



  /**
   * Model ZipzoongCareServiceCheckModel
   */


  export type AggregateZipzoongCareServiceCheckModel = {
    _count: ZipzoongCareServiceCheckModelCountAggregateOutputType | null
    _min: ZipzoongCareServiceCheckModelMinAggregateOutputType | null
    _max: ZipzoongCareServiceCheckModelMaxAggregateOutputType | null
  }

  export type ZipzoongCareServiceCheckModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    service_super_category_id: string | null
    request_id: string | null
  }

  export type ZipzoongCareServiceCheckModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    service_super_category_id: string | null
    request_id: string | null
  }

  export type ZipzoongCareServiceCheckModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    service_super_category_id: number
    request_id: number
    _all: number
  }


  export type ZipzoongCareServiceCheckModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    service_super_category_id?: true
    request_id?: true
  }

  export type ZipzoongCareServiceCheckModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    service_super_category_id?: true
    request_id?: true
  }

  export type ZipzoongCareServiceCheckModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    service_super_category_id?: true
    request_id?: true
    _all?: true
  }

  export type ZipzoongCareServiceCheckModelAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZipzoongCareServiceCheckModel to aggregate.
     */
    where?: ZipzoongCareServiceCheckModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZipzoongCareServiceCheckModels to fetch.
     */
    orderBy?: Enumerable<ZipzoongCareServiceCheckModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZipzoongCareServiceCheckModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZipzoongCareServiceCheckModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZipzoongCareServiceCheckModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ZipzoongCareServiceCheckModels
    **/
    _count?: true | ZipzoongCareServiceCheckModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZipzoongCareServiceCheckModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZipzoongCareServiceCheckModelMaxAggregateInputType
  }

  export type GetZipzoongCareServiceCheckModelAggregateType<T extends ZipzoongCareServiceCheckModelAggregateArgs> = {
        [P in keyof T & keyof AggregateZipzoongCareServiceCheckModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZipzoongCareServiceCheckModel[P]>
      : GetScalarType<T[P], AggregateZipzoongCareServiceCheckModel[P]>
  }




  export type ZipzoongCareServiceCheckModelGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ZipzoongCareServiceCheckModelWhereInput
    orderBy?: Enumerable<ZipzoongCareServiceCheckModelOrderByWithAggregationInput>
    by: ZipzoongCareServiceCheckModelScalarFieldEnum[]
    having?: ZipzoongCareServiceCheckModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZipzoongCareServiceCheckModelCountAggregateInputType | true
    _min?: ZipzoongCareServiceCheckModelMinAggregateInputType
    _max?: ZipzoongCareServiceCheckModelMaxAggregateInputType
  }


  export type ZipzoongCareServiceCheckModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    service_super_category_id: string
    request_id: string
    _count: ZipzoongCareServiceCheckModelCountAggregateOutputType | null
    _min: ZipzoongCareServiceCheckModelMinAggregateOutputType | null
    _max: ZipzoongCareServiceCheckModelMaxAggregateOutputType | null
  }

  type GetZipzoongCareServiceCheckModelGroupByPayload<T extends ZipzoongCareServiceCheckModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ZipzoongCareServiceCheckModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZipzoongCareServiceCheckModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZipzoongCareServiceCheckModelGroupByOutputType[P]>
            : GetScalarType<T[P], ZipzoongCareServiceCheckModelGroupByOutputType[P]>
        }
      >
    >


  export type ZipzoongCareServiceCheckModelSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    service_super_category_id?: boolean
    request_id?: boolean
    service_super_category?: boolean | ServiceSuperCategoryModelArgs<ExtArgs>
    request?: boolean | ZipzoongCareRequestModelArgs<ExtArgs>
  }, ExtArgs["result"]["zipzoongCareServiceCheckModel"]>

  export type ZipzoongCareServiceCheckModelSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    service_super_category_id?: boolean
    request_id?: boolean
  }

  export type ZipzoongCareServiceCheckModelInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    service_super_category?: boolean | ServiceSuperCategoryModelArgs<ExtArgs>
    request?: boolean | ZipzoongCareRequestModelArgs<ExtArgs>
  }


  type ZipzoongCareServiceCheckModelGetPayload<S extends boolean | null | undefined | ZipzoongCareServiceCheckModelArgs> = $Types.GetResult<ZipzoongCareServiceCheckModelPayload, S>

  type ZipzoongCareServiceCheckModelCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ZipzoongCareServiceCheckModelFindManyArgs, 'select' | 'include'> & {
      select?: ZipzoongCareServiceCheckModelCountAggregateInputType | true
    }

  export interface ZipzoongCareServiceCheckModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ZipzoongCareServiceCheckModel'], meta: { name: 'ZipzoongCareServiceCheckModel' } }
    /**
     * Find zero or one ZipzoongCareServiceCheckModel that matches the filter.
     * @param {ZipzoongCareServiceCheckModelFindUniqueArgs} args - Arguments to find a ZipzoongCareServiceCheckModel
     * @example
     * // Get one ZipzoongCareServiceCheckModel
     * const zipzoongCareServiceCheckModel = await prisma.zipzoongCareServiceCheckModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ZipzoongCareServiceCheckModelFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ZipzoongCareServiceCheckModelFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ZipzoongCareServiceCheckModel'> extends True ? Prisma__ZipzoongCareServiceCheckModelClient<$Types.GetResult<ZipzoongCareServiceCheckModelPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ZipzoongCareServiceCheckModelClient<$Types.GetResult<ZipzoongCareServiceCheckModelPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ZipzoongCareServiceCheckModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ZipzoongCareServiceCheckModelFindUniqueOrThrowArgs} args - Arguments to find a ZipzoongCareServiceCheckModel
     * @example
     * // Get one ZipzoongCareServiceCheckModel
     * const zipzoongCareServiceCheckModel = await prisma.zipzoongCareServiceCheckModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ZipzoongCareServiceCheckModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ZipzoongCareServiceCheckModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ZipzoongCareServiceCheckModelClient<$Types.GetResult<ZipzoongCareServiceCheckModelPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ZipzoongCareServiceCheckModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZipzoongCareServiceCheckModelFindFirstArgs} args - Arguments to find a ZipzoongCareServiceCheckModel
     * @example
     * // Get one ZipzoongCareServiceCheckModel
     * const zipzoongCareServiceCheckModel = await prisma.zipzoongCareServiceCheckModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ZipzoongCareServiceCheckModelFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ZipzoongCareServiceCheckModelFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ZipzoongCareServiceCheckModel'> extends True ? Prisma__ZipzoongCareServiceCheckModelClient<$Types.GetResult<ZipzoongCareServiceCheckModelPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ZipzoongCareServiceCheckModelClient<$Types.GetResult<ZipzoongCareServiceCheckModelPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ZipzoongCareServiceCheckModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZipzoongCareServiceCheckModelFindFirstOrThrowArgs} args - Arguments to find a ZipzoongCareServiceCheckModel
     * @example
     * // Get one ZipzoongCareServiceCheckModel
     * const zipzoongCareServiceCheckModel = await prisma.zipzoongCareServiceCheckModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ZipzoongCareServiceCheckModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ZipzoongCareServiceCheckModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ZipzoongCareServiceCheckModelClient<$Types.GetResult<ZipzoongCareServiceCheckModelPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ZipzoongCareServiceCheckModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZipzoongCareServiceCheckModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ZipzoongCareServiceCheckModels
     * const zipzoongCareServiceCheckModels = await prisma.zipzoongCareServiceCheckModel.findMany()
     * 
     * // Get first 10 ZipzoongCareServiceCheckModels
     * const zipzoongCareServiceCheckModels = await prisma.zipzoongCareServiceCheckModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zipzoongCareServiceCheckModelWithIdOnly = await prisma.zipzoongCareServiceCheckModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ZipzoongCareServiceCheckModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ZipzoongCareServiceCheckModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ZipzoongCareServiceCheckModelPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ZipzoongCareServiceCheckModel.
     * @param {ZipzoongCareServiceCheckModelCreateArgs} args - Arguments to create a ZipzoongCareServiceCheckModel.
     * @example
     * // Create one ZipzoongCareServiceCheckModel
     * const ZipzoongCareServiceCheckModel = await prisma.zipzoongCareServiceCheckModel.create({
     *   data: {
     *     // ... data to create a ZipzoongCareServiceCheckModel
     *   }
     * })
     * 
    **/
    create<T extends ZipzoongCareServiceCheckModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ZipzoongCareServiceCheckModelCreateArgs<ExtArgs>>
    ): Prisma__ZipzoongCareServiceCheckModelClient<$Types.GetResult<ZipzoongCareServiceCheckModelPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ZipzoongCareServiceCheckModels.
     *     @param {ZipzoongCareServiceCheckModelCreateManyArgs} args - Arguments to create many ZipzoongCareServiceCheckModels.
     *     @example
     *     // Create many ZipzoongCareServiceCheckModels
     *     const zipzoongCareServiceCheckModel = await prisma.zipzoongCareServiceCheckModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ZipzoongCareServiceCheckModelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ZipzoongCareServiceCheckModelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ZipzoongCareServiceCheckModel.
     * @param {ZipzoongCareServiceCheckModelDeleteArgs} args - Arguments to delete one ZipzoongCareServiceCheckModel.
     * @example
     * // Delete one ZipzoongCareServiceCheckModel
     * const ZipzoongCareServiceCheckModel = await prisma.zipzoongCareServiceCheckModel.delete({
     *   where: {
     *     // ... filter to delete one ZipzoongCareServiceCheckModel
     *   }
     * })
     * 
    **/
    delete<T extends ZipzoongCareServiceCheckModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ZipzoongCareServiceCheckModelDeleteArgs<ExtArgs>>
    ): Prisma__ZipzoongCareServiceCheckModelClient<$Types.GetResult<ZipzoongCareServiceCheckModelPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ZipzoongCareServiceCheckModel.
     * @param {ZipzoongCareServiceCheckModelUpdateArgs} args - Arguments to update one ZipzoongCareServiceCheckModel.
     * @example
     * // Update one ZipzoongCareServiceCheckModel
     * const zipzoongCareServiceCheckModel = await prisma.zipzoongCareServiceCheckModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ZipzoongCareServiceCheckModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ZipzoongCareServiceCheckModelUpdateArgs<ExtArgs>>
    ): Prisma__ZipzoongCareServiceCheckModelClient<$Types.GetResult<ZipzoongCareServiceCheckModelPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ZipzoongCareServiceCheckModels.
     * @param {ZipzoongCareServiceCheckModelDeleteManyArgs} args - Arguments to filter ZipzoongCareServiceCheckModels to delete.
     * @example
     * // Delete a few ZipzoongCareServiceCheckModels
     * const { count } = await prisma.zipzoongCareServiceCheckModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ZipzoongCareServiceCheckModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ZipzoongCareServiceCheckModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZipzoongCareServiceCheckModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZipzoongCareServiceCheckModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ZipzoongCareServiceCheckModels
     * const zipzoongCareServiceCheckModel = await prisma.zipzoongCareServiceCheckModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ZipzoongCareServiceCheckModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ZipzoongCareServiceCheckModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ZipzoongCareServiceCheckModel.
     * @param {ZipzoongCareServiceCheckModelUpsertArgs} args - Arguments to update or create a ZipzoongCareServiceCheckModel.
     * @example
     * // Update or create a ZipzoongCareServiceCheckModel
     * const zipzoongCareServiceCheckModel = await prisma.zipzoongCareServiceCheckModel.upsert({
     *   create: {
     *     // ... data to create a ZipzoongCareServiceCheckModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ZipzoongCareServiceCheckModel we want to update
     *   }
     * })
    **/
    upsert<T extends ZipzoongCareServiceCheckModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ZipzoongCareServiceCheckModelUpsertArgs<ExtArgs>>
    ): Prisma__ZipzoongCareServiceCheckModelClient<$Types.GetResult<ZipzoongCareServiceCheckModelPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ZipzoongCareServiceCheckModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZipzoongCareServiceCheckModelCountArgs} args - Arguments to filter ZipzoongCareServiceCheckModels to count.
     * @example
     * // Count the number of ZipzoongCareServiceCheckModels
     * const count = await prisma.zipzoongCareServiceCheckModel.count({
     *   where: {
     *     // ... the filter for the ZipzoongCareServiceCheckModels we want to count
     *   }
     * })
    **/
    count<T extends ZipzoongCareServiceCheckModelCountArgs>(
      args?: Subset<T, ZipzoongCareServiceCheckModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZipzoongCareServiceCheckModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ZipzoongCareServiceCheckModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZipzoongCareServiceCheckModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZipzoongCareServiceCheckModelAggregateArgs>(args: Subset<T, ZipzoongCareServiceCheckModelAggregateArgs>): Prisma.PrismaPromise<GetZipzoongCareServiceCheckModelAggregateType<T>>

    /**
     * Group by ZipzoongCareServiceCheckModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZipzoongCareServiceCheckModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZipzoongCareServiceCheckModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZipzoongCareServiceCheckModelGroupByArgs['orderBy'] }
        : { orderBy?: ZipzoongCareServiceCheckModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZipzoongCareServiceCheckModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZipzoongCareServiceCheckModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ZipzoongCareServiceCheckModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ZipzoongCareServiceCheckModelClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    service_super_category<T extends ServiceSuperCategoryModelArgs<ExtArgs> = {}>(args?: Subset<T, ServiceSuperCategoryModelArgs<ExtArgs>>): Prisma__ServiceSuperCategoryModelClient<$Types.GetResult<ServiceSuperCategoryModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    request<T extends ZipzoongCareRequestModelArgs<ExtArgs> = {}>(args?: Subset<T, ZipzoongCareRequestModelArgs<ExtArgs>>): Prisma__ZipzoongCareRequestModelClient<$Types.GetResult<ZipzoongCareRequestModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ZipzoongCareServiceCheckModel base type for findUnique actions
   */
  export type ZipzoongCareServiceCheckModelFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareServiceCheckModel
     */
    select?: ZipzoongCareServiceCheckModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareServiceCheckModelInclude<ExtArgs> | null
    /**
     * Filter, which ZipzoongCareServiceCheckModel to fetch.
     */
    where: ZipzoongCareServiceCheckModelWhereUniqueInput
  }

  /**
   * ZipzoongCareServiceCheckModel findUnique
   */
  export interface ZipzoongCareServiceCheckModelFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ZipzoongCareServiceCheckModelFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ZipzoongCareServiceCheckModel findUniqueOrThrow
   */
  export type ZipzoongCareServiceCheckModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareServiceCheckModel
     */
    select?: ZipzoongCareServiceCheckModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareServiceCheckModelInclude<ExtArgs> | null
    /**
     * Filter, which ZipzoongCareServiceCheckModel to fetch.
     */
    where: ZipzoongCareServiceCheckModelWhereUniqueInput
  }


  /**
   * ZipzoongCareServiceCheckModel base type for findFirst actions
   */
  export type ZipzoongCareServiceCheckModelFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareServiceCheckModel
     */
    select?: ZipzoongCareServiceCheckModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareServiceCheckModelInclude<ExtArgs> | null
    /**
     * Filter, which ZipzoongCareServiceCheckModel to fetch.
     */
    where?: ZipzoongCareServiceCheckModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZipzoongCareServiceCheckModels to fetch.
     */
    orderBy?: Enumerable<ZipzoongCareServiceCheckModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZipzoongCareServiceCheckModels.
     */
    cursor?: ZipzoongCareServiceCheckModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZipzoongCareServiceCheckModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZipzoongCareServiceCheckModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZipzoongCareServiceCheckModels.
     */
    distinct?: Enumerable<ZipzoongCareServiceCheckModelScalarFieldEnum>
  }

  /**
   * ZipzoongCareServiceCheckModel findFirst
   */
  export interface ZipzoongCareServiceCheckModelFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ZipzoongCareServiceCheckModelFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ZipzoongCareServiceCheckModel findFirstOrThrow
   */
  export type ZipzoongCareServiceCheckModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareServiceCheckModel
     */
    select?: ZipzoongCareServiceCheckModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareServiceCheckModelInclude<ExtArgs> | null
    /**
     * Filter, which ZipzoongCareServiceCheckModel to fetch.
     */
    where?: ZipzoongCareServiceCheckModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZipzoongCareServiceCheckModels to fetch.
     */
    orderBy?: Enumerable<ZipzoongCareServiceCheckModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZipzoongCareServiceCheckModels.
     */
    cursor?: ZipzoongCareServiceCheckModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZipzoongCareServiceCheckModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZipzoongCareServiceCheckModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZipzoongCareServiceCheckModels.
     */
    distinct?: Enumerable<ZipzoongCareServiceCheckModelScalarFieldEnum>
  }


  /**
   * ZipzoongCareServiceCheckModel findMany
   */
  export type ZipzoongCareServiceCheckModelFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareServiceCheckModel
     */
    select?: ZipzoongCareServiceCheckModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareServiceCheckModelInclude<ExtArgs> | null
    /**
     * Filter, which ZipzoongCareServiceCheckModels to fetch.
     */
    where?: ZipzoongCareServiceCheckModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZipzoongCareServiceCheckModels to fetch.
     */
    orderBy?: Enumerable<ZipzoongCareServiceCheckModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ZipzoongCareServiceCheckModels.
     */
    cursor?: ZipzoongCareServiceCheckModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZipzoongCareServiceCheckModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZipzoongCareServiceCheckModels.
     */
    skip?: number
    distinct?: Enumerable<ZipzoongCareServiceCheckModelScalarFieldEnum>
  }


  /**
   * ZipzoongCareServiceCheckModel create
   */
  export type ZipzoongCareServiceCheckModelCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareServiceCheckModel
     */
    select?: ZipzoongCareServiceCheckModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareServiceCheckModelInclude<ExtArgs> | null
    /**
     * The data needed to create a ZipzoongCareServiceCheckModel.
     */
    data: XOR<ZipzoongCareServiceCheckModelCreateInput, ZipzoongCareServiceCheckModelUncheckedCreateInput>
  }


  /**
   * ZipzoongCareServiceCheckModel createMany
   */
  export type ZipzoongCareServiceCheckModelCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ZipzoongCareServiceCheckModels.
     */
    data: Enumerable<ZipzoongCareServiceCheckModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ZipzoongCareServiceCheckModel update
   */
  export type ZipzoongCareServiceCheckModelUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareServiceCheckModel
     */
    select?: ZipzoongCareServiceCheckModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareServiceCheckModelInclude<ExtArgs> | null
    /**
     * The data needed to update a ZipzoongCareServiceCheckModel.
     */
    data: XOR<ZipzoongCareServiceCheckModelUpdateInput, ZipzoongCareServiceCheckModelUncheckedUpdateInput>
    /**
     * Choose, which ZipzoongCareServiceCheckModel to update.
     */
    where: ZipzoongCareServiceCheckModelWhereUniqueInput
  }


  /**
   * ZipzoongCareServiceCheckModel updateMany
   */
  export type ZipzoongCareServiceCheckModelUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ZipzoongCareServiceCheckModels.
     */
    data: XOR<ZipzoongCareServiceCheckModelUpdateManyMutationInput, ZipzoongCareServiceCheckModelUncheckedUpdateManyInput>
    /**
     * Filter which ZipzoongCareServiceCheckModels to update
     */
    where?: ZipzoongCareServiceCheckModelWhereInput
  }


  /**
   * ZipzoongCareServiceCheckModel upsert
   */
  export type ZipzoongCareServiceCheckModelUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareServiceCheckModel
     */
    select?: ZipzoongCareServiceCheckModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareServiceCheckModelInclude<ExtArgs> | null
    /**
     * The filter to search for the ZipzoongCareServiceCheckModel to update in case it exists.
     */
    where: ZipzoongCareServiceCheckModelWhereUniqueInput
    /**
     * In case the ZipzoongCareServiceCheckModel found by the `where` argument doesn't exist, create a new ZipzoongCareServiceCheckModel with this data.
     */
    create: XOR<ZipzoongCareServiceCheckModelCreateInput, ZipzoongCareServiceCheckModelUncheckedCreateInput>
    /**
     * In case the ZipzoongCareServiceCheckModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZipzoongCareServiceCheckModelUpdateInput, ZipzoongCareServiceCheckModelUncheckedUpdateInput>
  }


  /**
   * ZipzoongCareServiceCheckModel delete
   */
  export type ZipzoongCareServiceCheckModelDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareServiceCheckModel
     */
    select?: ZipzoongCareServiceCheckModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareServiceCheckModelInclude<ExtArgs> | null
    /**
     * Filter which ZipzoongCareServiceCheckModel to delete.
     */
    where: ZipzoongCareServiceCheckModelWhereUniqueInput
  }


  /**
   * ZipzoongCareServiceCheckModel deleteMany
   */
  export type ZipzoongCareServiceCheckModelDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZipzoongCareServiceCheckModels to delete
     */
    where?: ZipzoongCareServiceCheckModelWhereInput
  }


  /**
   * ZipzoongCareServiceCheckModel without action
   */
  export type ZipzoongCareServiceCheckModelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareServiceCheckModel
     */
    select?: ZipzoongCareServiceCheckModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareServiceCheckModelInclude<ExtArgs> | null
  }



  /**
   * Model ZipzoongCareConsultationTimeCheckModel
   */


  export type AggregateZipzoongCareConsultationTimeCheckModel = {
    _count: ZipzoongCareConsultationTimeCheckModelCountAggregateOutputType | null
    _min: ZipzoongCareConsultationTimeCheckModelMinAggregateOutputType | null
    _max: ZipzoongCareConsultationTimeCheckModelMaxAggregateOutputType | null
  }

  export type ZipzoongCareConsultationTimeCheckModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    start_time: Date | null
    end_time: Date | null
    request_id: string | null
  }

  export type ZipzoongCareConsultationTimeCheckModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    start_time: Date | null
    end_time: Date | null
    request_id: string | null
  }

  export type ZipzoongCareConsultationTimeCheckModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    start_time: number
    end_time: number
    request_id: number
    _all: number
  }


  export type ZipzoongCareConsultationTimeCheckModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    start_time?: true
    end_time?: true
    request_id?: true
  }

  export type ZipzoongCareConsultationTimeCheckModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    start_time?: true
    end_time?: true
    request_id?: true
  }

  export type ZipzoongCareConsultationTimeCheckModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    start_time?: true
    end_time?: true
    request_id?: true
    _all?: true
  }

  export type ZipzoongCareConsultationTimeCheckModelAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZipzoongCareConsultationTimeCheckModel to aggregate.
     */
    where?: ZipzoongCareConsultationTimeCheckModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZipzoongCareConsultationTimeCheckModels to fetch.
     */
    orderBy?: Enumerable<ZipzoongCareConsultationTimeCheckModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZipzoongCareConsultationTimeCheckModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZipzoongCareConsultationTimeCheckModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZipzoongCareConsultationTimeCheckModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ZipzoongCareConsultationTimeCheckModels
    **/
    _count?: true | ZipzoongCareConsultationTimeCheckModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZipzoongCareConsultationTimeCheckModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZipzoongCareConsultationTimeCheckModelMaxAggregateInputType
  }

  export type GetZipzoongCareConsultationTimeCheckModelAggregateType<T extends ZipzoongCareConsultationTimeCheckModelAggregateArgs> = {
        [P in keyof T & keyof AggregateZipzoongCareConsultationTimeCheckModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZipzoongCareConsultationTimeCheckModel[P]>
      : GetScalarType<T[P], AggregateZipzoongCareConsultationTimeCheckModel[P]>
  }




  export type ZipzoongCareConsultationTimeCheckModelGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ZipzoongCareConsultationTimeCheckModelWhereInput
    orderBy?: Enumerable<ZipzoongCareConsultationTimeCheckModelOrderByWithAggregationInput>
    by: ZipzoongCareConsultationTimeCheckModelScalarFieldEnum[]
    having?: ZipzoongCareConsultationTimeCheckModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZipzoongCareConsultationTimeCheckModelCountAggregateInputType | true
    _min?: ZipzoongCareConsultationTimeCheckModelMinAggregateInputType
    _max?: ZipzoongCareConsultationTimeCheckModelMaxAggregateInputType
  }


  export type ZipzoongCareConsultationTimeCheckModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    start_time: Date
    end_time: Date
    request_id: string
    _count: ZipzoongCareConsultationTimeCheckModelCountAggregateOutputType | null
    _min: ZipzoongCareConsultationTimeCheckModelMinAggregateOutputType | null
    _max: ZipzoongCareConsultationTimeCheckModelMaxAggregateOutputType | null
  }

  type GetZipzoongCareConsultationTimeCheckModelGroupByPayload<T extends ZipzoongCareConsultationTimeCheckModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ZipzoongCareConsultationTimeCheckModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZipzoongCareConsultationTimeCheckModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZipzoongCareConsultationTimeCheckModelGroupByOutputType[P]>
            : GetScalarType<T[P], ZipzoongCareConsultationTimeCheckModelGroupByOutputType[P]>
        }
      >
    >


  export type ZipzoongCareConsultationTimeCheckModelSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    start_time?: boolean
    end_time?: boolean
    request_id?: boolean
    request?: boolean | ZipzoongCareRequestModelArgs<ExtArgs>
  }, ExtArgs["result"]["zipzoongCareConsultationTimeCheckModel"]>

  export type ZipzoongCareConsultationTimeCheckModelSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    start_time?: boolean
    end_time?: boolean
    request_id?: boolean
  }

  export type ZipzoongCareConsultationTimeCheckModelInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    request?: boolean | ZipzoongCareRequestModelArgs<ExtArgs>
  }


  type ZipzoongCareConsultationTimeCheckModelGetPayload<S extends boolean | null | undefined | ZipzoongCareConsultationTimeCheckModelArgs> = $Types.GetResult<ZipzoongCareConsultationTimeCheckModelPayload, S>

  type ZipzoongCareConsultationTimeCheckModelCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ZipzoongCareConsultationTimeCheckModelFindManyArgs, 'select' | 'include'> & {
      select?: ZipzoongCareConsultationTimeCheckModelCountAggregateInputType | true
    }

  export interface ZipzoongCareConsultationTimeCheckModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ZipzoongCareConsultationTimeCheckModel'], meta: { name: 'ZipzoongCareConsultationTimeCheckModel' } }
    /**
     * Find zero or one ZipzoongCareConsultationTimeCheckModel that matches the filter.
     * @param {ZipzoongCareConsultationTimeCheckModelFindUniqueArgs} args - Arguments to find a ZipzoongCareConsultationTimeCheckModel
     * @example
     * // Get one ZipzoongCareConsultationTimeCheckModel
     * const zipzoongCareConsultationTimeCheckModel = await prisma.zipzoongCareConsultationTimeCheckModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ZipzoongCareConsultationTimeCheckModelFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ZipzoongCareConsultationTimeCheckModelFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ZipzoongCareConsultationTimeCheckModel'> extends True ? Prisma__ZipzoongCareConsultationTimeCheckModelClient<$Types.GetResult<ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ZipzoongCareConsultationTimeCheckModelClient<$Types.GetResult<ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ZipzoongCareConsultationTimeCheckModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ZipzoongCareConsultationTimeCheckModelFindUniqueOrThrowArgs} args - Arguments to find a ZipzoongCareConsultationTimeCheckModel
     * @example
     * // Get one ZipzoongCareConsultationTimeCheckModel
     * const zipzoongCareConsultationTimeCheckModel = await prisma.zipzoongCareConsultationTimeCheckModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ZipzoongCareConsultationTimeCheckModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ZipzoongCareConsultationTimeCheckModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ZipzoongCareConsultationTimeCheckModelClient<$Types.GetResult<ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ZipzoongCareConsultationTimeCheckModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZipzoongCareConsultationTimeCheckModelFindFirstArgs} args - Arguments to find a ZipzoongCareConsultationTimeCheckModel
     * @example
     * // Get one ZipzoongCareConsultationTimeCheckModel
     * const zipzoongCareConsultationTimeCheckModel = await prisma.zipzoongCareConsultationTimeCheckModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ZipzoongCareConsultationTimeCheckModelFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ZipzoongCareConsultationTimeCheckModelFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ZipzoongCareConsultationTimeCheckModel'> extends True ? Prisma__ZipzoongCareConsultationTimeCheckModelClient<$Types.GetResult<ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ZipzoongCareConsultationTimeCheckModelClient<$Types.GetResult<ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ZipzoongCareConsultationTimeCheckModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZipzoongCareConsultationTimeCheckModelFindFirstOrThrowArgs} args - Arguments to find a ZipzoongCareConsultationTimeCheckModel
     * @example
     * // Get one ZipzoongCareConsultationTimeCheckModel
     * const zipzoongCareConsultationTimeCheckModel = await prisma.zipzoongCareConsultationTimeCheckModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ZipzoongCareConsultationTimeCheckModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ZipzoongCareConsultationTimeCheckModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ZipzoongCareConsultationTimeCheckModelClient<$Types.GetResult<ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ZipzoongCareConsultationTimeCheckModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZipzoongCareConsultationTimeCheckModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ZipzoongCareConsultationTimeCheckModels
     * const zipzoongCareConsultationTimeCheckModels = await prisma.zipzoongCareConsultationTimeCheckModel.findMany()
     * 
     * // Get first 10 ZipzoongCareConsultationTimeCheckModels
     * const zipzoongCareConsultationTimeCheckModels = await prisma.zipzoongCareConsultationTimeCheckModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zipzoongCareConsultationTimeCheckModelWithIdOnly = await prisma.zipzoongCareConsultationTimeCheckModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ZipzoongCareConsultationTimeCheckModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ZipzoongCareConsultationTimeCheckModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ZipzoongCareConsultationTimeCheckModel.
     * @param {ZipzoongCareConsultationTimeCheckModelCreateArgs} args - Arguments to create a ZipzoongCareConsultationTimeCheckModel.
     * @example
     * // Create one ZipzoongCareConsultationTimeCheckModel
     * const ZipzoongCareConsultationTimeCheckModel = await prisma.zipzoongCareConsultationTimeCheckModel.create({
     *   data: {
     *     // ... data to create a ZipzoongCareConsultationTimeCheckModel
     *   }
     * })
     * 
    **/
    create<T extends ZipzoongCareConsultationTimeCheckModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ZipzoongCareConsultationTimeCheckModelCreateArgs<ExtArgs>>
    ): Prisma__ZipzoongCareConsultationTimeCheckModelClient<$Types.GetResult<ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ZipzoongCareConsultationTimeCheckModels.
     *     @param {ZipzoongCareConsultationTimeCheckModelCreateManyArgs} args - Arguments to create many ZipzoongCareConsultationTimeCheckModels.
     *     @example
     *     // Create many ZipzoongCareConsultationTimeCheckModels
     *     const zipzoongCareConsultationTimeCheckModel = await prisma.zipzoongCareConsultationTimeCheckModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ZipzoongCareConsultationTimeCheckModelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ZipzoongCareConsultationTimeCheckModelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ZipzoongCareConsultationTimeCheckModel.
     * @param {ZipzoongCareConsultationTimeCheckModelDeleteArgs} args - Arguments to delete one ZipzoongCareConsultationTimeCheckModel.
     * @example
     * // Delete one ZipzoongCareConsultationTimeCheckModel
     * const ZipzoongCareConsultationTimeCheckModel = await prisma.zipzoongCareConsultationTimeCheckModel.delete({
     *   where: {
     *     // ... filter to delete one ZipzoongCareConsultationTimeCheckModel
     *   }
     * })
     * 
    **/
    delete<T extends ZipzoongCareConsultationTimeCheckModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ZipzoongCareConsultationTimeCheckModelDeleteArgs<ExtArgs>>
    ): Prisma__ZipzoongCareConsultationTimeCheckModelClient<$Types.GetResult<ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ZipzoongCareConsultationTimeCheckModel.
     * @param {ZipzoongCareConsultationTimeCheckModelUpdateArgs} args - Arguments to update one ZipzoongCareConsultationTimeCheckModel.
     * @example
     * // Update one ZipzoongCareConsultationTimeCheckModel
     * const zipzoongCareConsultationTimeCheckModel = await prisma.zipzoongCareConsultationTimeCheckModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ZipzoongCareConsultationTimeCheckModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ZipzoongCareConsultationTimeCheckModelUpdateArgs<ExtArgs>>
    ): Prisma__ZipzoongCareConsultationTimeCheckModelClient<$Types.GetResult<ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ZipzoongCareConsultationTimeCheckModels.
     * @param {ZipzoongCareConsultationTimeCheckModelDeleteManyArgs} args - Arguments to filter ZipzoongCareConsultationTimeCheckModels to delete.
     * @example
     * // Delete a few ZipzoongCareConsultationTimeCheckModels
     * const { count } = await prisma.zipzoongCareConsultationTimeCheckModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ZipzoongCareConsultationTimeCheckModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ZipzoongCareConsultationTimeCheckModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZipzoongCareConsultationTimeCheckModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZipzoongCareConsultationTimeCheckModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ZipzoongCareConsultationTimeCheckModels
     * const zipzoongCareConsultationTimeCheckModel = await prisma.zipzoongCareConsultationTimeCheckModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ZipzoongCareConsultationTimeCheckModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ZipzoongCareConsultationTimeCheckModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ZipzoongCareConsultationTimeCheckModel.
     * @param {ZipzoongCareConsultationTimeCheckModelUpsertArgs} args - Arguments to update or create a ZipzoongCareConsultationTimeCheckModel.
     * @example
     * // Update or create a ZipzoongCareConsultationTimeCheckModel
     * const zipzoongCareConsultationTimeCheckModel = await prisma.zipzoongCareConsultationTimeCheckModel.upsert({
     *   create: {
     *     // ... data to create a ZipzoongCareConsultationTimeCheckModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ZipzoongCareConsultationTimeCheckModel we want to update
     *   }
     * })
    **/
    upsert<T extends ZipzoongCareConsultationTimeCheckModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ZipzoongCareConsultationTimeCheckModelUpsertArgs<ExtArgs>>
    ): Prisma__ZipzoongCareConsultationTimeCheckModelClient<$Types.GetResult<ZipzoongCareConsultationTimeCheckModelPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ZipzoongCareConsultationTimeCheckModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZipzoongCareConsultationTimeCheckModelCountArgs} args - Arguments to filter ZipzoongCareConsultationTimeCheckModels to count.
     * @example
     * // Count the number of ZipzoongCareConsultationTimeCheckModels
     * const count = await prisma.zipzoongCareConsultationTimeCheckModel.count({
     *   where: {
     *     // ... the filter for the ZipzoongCareConsultationTimeCheckModels we want to count
     *   }
     * })
    **/
    count<T extends ZipzoongCareConsultationTimeCheckModelCountArgs>(
      args?: Subset<T, ZipzoongCareConsultationTimeCheckModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZipzoongCareConsultationTimeCheckModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ZipzoongCareConsultationTimeCheckModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZipzoongCareConsultationTimeCheckModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZipzoongCareConsultationTimeCheckModelAggregateArgs>(args: Subset<T, ZipzoongCareConsultationTimeCheckModelAggregateArgs>): Prisma.PrismaPromise<GetZipzoongCareConsultationTimeCheckModelAggregateType<T>>

    /**
     * Group by ZipzoongCareConsultationTimeCheckModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZipzoongCareConsultationTimeCheckModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZipzoongCareConsultationTimeCheckModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZipzoongCareConsultationTimeCheckModelGroupByArgs['orderBy'] }
        : { orderBy?: ZipzoongCareConsultationTimeCheckModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZipzoongCareConsultationTimeCheckModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZipzoongCareConsultationTimeCheckModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ZipzoongCareConsultationTimeCheckModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ZipzoongCareConsultationTimeCheckModelClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    request<T extends ZipzoongCareRequestModelArgs<ExtArgs> = {}>(args?: Subset<T, ZipzoongCareRequestModelArgs<ExtArgs>>): Prisma__ZipzoongCareRequestModelClient<$Types.GetResult<ZipzoongCareRequestModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ZipzoongCareConsultationTimeCheckModel base type for findUnique actions
   */
  export type ZipzoongCareConsultationTimeCheckModelFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareConsultationTimeCheckModel
     */
    select?: ZipzoongCareConsultationTimeCheckModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareConsultationTimeCheckModelInclude<ExtArgs> | null
    /**
     * Filter, which ZipzoongCareConsultationTimeCheckModel to fetch.
     */
    where: ZipzoongCareConsultationTimeCheckModelWhereUniqueInput
  }

  /**
   * ZipzoongCareConsultationTimeCheckModel findUnique
   */
  export interface ZipzoongCareConsultationTimeCheckModelFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ZipzoongCareConsultationTimeCheckModelFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ZipzoongCareConsultationTimeCheckModel findUniqueOrThrow
   */
  export type ZipzoongCareConsultationTimeCheckModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareConsultationTimeCheckModel
     */
    select?: ZipzoongCareConsultationTimeCheckModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareConsultationTimeCheckModelInclude<ExtArgs> | null
    /**
     * Filter, which ZipzoongCareConsultationTimeCheckModel to fetch.
     */
    where: ZipzoongCareConsultationTimeCheckModelWhereUniqueInput
  }


  /**
   * ZipzoongCareConsultationTimeCheckModel base type for findFirst actions
   */
  export type ZipzoongCareConsultationTimeCheckModelFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareConsultationTimeCheckModel
     */
    select?: ZipzoongCareConsultationTimeCheckModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareConsultationTimeCheckModelInclude<ExtArgs> | null
    /**
     * Filter, which ZipzoongCareConsultationTimeCheckModel to fetch.
     */
    where?: ZipzoongCareConsultationTimeCheckModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZipzoongCareConsultationTimeCheckModels to fetch.
     */
    orderBy?: Enumerable<ZipzoongCareConsultationTimeCheckModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZipzoongCareConsultationTimeCheckModels.
     */
    cursor?: ZipzoongCareConsultationTimeCheckModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZipzoongCareConsultationTimeCheckModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZipzoongCareConsultationTimeCheckModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZipzoongCareConsultationTimeCheckModels.
     */
    distinct?: Enumerable<ZipzoongCareConsultationTimeCheckModelScalarFieldEnum>
  }

  /**
   * ZipzoongCareConsultationTimeCheckModel findFirst
   */
  export interface ZipzoongCareConsultationTimeCheckModelFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ZipzoongCareConsultationTimeCheckModelFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ZipzoongCareConsultationTimeCheckModel findFirstOrThrow
   */
  export type ZipzoongCareConsultationTimeCheckModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareConsultationTimeCheckModel
     */
    select?: ZipzoongCareConsultationTimeCheckModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareConsultationTimeCheckModelInclude<ExtArgs> | null
    /**
     * Filter, which ZipzoongCareConsultationTimeCheckModel to fetch.
     */
    where?: ZipzoongCareConsultationTimeCheckModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZipzoongCareConsultationTimeCheckModels to fetch.
     */
    orderBy?: Enumerable<ZipzoongCareConsultationTimeCheckModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZipzoongCareConsultationTimeCheckModels.
     */
    cursor?: ZipzoongCareConsultationTimeCheckModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZipzoongCareConsultationTimeCheckModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZipzoongCareConsultationTimeCheckModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZipzoongCareConsultationTimeCheckModels.
     */
    distinct?: Enumerable<ZipzoongCareConsultationTimeCheckModelScalarFieldEnum>
  }


  /**
   * ZipzoongCareConsultationTimeCheckModel findMany
   */
  export type ZipzoongCareConsultationTimeCheckModelFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareConsultationTimeCheckModel
     */
    select?: ZipzoongCareConsultationTimeCheckModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareConsultationTimeCheckModelInclude<ExtArgs> | null
    /**
     * Filter, which ZipzoongCareConsultationTimeCheckModels to fetch.
     */
    where?: ZipzoongCareConsultationTimeCheckModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZipzoongCareConsultationTimeCheckModels to fetch.
     */
    orderBy?: Enumerable<ZipzoongCareConsultationTimeCheckModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ZipzoongCareConsultationTimeCheckModels.
     */
    cursor?: ZipzoongCareConsultationTimeCheckModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZipzoongCareConsultationTimeCheckModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZipzoongCareConsultationTimeCheckModels.
     */
    skip?: number
    distinct?: Enumerable<ZipzoongCareConsultationTimeCheckModelScalarFieldEnum>
  }


  /**
   * ZipzoongCareConsultationTimeCheckModel create
   */
  export type ZipzoongCareConsultationTimeCheckModelCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareConsultationTimeCheckModel
     */
    select?: ZipzoongCareConsultationTimeCheckModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareConsultationTimeCheckModelInclude<ExtArgs> | null
    /**
     * The data needed to create a ZipzoongCareConsultationTimeCheckModel.
     */
    data: XOR<ZipzoongCareConsultationTimeCheckModelCreateInput, ZipzoongCareConsultationTimeCheckModelUncheckedCreateInput>
  }


  /**
   * ZipzoongCareConsultationTimeCheckModel createMany
   */
  export type ZipzoongCareConsultationTimeCheckModelCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ZipzoongCareConsultationTimeCheckModels.
     */
    data: Enumerable<ZipzoongCareConsultationTimeCheckModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ZipzoongCareConsultationTimeCheckModel update
   */
  export type ZipzoongCareConsultationTimeCheckModelUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareConsultationTimeCheckModel
     */
    select?: ZipzoongCareConsultationTimeCheckModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareConsultationTimeCheckModelInclude<ExtArgs> | null
    /**
     * The data needed to update a ZipzoongCareConsultationTimeCheckModel.
     */
    data: XOR<ZipzoongCareConsultationTimeCheckModelUpdateInput, ZipzoongCareConsultationTimeCheckModelUncheckedUpdateInput>
    /**
     * Choose, which ZipzoongCareConsultationTimeCheckModel to update.
     */
    where: ZipzoongCareConsultationTimeCheckModelWhereUniqueInput
  }


  /**
   * ZipzoongCareConsultationTimeCheckModel updateMany
   */
  export type ZipzoongCareConsultationTimeCheckModelUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ZipzoongCareConsultationTimeCheckModels.
     */
    data: XOR<ZipzoongCareConsultationTimeCheckModelUpdateManyMutationInput, ZipzoongCareConsultationTimeCheckModelUncheckedUpdateManyInput>
    /**
     * Filter which ZipzoongCareConsultationTimeCheckModels to update
     */
    where?: ZipzoongCareConsultationTimeCheckModelWhereInput
  }


  /**
   * ZipzoongCareConsultationTimeCheckModel upsert
   */
  export type ZipzoongCareConsultationTimeCheckModelUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareConsultationTimeCheckModel
     */
    select?: ZipzoongCareConsultationTimeCheckModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareConsultationTimeCheckModelInclude<ExtArgs> | null
    /**
     * The filter to search for the ZipzoongCareConsultationTimeCheckModel to update in case it exists.
     */
    where: ZipzoongCareConsultationTimeCheckModelWhereUniqueInput
    /**
     * In case the ZipzoongCareConsultationTimeCheckModel found by the `where` argument doesn't exist, create a new ZipzoongCareConsultationTimeCheckModel with this data.
     */
    create: XOR<ZipzoongCareConsultationTimeCheckModelCreateInput, ZipzoongCareConsultationTimeCheckModelUncheckedCreateInput>
    /**
     * In case the ZipzoongCareConsultationTimeCheckModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZipzoongCareConsultationTimeCheckModelUpdateInput, ZipzoongCareConsultationTimeCheckModelUncheckedUpdateInput>
  }


  /**
   * ZipzoongCareConsultationTimeCheckModel delete
   */
  export type ZipzoongCareConsultationTimeCheckModelDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareConsultationTimeCheckModel
     */
    select?: ZipzoongCareConsultationTimeCheckModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareConsultationTimeCheckModelInclude<ExtArgs> | null
    /**
     * Filter which ZipzoongCareConsultationTimeCheckModel to delete.
     */
    where: ZipzoongCareConsultationTimeCheckModelWhereUniqueInput
  }


  /**
   * ZipzoongCareConsultationTimeCheckModel deleteMany
   */
  export type ZipzoongCareConsultationTimeCheckModelDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZipzoongCareConsultationTimeCheckModels to delete
     */
    where?: ZipzoongCareConsultationTimeCheckModelWhereInput
  }


  /**
   * ZipzoongCareConsultationTimeCheckModel without action
   */
  export type ZipzoongCareConsultationTimeCheckModelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareConsultationTimeCheckModel
     */
    select?: ZipzoongCareConsultationTimeCheckModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareConsultationTimeCheckModelInclude<ExtArgs> | null
  }



  /**
   * Model UserModel
   */


  export type AggregateUserModel = {
    _count: UserModelCountAggregateOutputType | null
    _min: UserModelMinAggregateOutputType | null
    _max: UserModelMaxAggregateOutputType | null
  }

  export type UserModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    email: string | null
  }

  export type UserModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    name: string | null
    email: string | null
  }

  export type UserModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    name: number
    email: number
    _all: number
  }


  export type UserModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    email?: true
  }

  export type UserModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    email?: true
  }

  export type UserModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    name?: true
    email?: true
    _all?: true
  }

  export type UserModelAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserModel to aggregate.
     */
    where?: UserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserModels to fetch.
     */
    orderBy?: Enumerable<UserModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserModels
    **/
    _count?: true | UserModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserModelMaxAggregateInputType
  }

  export type GetUserModelAggregateType<T extends UserModelAggregateArgs> = {
        [P in keyof T & keyof AggregateUserModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserModel[P]>
      : GetScalarType<T[P], AggregateUserModel[P]>
  }




  export type UserModelGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserModelWhereInput
    orderBy?: Enumerable<UserModelOrderByWithAggregationInput>
    by: UserModelScalarFieldEnum[]
    having?: UserModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserModelCountAggregateInputType | true
    _min?: UserModelMinAggregateInputType
    _max?: UserModelMaxAggregateInputType
  }


  export type UserModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    name: string
    email: string | null
    _count: UserModelCountAggregateOutputType | null
    _min: UserModelMinAggregateOutputType | null
    _max: UserModelMaxAggregateOutputType | null
  }

  type GetUserModelGroupByPayload<T extends UserModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserModelGroupByOutputType[P]>
            : GetScalarType<T[P], UserModelGroupByOutputType[P]>
        }
      >
    >


  export type UserModelSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    name?: boolean
    email?: boolean
    customer?: boolean | CustomerModelArgs<ExtArgs>
    business_user?: boolean | BusinessUserModelArgs<ExtArgs>
    agreement_acceptances?: boolean | UserModel$agreement_acceptancesArgs<ExtArgs>
    _count?: boolean | UserModelCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["userModel"]>

  export type UserModelSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    name?: boolean
    email?: boolean
  }

  export type UserModelInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerModelArgs<ExtArgs>
    business_user?: boolean | BusinessUserModelArgs<ExtArgs>
    agreement_acceptances?: boolean | UserModel$agreement_acceptancesArgs<ExtArgs>
    _count?: boolean | UserModelCountOutputTypeArgs<ExtArgs>
  }


  type UserModelGetPayload<S extends boolean | null | undefined | UserModelArgs> = $Types.GetResult<UserModelPayload, S>

  type UserModelCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserModelFindManyArgs, 'select' | 'include'> & {
      select?: UserModelCountAggregateInputType | true
    }

  export interface UserModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserModel'], meta: { name: 'UserModel' } }
    /**
     * Find zero or one UserModel that matches the filter.
     * @param {UserModelFindUniqueArgs} args - Arguments to find a UserModel
     * @example
     * // Get one UserModel
     * const userModel = await prisma.userModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserModelFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserModelFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserModel'> extends True ? Prisma__UserModelClient<$Types.GetResult<UserModelPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserModelClient<$Types.GetResult<UserModelPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one UserModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserModelFindUniqueOrThrowArgs} args - Arguments to find a UserModel
     * @example
     * // Get one UserModel
     * const userModel = await prisma.userModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserModelClient<$Types.GetResult<UserModelPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first UserModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelFindFirstArgs} args - Arguments to find a UserModel
     * @example
     * // Get one UserModel
     * const userModel = await prisma.userModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserModelFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserModelFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserModel'> extends True ? Prisma__UserModelClient<$Types.GetResult<UserModelPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserModelClient<$Types.GetResult<UserModelPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first UserModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelFindFirstOrThrowArgs} args - Arguments to find a UserModel
     * @example
     * // Get one UserModel
     * const userModel = await prisma.userModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserModelClient<$Types.GetResult<UserModelPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more UserModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserModels
     * const userModels = await prisma.userModel.findMany()
     * 
     * // Get first 10 UserModels
     * const userModels = await prisma.userModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userModelWithIdOnly = await prisma.userModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserModelPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a UserModel.
     * @param {UserModelCreateArgs} args - Arguments to create a UserModel.
     * @example
     * // Create one UserModel
     * const UserModel = await prisma.userModel.create({
     *   data: {
     *     // ... data to create a UserModel
     *   }
     * })
     * 
    **/
    create<T extends UserModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserModelCreateArgs<ExtArgs>>
    ): Prisma__UserModelClient<$Types.GetResult<UserModelPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many UserModels.
     *     @param {UserModelCreateManyArgs} args - Arguments to create many UserModels.
     *     @example
     *     // Create many UserModels
     *     const userModel = await prisma.userModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserModelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserModelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserModel.
     * @param {UserModelDeleteArgs} args - Arguments to delete one UserModel.
     * @example
     * // Delete one UserModel
     * const UserModel = await prisma.userModel.delete({
     *   where: {
     *     // ... filter to delete one UserModel
     *   }
     * })
     * 
    **/
    delete<T extends UserModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserModelDeleteArgs<ExtArgs>>
    ): Prisma__UserModelClient<$Types.GetResult<UserModelPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one UserModel.
     * @param {UserModelUpdateArgs} args - Arguments to update one UserModel.
     * @example
     * // Update one UserModel
     * const userModel = await prisma.userModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserModelUpdateArgs<ExtArgs>>
    ): Prisma__UserModelClient<$Types.GetResult<UserModelPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more UserModels.
     * @param {UserModelDeleteManyArgs} args - Arguments to filter UserModels to delete.
     * @example
     * // Delete a few UserModels
     * const { count } = await prisma.userModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserModels
     * const userModel = await prisma.userModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserModel.
     * @param {UserModelUpsertArgs} args - Arguments to update or create a UserModel.
     * @example
     * // Update or create a UserModel
     * const userModel = await prisma.userModel.upsert({
     *   create: {
     *     // ... data to create a UserModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserModel we want to update
     *   }
     * })
    **/
    upsert<T extends UserModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserModelUpsertArgs<ExtArgs>>
    ): Prisma__UserModelClient<$Types.GetResult<UserModelPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of UserModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelCountArgs} args - Arguments to filter UserModels to count.
     * @example
     * // Count the number of UserModels
     * const count = await prisma.userModel.count({
     *   where: {
     *     // ... the filter for the UserModels we want to count
     *   }
     * })
    **/
    count<T extends UserModelCountArgs>(
      args?: Subset<T, UserModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserModelAggregateArgs>(args: Subset<T, UserModelAggregateArgs>): Prisma.PrismaPromise<GetUserModelAggregateType<T>>

    /**
     * Group by UserModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserModelGroupByArgs['orderBy'] }
        : { orderBy?: UserModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserModelClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    customer<T extends CustomerModelArgs<ExtArgs> = {}>(args?: Subset<T, CustomerModelArgs<ExtArgs>>): Prisma__CustomerModelClient<$Types.GetResult<CustomerModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    business_user<T extends BusinessUserModelArgs<ExtArgs> = {}>(args?: Subset<T, BusinessUserModelArgs<ExtArgs>>): Prisma__BusinessUserModelClient<$Types.GetResult<BusinessUserModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    agreement_acceptances<T extends UserModel$agreement_acceptancesArgs<ExtArgs> = {}>(args?: Subset<T, UserModel$agreement_acceptancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AgreementAcceptanceModelPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserModel base type for findUnique actions
   */
  export type UserModelFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude<ExtArgs> | null
    /**
     * Filter, which UserModel to fetch.
     */
    where: UserModelWhereUniqueInput
  }

  /**
   * UserModel findUnique
   */
  export interface UserModelFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserModelFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserModel findUniqueOrThrow
   */
  export type UserModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude<ExtArgs> | null
    /**
     * Filter, which UserModel to fetch.
     */
    where: UserModelWhereUniqueInput
  }


  /**
   * UserModel base type for findFirst actions
   */
  export type UserModelFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude<ExtArgs> | null
    /**
     * Filter, which UserModel to fetch.
     */
    where?: UserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserModels to fetch.
     */
    orderBy?: Enumerable<UserModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserModels.
     */
    cursor?: UserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserModels.
     */
    distinct?: Enumerable<UserModelScalarFieldEnum>
  }

  /**
   * UserModel findFirst
   */
  export interface UserModelFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserModelFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserModel findFirstOrThrow
   */
  export type UserModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude<ExtArgs> | null
    /**
     * Filter, which UserModel to fetch.
     */
    where?: UserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserModels to fetch.
     */
    orderBy?: Enumerable<UserModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserModels.
     */
    cursor?: UserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserModels.
     */
    distinct?: Enumerable<UserModelScalarFieldEnum>
  }


  /**
   * UserModel findMany
   */
  export type UserModelFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude<ExtArgs> | null
    /**
     * Filter, which UserModels to fetch.
     */
    where?: UserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserModels to fetch.
     */
    orderBy?: Enumerable<UserModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserModels.
     */
    cursor?: UserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserModels.
     */
    skip?: number
    distinct?: Enumerable<UserModelScalarFieldEnum>
  }


  /**
   * UserModel create
   */
  export type UserModelCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude<ExtArgs> | null
    /**
     * The data needed to create a UserModel.
     */
    data: XOR<UserModelCreateInput, UserModelUncheckedCreateInput>
  }


  /**
   * UserModel createMany
   */
  export type UserModelCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserModels.
     */
    data: Enumerable<UserModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserModel update
   */
  export type UserModelUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude<ExtArgs> | null
    /**
     * The data needed to update a UserModel.
     */
    data: XOR<UserModelUpdateInput, UserModelUncheckedUpdateInput>
    /**
     * Choose, which UserModel to update.
     */
    where: UserModelWhereUniqueInput
  }


  /**
   * UserModel updateMany
   */
  export type UserModelUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserModels.
     */
    data: XOR<UserModelUpdateManyMutationInput, UserModelUncheckedUpdateManyInput>
    /**
     * Filter which UserModels to update
     */
    where?: UserModelWhereInput
  }


  /**
   * UserModel upsert
   */
  export type UserModelUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude<ExtArgs> | null
    /**
     * The filter to search for the UserModel to update in case it exists.
     */
    where: UserModelWhereUniqueInput
    /**
     * In case the UserModel found by the `where` argument doesn't exist, create a new UserModel with this data.
     */
    create: XOR<UserModelCreateInput, UserModelUncheckedCreateInput>
    /**
     * In case the UserModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserModelUpdateInput, UserModelUncheckedUpdateInput>
  }


  /**
   * UserModel delete
   */
  export type UserModelDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude<ExtArgs> | null
    /**
     * Filter which UserModel to delete.
     */
    where: UserModelWhereUniqueInput
  }


  /**
   * UserModel deleteMany
   */
  export type UserModelDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserModels to delete
     */
    where?: UserModelWhereInput
  }


  /**
   * UserModel.agreement_acceptances
   */
  export type UserModel$agreement_acceptancesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementAcceptanceModel
     */
    select?: AgreementAcceptanceModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementAcceptanceModelInclude<ExtArgs> | null
    where?: AgreementAcceptanceModelWhereInput
    orderBy?: Enumerable<AgreementAcceptanceModelOrderByWithRelationInput>
    cursor?: AgreementAcceptanceModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AgreementAcceptanceModelScalarFieldEnum>
  }


  /**
   * UserModel without action
   */
  export type UserModelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModel
     */
    select?: UserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserModelInclude<ExtArgs> | null
  }



  /**
   * Model CustomerModel
   */


  export type AggregateCustomerModel = {
    _count: CustomerModelCountAggregateOutputType | null
    _min: CustomerModelMinAggregateOutputType | null
    _max: CustomerModelMaxAggregateOutputType | null
  }

  export type CustomerModelMinAggregateOutputType = {
    id: string | null
    birth: string | null
    gender: GenderType | null
    phone: string | null
    address_first: string | null
    address_second: string | null
    profile_image_url: string | null
  }

  export type CustomerModelMaxAggregateOutputType = {
    id: string | null
    birth: string | null
    gender: GenderType | null
    phone: string | null
    address_first: string | null
    address_second: string | null
    profile_image_url: string | null
  }

  export type CustomerModelCountAggregateOutputType = {
    id: number
    birth: number
    gender: number
    phone: number
    address_first: number
    address_second: number
    profile_image_url: number
    _all: number
  }


  export type CustomerModelMinAggregateInputType = {
    id?: true
    birth?: true
    gender?: true
    phone?: true
    address_first?: true
    address_second?: true
    profile_image_url?: true
  }

  export type CustomerModelMaxAggregateInputType = {
    id?: true
    birth?: true
    gender?: true
    phone?: true
    address_first?: true
    address_second?: true
    profile_image_url?: true
  }

  export type CustomerModelCountAggregateInputType = {
    id?: true
    birth?: true
    gender?: true
    phone?: true
    address_first?: true
    address_second?: true
    profile_image_url?: true
    _all?: true
  }

  export type CustomerModelAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerModel to aggregate.
     */
    where?: CustomerModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerModels to fetch.
     */
    orderBy?: Enumerable<CustomerModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerModels
    **/
    _count?: true | CustomerModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerModelMaxAggregateInputType
  }

  export type GetCustomerModelAggregateType<T extends CustomerModelAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerModel[P]>
      : GetScalarType<T[P], AggregateCustomerModel[P]>
  }




  export type CustomerModelGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CustomerModelWhereInput
    orderBy?: Enumerable<CustomerModelOrderByWithAggregationInput>
    by: CustomerModelScalarFieldEnum[]
    having?: CustomerModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerModelCountAggregateInputType | true
    _min?: CustomerModelMinAggregateInputType
    _max?: CustomerModelMaxAggregateInputType
  }


  export type CustomerModelGroupByOutputType = {
    id: string
    birth: string | null
    gender: GenderType | null
    phone: string | null
    address_first: string | null
    address_second: string | null
    profile_image_url: string | null
    _count: CustomerModelCountAggregateOutputType | null
    _min: CustomerModelMinAggregateOutputType | null
    _max: CustomerModelMaxAggregateOutputType | null
  }

  type GetCustomerModelGroupByPayload<T extends CustomerModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CustomerModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerModelGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerModelGroupByOutputType[P]>
        }
      >
    >


  export type CustomerModelSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    birth?: boolean
    gender?: boolean
    phone?: boolean
    address_first?: boolean
    address_second?: boolean
    profile_image_url?: boolean
    base?: boolean | UserModelArgs<ExtArgs>
    oauth_accounts?: boolean | CustomerModel$oauth_accountsArgs<ExtArgs>
    zipzoong_care_requests?: boolean | CustomerModel$zipzoong_care_requestsArgs<ExtArgs>
    _count?: boolean | CustomerModelCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["customerModel"]>

  export type CustomerModelSelectScalar = {
    id?: boolean
    birth?: boolean
    gender?: boolean
    phone?: boolean
    address_first?: boolean
    address_second?: boolean
    profile_image_url?: boolean
  }

  export type CustomerModelInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    base?: boolean | UserModelArgs<ExtArgs>
    oauth_accounts?: boolean | CustomerModel$oauth_accountsArgs<ExtArgs>
    zipzoong_care_requests?: boolean | CustomerModel$zipzoong_care_requestsArgs<ExtArgs>
    _count?: boolean | CustomerModelCountOutputTypeArgs<ExtArgs>
  }


  type CustomerModelGetPayload<S extends boolean | null | undefined | CustomerModelArgs> = $Types.GetResult<CustomerModelPayload, S>

  type CustomerModelCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CustomerModelFindManyArgs, 'select' | 'include'> & {
      select?: CustomerModelCountAggregateInputType | true
    }

  export interface CustomerModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerModel'], meta: { name: 'CustomerModel' } }
    /**
     * Find zero or one CustomerModel that matches the filter.
     * @param {CustomerModelFindUniqueArgs} args - Arguments to find a CustomerModel
     * @example
     * // Get one CustomerModel
     * const customerModel = await prisma.customerModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerModelFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerModelFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CustomerModel'> extends True ? Prisma__CustomerModelClient<$Types.GetResult<CustomerModelPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__CustomerModelClient<$Types.GetResult<CustomerModelPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one CustomerModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CustomerModelFindUniqueOrThrowArgs} args - Arguments to find a CustomerModel
     * @example
     * // Get one CustomerModel
     * const customerModel = await prisma.customerModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CustomerModelClient<$Types.GetResult<CustomerModelPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first CustomerModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerModelFindFirstArgs} args - Arguments to find a CustomerModel
     * @example
     * // Get one CustomerModel
     * const customerModel = await prisma.customerModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerModelFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerModelFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CustomerModel'> extends True ? Prisma__CustomerModelClient<$Types.GetResult<CustomerModelPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__CustomerModelClient<$Types.GetResult<CustomerModelPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first CustomerModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerModelFindFirstOrThrowArgs} args - Arguments to find a CustomerModel
     * @example
     * // Get one CustomerModel
     * const customerModel = await prisma.customerModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CustomerModelClient<$Types.GetResult<CustomerModelPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more CustomerModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerModels
     * const customerModels = await prisma.customerModel.findMany()
     * 
     * // Get first 10 CustomerModels
     * const customerModels = await prisma.customerModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerModelWithIdOnly = await prisma.customerModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomerModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CustomerModelPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a CustomerModel.
     * @param {CustomerModelCreateArgs} args - Arguments to create a CustomerModel.
     * @example
     * // Create one CustomerModel
     * const CustomerModel = await prisma.customerModel.create({
     *   data: {
     *     // ... data to create a CustomerModel
     *   }
     * })
     * 
    **/
    create<T extends CustomerModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerModelCreateArgs<ExtArgs>>
    ): Prisma__CustomerModelClient<$Types.GetResult<CustomerModelPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many CustomerModels.
     *     @param {CustomerModelCreateManyArgs} args - Arguments to create many CustomerModels.
     *     @example
     *     // Create many CustomerModels
     *     const customerModel = await prisma.customerModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerModelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerModelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerModel.
     * @param {CustomerModelDeleteArgs} args - Arguments to delete one CustomerModel.
     * @example
     * // Delete one CustomerModel
     * const CustomerModel = await prisma.customerModel.delete({
     *   where: {
     *     // ... filter to delete one CustomerModel
     *   }
     * })
     * 
    **/
    delete<T extends CustomerModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerModelDeleteArgs<ExtArgs>>
    ): Prisma__CustomerModelClient<$Types.GetResult<CustomerModelPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one CustomerModel.
     * @param {CustomerModelUpdateArgs} args - Arguments to update one CustomerModel.
     * @example
     * // Update one CustomerModel
     * const customerModel = await prisma.customerModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerModelUpdateArgs<ExtArgs>>
    ): Prisma__CustomerModelClient<$Types.GetResult<CustomerModelPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more CustomerModels.
     * @param {CustomerModelDeleteManyArgs} args - Arguments to filter CustomerModels to delete.
     * @example
     * // Delete a few CustomerModels
     * const { count } = await prisma.customerModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerModels
     * const customerModel = await prisma.customerModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerModel.
     * @param {CustomerModelUpsertArgs} args - Arguments to update or create a CustomerModel.
     * @example
     * // Update or create a CustomerModel
     * const customerModel = await prisma.customerModel.upsert({
     *   create: {
     *     // ... data to create a CustomerModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerModel we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerModelUpsertArgs<ExtArgs>>
    ): Prisma__CustomerModelClient<$Types.GetResult<CustomerModelPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of CustomerModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerModelCountArgs} args - Arguments to filter CustomerModels to count.
     * @example
     * // Count the number of CustomerModels
     * const count = await prisma.customerModel.count({
     *   where: {
     *     // ... the filter for the CustomerModels we want to count
     *   }
     * })
    **/
    count<T extends CustomerModelCountArgs>(
      args?: Subset<T, CustomerModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerModelAggregateArgs>(args: Subset<T, CustomerModelAggregateArgs>): Prisma.PrismaPromise<GetCustomerModelAggregateType<T>>

    /**
     * Group by CustomerModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerModelGroupByArgs['orderBy'] }
        : { orderBy?: CustomerModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerModelClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    base<T extends UserModelArgs<ExtArgs> = {}>(args?: Subset<T, UserModelArgs<ExtArgs>>): Prisma__UserModelClient<$Types.GetResult<UserModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    oauth_accounts<T extends CustomerModel$oauth_accountsArgs<ExtArgs> = {}>(args?: Subset<T, CustomerModel$oauth_accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OauthAccountModelPayload<ExtArgs>, T, 'findMany', never>| Null>;

    zipzoong_care_requests<T extends CustomerModel$zipzoong_care_requestsArgs<ExtArgs> = {}>(args?: Subset<T, CustomerModel$zipzoong_care_requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ZipzoongCareRequestModelPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CustomerModel base type for findUnique actions
   */
  export type CustomerModelFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude<ExtArgs> | null
    /**
     * Filter, which CustomerModel to fetch.
     */
    where: CustomerModelWhereUniqueInput
  }

  /**
   * CustomerModel findUnique
   */
  export interface CustomerModelFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CustomerModelFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerModel findUniqueOrThrow
   */
  export type CustomerModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude<ExtArgs> | null
    /**
     * Filter, which CustomerModel to fetch.
     */
    where: CustomerModelWhereUniqueInput
  }


  /**
   * CustomerModel base type for findFirst actions
   */
  export type CustomerModelFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude<ExtArgs> | null
    /**
     * Filter, which CustomerModel to fetch.
     */
    where?: CustomerModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerModels to fetch.
     */
    orderBy?: Enumerable<CustomerModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerModels.
     */
    cursor?: CustomerModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerModels.
     */
    distinct?: Enumerable<CustomerModelScalarFieldEnum>
  }

  /**
   * CustomerModel findFirst
   */
  export interface CustomerModelFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CustomerModelFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CustomerModel findFirstOrThrow
   */
  export type CustomerModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude<ExtArgs> | null
    /**
     * Filter, which CustomerModel to fetch.
     */
    where?: CustomerModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerModels to fetch.
     */
    orderBy?: Enumerable<CustomerModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerModels.
     */
    cursor?: CustomerModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerModels.
     */
    distinct?: Enumerable<CustomerModelScalarFieldEnum>
  }


  /**
   * CustomerModel findMany
   */
  export type CustomerModelFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude<ExtArgs> | null
    /**
     * Filter, which CustomerModels to fetch.
     */
    where?: CustomerModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerModels to fetch.
     */
    orderBy?: Enumerable<CustomerModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerModels.
     */
    cursor?: CustomerModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerModels.
     */
    skip?: number
    distinct?: Enumerable<CustomerModelScalarFieldEnum>
  }


  /**
   * CustomerModel create
   */
  export type CustomerModelCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerModel.
     */
    data: XOR<CustomerModelCreateInput, CustomerModelUncheckedCreateInput>
  }


  /**
   * CustomerModel createMany
   */
  export type CustomerModelCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerModels.
     */
    data: Enumerable<CustomerModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CustomerModel update
   */
  export type CustomerModelUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerModel.
     */
    data: XOR<CustomerModelUpdateInput, CustomerModelUncheckedUpdateInput>
    /**
     * Choose, which CustomerModel to update.
     */
    where: CustomerModelWhereUniqueInput
  }


  /**
   * CustomerModel updateMany
   */
  export type CustomerModelUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerModels.
     */
    data: XOR<CustomerModelUpdateManyMutationInput, CustomerModelUncheckedUpdateManyInput>
    /**
     * Filter which CustomerModels to update
     */
    where?: CustomerModelWhereInput
  }


  /**
   * CustomerModel upsert
   */
  export type CustomerModelUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerModel to update in case it exists.
     */
    where: CustomerModelWhereUniqueInput
    /**
     * In case the CustomerModel found by the `where` argument doesn't exist, create a new CustomerModel with this data.
     */
    create: XOR<CustomerModelCreateInput, CustomerModelUncheckedCreateInput>
    /**
     * In case the CustomerModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerModelUpdateInput, CustomerModelUncheckedUpdateInput>
  }


  /**
   * CustomerModel delete
   */
  export type CustomerModelDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude<ExtArgs> | null
    /**
     * Filter which CustomerModel to delete.
     */
    where: CustomerModelWhereUniqueInput
  }


  /**
   * CustomerModel deleteMany
   */
  export type CustomerModelDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerModels to delete
     */
    where?: CustomerModelWhereInput
  }


  /**
   * CustomerModel.oauth_accounts
   */
  export type CustomerModel$oauth_accountsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OauthAccountModel
     */
    select?: OauthAccountModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OauthAccountModelInclude<ExtArgs> | null
    where?: OauthAccountModelWhereInput
    orderBy?: Enumerable<OauthAccountModelOrderByWithRelationInput>
    cursor?: OauthAccountModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OauthAccountModelScalarFieldEnum>
  }


  /**
   * CustomerModel.zipzoong_care_requests
   */
  export type CustomerModel$zipzoong_care_requestsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZipzoongCareRequestModel
     */
    select?: ZipzoongCareRequestModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ZipzoongCareRequestModelInclude<ExtArgs> | null
    where?: ZipzoongCareRequestModelWhereInput
    orderBy?: Enumerable<ZipzoongCareRequestModelOrderByWithRelationInput>
    cursor?: ZipzoongCareRequestModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ZipzoongCareRequestModelScalarFieldEnum>
  }


  /**
   * CustomerModel without action
   */
  export type CustomerModelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerModel
     */
    select?: CustomerModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerModelInclude<ExtArgs> | null
  }



  /**
   * Model BusinessUserModel
   */


  export type AggregateBusinessUserModel = {
    _count: BusinessUserModelCountAggregateOutputType | null
    _min: BusinessUserModelMinAggregateOutputType | null
    _max: BusinessUserModelMaxAggregateOutputType | null
  }

  export type BusinessUserModelMinAggregateOutputType = {
    id: string | null
    is_verified: boolean | null
    introduction_title: string | null
    introduction_content: string | null
    phone: string | null
    address_first: string | null
    address_second: string | null
    profile_image_url: string | null
  }

  export type BusinessUserModelMaxAggregateOutputType = {
    id: string | null
    is_verified: boolean | null
    introduction_title: string | null
    introduction_content: string | null
    phone: string | null
    address_first: string | null
    address_second: string | null
    profile_image_url: string | null
  }

  export type BusinessUserModelCountAggregateOutputType = {
    id: number
    is_verified: number
    introduction_title: number
    introduction_content: number
    phone: number
    address_first: number
    address_second: number
    profile_image_url: number
    _all: number
  }


  export type BusinessUserModelMinAggregateInputType = {
    id?: true
    is_verified?: true
    introduction_title?: true
    introduction_content?: true
    phone?: true
    address_first?: true
    address_second?: true
    profile_image_url?: true
  }

  export type BusinessUserModelMaxAggregateInputType = {
    id?: true
    is_verified?: true
    introduction_title?: true
    introduction_content?: true
    phone?: true
    address_first?: true
    address_second?: true
    profile_image_url?: true
  }

  export type BusinessUserModelCountAggregateInputType = {
    id?: true
    is_verified?: true
    introduction_title?: true
    introduction_content?: true
    phone?: true
    address_first?: true
    address_second?: true
    profile_image_url?: true
    _all?: true
  }

  export type BusinessUserModelAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessUserModel to aggregate.
     */
    where?: BusinessUserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUserModels to fetch.
     */
    orderBy?: Enumerable<BusinessUserModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessUserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUserModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessUserModels
    **/
    _count?: true | BusinessUserModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessUserModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessUserModelMaxAggregateInputType
  }

  export type GetBusinessUserModelAggregateType<T extends BusinessUserModelAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessUserModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessUserModel[P]>
      : GetScalarType<T[P], AggregateBusinessUserModel[P]>
  }




  export type BusinessUserModelGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BusinessUserModelWhereInput
    orderBy?: Enumerable<BusinessUserModelOrderByWithAggregationInput>
    by: BusinessUserModelScalarFieldEnum[]
    having?: BusinessUserModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessUserModelCountAggregateInputType | true
    _min?: BusinessUserModelMinAggregateInputType
    _max?: BusinessUserModelMaxAggregateInputType
  }


  export type BusinessUserModelGroupByOutputType = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second: string | null
    profile_image_url: string
    _count: BusinessUserModelCountAggregateOutputType | null
    _min: BusinessUserModelMinAggregateOutputType | null
    _max: BusinessUserModelMaxAggregateOutputType | null
  }

  type GetBusinessUserModelGroupByPayload<T extends BusinessUserModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BusinessUserModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessUserModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessUserModelGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessUserModelGroupByOutputType[P]>
        }
      >
    >


  export type BusinessUserModelSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    is_verified?: boolean
    introduction_title?: boolean
    introduction_content?: boolean
    phone?: boolean
    address_first?: boolean
    address_second?: boolean
    profile_image_url?: boolean
    base?: boolean | UserModelArgs<ExtArgs>
    re_agent?: boolean | REAgentModelArgs<ExtArgs>
    hs_provider?: boolean | HSProviderModelArgs<ExtArgs>
    certification_images?: boolean | BusinessUserModel$certification_imagesArgs<ExtArgs>
    sub_expertises?: boolean | BusinessUserModel$sub_expertisesArgs<ExtArgs>
    oauth_accounts?: boolean | BusinessUserModel$oauth_accountsArgs<ExtArgs>
    _count?: boolean | BusinessUserModelCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["businessUserModel"]>

  export type BusinessUserModelSelectScalar = {
    id?: boolean
    is_verified?: boolean
    introduction_title?: boolean
    introduction_content?: boolean
    phone?: boolean
    address_first?: boolean
    address_second?: boolean
    profile_image_url?: boolean
  }

  export type BusinessUserModelInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    base?: boolean | UserModelArgs<ExtArgs>
    re_agent?: boolean | REAgentModelArgs<ExtArgs>
    hs_provider?: boolean | HSProviderModelArgs<ExtArgs>
    certification_images?: boolean | BusinessUserModel$certification_imagesArgs<ExtArgs>
    sub_expertises?: boolean | BusinessUserModel$sub_expertisesArgs<ExtArgs>
    oauth_accounts?: boolean | BusinessUserModel$oauth_accountsArgs<ExtArgs>
    _count?: boolean | BusinessUserModelCountOutputTypeArgs<ExtArgs>
  }


  type BusinessUserModelGetPayload<S extends boolean | null | undefined | BusinessUserModelArgs> = $Types.GetResult<BusinessUserModelPayload, S>

  type BusinessUserModelCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BusinessUserModelFindManyArgs, 'select' | 'include'> & {
      select?: BusinessUserModelCountAggregateInputType | true
    }

  export interface BusinessUserModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessUserModel'], meta: { name: 'BusinessUserModel' } }
    /**
     * Find zero or one BusinessUserModel that matches the filter.
     * @param {BusinessUserModelFindUniqueArgs} args - Arguments to find a BusinessUserModel
     * @example
     * // Get one BusinessUserModel
     * const businessUserModel = await prisma.businessUserModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BusinessUserModelFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BusinessUserModelFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BusinessUserModel'> extends True ? Prisma__BusinessUserModelClient<$Types.GetResult<BusinessUserModelPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__BusinessUserModelClient<$Types.GetResult<BusinessUserModelPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one BusinessUserModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BusinessUserModelFindUniqueOrThrowArgs} args - Arguments to find a BusinessUserModel
     * @example
     * // Get one BusinessUserModel
     * const businessUserModel = await prisma.businessUserModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BusinessUserModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessUserModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BusinessUserModelClient<$Types.GetResult<BusinessUserModelPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first BusinessUserModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUserModelFindFirstArgs} args - Arguments to find a BusinessUserModel
     * @example
     * // Get one BusinessUserModel
     * const businessUserModel = await prisma.businessUserModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BusinessUserModelFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BusinessUserModelFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BusinessUserModel'> extends True ? Prisma__BusinessUserModelClient<$Types.GetResult<BusinessUserModelPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__BusinessUserModelClient<$Types.GetResult<BusinessUserModelPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first BusinessUserModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUserModelFindFirstOrThrowArgs} args - Arguments to find a BusinessUserModel
     * @example
     * // Get one BusinessUserModel
     * const businessUserModel = await prisma.businessUserModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BusinessUserModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessUserModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BusinessUserModelClient<$Types.GetResult<BusinessUserModelPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more BusinessUserModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUserModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessUserModels
     * const businessUserModels = await prisma.businessUserModel.findMany()
     * 
     * // Get first 10 BusinessUserModels
     * const businessUserModels = await prisma.businessUserModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessUserModelWithIdOnly = await prisma.businessUserModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BusinessUserModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessUserModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BusinessUserModelPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a BusinessUserModel.
     * @param {BusinessUserModelCreateArgs} args - Arguments to create a BusinessUserModel.
     * @example
     * // Create one BusinessUserModel
     * const BusinessUserModel = await prisma.businessUserModel.create({
     *   data: {
     *     // ... data to create a BusinessUserModel
     *   }
     * })
     * 
    **/
    create<T extends BusinessUserModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessUserModelCreateArgs<ExtArgs>>
    ): Prisma__BusinessUserModelClient<$Types.GetResult<BusinessUserModelPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many BusinessUserModels.
     *     @param {BusinessUserModelCreateManyArgs} args - Arguments to create many BusinessUserModels.
     *     @example
     *     // Create many BusinessUserModels
     *     const businessUserModel = await prisma.businessUserModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BusinessUserModelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessUserModelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BusinessUserModel.
     * @param {BusinessUserModelDeleteArgs} args - Arguments to delete one BusinessUserModel.
     * @example
     * // Delete one BusinessUserModel
     * const BusinessUserModel = await prisma.businessUserModel.delete({
     *   where: {
     *     // ... filter to delete one BusinessUserModel
     *   }
     * })
     * 
    **/
    delete<T extends BusinessUserModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessUserModelDeleteArgs<ExtArgs>>
    ): Prisma__BusinessUserModelClient<$Types.GetResult<BusinessUserModelPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one BusinessUserModel.
     * @param {BusinessUserModelUpdateArgs} args - Arguments to update one BusinessUserModel.
     * @example
     * // Update one BusinessUserModel
     * const businessUserModel = await prisma.businessUserModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BusinessUserModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessUserModelUpdateArgs<ExtArgs>>
    ): Prisma__BusinessUserModelClient<$Types.GetResult<BusinessUserModelPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more BusinessUserModels.
     * @param {BusinessUserModelDeleteManyArgs} args - Arguments to filter BusinessUserModels to delete.
     * @example
     * // Delete a few BusinessUserModels
     * const { count } = await prisma.businessUserModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BusinessUserModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessUserModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessUserModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUserModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessUserModels
     * const businessUserModel = await prisma.businessUserModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BusinessUserModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessUserModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessUserModel.
     * @param {BusinessUserModelUpsertArgs} args - Arguments to update or create a BusinessUserModel.
     * @example
     * // Update or create a BusinessUserModel
     * const businessUserModel = await prisma.businessUserModel.upsert({
     *   create: {
     *     // ... data to create a BusinessUserModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessUserModel we want to update
     *   }
     * })
    **/
    upsert<T extends BusinessUserModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessUserModelUpsertArgs<ExtArgs>>
    ): Prisma__BusinessUserModelClient<$Types.GetResult<BusinessUserModelPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of BusinessUserModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUserModelCountArgs} args - Arguments to filter BusinessUserModels to count.
     * @example
     * // Count the number of BusinessUserModels
     * const count = await prisma.businessUserModel.count({
     *   where: {
     *     // ... the filter for the BusinessUserModels we want to count
     *   }
     * })
    **/
    count<T extends BusinessUserModelCountArgs>(
      args?: Subset<T, BusinessUserModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessUserModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessUserModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUserModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessUserModelAggregateArgs>(args: Subset<T, BusinessUserModelAggregateArgs>): Prisma.PrismaPromise<GetBusinessUserModelAggregateType<T>>

    /**
     * Group by BusinessUserModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUserModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessUserModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessUserModelGroupByArgs['orderBy'] }
        : { orderBy?: BusinessUserModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessUserModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessUserModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessUserModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BusinessUserModelClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    base<T extends UserModelArgs<ExtArgs> = {}>(args?: Subset<T, UserModelArgs<ExtArgs>>): Prisma__UserModelClient<$Types.GetResult<UserModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    re_agent<T extends REAgentModelArgs<ExtArgs> = {}>(args?: Subset<T, REAgentModelArgs<ExtArgs>>): Prisma__REAgentModelClient<$Types.GetResult<REAgentModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    hs_provider<T extends HSProviderModelArgs<ExtArgs> = {}>(args?: Subset<T, HSProviderModelArgs<ExtArgs>>): Prisma__HSProviderModelClient<$Types.GetResult<HSProviderModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    certification_images<T extends BusinessUserModel$certification_imagesArgs<ExtArgs> = {}>(args?: Subset<T, BusinessUserModel$certification_imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<BusinessCertificationImageModelPayload<ExtArgs>, T, 'findMany', never>| Null>;

    sub_expertises<T extends BusinessUserModel$sub_expertisesArgs<ExtArgs> = {}>(args?: Subset<T, BusinessUserModel$sub_expertisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<SubExpertiseModelPayload<ExtArgs>, T, 'findMany', never>| Null>;

    oauth_accounts<T extends BusinessUserModel$oauth_accountsArgs<ExtArgs> = {}>(args?: Subset<T, BusinessUserModel$oauth_accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OauthAccountModelPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BusinessUserModel base type for findUnique actions
   */
  export type BusinessUserModelFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUserModel to fetch.
     */
    where: BusinessUserModelWhereUniqueInput
  }

  /**
   * BusinessUserModel findUnique
   */
  export interface BusinessUserModelFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BusinessUserModelFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusinessUserModel findUniqueOrThrow
   */
  export type BusinessUserModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUserModel to fetch.
     */
    where: BusinessUserModelWhereUniqueInput
  }


  /**
   * BusinessUserModel base type for findFirst actions
   */
  export type BusinessUserModelFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUserModel to fetch.
     */
    where?: BusinessUserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUserModels to fetch.
     */
    orderBy?: Enumerable<BusinessUserModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessUserModels.
     */
    cursor?: BusinessUserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUserModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessUserModels.
     */
    distinct?: Enumerable<BusinessUserModelScalarFieldEnum>
  }

  /**
   * BusinessUserModel findFirst
   */
  export interface BusinessUserModelFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BusinessUserModelFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusinessUserModel findFirstOrThrow
   */
  export type BusinessUserModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUserModel to fetch.
     */
    where?: BusinessUserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUserModels to fetch.
     */
    orderBy?: Enumerable<BusinessUserModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessUserModels.
     */
    cursor?: BusinessUserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUserModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessUserModels.
     */
    distinct?: Enumerable<BusinessUserModelScalarFieldEnum>
  }


  /**
   * BusinessUserModel findMany
   */
  export type BusinessUserModelFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUserModels to fetch.
     */
    where?: BusinessUserModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUserModels to fetch.
     */
    orderBy?: Enumerable<BusinessUserModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessUserModels.
     */
    cursor?: BusinessUserModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUserModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUserModels.
     */
    skip?: number
    distinct?: Enumerable<BusinessUserModelScalarFieldEnum>
  }


  /**
   * BusinessUserModel create
   */
  export type BusinessUserModelCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessUserModel.
     */
    data: XOR<BusinessUserModelCreateInput, BusinessUserModelUncheckedCreateInput>
  }


  /**
   * BusinessUserModel createMany
   */
  export type BusinessUserModelCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessUserModels.
     */
    data: Enumerable<BusinessUserModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BusinessUserModel update
   */
  export type BusinessUserModelUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessUserModel.
     */
    data: XOR<BusinessUserModelUpdateInput, BusinessUserModelUncheckedUpdateInput>
    /**
     * Choose, which BusinessUserModel to update.
     */
    where: BusinessUserModelWhereUniqueInput
  }


  /**
   * BusinessUserModel updateMany
   */
  export type BusinessUserModelUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessUserModels.
     */
    data: XOR<BusinessUserModelUpdateManyMutationInput, BusinessUserModelUncheckedUpdateManyInput>
    /**
     * Filter which BusinessUserModels to update
     */
    where?: BusinessUserModelWhereInput
  }


  /**
   * BusinessUserModel upsert
   */
  export type BusinessUserModelUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessUserModel to update in case it exists.
     */
    where: BusinessUserModelWhereUniqueInput
    /**
     * In case the BusinessUserModel found by the `where` argument doesn't exist, create a new BusinessUserModel with this data.
     */
    create: XOR<BusinessUserModelCreateInput, BusinessUserModelUncheckedCreateInput>
    /**
     * In case the BusinessUserModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessUserModelUpdateInput, BusinessUserModelUncheckedUpdateInput>
  }


  /**
   * BusinessUserModel delete
   */
  export type BusinessUserModelDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude<ExtArgs> | null
    /**
     * Filter which BusinessUserModel to delete.
     */
    where: BusinessUserModelWhereUniqueInput
  }


  /**
   * BusinessUserModel deleteMany
   */
  export type BusinessUserModelDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessUserModels to delete
     */
    where?: BusinessUserModelWhereInput
  }


  /**
   * BusinessUserModel.certification_images
   */
  export type BusinessUserModel$certification_imagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCertificationImageModel
     */
    select?: BusinessCertificationImageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessCertificationImageModelInclude<ExtArgs> | null
    where?: BusinessCertificationImageModelWhereInput
    orderBy?: Enumerable<BusinessCertificationImageModelOrderByWithRelationInput>
    cursor?: BusinessCertificationImageModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BusinessCertificationImageModelScalarFieldEnum>
  }


  /**
   * BusinessUserModel.sub_expertises
   */
  export type BusinessUserModel$sub_expertisesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubExpertiseModel
     */
    select?: SubExpertiseModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubExpertiseModelInclude<ExtArgs> | null
    where?: SubExpertiseModelWhereInput
    orderBy?: Enumerable<SubExpertiseModelOrderByWithRelationInput>
    cursor?: SubExpertiseModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SubExpertiseModelScalarFieldEnum>
  }


  /**
   * BusinessUserModel.oauth_accounts
   */
  export type BusinessUserModel$oauth_accountsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OauthAccountModel
     */
    select?: OauthAccountModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OauthAccountModelInclude<ExtArgs> | null
    where?: OauthAccountModelWhereInput
    orderBy?: Enumerable<OauthAccountModelOrderByWithRelationInput>
    cursor?: OauthAccountModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OauthAccountModelScalarFieldEnum>
  }


  /**
   * BusinessUserModel without action
   */
  export type BusinessUserModelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUserModel
     */
    select?: BusinessUserModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessUserModelInclude<ExtArgs> | null
  }



  /**
   * Model SubExpertiseModel
   */


  export type AggregateSubExpertiseModel = {
    _count: SubExpertiseModelCountAggregateOutputType | null
    _min: SubExpertiseModelMinAggregateOutputType | null
    _max: SubExpertiseModelMaxAggregateOutputType | null
  }

  export type SubExpertiseModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    sub_category_id: string | null
    business_user_id: string | null
  }

  export type SubExpertiseModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    sub_category_id: string | null
    business_user_id: string | null
  }

  export type SubExpertiseModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    sub_category_id: number
    business_user_id: number
    _all: number
  }


  export type SubExpertiseModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    sub_category_id?: true
    business_user_id?: true
  }

  export type SubExpertiseModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    sub_category_id?: true
    business_user_id?: true
  }

  export type SubExpertiseModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    sub_category_id?: true
    business_user_id?: true
    _all?: true
  }

  export type SubExpertiseModelAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubExpertiseModel to aggregate.
     */
    where?: SubExpertiseModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubExpertiseModels to fetch.
     */
    orderBy?: Enumerable<SubExpertiseModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubExpertiseModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubExpertiseModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubExpertiseModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubExpertiseModels
    **/
    _count?: true | SubExpertiseModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubExpertiseModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubExpertiseModelMaxAggregateInputType
  }

  export type GetSubExpertiseModelAggregateType<T extends SubExpertiseModelAggregateArgs> = {
        [P in keyof T & keyof AggregateSubExpertiseModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubExpertiseModel[P]>
      : GetScalarType<T[P], AggregateSubExpertiseModel[P]>
  }




  export type SubExpertiseModelGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SubExpertiseModelWhereInput
    orderBy?: Enumerable<SubExpertiseModelOrderByWithAggregationInput>
    by: SubExpertiseModelScalarFieldEnum[]
    having?: SubExpertiseModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubExpertiseModelCountAggregateInputType | true
    _min?: SubExpertiseModelMinAggregateInputType
    _max?: SubExpertiseModelMaxAggregateInputType
  }


  export type SubExpertiseModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    sub_category_id: string
    business_user_id: string
    _count: SubExpertiseModelCountAggregateOutputType | null
    _min: SubExpertiseModelMinAggregateOutputType | null
    _max: SubExpertiseModelMaxAggregateOutputType | null
  }

  type GetSubExpertiseModelGroupByPayload<T extends SubExpertiseModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SubExpertiseModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubExpertiseModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubExpertiseModelGroupByOutputType[P]>
            : GetScalarType<T[P], SubExpertiseModelGroupByOutputType[P]>
        }
      >
    >


  export type SubExpertiseModelSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    sub_category_id?: boolean
    business_user_id?: boolean
    sub_category?: boolean | ServiceSubCategoryModelArgs<ExtArgs>
    business_user?: boolean | BusinessUserModelArgs<ExtArgs>
  }, ExtArgs["result"]["subExpertiseModel"]>

  export type SubExpertiseModelSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    sub_category_id?: boolean
    business_user_id?: boolean
  }

  export type SubExpertiseModelInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    sub_category?: boolean | ServiceSubCategoryModelArgs<ExtArgs>
    business_user?: boolean | BusinessUserModelArgs<ExtArgs>
  }


  type SubExpertiseModelGetPayload<S extends boolean | null | undefined | SubExpertiseModelArgs> = $Types.GetResult<SubExpertiseModelPayload, S>

  type SubExpertiseModelCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SubExpertiseModelFindManyArgs, 'select' | 'include'> & {
      select?: SubExpertiseModelCountAggregateInputType | true
    }

  export interface SubExpertiseModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubExpertiseModel'], meta: { name: 'SubExpertiseModel' } }
    /**
     * Find zero or one SubExpertiseModel that matches the filter.
     * @param {SubExpertiseModelFindUniqueArgs} args - Arguments to find a SubExpertiseModel
     * @example
     * // Get one SubExpertiseModel
     * const subExpertiseModel = await prisma.subExpertiseModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubExpertiseModelFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubExpertiseModelFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SubExpertiseModel'> extends True ? Prisma__SubExpertiseModelClient<$Types.GetResult<SubExpertiseModelPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__SubExpertiseModelClient<$Types.GetResult<SubExpertiseModelPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one SubExpertiseModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SubExpertiseModelFindUniqueOrThrowArgs} args - Arguments to find a SubExpertiseModel
     * @example
     * // Get one SubExpertiseModel
     * const subExpertiseModel = await prisma.subExpertiseModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubExpertiseModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SubExpertiseModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SubExpertiseModelClient<$Types.GetResult<SubExpertiseModelPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first SubExpertiseModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubExpertiseModelFindFirstArgs} args - Arguments to find a SubExpertiseModel
     * @example
     * // Get one SubExpertiseModel
     * const subExpertiseModel = await prisma.subExpertiseModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubExpertiseModelFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubExpertiseModelFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SubExpertiseModel'> extends True ? Prisma__SubExpertiseModelClient<$Types.GetResult<SubExpertiseModelPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__SubExpertiseModelClient<$Types.GetResult<SubExpertiseModelPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first SubExpertiseModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubExpertiseModelFindFirstOrThrowArgs} args - Arguments to find a SubExpertiseModel
     * @example
     * // Get one SubExpertiseModel
     * const subExpertiseModel = await prisma.subExpertiseModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubExpertiseModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SubExpertiseModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SubExpertiseModelClient<$Types.GetResult<SubExpertiseModelPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more SubExpertiseModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubExpertiseModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubExpertiseModels
     * const subExpertiseModels = await prisma.subExpertiseModel.findMany()
     * 
     * // Get first 10 SubExpertiseModels
     * const subExpertiseModels = await prisma.subExpertiseModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subExpertiseModelWithIdOnly = await prisma.subExpertiseModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubExpertiseModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubExpertiseModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<SubExpertiseModelPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a SubExpertiseModel.
     * @param {SubExpertiseModelCreateArgs} args - Arguments to create a SubExpertiseModel.
     * @example
     * // Create one SubExpertiseModel
     * const SubExpertiseModel = await prisma.subExpertiseModel.create({
     *   data: {
     *     // ... data to create a SubExpertiseModel
     *   }
     * })
     * 
    **/
    create<T extends SubExpertiseModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SubExpertiseModelCreateArgs<ExtArgs>>
    ): Prisma__SubExpertiseModelClient<$Types.GetResult<SubExpertiseModelPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many SubExpertiseModels.
     *     @param {SubExpertiseModelCreateManyArgs} args - Arguments to create many SubExpertiseModels.
     *     @example
     *     // Create many SubExpertiseModels
     *     const subExpertiseModel = await prisma.subExpertiseModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubExpertiseModelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubExpertiseModelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SubExpertiseModel.
     * @param {SubExpertiseModelDeleteArgs} args - Arguments to delete one SubExpertiseModel.
     * @example
     * // Delete one SubExpertiseModel
     * const SubExpertiseModel = await prisma.subExpertiseModel.delete({
     *   where: {
     *     // ... filter to delete one SubExpertiseModel
     *   }
     * })
     * 
    **/
    delete<T extends SubExpertiseModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SubExpertiseModelDeleteArgs<ExtArgs>>
    ): Prisma__SubExpertiseModelClient<$Types.GetResult<SubExpertiseModelPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one SubExpertiseModel.
     * @param {SubExpertiseModelUpdateArgs} args - Arguments to update one SubExpertiseModel.
     * @example
     * // Update one SubExpertiseModel
     * const subExpertiseModel = await prisma.subExpertiseModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubExpertiseModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SubExpertiseModelUpdateArgs<ExtArgs>>
    ): Prisma__SubExpertiseModelClient<$Types.GetResult<SubExpertiseModelPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more SubExpertiseModels.
     * @param {SubExpertiseModelDeleteManyArgs} args - Arguments to filter SubExpertiseModels to delete.
     * @example
     * // Delete a few SubExpertiseModels
     * const { count } = await prisma.subExpertiseModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubExpertiseModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubExpertiseModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubExpertiseModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubExpertiseModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubExpertiseModels
     * const subExpertiseModel = await prisma.subExpertiseModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubExpertiseModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SubExpertiseModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubExpertiseModel.
     * @param {SubExpertiseModelUpsertArgs} args - Arguments to update or create a SubExpertiseModel.
     * @example
     * // Update or create a SubExpertiseModel
     * const subExpertiseModel = await prisma.subExpertiseModel.upsert({
     *   create: {
     *     // ... data to create a SubExpertiseModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubExpertiseModel we want to update
     *   }
     * })
    **/
    upsert<T extends SubExpertiseModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SubExpertiseModelUpsertArgs<ExtArgs>>
    ): Prisma__SubExpertiseModelClient<$Types.GetResult<SubExpertiseModelPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of SubExpertiseModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubExpertiseModelCountArgs} args - Arguments to filter SubExpertiseModels to count.
     * @example
     * // Count the number of SubExpertiseModels
     * const count = await prisma.subExpertiseModel.count({
     *   where: {
     *     // ... the filter for the SubExpertiseModels we want to count
     *   }
     * })
    **/
    count<T extends SubExpertiseModelCountArgs>(
      args?: Subset<T, SubExpertiseModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubExpertiseModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubExpertiseModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubExpertiseModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubExpertiseModelAggregateArgs>(args: Subset<T, SubExpertiseModelAggregateArgs>): Prisma.PrismaPromise<GetSubExpertiseModelAggregateType<T>>

    /**
     * Group by SubExpertiseModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubExpertiseModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubExpertiseModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubExpertiseModelGroupByArgs['orderBy'] }
        : { orderBy?: SubExpertiseModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubExpertiseModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubExpertiseModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SubExpertiseModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubExpertiseModelClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    sub_category<T extends ServiceSubCategoryModelArgs<ExtArgs> = {}>(args?: Subset<T, ServiceSubCategoryModelArgs<ExtArgs>>): Prisma__ServiceSubCategoryModelClient<$Types.GetResult<ServiceSubCategoryModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    business_user<T extends BusinessUserModelArgs<ExtArgs> = {}>(args?: Subset<T, BusinessUserModelArgs<ExtArgs>>): Prisma__BusinessUserModelClient<$Types.GetResult<BusinessUserModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SubExpertiseModel base type for findUnique actions
   */
  export type SubExpertiseModelFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubExpertiseModel
     */
    select?: SubExpertiseModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubExpertiseModelInclude<ExtArgs> | null
    /**
     * Filter, which SubExpertiseModel to fetch.
     */
    where: SubExpertiseModelWhereUniqueInput
  }

  /**
   * SubExpertiseModel findUnique
   */
  export interface SubExpertiseModelFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SubExpertiseModelFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SubExpertiseModel findUniqueOrThrow
   */
  export type SubExpertiseModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubExpertiseModel
     */
    select?: SubExpertiseModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubExpertiseModelInclude<ExtArgs> | null
    /**
     * Filter, which SubExpertiseModel to fetch.
     */
    where: SubExpertiseModelWhereUniqueInput
  }


  /**
   * SubExpertiseModel base type for findFirst actions
   */
  export type SubExpertiseModelFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubExpertiseModel
     */
    select?: SubExpertiseModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubExpertiseModelInclude<ExtArgs> | null
    /**
     * Filter, which SubExpertiseModel to fetch.
     */
    where?: SubExpertiseModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubExpertiseModels to fetch.
     */
    orderBy?: Enumerable<SubExpertiseModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubExpertiseModels.
     */
    cursor?: SubExpertiseModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubExpertiseModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubExpertiseModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubExpertiseModels.
     */
    distinct?: Enumerable<SubExpertiseModelScalarFieldEnum>
  }

  /**
   * SubExpertiseModel findFirst
   */
  export interface SubExpertiseModelFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SubExpertiseModelFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SubExpertiseModel findFirstOrThrow
   */
  export type SubExpertiseModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubExpertiseModel
     */
    select?: SubExpertiseModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubExpertiseModelInclude<ExtArgs> | null
    /**
     * Filter, which SubExpertiseModel to fetch.
     */
    where?: SubExpertiseModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubExpertiseModels to fetch.
     */
    orderBy?: Enumerable<SubExpertiseModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubExpertiseModels.
     */
    cursor?: SubExpertiseModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubExpertiseModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubExpertiseModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubExpertiseModels.
     */
    distinct?: Enumerable<SubExpertiseModelScalarFieldEnum>
  }


  /**
   * SubExpertiseModel findMany
   */
  export type SubExpertiseModelFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubExpertiseModel
     */
    select?: SubExpertiseModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubExpertiseModelInclude<ExtArgs> | null
    /**
     * Filter, which SubExpertiseModels to fetch.
     */
    where?: SubExpertiseModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubExpertiseModels to fetch.
     */
    orderBy?: Enumerable<SubExpertiseModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubExpertiseModels.
     */
    cursor?: SubExpertiseModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubExpertiseModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubExpertiseModels.
     */
    skip?: number
    distinct?: Enumerable<SubExpertiseModelScalarFieldEnum>
  }


  /**
   * SubExpertiseModel create
   */
  export type SubExpertiseModelCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubExpertiseModel
     */
    select?: SubExpertiseModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubExpertiseModelInclude<ExtArgs> | null
    /**
     * The data needed to create a SubExpertiseModel.
     */
    data: XOR<SubExpertiseModelCreateInput, SubExpertiseModelUncheckedCreateInput>
  }


  /**
   * SubExpertiseModel createMany
   */
  export type SubExpertiseModelCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubExpertiseModels.
     */
    data: Enumerable<SubExpertiseModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SubExpertiseModel update
   */
  export type SubExpertiseModelUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubExpertiseModel
     */
    select?: SubExpertiseModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubExpertiseModelInclude<ExtArgs> | null
    /**
     * The data needed to update a SubExpertiseModel.
     */
    data: XOR<SubExpertiseModelUpdateInput, SubExpertiseModelUncheckedUpdateInput>
    /**
     * Choose, which SubExpertiseModel to update.
     */
    where: SubExpertiseModelWhereUniqueInput
  }


  /**
   * SubExpertiseModel updateMany
   */
  export type SubExpertiseModelUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubExpertiseModels.
     */
    data: XOR<SubExpertiseModelUpdateManyMutationInput, SubExpertiseModelUncheckedUpdateManyInput>
    /**
     * Filter which SubExpertiseModels to update
     */
    where?: SubExpertiseModelWhereInput
  }


  /**
   * SubExpertiseModel upsert
   */
  export type SubExpertiseModelUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubExpertiseModel
     */
    select?: SubExpertiseModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubExpertiseModelInclude<ExtArgs> | null
    /**
     * The filter to search for the SubExpertiseModel to update in case it exists.
     */
    where: SubExpertiseModelWhereUniqueInput
    /**
     * In case the SubExpertiseModel found by the `where` argument doesn't exist, create a new SubExpertiseModel with this data.
     */
    create: XOR<SubExpertiseModelCreateInput, SubExpertiseModelUncheckedCreateInput>
    /**
     * In case the SubExpertiseModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubExpertiseModelUpdateInput, SubExpertiseModelUncheckedUpdateInput>
  }


  /**
   * SubExpertiseModel delete
   */
  export type SubExpertiseModelDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubExpertiseModel
     */
    select?: SubExpertiseModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubExpertiseModelInclude<ExtArgs> | null
    /**
     * Filter which SubExpertiseModel to delete.
     */
    where: SubExpertiseModelWhereUniqueInput
  }


  /**
   * SubExpertiseModel deleteMany
   */
  export type SubExpertiseModelDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubExpertiseModels to delete
     */
    where?: SubExpertiseModelWhereInput
  }


  /**
   * SubExpertiseModel without action
   */
  export type SubExpertiseModelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubExpertiseModel
     */
    select?: SubExpertiseModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubExpertiseModelInclude<ExtArgs> | null
  }



  /**
   * Model REAgentModel
   */


  export type AggregateREAgentModel = {
    _count: REAgentModelCountAggregateOutputType | null
    _min: REAgentModelMinAggregateOutputType | null
    _max: REAgentModelMaxAggregateOutputType | null
  }

  export type REAgentModelMinAggregateOutputType = {
    id: string | null
    is_licensed: boolean | null
    re_num: string | null
    re_name: string | null
    re_phone: string | null
    re_licensed_agent_name: string | null
  }

  export type REAgentModelMaxAggregateOutputType = {
    id: string | null
    is_licensed: boolean | null
    re_num: string | null
    re_name: string | null
    re_phone: string | null
    re_licensed_agent_name: string | null
  }

  export type REAgentModelCountAggregateOutputType = {
    id: number
    is_licensed: number
    re_num: number
    re_name: number
    re_phone: number
    re_licensed_agent_name: number
    _all: number
  }


  export type REAgentModelMinAggregateInputType = {
    id?: true
    is_licensed?: true
    re_num?: true
    re_name?: true
    re_phone?: true
    re_licensed_agent_name?: true
  }

  export type REAgentModelMaxAggregateInputType = {
    id?: true
    is_licensed?: true
    re_num?: true
    re_name?: true
    re_phone?: true
    re_licensed_agent_name?: true
  }

  export type REAgentModelCountAggregateInputType = {
    id?: true
    is_licensed?: true
    re_num?: true
    re_name?: true
    re_phone?: true
    re_licensed_agent_name?: true
    _all?: true
  }

  export type REAgentModelAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which REAgentModel to aggregate.
     */
    where?: REAgentModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REAgentModels to fetch.
     */
    orderBy?: Enumerable<REAgentModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: REAgentModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REAgentModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REAgentModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned REAgentModels
    **/
    _count?: true | REAgentModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: REAgentModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: REAgentModelMaxAggregateInputType
  }

  export type GetREAgentModelAggregateType<T extends REAgentModelAggregateArgs> = {
        [P in keyof T & keyof AggregateREAgentModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateREAgentModel[P]>
      : GetScalarType<T[P], AggregateREAgentModel[P]>
  }




  export type REAgentModelGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: REAgentModelWhereInput
    orderBy?: Enumerable<REAgentModelOrderByWithAggregationInput>
    by: REAgentModelScalarFieldEnum[]
    having?: REAgentModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: REAgentModelCountAggregateInputType | true
    _min?: REAgentModelMinAggregateInputType
    _max?: REAgentModelMaxAggregateInputType
  }


  export type REAgentModelGroupByOutputType = {
    id: string
    is_licensed: boolean
    re_num: string
    re_name: string
    re_phone: string
    re_licensed_agent_name: string
    _count: REAgentModelCountAggregateOutputType | null
    _min: REAgentModelMinAggregateOutputType | null
    _max: REAgentModelMaxAggregateOutputType | null
  }

  type GetREAgentModelGroupByPayload<T extends REAgentModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<REAgentModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof REAgentModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], REAgentModelGroupByOutputType[P]>
            : GetScalarType<T[P], REAgentModelGroupByOutputType[P]>
        }
      >
    >


  export type REAgentModelSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    is_licensed?: boolean
    re_num?: boolean
    re_name?: boolean
    re_phone?: boolean
    re_licensed_agent_name?: boolean
    base?: boolean | BusinessUserModelArgs<ExtArgs>
    properties?: boolean | REAgentModel$propertiesArgs<ExtArgs>
    _count?: boolean | REAgentModelCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["rEAgentModel"]>

  export type REAgentModelSelectScalar = {
    id?: boolean
    is_licensed?: boolean
    re_num?: boolean
    re_name?: boolean
    re_phone?: boolean
    re_licensed_agent_name?: boolean
  }

  export type REAgentModelInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    base?: boolean | BusinessUserModelArgs<ExtArgs>
    properties?: boolean | REAgentModel$propertiesArgs<ExtArgs>
    _count?: boolean | REAgentModelCountOutputTypeArgs<ExtArgs>
  }


  type REAgentModelGetPayload<S extends boolean | null | undefined | REAgentModelArgs> = $Types.GetResult<REAgentModelPayload, S>

  type REAgentModelCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<REAgentModelFindManyArgs, 'select' | 'include'> & {
      select?: REAgentModelCountAggregateInputType | true
    }

  export interface REAgentModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['REAgentModel'], meta: { name: 'REAgentModel' } }
    /**
     * Find zero or one REAgentModel that matches the filter.
     * @param {REAgentModelFindUniqueArgs} args - Arguments to find a REAgentModel
     * @example
     * // Get one REAgentModel
     * const rEAgentModel = await prisma.rEAgentModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends REAgentModelFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, REAgentModelFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'REAgentModel'> extends True ? Prisma__REAgentModelClient<$Types.GetResult<REAgentModelPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__REAgentModelClient<$Types.GetResult<REAgentModelPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one REAgentModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {REAgentModelFindUniqueOrThrowArgs} args - Arguments to find a REAgentModel
     * @example
     * // Get one REAgentModel
     * const rEAgentModel = await prisma.rEAgentModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends REAgentModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, REAgentModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__REAgentModelClient<$Types.GetResult<REAgentModelPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first REAgentModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REAgentModelFindFirstArgs} args - Arguments to find a REAgentModel
     * @example
     * // Get one REAgentModel
     * const rEAgentModel = await prisma.rEAgentModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends REAgentModelFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, REAgentModelFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'REAgentModel'> extends True ? Prisma__REAgentModelClient<$Types.GetResult<REAgentModelPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__REAgentModelClient<$Types.GetResult<REAgentModelPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first REAgentModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REAgentModelFindFirstOrThrowArgs} args - Arguments to find a REAgentModel
     * @example
     * // Get one REAgentModel
     * const rEAgentModel = await prisma.rEAgentModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends REAgentModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, REAgentModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__REAgentModelClient<$Types.GetResult<REAgentModelPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more REAgentModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REAgentModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all REAgentModels
     * const rEAgentModels = await prisma.rEAgentModel.findMany()
     * 
     * // Get first 10 REAgentModels
     * const rEAgentModels = await prisma.rEAgentModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rEAgentModelWithIdOnly = await prisma.rEAgentModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends REAgentModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, REAgentModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<REAgentModelPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a REAgentModel.
     * @param {REAgentModelCreateArgs} args - Arguments to create a REAgentModel.
     * @example
     * // Create one REAgentModel
     * const REAgentModel = await prisma.rEAgentModel.create({
     *   data: {
     *     // ... data to create a REAgentModel
     *   }
     * })
     * 
    **/
    create<T extends REAgentModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, REAgentModelCreateArgs<ExtArgs>>
    ): Prisma__REAgentModelClient<$Types.GetResult<REAgentModelPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many REAgentModels.
     *     @param {REAgentModelCreateManyArgs} args - Arguments to create many REAgentModels.
     *     @example
     *     // Create many REAgentModels
     *     const rEAgentModel = await prisma.rEAgentModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends REAgentModelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, REAgentModelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a REAgentModel.
     * @param {REAgentModelDeleteArgs} args - Arguments to delete one REAgentModel.
     * @example
     * // Delete one REAgentModel
     * const REAgentModel = await prisma.rEAgentModel.delete({
     *   where: {
     *     // ... filter to delete one REAgentModel
     *   }
     * })
     * 
    **/
    delete<T extends REAgentModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, REAgentModelDeleteArgs<ExtArgs>>
    ): Prisma__REAgentModelClient<$Types.GetResult<REAgentModelPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one REAgentModel.
     * @param {REAgentModelUpdateArgs} args - Arguments to update one REAgentModel.
     * @example
     * // Update one REAgentModel
     * const rEAgentModel = await prisma.rEAgentModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends REAgentModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, REAgentModelUpdateArgs<ExtArgs>>
    ): Prisma__REAgentModelClient<$Types.GetResult<REAgentModelPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more REAgentModels.
     * @param {REAgentModelDeleteManyArgs} args - Arguments to filter REAgentModels to delete.
     * @example
     * // Delete a few REAgentModels
     * const { count } = await prisma.rEAgentModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends REAgentModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, REAgentModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more REAgentModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REAgentModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many REAgentModels
     * const rEAgentModel = await prisma.rEAgentModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends REAgentModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, REAgentModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one REAgentModel.
     * @param {REAgentModelUpsertArgs} args - Arguments to update or create a REAgentModel.
     * @example
     * // Update or create a REAgentModel
     * const rEAgentModel = await prisma.rEAgentModel.upsert({
     *   create: {
     *     // ... data to create a REAgentModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the REAgentModel we want to update
     *   }
     * })
    **/
    upsert<T extends REAgentModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, REAgentModelUpsertArgs<ExtArgs>>
    ): Prisma__REAgentModelClient<$Types.GetResult<REAgentModelPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of REAgentModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REAgentModelCountArgs} args - Arguments to filter REAgentModels to count.
     * @example
     * // Count the number of REAgentModels
     * const count = await prisma.rEAgentModel.count({
     *   where: {
     *     // ... the filter for the REAgentModels we want to count
     *   }
     * })
    **/
    count<T extends REAgentModelCountArgs>(
      args?: Subset<T, REAgentModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], REAgentModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a REAgentModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REAgentModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends REAgentModelAggregateArgs>(args: Subset<T, REAgentModelAggregateArgs>): Prisma.PrismaPromise<GetREAgentModelAggregateType<T>>

    /**
     * Group by REAgentModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REAgentModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends REAgentModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: REAgentModelGroupByArgs['orderBy'] }
        : { orderBy?: REAgentModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, REAgentModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetREAgentModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for REAgentModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__REAgentModelClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    base<T extends BusinessUserModelArgs<ExtArgs> = {}>(args?: Subset<T, BusinessUserModelArgs<ExtArgs>>): Prisma__BusinessUserModelClient<$Types.GetResult<BusinessUserModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    properties<T extends REAgentModel$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, REAgentModel$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<REPropertyModelPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * REAgentModel base type for findUnique actions
   */
  export type REAgentModelFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REAgentModel
     */
    select?: REAgentModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REAgentModelInclude<ExtArgs> | null
    /**
     * Filter, which REAgentModel to fetch.
     */
    where: REAgentModelWhereUniqueInput
  }

  /**
   * REAgentModel findUnique
   */
  export interface REAgentModelFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends REAgentModelFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * REAgentModel findUniqueOrThrow
   */
  export type REAgentModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REAgentModel
     */
    select?: REAgentModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REAgentModelInclude<ExtArgs> | null
    /**
     * Filter, which REAgentModel to fetch.
     */
    where: REAgentModelWhereUniqueInput
  }


  /**
   * REAgentModel base type for findFirst actions
   */
  export type REAgentModelFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REAgentModel
     */
    select?: REAgentModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REAgentModelInclude<ExtArgs> | null
    /**
     * Filter, which REAgentModel to fetch.
     */
    where?: REAgentModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REAgentModels to fetch.
     */
    orderBy?: Enumerable<REAgentModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REAgentModels.
     */
    cursor?: REAgentModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REAgentModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REAgentModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REAgentModels.
     */
    distinct?: Enumerable<REAgentModelScalarFieldEnum>
  }

  /**
   * REAgentModel findFirst
   */
  export interface REAgentModelFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends REAgentModelFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * REAgentModel findFirstOrThrow
   */
  export type REAgentModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REAgentModel
     */
    select?: REAgentModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REAgentModelInclude<ExtArgs> | null
    /**
     * Filter, which REAgentModel to fetch.
     */
    where?: REAgentModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REAgentModels to fetch.
     */
    orderBy?: Enumerable<REAgentModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REAgentModels.
     */
    cursor?: REAgentModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REAgentModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REAgentModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REAgentModels.
     */
    distinct?: Enumerable<REAgentModelScalarFieldEnum>
  }


  /**
   * REAgentModel findMany
   */
  export type REAgentModelFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REAgentModel
     */
    select?: REAgentModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REAgentModelInclude<ExtArgs> | null
    /**
     * Filter, which REAgentModels to fetch.
     */
    where?: REAgentModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REAgentModels to fetch.
     */
    orderBy?: Enumerable<REAgentModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing REAgentModels.
     */
    cursor?: REAgentModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REAgentModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REAgentModels.
     */
    skip?: number
    distinct?: Enumerable<REAgentModelScalarFieldEnum>
  }


  /**
   * REAgentModel create
   */
  export type REAgentModelCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REAgentModel
     */
    select?: REAgentModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REAgentModelInclude<ExtArgs> | null
    /**
     * The data needed to create a REAgentModel.
     */
    data: XOR<REAgentModelCreateInput, REAgentModelUncheckedCreateInput>
  }


  /**
   * REAgentModel createMany
   */
  export type REAgentModelCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many REAgentModels.
     */
    data: Enumerable<REAgentModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * REAgentModel update
   */
  export type REAgentModelUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REAgentModel
     */
    select?: REAgentModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REAgentModelInclude<ExtArgs> | null
    /**
     * The data needed to update a REAgentModel.
     */
    data: XOR<REAgentModelUpdateInput, REAgentModelUncheckedUpdateInput>
    /**
     * Choose, which REAgentModel to update.
     */
    where: REAgentModelWhereUniqueInput
  }


  /**
   * REAgentModel updateMany
   */
  export type REAgentModelUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update REAgentModels.
     */
    data: XOR<REAgentModelUpdateManyMutationInput, REAgentModelUncheckedUpdateManyInput>
    /**
     * Filter which REAgentModels to update
     */
    where?: REAgentModelWhereInput
  }


  /**
   * REAgentModel upsert
   */
  export type REAgentModelUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REAgentModel
     */
    select?: REAgentModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REAgentModelInclude<ExtArgs> | null
    /**
     * The filter to search for the REAgentModel to update in case it exists.
     */
    where: REAgentModelWhereUniqueInput
    /**
     * In case the REAgentModel found by the `where` argument doesn't exist, create a new REAgentModel with this data.
     */
    create: XOR<REAgentModelCreateInput, REAgentModelUncheckedCreateInput>
    /**
     * In case the REAgentModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<REAgentModelUpdateInput, REAgentModelUncheckedUpdateInput>
  }


  /**
   * REAgentModel delete
   */
  export type REAgentModelDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REAgentModel
     */
    select?: REAgentModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REAgentModelInclude<ExtArgs> | null
    /**
     * Filter which REAgentModel to delete.
     */
    where: REAgentModelWhereUniqueInput
  }


  /**
   * REAgentModel deleteMany
   */
  export type REAgentModelDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which REAgentModels to delete
     */
    where?: REAgentModelWhereInput
  }


  /**
   * REAgentModel.properties
   */
  export type REAgentModel$propertiesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REPropertyModel
     */
    select?: REPropertyModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REPropertyModelInclude<ExtArgs> | null
    where?: REPropertyModelWhereInput
    orderBy?: Enumerable<REPropertyModelOrderByWithRelationInput>
    cursor?: REPropertyModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<REPropertyModelScalarFieldEnum>
  }


  /**
   * REAgentModel without action
   */
  export type REAgentModelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the REAgentModel
     */
    select?: REAgentModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: REAgentModelInclude<ExtArgs> | null
  }



  /**
   * Model HSProviderModel
   */


  export type AggregateHSProviderModel = {
    _count: HSProviderModelCountAggregateOutputType | null
    _min: HSProviderModelMinAggregateOutputType | null
    _max: HSProviderModelMaxAggregateOutputType | null
  }

  export type HSProviderModelMinAggregateOutputType = {
    id: string | null
    business_registration_num: string | null
  }

  export type HSProviderModelMaxAggregateOutputType = {
    id: string | null
    business_registration_num: string | null
  }

  export type HSProviderModelCountAggregateOutputType = {
    id: number
    business_registration_num: number
    _all: number
  }


  export type HSProviderModelMinAggregateInputType = {
    id?: true
    business_registration_num?: true
  }

  export type HSProviderModelMaxAggregateInputType = {
    id?: true
    business_registration_num?: true
  }

  export type HSProviderModelCountAggregateInputType = {
    id?: true
    business_registration_num?: true
    _all?: true
  }

  export type HSProviderModelAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which HSProviderModel to aggregate.
     */
    where?: HSProviderModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HSProviderModels to fetch.
     */
    orderBy?: Enumerable<HSProviderModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HSProviderModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HSProviderModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HSProviderModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HSProviderModels
    **/
    _count?: true | HSProviderModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HSProviderModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HSProviderModelMaxAggregateInputType
  }

  export type GetHSProviderModelAggregateType<T extends HSProviderModelAggregateArgs> = {
        [P in keyof T & keyof AggregateHSProviderModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHSProviderModel[P]>
      : GetScalarType<T[P], AggregateHSProviderModel[P]>
  }




  export type HSProviderModelGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: HSProviderModelWhereInput
    orderBy?: Enumerable<HSProviderModelOrderByWithAggregationInput>
    by: HSProviderModelScalarFieldEnum[]
    having?: HSProviderModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HSProviderModelCountAggregateInputType | true
    _min?: HSProviderModelMinAggregateInputType
    _max?: HSProviderModelMaxAggregateInputType
  }


  export type HSProviderModelGroupByOutputType = {
    id: string
    business_registration_num: string
    _count: HSProviderModelCountAggregateOutputType | null
    _min: HSProviderModelMinAggregateOutputType | null
    _max: HSProviderModelMaxAggregateOutputType | null
  }

  type GetHSProviderModelGroupByPayload<T extends HSProviderModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HSProviderModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HSProviderModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HSProviderModelGroupByOutputType[P]>
            : GetScalarType<T[P], HSProviderModelGroupByOutputType[P]>
        }
      >
    >


  export type HSProviderModelSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    business_registration_num?: boolean
    base?: boolean | BusinessUserModelArgs<ExtArgs>
    example_images?: boolean | HSProviderModel$example_imagesArgs<ExtArgs>
    _count?: boolean | HSProviderModelCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["hSProviderModel"]>

  export type HSProviderModelSelectScalar = {
    id?: boolean
    business_registration_num?: boolean
  }

  export type HSProviderModelInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    base?: boolean | BusinessUserModelArgs<ExtArgs>
    example_images?: boolean | HSProviderModel$example_imagesArgs<ExtArgs>
    _count?: boolean | HSProviderModelCountOutputTypeArgs<ExtArgs>
  }


  type HSProviderModelGetPayload<S extends boolean | null | undefined | HSProviderModelArgs> = $Types.GetResult<HSProviderModelPayload, S>

  type HSProviderModelCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<HSProviderModelFindManyArgs, 'select' | 'include'> & {
      select?: HSProviderModelCountAggregateInputType | true
    }

  export interface HSProviderModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HSProviderModel'], meta: { name: 'HSProviderModel' } }
    /**
     * Find zero or one HSProviderModel that matches the filter.
     * @param {HSProviderModelFindUniqueArgs} args - Arguments to find a HSProviderModel
     * @example
     * // Get one HSProviderModel
     * const hSProviderModel = await prisma.hSProviderModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HSProviderModelFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HSProviderModelFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'HSProviderModel'> extends True ? Prisma__HSProviderModelClient<$Types.GetResult<HSProviderModelPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__HSProviderModelClient<$Types.GetResult<HSProviderModelPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one HSProviderModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HSProviderModelFindUniqueOrThrowArgs} args - Arguments to find a HSProviderModel
     * @example
     * // Get one HSProviderModel
     * const hSProviderModel = await prisma.hSProviderModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HSProviderModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HSProviderModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__HSProviderModelClient<$Types.GetResult<HSProviderModelPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first HSProviderModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSProviderModelFindFirstArgs} args - Arguments to find a HSProviderModel
     * @example
     * // Get one HSProviderModel
     * const hSProviderModel = await prisma.hSProviderModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HSProviderModelFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HSProviderModelFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'HSProviderModel'> extends True ? Prisma__HSProviderModelClient<$Types.GetResult<HSProviderModelPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__HSProviderModelClient<$Types.GetResult<HSProviderModelPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first HSProviderModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSProviderModelFindFirstOrThrowArgs} args - Arguments to find a HSProviderModel
     * @example
     * // Get one HSProviderModel
     * const hSProviderModel = await prisma.hSProviderModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HSProviderModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HSProviderModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__HSProviderModelClient<$Types.GetResult<HSProviderModelPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more HSProviderModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSProviderModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HSProviderModels
     * const hSProviderModels = await prisma.hSProviderModel.findMany()
     * 
     * // Get first 10 HSProviderModels
     * const hSProviderModels = await prisma.hSProviderModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hSProviderModelWithIdOnly = await prisma.hSProviderModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HSProviderModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HSProviderModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<HSProviderModelPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a HSProviderModel.
     * @param {HSProviderModelCreateArgs} args - Arguments to create a HSProviderModel.
     * @example
     * // Create one HSProviderModel
     * const HSProviderModel = await prisma.hSProviderModel.create({
     *   data: {
     *     // ... data to create a HSProviderModel
     *   }
     * })
     * 
    **/
    create<T extends HSProviderModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, HSProviderModelCreateArgs<ExtArgs>>
    ): Prisma__HSProviderModelClient<$Types.GetResult<HSProviderModelPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many HSProviderModels.
     *     @param {HSProviderModelCreateManyArgs} args - Arguments to create many HSProviderModels.
     *     @example
     *     // Create many HSProviderModels
     *     const hSProviderModel = await prisma.hSProviderModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HSProviderModelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HSProviderModelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HSProviderModel.
     * @param {HSProviderModelDeleteArgs} args - Arguments to delete one HSProviderModel.
     * @example
     * // Delete one HSProviderModel
     * const HSProviderModel = await prisma.hSProviderModel.delete({
     *   where: {
     *     // ... filter to delete one HSProviderModel
     *   }
     * })
     * 
    **/
    delete<T extends HSProviderModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, HSProviderModelDeleteArgs<ExtArgs>>
    ): Prisma__HSProviderModelClient<$Types.GetResult<HSProviderModelPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one HSProviderModel.
     * @param {HSProviderModelUpdateArgs} args - Arguments to update one HSProviderModel.
     * @example
     * // Update one HSProviderModel
     * const hSProviderModel = await prisma.hSProviderModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HSProviderModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, HSProviderModelUpdateArgs<ExtArgs>>
    ): Prisma__HSProviderModelClient<$Types.GetResult<HSProviderModelPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more HSProviderModels.
     * @param {HSProviderModelDeleteManyArgs} args - Arguments to filter HSProviderModels to delete.
     * @example
     * // Delete a few HSProviderModels
     * const { count } = await prisma.hSProviderModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HSProviderModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HSProviderModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HSProviderModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSProviderModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HSProviderModels
     * const hSProviderModel = await prisma.hSProviderModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HSProviderModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, HSProviderModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HSProviderModel.
     * @param {HSProviderModelUpsertArgs} args - Arguments to update or create a HSProviderModel.
     * @example
     * // Update or create a HSProviderModel
     * const hSProviderModel = await prisma.hSProviderModel.upsert({
     *   create: {
     *     // ... data to create a HSProviderModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HSProviderModel we want to update
     *   }
     * })
    **/
    upsert<T extends HSProviderModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, HSProviderModelUpsertArgs<ExtArgs>>
    ): Prisma__HSProviderModelClient<$Types.GetResult<HSProviderModelPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of HSProviderModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSProviderModelCountArgs} args - Arguments to filter HSProviderModels to count.
     * @example
     * // Count the number of HSProviderModels
     * const count = await prisma.hSProviderModel.count({
     *   where: {
     *     // ... the filter for the HSProviderModels we want to count
     *   }
     * })
    **/
    count<T extends HSProviderModelCountArgs>(
      args?: Subset<T, HSProviderModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HSProviderModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HSProviderModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSProviderModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HSProviderModelAggregateArgs>(args: Subset<T, HSProviderModelAggregateArgs>): Prisma.PrismaPromise<GetHSProviderModelAggregateType<T>>

    /**
     * Group by HSProviderModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSProviderModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HSProviderModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HSProviderModelGroupByArgs['orderBy'] }
        : { orderBy?: HSProviderModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HSProviderModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHSProviderModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for HSProviderModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HSProviderModelClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    base<T extends BusinessUserModelArgs<ExtArgs> = {}>(args?: Subset<T, BusinessUserModelArgs<ExtArgs>>): Prisma__BusinessUserModelClient<$Types.GetResult<BusinessUserModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    example_images<T extends HSProviderModel$example_imagesArgs<ExtArgs> = {}>(args?: Subset<T, HSProviderModel$example_imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<HSExampleImageModelPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * HSProviderModel base type for findUnique actions
   */
  export type HSProviderModelFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HSProviderModel
     */
    select?: HSProviderModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSProviderModelInclude<ExtArgs> | null
    /**
     * Filter, which HSProviderModel to fetch.
     */
    where: HSProviderModelWhereUniqueInput
  }

  /**
   * HSProviderModel findUnique
   */
  export interface HSProviderModelFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends HSProviderModelFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HSProviderModel findUniqueOrThrow
   */
  export type HSProviderModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HSProviderModel
     */
    select?: HSProviderModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSProviderModelInclude<ExtArgs> | null
    /**
     * Filter, which HSProviderModel to fetch.
     */
    where: HSProviderModelWhereUniqueInput
  }


  /**
   * HSProviderModel base type for findFirst actions
   */
  export type HSProviderModelFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HSProviderModel
     */
    select?: HSProviderModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSProviderModelInclude<ExtArgs> | null
    /**
     * Filter, which HSProviderModel to fetch.
     */
    where?: HSProviderModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HSProviderModels to fetch.
     */
    orderBy?: Enumerable<HSProviderModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HSProviderModels.
     */
    cursor?: HSProviderModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HSProviderModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HSProviderModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HSProviderModels.
     */
    distinct?: Enumerable<HSProviderModelScalarFieldEnum>
  }

  /**
   * HSProviderModel findFirst
   */
  export interface HSProviderModelFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends HSProviderModelFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HSProviderModel findFirstOrThrow
   */
  export type HSProviderModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HSProviderModel
     */
    select?: HSProviderModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSProviderModelInclude<ExtArgs> | null
    /**
     * Filter, which HSProviderModel to fetch.
     */
    where?: HSProviderModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HSProviderModels to fetch.
     */
    orderBy?: Enumerable<HSProviderModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HSProviderModels.
     */
    cursor?: HSProviderModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HSProviderModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HSProviderModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HSProviderModels.
     */
    distinct?: Enumerable<HSProviderModelScalarFieldEnum>
  }


  /**
   * HSProviderModel findMany
   */
  export type HSProviderModelFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HSProviderModel
     */
    select?: HSProviderModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSProviderModelInclude<ExtArgs> | null
    /**
     * Filter, which HSProviderModels to fetch.
     */
    where?: HSProviderModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HSProviderModels to fetch.
     */
    orderBy?: Enumerable<HSProviderModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HSProviderModels.
     */
    cursor?: HSProviderModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HSProviderModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HSProviderModels.
     */
    skip?: number
    distinct?: Enumerable<HSProviderModelScalarFieldEnum>
  }


  /**
   * HSProviderModel create
   */
  export type HSProviderModelCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HSProviderModel
     */
    select?: HSProviderModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSProviderModelInclude<ExtArgs> | null
    /**
     * The data needed to create a HSProviderModel.
     */
    data: XOR<HSProviderModelCreateInput, HSProviderModelUncheckedCreateInput>
  }


  /**
   * HSProviderModel createMany
   */
  export type HSProviderModelCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HSProviderModels.
     */
    data: Enumerable<HSProviderModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * HSProviderModel update
   */
  export type HSProviderModelUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HSProviderModel
     */
    select?: HSProviderModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSProviderModelInclude<ExtArgs> | null
    /**
     * The data needed to update a HSProviderModel.
     */
    data: XOR<HSProviderModelUpdateInput, HSProviderModelUncheckedUpdateInput>
    /**
     * Choose, which HSProviderModel to update.
     */
    where: HSProviderModelWhereUniqueInput
  }


  /**
   * HSProviderModel updateMany
   */
  export type HSProviderModelUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HSProviderModels.
     */
    data: XOR<HSProviderModelUpdateManyMutationInput, HSProviderModelUncheckedUpdateManyInput>
    /**
     * Filter which HSProviderModels to update
     */
    where?: HSProviderModelWhereInput
  }


  /**
   * HSProviderModel upsert
   */
  export type HSProviderModelUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HSProviderModel
     */
    select?: HSProviderModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSProviderModelInclude<ExtArgs> | null
    /**
     * The filter to search for the HSProviderModel to update in case it exists.
     */
    where: HSProviderModelWhereUniqueInput
    /**
     * In case the HSProviderModel found by the `where` argument doesn't exist, create a new HSProviderModel with this data.
     */
    create: XOR<HSProviderModelCreateInput, HSProviderModelUncheckedCreateInput>
    /**
     * In case the HSProviderModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HSProviderModelUpdateInput, HSProviderModelUncheckedUpdateInput>
  }


  /**
   * HSProviderModel delete
   */
  export type HSProviderModelDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HSProviderModel
     */
    select?: HSProviderModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSProviderModelInclude<ExtArgs> | null
    /**
     * Filter which HSProviderModel to delete.
     */
    where: HSProviderModelWhereUniqueInput
  }


  /**
   * HSProviderModel deleteMany
   */
  export type HSProviderModelDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which HSProviderModels to delete
     */
    where?: HSProviderModelWhereInput
  }


  /**
   * HSProviderModel.example_images
   */
  export type HSProviderModel$example_imagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HSExampleImageModel
     */
    select?: HSExampleImageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSExampleImageModelInclude<ExtArgs> | null
    where?: HSExampleImageModelWhereInput
    orderBy?: Enumerable<HSExampleImageModelOrderByWithRelationInput>
    cursor?: HSExampleImageModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HSExampleImageModelScalarFieldEnum>
  }


  /**
   * HSProviderModel without action
   */
  export type HSProviderModelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HSProviderModel
     */
    select?: HSProviderModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSProviderModelInclude<ExtArgs> | null
  }



  /**
   * Model BusinessCertificationImageModel
   */


  export type AggregateBusinessCertificationImageModel = {
    _count: BusinessCertificationImageModelCountAggregateOutputType | null
    _min: BusinessCertificationImageModelMinAggregateOutputType | null
    _max: BusinessCertificationImageModelMaxAggregateOutputType | null
  }

  export type BusinessCertificationImageModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    business_user_id: string | null
    url: string | null
  }

  export type BusinessCertificationImageModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    business_user_id: string | null
    url: string | null
  }

  export type BusinessCertificationImageModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    business_user_id: number
    url: number
    _all: number
  }


  export type BusinessCertificationImageModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    business_user_id?: true
    url?: true
  }

  export type BusinessCertificationImageModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    business_user_id?: true
    url?: true
  }

  export type BusinessCertificationImageModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    business_user_id?: true
    url?: true
    _all?: true
  }

  export type BusinessCertificationImageModelAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessCertificationImageModel to aggregate.
     */
    where?: BusinessCertificationImageModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessCertificationImageModels to fetch.
     */
    orderBy?: Enumerable<BusinessCertificationImageModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessCertificationImageModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessCertificationImageModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessCertificationImageModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessCertificationImageModels
    **/
    _count?: true | BusinessCertificationImageModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessCertificationImageModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessCertificationImageModelMaxAggregateInputType
  }

  export type GetBusinessCertificationImageModelAggregateType<T extends BusinessCertificationImageModelAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessCertificationImageModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessCertificationImageModel[P]>
      : GetScalarType<T[P], AggregateBusinessCertificationImageModel[P]>
  }




  export type BusinessCertificationImageModelGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BusinessCertificationImageModelWhereInput
    orderBy?: Enumerable<BusinessCertificationImageModelOrderByWithAggregationInput>
    by: BusinessCertificationImageModelScalarFieldEnum[]
    having?: BusinessCertificationImageModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessCertificationImageModelCountAggregateInputType | true
    _min?: BusinessCertificationImageModelMinAggregateInputType
    _max?: BusinessCertificationImageModelMaxAggregateInputType
  }


  export type BusinessCertificationImageModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    business_user_id: string
    url: string
    _count: BusinessCertificationImageModelCountAggregateOutputType | null
    _min: BusinessCertificationImageModelMinAggregateOutputType | null
    _max: BusinessCertificationImageModelMaxAggregateOutputType | null
  }

  type GetBusinessCertificationImageModelGroupByPayload<T extends BusinessCertificationImageModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BusinessCertificationImageModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessCertificationImageModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessCertificationImageModelGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessCertificationImageModelGroupByOutputType[P]>
        }
      >
    >


  export type BusinessCertificationImageModelSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    business_user_id?: boolean
    url?: boolean
    business_user?: boolean | BusinessUserModelArgs<ExtArgs>
  }, ExtArgs["result"]["businessCertificationImageModel"]>

  export type BusinessCertificationImageModelSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    business_user_id?: boolean
    url?: boolean
  }

  export type BusinessCertificationImageModelInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    business_user?: boolean | BusinessUserModelArgs<ExtArgs>
  }


  type BusinessCertificationImageModelGetPayload<S extends boolean | null | undefined | BusinessCertificationImageModelArgs> = $Types.GetResult<BusinessCertificationImageModelPayload, S>

  type BusinessCertificationImageModelCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BusinessCertificationImageModelFindManyArgs, 'select' | 'include'> & {
      select?: BusinessCertificationImageModelCountAggregateInputType | true
    }

  export interface BusinessCertificationImageModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessCertificationImageModel'], meta: { name: 'BusinessCertificationImageModel' } }
    /**
     * Find zero or one BusinessCertificationImageModel that matches the filter.
     * @param {BusinessCertificationImageModelFindUniqueArgs} args - Arguments to find a BusinessCertificationImageModel
     * @example
     * // Get one BusinessCertificationImageModel
     * const businessCertificationImageModel = await prisma.businessCertificationImageModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BusinessCertificationImageModelFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BusinessCertificationImageModelFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BusinessCertificationImageModel'> extends True ? Prisma__BusinessCertificationImageModelClient<$Types.GetResult<BusinessCertificationImageModelPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__BusinessCertificationImageModelClient<$Types.GetResult<BusinessCertificationImageModelPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one BusinessCertificationImageModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BusinessCertificationImageModelFindUniqueOrThrowArgs} args - Arguments to find a BusinessCertificationImageModel
     * @example
     * // Get one BusinessCertificationImageModel
     * const businessCertificationImageModel = await prisma.businessCertificationImageModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BusinessCertificationImageModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessCertificationImageModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BusinessCertificationImageModelClient<$Types.GetResult<BusinessCertificationImageModelPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first BusinessCertificationImageModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCertificationImageModelFindFirstArgs} args - Arguments to find a BusinessCertificationImageModel
     * @example
     * // Get one BusinessCertificationImageModel
     * const businessCertificationImageModel = await prisma.businessCertificationImageModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BusinessCertificationImageModelFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BusinessCertificationImageModelFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BusinessCertificationImageModel'> extends True ? Prisma__BusinessCertificationImageModelClient<$Types.GetResult<BusinessCertificationImageModelPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__BusinessCertificationImageModelClient<$Types.GetResult<BusinessCertificationImageModelPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first BusinessCertificationImageModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCertificationImageModelFindFirstOrThrowArgs} args - Arguments to find a BusinessCertificationImageModel
     * @example
     * // Get one BusinessCertificationImageModel
     * const businessCertificationImageModel = await prisma.businessCertificationImageModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BusinessCertificationImageModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessCertificationImageModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BusinessCertificationImageModelClient<$Types.GetResult<BusinessCertificationImageModelPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more BusinessCertificationImageModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCertificationImageModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessCertificationImageModels
     * const businessCertificationImageModels = await prisma.businessCertificationImageModel.findMany()
     * 
     * // Get first 10 BusinessCertificationImageModels
     * const businessCertificationImageModels = await prisma.businessCertificationImageModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessCertificationImageModelWithIdOnly = await prisma.businessCertificationImageModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BusinessCertificationImageModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessCertificationImageModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BusinessCertificationImageModelPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a BusinessCertificationImageModel.
     * @param {BusinessCertificationImageModelCreateArgs} args - Arguments to create a BusinessCertificationImageModel.
     * @example
     * // Create one BusinessCertificationImageModel
     * const BusinessCertificationImageModel = await prisma.businessCertificationImageModel.create({
     *   data: {
     *     // ... data to create a BusinessCertificationImageModel
     *   }
     * })
     * 
    **/
    create<T extends BusinessCertificationImageModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessCertificationImageModelCreateArgs<ExtArgs>>
    ): Prisma__BusinessCertificationImageModelClient<$Types.GetResult<BusinessCertificationImageModelPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many BusinessCertificationImageModels.
     *     @param {BusinessCertificationImageModelCreateManyArgs} args - Arguments to create many BusinessCertificationImageModels.
     *     @example
     *     // Create many BusinessCertificationImageModels
     *     const businessCertificationImageModel = await prisma.businessCertificationImageModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BusinessCertificationImageModelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessCertificationImageModelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BusinessCertificationImageModel.
     * @param {BusinessCertificationImageModelDeleteArgs} args - Arguments to delete one BusinessCertificationImageModel.
     * @example
     * // Delete one BusinessCertificationImageModel
     * const BusinessCertificationImageModel = await prisma.businessCertificationImageModel.delete({
     *   where: {
     *     // ... filter to delete one BusinessCertificationImageModel
     *   }
     * })
     * 
    **/
    delete<T extends BusinessCertificationImageModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessCertificationImageModelDeleteArgs<ExtArgs>>
    ): Prisma__BusinessCertificationImageModelClient<$Types.GetResult<BusinessCertificationImageModelPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one BusinessCertificationImageModel.
     * @param {BusinessCertificationImageModelUpdateArgs} args - Arguments to update one BusinessCertificationImageModel.
     * @example
     * // Update one BusinessCertificationImageModel
     * const businessCertificationImageModel = await prisma.businessCertificationImageModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BusinessCertificationImageModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessCertificationImageModelUpdateArgs<ExtArgs>>
    ): Prisma__BusinessCertificationImageModelClient<$Types.GetResult<BusinessCertificationImageModelPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more BusinessCertificationImageModels.
     * @param {BusinessCertificationImageModelDeleteManyArgs} args - Arguments to filter BusinessCertificationImageModels to delete.
     * @example
     * // Delete a few BusinessCertificationImageModels
     * const { count } = await prisma.businessCertificationImageModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BusinessCertificationImageModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusinessCertificationImageModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessCertificationImageModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCertificationImageModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessCertificationImageModels
     * const businessCertificationImageModel = await prisma.businessCertificationImageModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BusinessCertificationImageModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessCertificationImageModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessCertificationImageModel.
     * @param {BusinessCertificationImageModelUpsertArgs} args - Arguments to update or create a BusinessCertificationImageModel.
     * @example
     * // Update or create a BusinessCertificationImageModel
     * const businessCertificationImageModel = await prisma.businessCertificationImageModel.upsert({
     *   create: {
     *     // ... data to create a BusinessCertificationImageModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessCertificationImageModel we want to update
     *   }
     * })
    **/
    upsert<T extends BusinessCertificationImageModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BusinessCertificationImageModelUpsertArgs<ExtArgs>>
    ): Prisma__BusinessCertificationImageModelClient<$Types.GetResult<BusinessCertificationImageModelPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of BusinessCertificationImageModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCertificationImageModelCountArgs} args - Arguments to filter BusinessCertificationImageModels to count.
     * @example
     * // Count the number of BusinessCertificationImageModels
     * const count = await prisma.businessCertificationImageModel.count({
     *   where: {
     *     // ... the filter for the BusinessCertificationImageModels we want to count
     *   }
     * })
    **/
    count<T extends BusinessCertificationImageModelCountArgs>(
      args?: Subset<T, BusinessCertificationImageModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessCertificationImageModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessCertificationImageModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCertificationImageModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessCertificationImageModelAggregateArgs>(args: Subset<T, BusinessCertificationImageModelAggregateArgs>): Prisma.PrismaPromise<GetBusinessCertificationImageModelAggregateType<T>>

    /**
     * Group by BusinessCertificationImageModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCertificationImageModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessCertificationImageModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessCertificationImageModelGroupByArgs['orderBy'] }
        : { orderBy?: BusinessCertificationImageModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessCertificationImageModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessCertificationImageModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessCertificationImageModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BusinessCertificationImageModelClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    business_user<T extends BusinessUserModelArgs<ExtArgs> = {}>(args?: Subset<T, BusinessUserModelArgs<ExtArgs>>): Prisma__BusinessUserModelClient<$Types.GetResult<BusinessUserModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BusinessCertificationImageModel base type for findUnique actions
   */
  export type BusinessCertificationImageModelFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCertificationImageModel
     */
    select?: BusinessCertificationImageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessCertificationImageModelInclude<ExtArgs> | null
    /**
     * Filter, which BusinessCertificationImageModel to fetch.
     */
    where: BusinessCertificationImageModelWhereUniqueInput
  }

  /**
   * BusinessCertificationImageModel findUnique
   */
  export interface BusinessCertificationImageModelFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BusinessCertificationImageModelFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusinessCertificationImageModel findUniqueOrThrow
   */
  export type BusinessCertificationImageModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCertificationImageModel
     */
    select?: BusinessCertificationImageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessCertificationImageModelInclude<ExtArgs> | null
    /**
     * Filter, which BusinessCertificationImageModel to fetch.
     */
    where: BusinessCertificationImageModelWhereUniqueInput
  }


  /**
   * BusinessCertificationImageModel base type for findFirst actions
   */
  export type BusinessCertificationImageModelFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCertificationImageModel
     */
    select?: BusinessCertificationImageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessCertificationImageModelInclude<ExtArgs> | null
    /**
     * Filter, which BusinessCertificationImageModel to fetch.
     */
    where?: BusinessCertificationImageModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessCertificationImageModels to fetch.
     */
    orderBy?: Enumerable<BusinessCertificationImageModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessCertificationImageModels.
     */
    cursor?: BusinessCertificationImageModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessCertificationImageModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessCertificationImageModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessCertificationImageModels.
     */
    distinct?: Enumerable<BusinessCertificationImageModelScalarFieldEnum>
  }

  /**
   * BusinessCertificationImageModel findFirst
   */
  export interface BusinessCertificationImageModelFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BusinessCertificationImageModelFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusinessCertificationImageModel findFirstOrThrow
   */
  export type BusinessCertificationImageModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCertificationImageModel
     */
    select?: BusinessCertificationImageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessCertificationImageModelInclude<ExtArgs> | null
    /**
     * Filter, which BusinessCertificationImageModel to fetch.
     */
    where?: BusinessCertificationImageModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessCertificationImageModels to fetch.
     */
    orderBy?: Enumerable<BusinessCertificationImageModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessCertificationImageModels.
     */
    cursor?: BusinessCertificationImageModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessCertificationImageModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessCertificationImageModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessCertificationImageModels.
     */
    distinct?: Enumerable<BusinessCertificationImageModelScalarFieldEnum>
  }


  /**
   * BusinessCertificationImageModel findMany
   */
  export type BusinessCertificationImageModelFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCertificationImageModel
     */
    select?: BusinessCertificationImageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessCertificationImageModelInclude<ExtArgs> | null
    /**
     * Filter, which BusinessCertificationImageModels to fetch.
     */
    where?: BusinessCertificationImageModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessCertificationImageModels to fetch.
     */
    orderBy?: Enumerable<BusinessCertificationImageModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessCertificationImageModels.
     */
    cursor?: BusinessCertificationImageModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessCertificationImageModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessCertificationImageModels.
     */
    skip?: number
    distinct?: Enumerable<BusinessCertificationImageModelScalarFieldEnum>
  }


  /**
   * BusinessCertificationImageModel create
   */
  export type BusinessCertificationImageModelCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCertificationImageModel
     */
    select?: BusinessCertificationImageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessCertificationImageModelInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessCertificationImageModel.
     */
    data: XOR<BusinessCertificationImageModelCreateInput, BusinessCertificationImageModelUncheckedCreateInput>
  }


  /**
   * BusinessCertificationImageModel createMany
   */
  export type BusinessCertificationImageModelCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessCertificationImageModels.
     */
    data: Enumerable<BusinessCertificationImageModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BusinessCertificationImageModel update
   */
  export type BusinessCertificationImageModelUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCertificationImageModel
     */
    select?: BusinessCertificationImageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessCertificationImageModelInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessCertificationImageModel.
     */
    data: XOR<BusinessCertificationImageModelUpdateInput, BusinessCertificationImageModelUncheckedUpdateInput>
    /**
     * Choose, which BusinessCertificationImageModel to update.
     */
    where: BusinessCertificationImageModelWhereUniqueInput
  }


  /**
   * BusinessCertificationImageModel updateMany
   */
  export type BusinessCertificationImageModelUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessCertificationImageModels.
     */
    data: XOR<BusinessCertificationImageModelUpdateManyMutationInput, BusinessCertificationImageModelUncheckedUpdateManyInput>
    /**
     * Filter which BusinessCertificationImageModels to update
     */
    where?: BusinessCertificationImageModelWhereInput
  }


  /**
   * BusinessCertificationImageModel upsert
   */
  export type BusinessCertificationImageModelUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCertificationImageModel
     */
    select?: BusinessCertificationImageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessCertificationImageModelInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessCertificationImageModel to update in case it exists.
     */
    where: BusinessCertificationImageModelWhereUniqueInput
    /**
     * In case the BusinessCertificationImageModel found by the `where` argument doesn't exist, create a new BusinessCertificationImageModel with this data.
     */
    create: XOR<BusinessCertificationImageModelCreateInput, BusinessCertificationImageModelUncheckedCreateInput>
    /**
     * In case the BusinessCertificationImageModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessCertificationImageModelUpdateInput, BusinessCertificationImageModelUncheckedUpdateInput>
  }


  /**
   * BusinessCertificationImageModel delete
   */
  export type BusinessCertificationImageModelDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCertificationImageModel
     */
    select?: BusinessCertificationImageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessCertificationImageModelInclude<ExtArgs> | null
    /**
     * Filter which BusinessCertificationImageModel to delete.
     */
    where: BusinessCertificationImageModelWhereUniqueInput
  }


  /**
   * BusinessCertificationImageModel deleteMany
   */
  export type BusinessCertificationImageModelDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessCertificationImageModels to delete
     */
    where?: BusinessCertificationImageModelWhereInput
  }


  /**
   * BusinessCertificationImageModel without action
   */
  export type BusinessCertificationImageModelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCertificationImageModel
     */
    select?: BusinessCertificationImageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BusinessCertificationImageModelInclude<ExtArgs> | null
  }



  /**
   * Model HSExampleImageModel
   */


  export type AggregateHSExampleImageModel = {
    _count: HSExampleImageModelCountAggregateOutputType | null
    _min: HSExampleImageModelMinAggregateOutputType | null
    _max: HSExampleImageModelMaxAggregateOutputType | null
  }

  export type HSExampleImageModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    hs_provider_id: string | null
    url: string | null
    is_visible: boolean | null
  }

  export type HSExampleImageModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    hs_provider_id: string | null
    url: string | null
    is_visible: boolean | null
  }

  export type HSExampleImageModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    hs_provider_id: number
    url: number
    is_visible: number
    _all: number
  }


  export type HSExampleImageModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    hs_provider_id?: true
    url?: true
    is_visible?: true
  }

  export type HSExampleImageModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    hs_provider_id?: true
    url?: true
    is_visible?: true
  }

  export type HSExampleImageModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    hs_provider_id?: true
    url?: true
    is_visible?: true
    _all?: true
  }

  export type HSExampleImageModelAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which HSExampleImageModel to aggregate.
     */
    where?: HSExampleImageModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HSExampleImageModels to fetch.
     */
    orderBy?: Enumerable<HSExampleImageModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HSExampleImageModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HSExampleImageModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HSExampleImageModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HSExampleImageModels
    **/
    _count?: true | HSExampleImageModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HSExampleImageModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HSExampleImageModelMaxAggregateInputType
  }

  export type GetHSExampleImageModelAggregateType<T extends HSExampleImageModelAggregateArgs> = {
        [P in keyof T & keyof AggregateHSExampleImageModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHSExampleImageModel[P]>
      : GetScalarType<T[P], AggregateHSExampleImageModel[P]>
  }




  export type HSExampleImageModelGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: HSExampleImageModelWhereInput
    orderBy?: Enumerable<HSExampleImageModelOrderByWithAggregationInput>
    by: HSExampleImageModelScalarFieldEnum[]
    having?: HSExampleImageModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HSExampleImageModelCountAggregateInputType | true
    _min?: HSExampleImageModelMinAggregateInputType
    _max?: HSExampleImageModelMaxAggregateInputType
  }


  export type HSExampleImageModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    hs_provider_id: string
    url: string
    is_visible: boolean
    _count: HSExampleImageModelCountAggregateOutputType | null
    _min: HSExampleImageModelMinAggregateOutputType | null
    _max: HSExampleImageModelMaxAggregateOutputType | null
  }

  type GetHSExampleImageModelGroupByPayload<T extends HSExampleImageModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HSExampleImageModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HSExampleImageModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HSExampleImageModelGroupByOutputType[P]>
            : GetScalarType<T[P], HSExampleImageModelGroupByOutputType[P]>
        }
      >
    >


  export type HSExampleImageModelSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    hs_provider_id?: boolean
    url?: boolean
    is_visible?: boolean
    hs_provider?: boolean | HSProviderModelArgs<ExtArgs>
  }, ExtArgs["result"]["hSExampleImageModel"]>

  export type HSExampleImageModelSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    hs_provider_id?: boolean
    url?: boolean
    is_visible?: boolean
  }

  export type HSExampleImageModelInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    hs_provider?: boolean | HSProviderModelArgs<ExtArgs>
  }


  type HSExampleImageModelGetPayload<S extends boolean | null | undefined | HSExampleImageModelArgs> = $Types.GetResult<HSExampleImageModelPayload, S>

  type HSExampleImageModelCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<HSExampleImageModelFindManyArgs, 'select' | 'include'> & {
      select?: HSExampleImageModelCountAggregateInputType | true
    }

  export interface HSExampleImageModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HSExampleImageModel'], meta: { name: 'HSExampleImageModel' } }
    /**
     * Find zero or one HSExampleImageModel that matches the filter.
     * @param {HSExampleImageModelFindUniqueArgs} args - Arguments to find a HSExampleImageModel
     * @example
     * // Get one HSExampleImageModel
     * const hSExampleImageModel = await prisma.hSExampleImageModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HSExampleImageModelFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HSExampleImageModelFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'HSExampleImageModel'> extends True ? Prisma__HSExampleImageModelClient<$Types.GetResult<HSExampleImageModelPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__HSExampleImageModelClient<$Types.GetResult<HSExampleImageModelPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one HSExampleImageModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HSExampleImageModelFindUniqueOrThrowArgs} args - Arguments to find a HSExampleImageModel
     * @example
     * // Get one HSExampleImageModel
     * const hSExampleImageModel = await prisma.hSExampleImageModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HSExampleImageModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HSExampleImageModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__HSExampleImageModelClient<$Types.GetResult<HSExampleImageModelPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first HSExampleImageModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSExampleImageModelFindFirstArgs} args - Arguments to find a HSExampleImageModel
     * @example
     * // Get one HSExampleImageModel
     * const hSExampleImageModel = await prisma.hSExampleImageModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HSExampleImageModelFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HSExampleImageModelFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'HSExampleImageModel'> extends True ? Prisma__HSExampleImageModelClient<$Types.GetResult<HSExampleImageModelPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__HSExampleImageModelClient<$Types.GetResult<HSExampleImageModelPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first HSExampleImageModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSExampleImageModelFindFirstOrThrowArgs} args - Arguments to find a HSExampleImageModel
     * @example
     * // Get one HSExampleImageModel
     * const hSExampleImageModel = await prisma.hSExampleImageModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HSExampleImageModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HSExampleImageModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__HSExampleImageModelClient<$Types.GetResult<HSExampleImageModelPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more HSExampleImageModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSExampleImageModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HSExampleImageModels
     * const hSExampleImageModels = await prisma.hSExampleImageModel.findMany()
     * 
     * // Get first 10 HSExampleImageModels
     * const hSExampleImageModels = await prisma.hSExampleImageModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hSExampleImageModelWithIdOnly = await prisma.hSExampleImageModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HSExampleImageModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HSExampleImageModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<HSExampleImageModelPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a HSExampleImageModel.
     * @param {HSExampleImageModelCreateArgs} args - Arguments to create a HSExampleImageModel.
     * @example
     * // Create one HSExampleImageModel
     * const HSExampleImageModel = await prisma.hSExampleImageModel.create({
     *   data: {
     *     // ... data to create a HSExampleImageModel
     *   }
     * })
     * 
    **/
    create<T extends HSExampleImageModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, HSExampleImageModelCreateArgs<ExtArgs>>
    ): Prisma__HSExampleImageModelClient<$Types.GetResult<HSExampleImageModelPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many HSExampleImageModels.
     *     @param {HSExampleImageModelCreateManyArgs} args - Arguments to create many HSExampleImageModels.
     *     @example
     *     // Create many HSExampleImageModels
     *     const hSExampleImageModel = await prisma.hSExampleImageModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HSExampleImageModelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HSExampleImageModelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HSExampleImageModel.
     * @param {HSExampleImageModelDeleteArgs} args - Arguments to delete one HSExampleImageModel.
     * @example
     * // Delete one HSExampleImageModel
     * const HSExampleImageModel = await prisma.hSExampleImageModel.delete({
     *   where: {
     *     // ... filter to delete one HSExampleImageModel
     *   }
     * })
     * 
    **/
    delete<T extends HSExampleImageModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, HSExampleImageModelDeleteArgs<ExtArgs>>
    ): Prisma__HSExampleImageModelClient<$Types.GetResult<HSExampleImageModelPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one HSExampleImageModel.
     * @param {HSExampleImageModelUpdateArgs} args - Arguments to update one HSExampleImageModel.
     * @example
     * // Update one HSExampleImageModel
     * const hSExampleImageModel = await prisma.hSExampleImageModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HSExampleImageModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, HSExampleImageModelUpdateArgs<ExtArgs>>
    ): Prisma__HSExampleImageModelClient<$Types.GetResult<HSExampleImageModelPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more HSExampleImageModels.
     * @param {HSExampleImageModelDeleteManyArgs} args - Arguments to filter HSExampleImageModels to delete.
     * @example
     * // Delete a few HSExampleImageModels
     * const { count } = await prisma.hSExampleImageModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HSExampleImageModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HSExampleImageModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HSExampleImageModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSExampleImageModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HSExampleImageModels
     * const hSExampleImageModel = await prisma.hSExampleImageModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HSExampleImageModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, HSExampleImageModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HSExampleImageModel.
     * @param {HSExampleImageModelUpsertArgs} args - Arguments to update or create a HSExampleImageModel.
     * @example
     * // Update or create a HSExampleImageModel
     * const hSExampleImageModel = await prisma.hSExampleImageModel.upsert({
     *   create: {
     *     // ... data to create a HSExampleImageModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HSExampleImageModel we want to update
     *   }
     * })
    **/
    upsert<T extends HSExampleImageModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, HSExampleImageModelUpsertArgs<ExtArgs>>
    ): Prisma__HSExampleImageModelClient<$Types.GetResult<HSExampleImageModelPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of HSExampleImageModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSExampleImageModelCountArgs} args - Arguments to filter HSExampleImageModels to count.
     * @example
     * // Count the number of HSExampleImageModels
     * const count = await prisma.hSExampleImageModel.count({
     *   where: {
     *     // ... the filter for the HSExampleImageModels we want to count
     *   }
     * })
    **/
    count<T extends HSExampleImageModelCountArgs>(
      args?: Subset<T, HSExampleImageModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HSExampleImageModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HSExampleImageModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSExampleImageModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HSExampleImageModelAggregateArgs>(args: Subset<T, HSExampleImageModelAggregateArgs>): Prisma.PrismaPromise<GetHSExampleImageModelAggregateType<T>>

    /**
     * Group by HSExampleImageModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HSExampleImageModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HSExampleImageModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HSExampleImageModelGroupByArgs['orderBy'] }
        : { orderBy?: HSExampleImageModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HSExampleImageModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHSExampleImageModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for HSExampleImageModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HSExampleImageModelClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    hs_provider<T extends HSProviderModelArgs<ExtArgs> = {}>(args?: Subset<T, HSProviderModelArgs<ExtArgs>>): Prisma__HSProviderModelClient<$Types.GetResult<HSProviderModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * HSExampleImageModel base type for findUnique actions
   */
  export type HSExampleImageModelFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HSExampleImageModel
     */
    select?: HSExampleImageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSExampleImageModelInclude<ExtArgs> | null
    /**
     * Filter, which HSExampleImageModel to fetch.
     */
    where: HSExampleImageModelWhereUniqueInput
  }

  /**
   * HSExampleImageModel findUnique
   */
  export interface HSExampleImageModelFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends HSExampleImageModelFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HSExampleImageModel findUniqueOrThrow
   */
  export type HSExampleImageModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HSExampleImageModel
     */
    select?: HSExampleImageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSExampleImageModelInclude<ExtArgs> | null
    /**
     * Filter, which HSExampleImageModel to fetch.
     */
    where: HSExampleImageModelWhereUniqueInput
  }


  /**
   * HSExampleImageModel base type for findFirst actions
   */
  export type HSExampleImageModelFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HSExampleImageModel
     */
    select?: HSExampleImageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSExampleImageModelInclude<ExtArgs> | null
    /**
     * Filter, which HSExampleImageModel to fetch.
     */
    where?: HSExampleImageModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HSExampleImageModels to fetch.
     */
    orderBy?: Enumerable<HSExampleImageModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HSExampleImageModels.
     */
    cursor?: HSExampleImageModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HSExampleImageModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HSExampleImageModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HSExampleImageModels.
     */
    distinct?: Enumerable<HSExampleImageModelScalarFieldEnum>
  }

  /**
   * HSExampleImageModel findFirst
   */
  export interface HSExampleImageModelFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends HSExampleImageModelFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HSExampleImageModel findFirstOrThrow
   */
  export type HSExampleImageModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HSExampleImageModel
     */
    select?: HSExampleImageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSExampleImageModelInclude<ExtArgs> | null
    /**
     * Filter, which HSExampleImageModel to fetch.
     */
    where?: HSExampleImageModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HSExampleImageModels to fetch.
     */
    orderBy?: Enumerable<HSExampleImageModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HSExampleImageModels.
     */
    cursor?: HSExampleImageModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HSExampleImageModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HSExampleImageModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HSExampleImageModels.
     */
    distinct?: Enumerable<HSExampleImageModelScalarFieldEnum>
  }


  /**
   * HSExampleImageModel findMany
   */
  export type HSExampleImageModelFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HSExampleImageModel
     */
    select?: HSExampleImageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSExampleImageModelInclude<ExtArgs> | null
    /**
     * Filter, which HSExampleImageModels to fetch.
     */
    where?: HSExampleImageModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HSExampleImageModels to fetch.
     */
    orderBy?: Enumerable<HSExampleImageModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HSExampleImageModels.
     */
    cursor?: HSExampleImageModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HSExampleImageModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HSExampleImageModels.
     */
    skip?: number
    distinct?: Enumerable<HSExampleImageModelScalarFieldEnum>
  }


  /**
   * HSExampleImageModel create
   */
  export type HSExampleImageModelCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HSExampleImageModel
     */
    select?: HSExampleImageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSExampleImageModelInclude<ExtArgs> | null
    /**
     * The data needed to create a HSExampleImageModel.
     */
    data: XOR<HSExampleImageModelCreateInput, HSExampleImageModelUncheckedCreateInput>
  }


  /**
   * HSExampleImageModel createMany
   */
  export type HSExampleImageModelCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HSExampleImageModels.
     */
    data: Enumerable<HSExampleImageModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * HSExampleImageModel update
   */
  export type HSExampleImageModelUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HSExampleImageModel
     */
    select?: HSExampleImageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSExampleImageModelInclude<ExtArgs> | null
    /**
     * The data needed to update a HSExampleImageModel.
     */
    data: XOR<HSExampleImageModelUpdateInput, HSExampleImageModelUncheckedUpdateInput>
    /**
     * Choose, which HSExampleImageModel to update.
     */
    where: HSExampleImageModelWhereUniqueInput
  }


  /**
   * HSExampleImageModel updateMany
   */
  export type HSExampleImageModelUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HSExampleImageModels.
     */
    data: XOR<HSExampleImageModelUpdateManyMutationInput, HSExampleImageModelUncheckedUpdateManyInput>
    /**
     * Filter which HSExampleImageModels to update
     */
    where?: HSExampleImageModelWhereInput
  }


  /**
   * HSExampleImageModel upsert
   */
  export type HSExampleImageModelUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HSExampleImageModel
     */
    select?: HSExampleImageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSExampleImageModelInclude<ExtArgs> | null
    /**
     * The filter to search for the HSExampleImageModel to update in case it exists.
     */
    where: HSExampleImageModelWhereUniqueInput
    /**
     * In case the HSExampleImageModel found by the `where` argument doesn't exist, create a new HSExampleImageModel with this data.
     */
    create: XOR<HSExampleImageModelCreateInput, HSExampleImageModelUncheckedCreateInput>
    /**
     * In case the HSExampleImageModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HSExampleImageModelUpdateInput, HSExampleImageModelUncheckedUpdateInput>
  }


  /**
   * HSExampleImageModel delete
   */
  export type HSExampleImageModelDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HSExampleImageModel
     */
    select?: HSExampleImageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSExampleImageModelInclude<ExtArgs> | null
    /**
     * Filter which HSExampleImageModel to delete.
     */
    where: HSExampleImageModelWhereUniqueInput
  }


  /**
   * HSExampleImageModel deleteMany
   */
  export type HSExampleImageModelDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which HSExampleImageModels to delete
     */
    where?: HSExampleImageModelWhereInput
  }


  /**
   * HSExampleImageModel without action
   */
  export type HSExampleImageModelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HSExampleImageModel
     */
    select?: HSExampleImageModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HSExampleImageModelInclude<ExtArgs> | null
  }



  /**
   * Model OauthAccountModel
   */


  export type AggregateOauthAccountModel = {
    _count: OauthAccountModelCountAggregateOutputType | null
    _min: OauthAccountModelMinAggregateOutputType | null
    _max: OauthAccountModelMaxAggregateOutputType | null
  }

  export type OauthAccountModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    oauth_type: OauthType | null
    oauth_sub: string | null
    business_user_id: string | null
    customer_id: string | null
    name: string | null
    email: string | null
    phone: string | null
    profile_image_url: string | null
    birth: string | null
    gender: GenderType | null
    address_first: string | null
    address_second: string | null
  }

  export type OauthAccountModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    oauth_type: OauthType | null
    oauth_sub: string | null
    business_user_id: string | null
    customer_id: string | null
    name: string | null
    email: string | null
    phone: string | null
    profile_image_url: string | null
    birth: string | null
    gender: GenderType | null
    address_first: string | null
    address_second: string | null
  }

  export type OauthAccountModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    oauth_type: number
    oauth_sub: number
    business_user_id: number
    customer_id: number
    name: number
    email: number
    phone: number
    profile_image_url: number
    birth: number
    gender: number
    address_first: number
    address_second: number
    _all: number
  }


  export type OauthAccountModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    oauth_type?: true
    oauth_sub?: true
    business_user_id?: true
    customer_id?: true
    name?: true
    email?: true
    phone?: true
    profile_image_url?: true
    birth?: true
    gender?: true
    address_first?: true
    address_second?: true
  }

  export type OauthAccountModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    oauth_type?: true
    oauth_sub?: true
    business_user_id?: true
    customer_id?: true
    name?: true
    email?: true
    phone?: true
    profile_image_url?: true
    birth?: true
    gender?: true
    address_first?: true
    address_second?: true
  }

  export type OauthAccountModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    oauth_type?: true
    oauth_sub?: true
    business_user_id?: true
    customer_id?: true
    name?: true
    email?: true
    phone?: true
    profile_image_url?: true
    birth?: true
    gender?: true
    address_first?: true
    address_second?: true
    _all?: true
  }

  export type OauthAccountModelAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OauthAccountModel to aggregate.
     */
    where?: OauthAccountModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OauthAccountModels to fetch.
     */
    orderBy?: Enumerable<OauthAccountModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OauthAccountModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OauthAccountModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OauthAccountModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OauthAccountModels
    **/
    _count?: true | OauthAccountModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OauthAccountModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OauthAccountModelMaxAggregateInputType
  }

  export type GetOauthAccountModelAggregateType<T extends OauthAccountModelAggregateArgs> = {
        [P in keyof T & keyof AggregateOauthAccountModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOauthAccountModel[P]>
      : GetScalarType<T[P], AggregateOauthAccountModel[P]>
  }




  export type OauthAccountModelGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OauthAccountModelWhereInput
    orderBy?: Enumerable<OauthAccountModelOrderByWithAggregationInput>
    by: OauthAccountModelScalarFieldEnum[]
    having?: OauthAccountModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OauthAccountModelCountAggregateInputType | true
    _min?: OauthAccountModelMinAggregateInputType
    _max?: OauthAccountModelMaxAggregateInputType
  }


  export type OauthAccountModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    oauth_type: OauthType
    oauth_sub: string
    business_user_id: string | null
    customer_id: string | null
    name: string | null
    email: string | null
    phone: string | null
    profile_image_url: string | null
    birth: string | null
    gender: GenderType | null
    address_first: string | null
    address_second: string | null
    _count: OauthAccountModelCountAggregateOutputType | null
    _min: OauthAccountModelMinAggregateOutputType | null
    _max: OauthAccountModelMaxAggregateOutputType | null
  }

  type GetOauthAccountModelGroupByPayload<T extends OauthAccountModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OauthAccountModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OauthAccountModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OauthAccountModelGroupByOutputType[P]>
            : GetScalarType<T[P], OauthAccountModelGroupByOutputType[P]>
        }
      >
    >


  export type OauthAccountModelSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    oauth_type?: boolean
    oauth_sub?: boolean
    business_user_id?: boolean
    customer_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    profile_image_url?: boolean
    birth?: boolean
    gender?: boolean
    address_first?: boolean
    address_second?: boolean
    business_user?: boolean | BusinessUserModelArgs<ExtArgs>
    customer?: boolean | CustomerModelArgs<ExtArgs>
  }, ExtArgs["result"]["oauthAccountModel"]>

  export type OauthAccountModelSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    oauth_type?: boolean
    oauth_sub?: boolean
    business_user_id?: boolean
    customer_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    profile_image_url?: boolean
    birth?: boolean
    gender?: boolean
    address_first?: boolean
    address_second?: boolean
  }

  export type OauthAccountModelInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    business_user?: boolean | BusinessUserModelArgs<ExtArgs>
    customer?: boolean | CustomerModelArgs<ExtArgs>
  }


  type OauthAccountModelGetPayload<S extends boolean | null | undefined | OauthAccountModelArgs> = $Types.GetResult<OauthAccountModelPayload, S>

  type OauthAccountModelCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OauthAccountModelFindManyArgs, 'select' | 'include'> & {
      select?: OauthAccountModelCountAggregateInputType | true
    }

  export interface OauthAccountModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OauthAccountModel'], meta: { name: 'OauthAccountModel' } }
    /**
     * Find zero or one OauthAccountModel that matches the filter.
     * @param {OauthAccountModelFindUniqueArgs} args - Arguments to find a OauthAccountModel
     * @example
     * // Get one OauthAccountModel
     * const oauthAccountModel = await prisma.oauthAccountModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OauthAccountModelFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OauthAccountModelFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OauthAccountModel'> extends True ? Prisma__OauthAccountModelClient<$Types.GetResult<OauthAccountModelPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__OauthAccountModelClient<$Types.GetResult<OauthAccountModelPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one OauthAccountModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OauthAccountModelFindUniqueOrThrowArgs} args - Arguments to find a OauthAccountModel
     * @example
     * // Get one OauthAccountModel
     * const oauthAccountModel = await prisma.oauthAccountModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OauthAccountModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OauthAccountModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OauthAccountModelClient<$Types.GetResult<OauthAccountModelPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first OauthAccountModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OauthAccountModelFindFirstArgs} args - Arguments to find a OauthAccountModel
     * @example
     * // Get one OauthAccountModel
     * const oauthAccountModel = await prisma.oauthAccountModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OauthAccountModelFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OauthAccountModelFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OauthAccountModel'> extends True ? Prisma__OauthAccountModelClient<$Types.GetResult<OauthAccountModelPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__OauthAccountModelClient<$Types.GetResult<OauthAccountModelPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first OauthAccountModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OauthAccountModelFindFirstOrThrowArgs} args - Arguments to find a OauthAccountModel
     * @example
     * // Get one OauthAccountModel
     * const oauthAccountModel = await prisma.oauthAccountModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OauthAccountModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OauthAccountModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OauthAccountModelClient<$Types.GetResult<OauthAccountModelPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more OauthAccountModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OauthAccountModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OauthAccountModels
     * const oauthAccountModels = await prisma.oauthAccountModel.findMany()
     * 
     * // Get first 10 OauthAccountModels
     * const oauthAccountModels = await prisma.oauthAccountModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oauthAccountModelWithIdOnly = await prisma.oauthAccountModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OauthAccountModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OauthAccountModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<OauthAccountModelPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a OauthAccountModel.
     * @param {OauthAccountModelCreateArgs} args - Arguments to create a OauthAccountModel.
     * @example
     * // Create one OauthAccountModel
     * const OauthAccountModel = await prisma.oauthAccountModel.create({
     *   data: {
     *     // ... data to create a OauthAccountModel
     *   }
     * })
     * 
    **/
    create<T extends OauthAccountModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OauthAccountModelCreateArgs<ExtArgs>>
    ): Prisma__OauthAccountModelClient<$Types.GetResult<OauthAccountModelPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many OauthAccountModels.
     *     @param {OauthAccountModelCreateManyArgs} args - Arguments to create many OauthAccountModels.
     *     @example
     *     // Create many OauthAccountModels
     *     const oauthAccountModel = await prisma.oauthAccountModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OauthAccountModelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OauthAccountModelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OauthAccountModel.
     * @param {OauthAccountModelDeleteArgs} args - Arguments to delete one OauthAccountModel.
     * @example
     * // Delete one OauthAccountModel
     * const OauthAccountModel = await prisma.oauthAccountModel.delete({
     *   where: {
     *     // ... filter to delete one OauthAccountModel
     *   }
     * })
     * 
    **/
    delete<T extends OauthAccountModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OauthAccountModelDeleteArgs<ExtArgs>>
    ): Prisma__OauthAccountModelClient<$Types.GetResult<OauthAccountModelPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one OauthAccountModel.
     * @param {OauthAccountModelUpdateArgs} args - Arguments to update one OauthAccountModel.
     * @example
     * // Update one OauthAccountModel
     * const oauthAccountModel = await prisma.oauthAccountModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OauthAccountModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OauthAccountModelUpdateArgs<ExtArgs>>
    ): Prisma__OauthAccountModelClient<$Types.GetResult<OauthAccountModelPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more OauthAccountModels.
     * @param {OauthAccountModelDeleteManyArgs} args - Arguments to filter OauthAccountModels to delete.
     * @example
     * // Delete a few OauthAccountModels
     * const { count } = await prisma.oauthAccountModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OauthAccountModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OauthAccountModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OauthAccountModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OauthAccountModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OauthAccountModels
     * const oauthAccountModel = await prisma.oauthAccountModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OauthAccountModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OauthAccountModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OauthAccountModel.
     * @param {OauthAccountModelUpsertArgs} args - Arguments to update or create a OauthAccountModel.
     * @example
     * // Update or create a OauthAccountModel
     * const oauthAccountModel = await prisma.oauthAccountModel.upsert({
     *   create: {
     *     // ... data to create a OauthAccountModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OauthAccountModel we want to update
     *   }
     * })
    **/
    upsert<T extends OauthAccountModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OauthAccountModelUpsertArgs<ExtArgs>>
    ): Prisma__OauthAccountModelClient<$Types.GetResult<OauthAccountModelPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of OauthAccountModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OauthAccountModelCountArgs} args - Arguments to filter OauthAccountModels to count.
     * @example
     * // Count the number of OauthAccountModels
     * const count = await prisma.oauthAccountModel.count({
     *   where: {
     *     // ... the filter for the OauthAccountModels we want to count
     *   }
     * })
    **/
    count<T extends OauthAccountModelCountArgs>(
      args?: Subset<T, OauthAccountModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OauthAccountModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OauthAccountModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OauthAccountModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OauthAccountModelAggregateArgs>(args: Subset<T, OauthAccountModelAggregateArgs>): Prisma.PrismaPromise<GetOauthAccountModelAggregateType<T>>

    /**
     * Group by OauthAccountModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OauthAccountModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OauthAccountModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OauthAccountModelGroupByArgs['orderBy'] }
        : { orderBy?: OauthAccountModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OauthAccountModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOauthAccountModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OauthAccountModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OauthAccountModelClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    business_user<T extends BusinessUserModelArgs<ExtArgs> = {}>(args?: Subset<T, BusinessUserModelArgs<ExtArgs>>): Prisma__BusinessUserModelClient<$Types.GetResult<BusinessUserModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    customer<T extends CustomerModelArgs<ExtArgs> = {}>(args?: Subset<T, CustomerModelArgs<ExtArgs>>): Prisma__CustomerModelClient<$Types.GetResult<CustomerModelPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OauthAccountModel base type for findUnique actions
   */
  export type OauthAccountModelFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OauthAccountModel
     */
    select?: OauthAccountModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OauthAccountModelInclude<ExtArgs> | null
    /**
     * Filter, which OauthAccountModel to fetch.
     */
    where: OauthAccountModelWhereUniqueInput
  }

  /**
   * OauthAccountModel findUnique
   */
  export interface OauthAccountModelFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OauthAccountModelFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OauthAccountModel findUniqueOrThrow
   */
  export type OauthAccountModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OauthAccountModel
     */
    select?: OauthAccountModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OauthAccountModelInclude<ExtArgs> | null
    /**
     * Filter, which OauthAccountModel to fetch.
     */
    where: OauthAccountModelWhereUniqueInput
  }


  /**
   * OauthAccountModel base type for findFirst actions
   */
  export type OauthAccountModelFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OauthAccountModel
     */
    select?: OauthAccountModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OauthAccountModelInclude<ExtArgs> | null
    /**
     * Filter, which OauthAccountModel to fetch.
     */
    where?: OauthAccountModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OauthAccountModels to fetch.
     */
    orderBy?: Enumerable<OauthAccountModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OauthAccountModels.
     */
    cursor?: OauthAccountModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OauthAccountModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OauthAccountModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OauthAccountModels.
     */
    distinct?: Enumerable<OauthAccountModelScalarFieldEnum>
  }

  /**
   * OauthAccountModel findFirst
   */
  export interface OauthAccountModelFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OauthAccountModelFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OauthAccountModel findFirstOrThrow
   */
  export type OauthAccountModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OauthAccountModel
     */
    select?: OauthAccountModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OauthAccountModelInclude<ExtArgs> | null
    /**
     * Filter, which OauthAccountModel to fetch.
     */
    where?: OauthAccountModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OauthAccountModels to fetch.
     */
    orderBy?: Enumerable<OauthAccountModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OauthAccountModels.
     */
    cursor?: OauthAccountModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OauthAccountModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OauthAccountModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OauthAccountModels.
     */
    distinct?: Enumerable<OauthAccountModelScalarFieldEnum>
  }


  /**
   * OauthAccountModel findMany
   */
  export type OauthAccountModelFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OauthAccountModel
     */
    select?: OauthAccountModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OauthAccountModelInclude<ExtArgs> | null
    /**
     * Filter, which OauthAccountModels to fetch.
     */
    where?: OauthAccountModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OauthAccountModels to fetch.
     */
    orderBy?: Enumerable<OauthAccountModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OauthAccountModels.
     */
    cursor?: OauthAccountModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OauthAccountModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OauthAccountModels.
     */
    skip?: number
    distinct?: Enumerable<OauthAccountModelScalarFieldEnum>
  }


  /**
   * OauthAccountModel create
   */
  export type OauthAccountModelCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OauthAccountModel
     */
    select?: OauthAccountModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OauthAccountModelInclude<ExtArgs> | null
    /**
     * The data needed to create a OauthAccountModel.
     */
    data: XOR<OauthAccountModelCreateInput, OauthAccountModelUncheckedCreateInput>
  }


  /**
   * OauthAccountModel createMany
   */
  export type OauthAccountModelCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OauthAccountModels.
     */
    data: Enumerable<OauthAccountModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OauthAccountModel update
   */
  export type OauthAccountModelUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OauthAccountModel
     */
    select?: OauthAccountModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OauthAccountModelInclude<ExtArgs> | null
    /**
     * The data needed to update a OauthAccountModel.
     */
    data: XOR<OauthAccountModelUpdateInput, OauthAccountModelUncheckedUpdateInput>
    /**
     * Choose, which OauthAccountModel to update.
     */
    where: OauthAccountModelWhereUniqueInput
  }


  /**
   * OauthAccountModel updateMany
   */
  export type OauthAccountModelUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OauthAccountModels.
     */
    data: XOR<OauthAccountModelUpdateManyMutationInput, OauthAccountModelUncheckedUpdateManyInput>
    /**
     * Filter which OauthAccountModels to update
     */
    where?: OauthAccountModelWhereInput
  }


  /**
   * OauthAccountModel upsert
   */
  export type OauthAccountModelUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OauthAccountModel
     */
    select?: OauthAccountModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OauthAccountModelInclude<ExtArgs> | null
    /**
     * The filter to search for the OauthAccountModel to update in case it exists.
     */
    where: OauthAccountModelWhereUniqueInput
    /**
     * In case the OauthAccountModel found by the `where` argument doesn't exist, create a new OauthAccountModel with this data.
     */
    create: XOR<OauthAccountModelCreateInput, OauthAccountModelUncheckedCreateInput>
    /**
     * In case the OauthAccountModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OauthAccountModelUpdateInput, OauthAccountModelUncheckedUpdateInput>
  }


  /**
   * OauthAccountModel delete
   */
  export type OauthAccountModelDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OauthAccountModel
     */
    select?: OauthAccountModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OauthAccountModelInclude<ExtArgs> | null
    /**
     * Filter which OauthAccountModel to delete.
     */
    where: OauthAccountModelWhereUniqueInput
  }


  /**
   * OauthAccountModel deleteMany
   */
  export type OauthAccountModelDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OauthAccountModels to delete
     */
    where?: OauthAccountModelWhereInput
  }


  /**
   * OauthAccountModel without action
   */
  export type OauthAccountModelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OauthAccountModel
     */
    select?: OauthAccountModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OauthAccountModelInclude<ExtArgs> | null
  }



  /**
   * Model PhoneVerificationModel
   */


  export type AggregatePhoneVerificationModel = {
    _count: PhoneVerificationModelCountAggregateOutputType | null
    _min: PhoneVerificationModelMinAggregateOutputType | null
    _max: PhoneVerificationModelMaxAggregateOutputType | null
  }

  export type PhoneVerificationModelMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    phone: string | null
    code: string | null
    request_id: string | null
    is_verified: boolean | null
  }

  export type PhoneVerificationModelMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    phone: string | null
    code: string | null
    request_id: string | null
    is_verified: boolean | null
  }

  export type PhoneVerificationModelCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    is_deleted: number
    deleted_at: number
    phone: number
    code: number
    request_id: number
    is_verified: number
    _all: number
  }


  export type PhoneVerificationModelMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    phone?: true
    code?: true
    request_id?: true
    is_verified?: true
  }

  export type PhoneVerificationModelMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    phone?: true
    code?: true
    request_id?: true
    is_verified?: true
  }

  export type PhoneVerificationModelCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    is_deleted?: true
    deleted_at?: true
    phone?: true
    code?: true
    request_id?: true
    is_verified?: true
    _all?: true
  }

  export type PhoneVerificationModelAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhoneVerificationModel to aggregate.
     */
    where?: PhoneVerificationModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhoneVerificationModels to fetch.
     */
    orderBy?: Enumerable<PhoneVerificationModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhoneVerificationModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhoneVerificationModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhoneVerificationModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhoneVerificationModels
    **/
    _count?: true | PhoneVerificationModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhoneVerificationModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhoneVerificationModelMaxAggregateInputType
  }

  export type GetPhoneVerificationModelAggregateType<T extends PhoneVerificationModelAggregateArgs> = {
        [P in keyof T & keyof AggregatePhoneVerificationModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhoneVerificationModel[P]>
      : GetScalarType<T[P], AggregatePhoneVerificationModel[P]>
  }




  export type PhoneVerificationModelGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PhoneVerificationModelWhereInput
    orderBy?: Enumerable<PhoneVerificationModelOrderByWithAggregationInput>
    by: PhoneVerificationModelScalarFieldEnum[]
    having?: PhoneVerificationModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhoneVerificationModelCountAggregateInputType | true
    _min?: PhoneVerificationModelMinAggregateInputType
    _max?: PhoneVerificationModelMaxAggregateInputType
  }


  export type PhoneVerificationModelGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    is_deleted: boolean
    deleted_at: Date | null
    phone: string
    code: string
    request_id: string
    is_verified: boolean
    _count: PhoneVerificationModelCountAggregateOutputType | null
    _min: PhoneVerificationModelMinAggregateOutputType | null
    _max: PhoneVerificationModelMaxAggregateOutputType | null
  }

  type GetPhoneVerificationModelGroupByPayload<T extends PhoneVerificationModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PhoneVerificationModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhoneVerificationModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhoneVerificationModelGroupByOutputType[P]>
            : GetScalarType<T[P], PhoneVerificationModelGroupByOutputType[P]>
        }
      >
    >


  export type PhoneVerificationModelSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    phone?: boolean
    code?: boolean
    request_id?: boolean
    is_verified?: boolean
  }, ExtArgs["result"]["phoneVerificationModel"]>

  export type PhoneVerificationModelSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    phone?: boolean
    code?: boolean
    request_id?: boolean
    is_verified?: boolean
  }


  type PhoneVerificationModelGetPayload<S extends boolean | null | undefined | PhoneVerificationModelArgs> = $Types.GetResult<PhoneVerificationModelPayload, S>

  type PhoneVerificationModelCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PhoneVerificationModelFindManyArgs, 'select' | 'include'> & {
      select?: PhoneVerificationModelCountAggregateInputType | true
    }

  export interface PhoneVerificationModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PhoneVerificationModel'], meta: { name: 'PhoneVerificationModel' } }
    /**
     * Find zero or one PhoneVerificationModel that matches the filter.
     * @param {PhoneVerificationModelFindUniqueArgs} args - Arguments to find a PhoneVerificationModel
     * @example
     * // Get one PhoneVerificationModel
     * const phoneVerificationModel = await prisma.phoneVerificationModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PhoneVerificationModelFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PhoneVerificationModelFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PhoneVerificationModel'> extends True ? Prisma__PhoneVerificationModelClient<$Types.GetResult<PhoneVerificationModelPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PhoneVerificationModelClient<$Types.GetResult<PhoneVerificationModelPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one PhoneVerificationModel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PhoneVerificationModelFindUniqueOrThrowArgs} args - Arguments to find a PhoneVerificationModel
     * @example
     * // Get one PhoneVerificationModel
     * const phoneVerificationModel = await prisma.phoneVerificationModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PhoneVerificationModelFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PhoneVerificationModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PhoneVerificationModelClient<$Types.GetResult<PhoneVerificationModelPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first PhoneVerificationModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationModelFindFirstArgs} args - Arguments to find a PhoneVerificationModel
     * @example
     * // Get one PhoneVerificationModel
     * const phoneVerificationModel = await prisma.phoneVerificationModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PhoneVerificationModelFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PhoneVerificationModelFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PhoneVerificationModel'> extends True ? Prisma__PhoneVerificationModelClient<$Types.GetResult<PhoneVerificationModelPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PhoneVerificationModelClient<$Types.GetResult<PhoneVerificationModelPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first PhoneVerificationModel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationModelFindFirstOrThrowArgs} args - Arguments to find a PhoneVerificationModel
     * @example
     * // Get one PhoneVerificationModel
     * const phoneVerificationModel = await prisma.phoneVerificationModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PhoneVerificationModelFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PhoneVerificationModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PhoneVerificationModelClient<$Types.GetResult<PhoneVerificationModelPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more PhoneVerificationModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhoneVerificationModels
     * const phoneVerificationModels = await prisma.phoneVerificationModel.findMany()
     * 
     * // Get first 10 PhoneVerificationModels
     * const phoneVerificationModels = await prisma.phoneVerificationModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phoneVerificationModelWithIdOnly = await prisma.phoneVerificationModel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PhoneVerificationModelFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PhoneVerificationModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PhoneVerificationModelPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a PhoneVerificationModel.
     * @param {PhoneVerificationModelCreateArgs} args - Arguments to create a PhoneVerificationModel.
     * @example
     * // Create one PhoneVerificationModel
     * const PhoneVerificationModel = await prisma.phoneVerificationModel.create({
     *   data: {
     *     // ... data to create a PhoneVerificationModel
     *   }
     * })
     * 
    **/
    create<T extends PhoneVerificationModelCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PhoneVerificationModelCreateArgs<ExtArgs>>
    ): Prisma__PhoneVerificationModelClient<$Types.GetResult<PhoneVerificationModelPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many PhoneVerificationModels.
     *     @param {PhoneVerificationModelCreateManyArgs} args - Arguments to create many PhoneVerificationModels.
     *     @example
     *     // Create many PhoneVerificationModels
     *     const phoneVerificationModel = await prisma.phoneVerificationModel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PhoneVerificationModelCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PhoneVerificationModelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PhoneVerificationModel.
     * @param {PhoneVerificationModelDeleteArgs} args - Arguments to delete one PhoneVerificationModel.
     * @example
     * // Delete one PhoneVerificationModel
     * const PhoneVerificationModel = await prisma.phoneVerificationModel.delete({
     *   where: {
     *     // ... filter to delete one PhoneVerificationModel
     *   }
     * })
     * 
    **/
    delete<T extends PhoneVerificationModelDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PhoneVerificationModelDeleteArgs<ExtArgs>>
    ): Prisma__PhoneVerificationModelClient<$Types.GetResult<PhoneVerificationModelPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one PhoneVerificationModel.
     * @param {PhoneVerificationModelUpdateArgs} args - Arguments to update one PhoneVerificationModel.
     * @example
     * // Update one PhoneVerificationModel
     * const phoneVerificationModel = await prisma.phoneVerificationModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PhoneVerificationModelUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PhoneVerificationModelUpdateArgs<ExtArgs>>
    ): Prisma__PhoneVerificationModelClient<$Types.GetResult<PhoneVerificationModelPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more PhoneVerificationModels.
     * @param {PhoneVerificationModelDeleteManyArgs} args - Arguments to filter PhoneVerificationModels to delete.
     * @example
     * // Delete a few PhoneVerificationModels
     * const { count } = await prisma.phoneVerificationModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PhoneVerificationModelDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PhoneVerificationModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhoneVerificationModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhoneVerificationModels
     * const phoneVerificationModel = await prisma.phoneVerificationModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PhoneVerificationModelUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PhoneVerificationModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PhoneVerificationModel.
     * @param {PhoneVerificationModelUpsertArgs} args - Arguments to update or create a PhoneVerificationModel.
     * @example
     * // Update or create a PhoneVerificationModel
     * const phoneVerificationModel = await prisma.phoneVerificationModel.upsert({
     *   create: {
     *     // ... data to create a PhoneVerificationModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhoneVerificationModel we want to update
     *   }
     * })
    **/
    upsert<T extends PhoneVerificationModelUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PhoneVerificationModelUpsertArgs<ExtArgs>>
    ): Prisma__PhoneVerificationModelClient<$Types.GetResult<PhoneVerificationModelPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of PhoneVerificationModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationModelCountArgs} args - Arguments to filter PhoneVerificationModels to count.
     * @example
     * // Count the number of PhoneVerificationModels
     * const count = await prisma.phoneVerificationModel.count({
     *   where: {
     *     // ... the filter for the PhoneVerificationModels we want to count
     *   }
     * })
    **/
    count<T extends PhoneVerificationModelCountArgs>(
      args?: Subset<T, PhoneVerificationModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhoneVerificationModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhoneVerificationModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhoneVerificationModelAggregateArgs>(args: Subset<T, PhoneVerificationModelAggregateArgs>): Prisma.PrismaPromise<GetPhoneVerificationModelAggregateType<T>>

    /**
     * Group by PhoneVerificationModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhoneVerificationModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhoneVerificationModelGroupByArgs['orderBy'] }
        : { orderBy?: PhoneVerificationModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhoneVerificationModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhoneVerificationModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PhoneVerificationModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PhoneVerificationModelClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PhoneVerificationModel base type for findUnique actions
   */
  export type PhoneVerificationModelFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerificationModel
     */
    select?: PhoneVerificationModelSelect<ExtArgs> | null
    /**
     * Filter, which PhoneVerificationModel to fetch.
     */
    where: PhoneVerificationModelWhereUniqueInput
  }

  /**
   * PhoneVerificationModel findUnique
   */
  export interface PhoneVerificationModelFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PhoneVerificationModelFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PhoneVerificationModel findUniqueOrThrow
   */
  export type PhoneVerificationModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerificationModel
     */
    select?: PhoneVerificationModelSelect<ExtArgs> | null
    /**
     * Filter, which PhoneVerificationModel to fetch.
     */
    where: PhoneVerificationModelWhereUniqueInput
  }


  /**
   * PhoneVerificationModel base type for findFirst actions
   */
  export type PhoneVerificationModelFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerificationModel
     */
    select?: PhoneVerificationModelSelect<ExtArgs> | null
    /**
     * Filter, which PhoneVerificationModel to fetch.
     */
    where?: PhoneVerificationModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhoneVerificationModels to fetch.
     */
    orderBy?: Enumerable<PhoneVerificationModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhoneVerificationModels.
     */
    cursor?: PhoneVerificationModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhoneVerificationModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhoneVerificationModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhoneVerificationModels.
     */
    distinct?: Enumerable<PhoneVerificationModelScalarFieldEnum>
  }

  /**
   * PhoneVerificationModel findFirst
   */
  export interface PhoneVerificationModelFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PhoneVerificationModelFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PhoneVerificationModel findFirstOrThrow
   */
  export type PhoneVerificationModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerificationModel
     */
    select?: PhoneVerificationModelSelect<ExtArgs> | null
    /**
     * Filter, which PhoneVerificationModel to fetch.
     */
    where?: PhoneVerificationModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhoneVerificationModels to fetch.
     */
    orderBy?: Enumerable<PhoneVerificationModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhoneVerificationModels.
     */
    cursor?: PhoneVerificationModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhoneVerificationModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhoneVerificationModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhoneVerificationModels.
     */
    distinct?: Enumerable<PhoneVerificationModelScalarFieldEnum>
  }


  /**
   * PhoneVerificationModel findMany
   */
  export type PhoneVerificationModelFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerificationModel
     */
    select?: PhoneVerificationModelSelect<ExtArgs> | null
    /**
     * Filter, which PhoneVerificationModels to fetch.
     */
    where?: PhoneVerificationModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhoneVerificationModels to fetch.
     */
    orderBy?: Enumerable<PhoneVerificationModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhoneVerificationModels.
     */
    cursor?: PhoneVerificationModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhoneVerificationModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhoneVerificationModels.
     */
    skip?: number
    distinct?: Enumerable<PhoneVerificationModelScalarFieldEnum>
  }


  /**
   * PhoneVerificationModel create
   */
  export type PhoneVerificationModelCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerificationModel
     */
    select?: PhoneVerificationModelSelect<ExtArgs> | null
    /**
     * The data needed to create a PhoneVerificationModel.
     */
    data: XOR<PhoneVerificationModelCreateInput, PhoneVerificationModelUncheckedCreateInput>
  }


  /**
   * PhoneVerificationModel createMany
   */
  export type PhoneVerificationModelCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PhoneVerificationModels.
     */
    data: Enumerable<PhoneVerificationModelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PhoneVerificationModel update
   */
  export type PhoneVerificationModelUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerificationModel
     */
    select?: PhoneVerificationModelSelect<ExtArgs> | null
    /**
     * The data needed to update a PhoneVerificationModel.
     */
    data: XOR<PhoneVerificationModelUpdateInput, PhoneVerificationModelUncheckedUpdateInput>
    /**
     * Choose, which PhoneVerificationModel to update.
     */
    where: PhoneVerificationModelWhereUniqueInput
  }


  /**
   * PhoneVerificationModel updateMany
   */
  export type PhoneVerificationModelUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PhoneVerificationModels.
     */
    data: XOR<PhoneVerificationModelUpdateManyMutationInput, PhoneVerificationModelUncheckedUpdateManyInput>
    /**
     * Filter which PhoneVerificationModels to update
     */
    where?: PhoneVerificationModelWhereInput
  }


  /**
   * PhoneVerificationModel upsert
   */
  export type PhoneVerificationModelUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerificationModel
     */
    select?: PhoneVerificationModelSelect<ExtArgs> | null
    /**
     * The filter to search for the PhoneVerificationModel to update in case it exists.
     */
    where: PhoneVerificationModelWhereUniqueInput
    /**
     * In case the PhoneVerificationModel found by the `where` argument doesn't exist, create a new PhoneVerificationModel with this data.
     */
    create: XOR<PhoneVerificationModelCreateInput, PhoneVerificationModelUncheckedCreateInput>
    /**
     * In case the PhoneVerificationModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhoneVerificationModelUpdateInput, PhoneVerificationModelUncheckedUpdateInput>
  }


  /**
   * PhoneVerificationModel delete
   */
  export type PhoneVerificationModelDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerificationModel
     */
    select?: PhoneVerificationModelSelect<ExtArgs> | null
    /**
     * Filter which PhoneVerificationModel to delete.
     */
    where: PhoneVerificationModelWhereUniqueInput
  }


  /**
   * PhoneVerificationModel deleteMany
   */
  export type PhoneVerificationModelDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhoneVerificationModels to delete
     */
    where?: PhoneVerificationModelWhereInput
  }


  /**
   * PhoneVerificationModel without action
   */
  export type PhoneVerificationModelArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerificationModel
     */
    select?: PhoneVerificationModelSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const REPropertyModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    name: 'name',
    main_image_url: 'main_image_url',
    re_agent_id: 're_agent_id',
    is_visible: 'is_visible'
  };

  export type REPropertyModelScalarFieldEnum = (typeof REPropertyModelScalarFieldEnum)[keyof typeof REPropertyModelScalarFieldEnum]


  export const REPropertyCategoryModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    re_property_id: 're_property_id',
    sub_category_id: 'sub_category_id'
  };

  export type REPropertyCategoryModelScalarFieldEnum = (typeof REPropertyCategoryModelScalarFieldEnum)[keyof typeof REPropertyCategoryModelScalarFieldEnum]


  export const REPropertySubCategoryModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    name: 'name',
    middle_category_id: 'middle_category_id'
  };

  export type REPropertySubCategoryModelScalarFieldEnum = (typeof REPropertySubCategoryModelScalarFieldEnum)[keyof typeof REPropertySubCategoryModelScalarFieldEnum]


  export const REPropertyMiddleCategoryModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    name: 'name',
    super_category_id: 'super_category_id'
  };

  export type REPropertyMiddleCategoryModelScalarFieldEnum = (typeof REPropertyMiddleCategoryModelScalarFieldEnum)[keyof typeof REPropertyMiddleCategoryModelScalarFieldEnum]


  export const REPropertySuperCategoryModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    name: 'name'
  };

  export type REPropertySuperCategoryModelScalarFieldEnum = (typeof REPropertySuperCategoryModelScalarFieldEnum)[keyof typeof REPropertySuperCategoryModelScalarFieldEnum]


  export const AgreementModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    title: 'title',
    content: 'content',
    is_required: 'is_required',
    target_type: 'target_type'
  };

  export type AgreementModelScalarFieldEnum = (typeof AgreementModelScalarFieldEnum)[keyof typeof AgreementModelScalarFieldEnum]


  export const AgreementAcceptanceModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    user_id: 'user_id',
    agreement_id: 'agreement_id'
  };

  export type AgreementAcceptanceModelScalarFieldEnum = (typeof AgreementAcceptanceModelScalarFieldEnum)[keyof typeof AgreementAcceptanceModelScalarFieldEnum]


  export const ServiceSubCategoryModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    name: 'name',
    super_category_id: 'super_category_id'
  };

  export type ServiceSubCategoryModelScalarFieldEnum = (typeof ServiceSubCategoryModelScalarFieldEnum)[keyof typeof ServiceSubCategoryModelScalarFieldEnum]


  export const ServiceSuperCategoryModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    name: 'name',
    type: 'type'
  };

  export type ServiceSuperCategoryModelScalarFieldEnum = (typeof ServiceSuperCategoryModelScalarFieldEnum)[keyof typeof ServiceSuperCategoryModelScalarFieldEnum]


  export const ZipzoongCareRequestModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    care_start_date: 'care_start_date',
    care_end_date: 'care_end_date',
    detail: 'detail',
    status: 'status',
    requester_id: 'requester_id'
  };

  export type ZipzoongCareRequestModelScalarFieldEnum = (typeof ZipzoongCareRequestModelScalarFieldEnum)[keyof typeof ZipzoongCareRequestModelScalarFieldEnum]


  export const ZipzoongCareServiceCheckModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    service_super_category_id: 'service_super_category_id',
    request_id: 'request_id'
  };

  export type ZipzoongCareServiceCheckModelScalarFieldEnum = (typeof ZipzoongCareServiceCheckModelScalarFieldEnum)[keyof typeof ZipzoongCareServiceCheckModelScalarFieldEnum]


  export const ZipzoongCareConsultationTimeCheckModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    start_time: 'start_time',
    end_time: 'end_time',
    request_id: 'request_id'
  };

  export type ZipzoongCareConsultationTimeCheckModelScalarFieldEnum = (typeof ZipzoongCareConsultationTimeCheckModelScalarFieldEnum)[keyof typeof ZipzoongCareConsultationTimeCheckModelScalarFieldEnum]


  export const UserModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    name: 'name',
    email: 'email'
  };

  export type UserModelScalarFieldEnum = (typeof UserModelScalarFieldEnum)[keyof typeof UserModelScalarFieldEnum]


  export const CustomerModelScalarFieldEnum: {
    id: 'id',
    birth: 'birth',
    gender: 'gender',
    phone: 'phone',
    address_first: 'address_first',
    address_second: 'address_second',
    profile_image_url: 'profile_image_url'
  };

  export type CustomerModelScalarFieldEnum = (typeof CustomerModelScalarFieldEnum)[keyof typeof CustomerModelScalarFieldEnum]


  export const BusinessUserModelScalarFieldEnum: {
    id: 'id',
    is_verified: 'is_verified',
    introduction_title: 'introduction_title',
    introduction_content: 'introduction_content',
    phone: 'phone',
    address_first: 'address_first',
    address_second: 'address_second',
    profile_image_url: 'profile_image_url'
  };

  export type BusinessUserModelScalarFieldEnum = (typeof BusinessUserModelScalarFieldEnum)[keyof typeof BusinessUserModelScalarFieldEnum]


  export const SubExpertiseModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    sub_category_id: 'sub_category_id',
    business_user_id: 'business_user_id'
  };

  export type SubExpertiseModelScalarFieldEnum = (typeof SubExpertiseModelScalarFieldEnum)[keyof typeof SubExpertiseModelScalarFieldEnum]


  export const REAgentModelScalarFieldEnum: {
    id: 'id',
    is_licensed: 'is_licensed',
    re_num: 're_num',
    re_name: 're_name',
    re_phone: 're_phone',
    re_licensed_agent_name: 're_licensed_agent_name'
  };

  export type REAgentModelScalarFieldEnum = (typeof REAgentModelScalarFieldEnum)[keyof typeof REAgentModelScalarFieldEnum]


  export const HSProviderModelScalarFieldEnum: {
    id: 'id',
    business_registration_num: 'business_registration_num'
  };

  export type HSProviderModelScalarFieldEnum = (typeof HSProviderModelScalarFieldEnum)[keyof typeof HSProviderModelScalarFieldEnum]


  export const BusinessCertificationImageModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    business_user_id: 'business_user_id',
    url: 'url'
  };

  export type BusinessCertificationImageModelScalarFieldEnum = (typeof BusinessCertificationImageModelScalarFieldEnum)[keyof typeof BusinessCertificationImageModelScalarFieldEnum]


  export const HSExampleImageModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    hs_provider_id: 'hs_provider_id',
    url: 'url',
    is_visible: 'is_visible'
  };

  export type HSExampleImageModelScalarFieldEnum = (typeof HSExampleImageModelScalarFieldEnum)[keyof typeof HSExampleImageModelScalarFieldEnum]


  export const OauthAccountModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    oauth_type: 'oauth_type',
    oauth_sub: 'oauth_sub',
    business_user_id: 'business_user_id',
    customer_id: 'customer_id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    profile_image_url: 'profile_image_url',
    birth: 'birth',
    gender: 'gender',
    address_first: 'address_first',
    address_second: 'address_second'
  };

  export type OauthAccountModelScalarFieldEnum = (typeof OauthAccountModelScalarFieldEnum)[keyof typeof OauthAccountModelScalarFieldEnum]


  export const PhoneVerificationModelScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    phone: 'phone',
    code: 'code',
    request_id: 'request_id',
    is_verified: 'is_verified'
  };

  export type PhoneVerificationModelScalarFieldEnum = (typeof PhoneVerificationModelScalarFieldEnum)[keyof typeof PhoneVerificationModelScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Deep Input Types
   */


  export type REPropertyModelWhereInput = {
    AND?: Enumerable<REPropertyModelWhereInput>
    OR?: Enumerable<REPropertyModelWhereInput>
    NOT?: Enumerable<REPropertyModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    name?: StringFilter | string
    main_image_url?: StringFilter | string
    re_agent_id?: StringFilter | string
    is_visible?: BoolFilter | boolean
    re_agent?: XOR<REAgentModelRelationFilter, REAgentModelWhereInput>
    categories?: REPropertyCategoryModelListRelationFilter
  }

  export type REPropertyModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    name?: SortOrder
    main_image_url?: SortOrder
    re_agent_id?: SortOrder
    is_visible?: SortOrder
    re_agent?: REAgentModelOrderByWithRelationInput
    categories?: REPropertyCategoryModelOrderByRelationAggregateInput
  }

  export type REPropertyModelWhereUniqueInput = {
    id?: string
  }

  export type REPropertyModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    name?: SortOrder
    main_image_url?: SortOrder
    re_agent_id?: SortOrder
    is_visible?: SortOrder
    _count?: REPropertyModelCountOrderByAggregateInput
    _max?: REPropertyModelMaxOrderByAggregateInput
    _min?: REPropertyModelMinOrderByAggregateInput
  }

  export type REPropertyModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<REPropertyModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<REPropertyModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<REPropertyModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    name?: StringWithAggregatesFilter | string
    main_image_url?: StringWithAggregatesFilter | string
    re_agent_id?: StringWithAggregatesFilter | string
    is_visible?: BoolWithAggregatesFilter | boolean
  }

  export type REPropertyCategoryModelWhereInput = {
    AND?: Enumerable<REPropertyCategoryModelWhereInput>
    OR?: Enumerable<REPropertyCategoryModelWhereInput>
    NOT?: Enumerable<REPropertyCategoryModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    re_property_id?: StringFilter | string
    sub_category_id?: StringFilter | string
    re_property?: XOR<REPropertyModelRelationFilter, REPropertyModelWhereInput>
    sub_category?: XOR<REPropertySubCategoryModelRelationFilter, REPropertySubCategoryModelWhereInput>
  }

  export type REPropertyCategoryModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    re_property_id?: SortOrder
    sub_category_id?: SortOrder
    re_property?: REPropertyModelOrderByWithRelationInput
    sub_category?: REPropertySubCategoryModelOrderByWithRelationInput
  }

  export type REPropertyCategoryModelWhereUniqueInput = {
    id?: string
  }

  export type REPropertyCategoryModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    re_property_id?: SortOrder
    sub_category_id?: SortOrder
    _count?: REPropertyCategoryModelCountOrderByAggregateInput
    _max?: REPropertyCategoryModelMaxOrderByAggregateInput
    _min?: REPropertyCategoryModelMinOrderByAggregateInput
  }

  export type REPropertyCategoryModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<REPropertyCategoryModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<REPropertyCategoryModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<REPropertyCategoryModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    re_property_id?: StringWithAggregatesFilter | string
    sub_category_id?: StringWithAggregatesFilter | string
  }

  export type REPropertySubCategoryModelWhereInput = {
    AND?: Enumerable<REPropertySubCategoryModelWhereInput>
    OR?: Enumerable<REPropertySubCategoryModelWhereInput>
    NOT?: Enumerable<REPropertySubCategoryModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    name?: StringFilter | string
    middle_category_id?: StringFilter | string
    middle_category?: XOR<REPropertyMiddleCategoryModelRelationFilter, REPropertyMiddleCategoryModelWhereInput>
    property_categories?: REPropertyCategoryModelListRelationFilter
  }

  export type REPropertySubCategoryModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    name?: SortOrder
    middle_category_id?: SortOrder
    middle_category?: REPropertyMiddleCategoryModelOrderByWithRelationInput
    property_categories?: REPropertyCategoryModelOrderByRelationAggregateInput
  }

  export type REPropertySubCategoryModelWhereUniqueInput = {
    id?: string
  }

  export type REPropertySubCategoryModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    name?: SortOrder
    middle_category_id?: SortOrder
    _count?: REPropertySubCategoryModelCountOrderByAggregateInput
    _max?: REPropertySubCategoryModelMaxOrderByAggregateInput
    _min?: REPropertySubCategoryModelMinOrderByAggregateInput
  }

  export type REPropertySubCategoryModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<REPropertySubCategoryModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<REPropertySubCategoryModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<REPropertySubCategoryModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    name?: StringWithAggregatesFilter | string
    middle_category_id?: StringWithAggregatesFilter | string
  }

  export type REPropertyMiddleCategoryModelWhereInput = {
    AND?: Enumerable<REPropertyMiddleCategoryModelWhereInput>
    OR?: Enumerable<REPropertyMiddleCategoryModelWhereInput>
    NOT?: Enumerable<REPropertyMiddleCategoryModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    name?: StringFilter | string
    super_category_id?: StringFilter | string
    super_category?: XOR<REPropertySuperCategoryModelRelationFilter, REPropertySuperCategoryModelWhereInput>
    sub_categories?: REPropertySubCategoryModelListRelationFilter
  }

  export type REPropertyMiddleCategoryModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    name?: SortOrder
    super_category_id?: SortOrder
    super_category?: REPropertySuperCategoryModelOrderByWithRelationInput
    sub_categories?: REPropertySubCategoryModelOrderByRelationAggregateInput
  }

  export type REPropertyMiddleCategoryModelWhereUniqueInput = {
    id?: string
  }

  export type REPropertyMiddleCategoryModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    name?: SortOrder
    super_category_id?: SortOrder
    _count?: REPropertyMiddleCategoryModelCountOrderByAggregateInput
    _max?: REPropertyMiddleCategoryModelMaxOrderByAggregateInput
    _min?: REPropertyMiddleCategoryModelMinOrderByAggregateInput
  }

  export type REPropertyMiddleCategoryModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<REPropertyMiddleCategoryModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<REPropertyMiddleCategoryModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<REPropertyMiddleCategoryModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    name?: StringWithAggregatesFilter | string
    super_category_id?: StringWithAggregatesFilter | string
  }

  export type REPropertySuperCategoryModelWhereInput = {
    AND?: Enumerable<REPropertySuperCategoryModelWhereInput>
    OR?: Enumerable<REPropertySuperCategoryModelWhereInput>
    NOT?: Enumerable<REPropertySuperCategoryModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    name?: StringFilter | string
    middle_categories?: REPropertyMiddleCategoryModelListRelationFilter
  }

  export type REPropertySuperCategoryModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    name?: SortOrder
    middle_categories?: REPropertyMiddleCategoryModelOrderByRelationAggregateInput
  }

  export type REPropertySuperCategoryModelWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type REPropertySuperCategoryModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    name?: SortOrder
    _count?: REPropertySuperCategoryModelCountOrderByAggregateInput
    _max?: REPropertySuperCategoryModelMaxOrderByAggregateInput
    _min?: REPropertySuperCategoryModelMinOrderByAggregateInput
  }

  export type REPropertySuperCategoryModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<REPropertySuperCategoryModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<REPropertySuperCategoryModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<REPropertySuperCategoryModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    name?: StringWithAggregatesFilter | string
  }

  export type AgreementModelWhereInput = {
    AND?: Enumerable<AgreementModelWhereInput>
    OR?: Enumerable<AgreementModelWhereInput>
    NOT?: Enumerable<AgreementModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    title?: StringFilter | string
    content?: StringFilter | string
    is_required?: BoolFilter | boolean
    target_type?: EnumAgreementTargetTypeFilter | AgreementTargetType
    acceptances?: AgreementAcceptanceModelListRelationFilter
  }

  export type AgreementModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    title?: SortOrder
    content?: SortOrder
    is_required?: SortOrder
    target_type?: SortOrder
    acceptances?: AgreementAcceptanceModelOrderByRelationAggregateInput
  }

  export type AgreementModelWhereUniqueInput = {
    id?: string
  }

  export type AgreementModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    title?: SortOrder
    content?: SortOrder
    is_required?: SortOrder
    target_type?: SortOrder
    _count?: AgreementModelCountOrderByAggregateInput
    _max?: AgreementModelMaxOrderByAggregateInput
    _min?: AgreementModelMinOrderByAggregateInput
  }

  export type AgreementModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AgreementModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<AgreementModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AgreementModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    title?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    is_required?: BoolWithAggregatesFilter | boolean
    target_type?: EnumAgreementTargetTypeWithAggregatesFilter | AgreementTargetType
  }

  export type AgreementAcceptanceModelWhereInput = {
    AND?: Enumerable<AgreementAcceptanceModelWhereInput>
    OR?: Enumerable<AgreementAcceptanceModelWhereInput>
    NOT?: Enumerable<AgreementAcceptanceModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    user_id?: StringFilter | string
    agreement_id?: StringFilter | string
    user?: XOR<UserModelRelationFilter, UserModelWhereInput>
    agreement?: XOR<AgreementModelRelationFilter, AgreementModelWhereInput>
  }

  export type AgreementAcceptanceModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    agreement_id?: SortOrder
    user?: UserModelOrderByWithRelationInput
    agreement?: AgreementModelOrderByWithRelationInput
  }

  export type AgreementAcceptanceModelWhereUniqueInput = {
    id?: string
    user_id_agreement_id?: AgreementAcceptanceModelUser_idAgreement_idCompoundUniqueInput
  }

  export type AgreementAcceptanceModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    agreement_id?: SortOrder
    _count?: AgreementAcceptanceModelCountOrderByAggregateInput
    _max?: AgreementAcceptanceModelMaxOrderByAggregateInput
    _min?: AgreementAcceptanceModelMinOrderByAggregateInput
  }

  export type AgreementAcceptanceModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AgreementAcceptanceModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<AgreementAcceptanceModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AgreementAcceptanceModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    user_id?: StringWithAggregatesFilter | string
    agreement_id?: StringWithAggregatesFilter | string
  }

  export type ServiceSubCategoryModelWhereInput = {
    AND?: Enumerable<ServiceSubCategoryModelWhereInput>
    OR?: Enumerable<ServiceSubCategoryModelWhereInput>
    NOT?: Enumerable<ServiceSubCategoryModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    name?: StringFilter | string
    super_category_id?: StringFilter | string
    super_category?: XOR<ServiceSuperCategoryModelRelationFilter, ServiceSuperCategoryModelWhereInput>
    expertises?: SubExpertiseModelListRelationFilter
  }

  export type ServiceSubCategoryModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    name?: SortOrder
    super_category_id?: SortOrder
    super_category?: ServiceSuperCategoryModelOrderByWithRelationInput
    expertises?: SubExpertiseModelOrderByRelationAggregateInput
  }

  export type ServiceSubCategoryModelWhereUniqueInput = {
    id?: string
  }

  export type ServiceSubCategoryModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    name?: SortOrder
    super_category_id?: SortOrder
    _count?: ServiceSubCategoryModelCountOrderByAggregateInput
    _max?: ServiceSubCategoryModelMaxOrderByAggregateInput
    _min?: ServiceSubCategoryModelMinOrderByAggregateInput
  }

  export type ServiceSubCategoryModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServiceSubCategoryModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServiceSubCategoryModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServiceSubCategoryModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    name?: StringWithAggregatesFilter | string
    super_category_id?: StringWithAggregatesFilter | string
  }

  export type ServiceSuperCategoryModelWhereInput = {
    AND?: Enumerable<ServiceSuperCategoryModelWhereInput>
    OR?: Enumerable<ServiceSuperCategoryModelWhereInput>
    NOT?: Enumerable<ServiceSuperCategoryModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    name?: StringFilter | string
    type?: EnumServiceTypeFilter | ServiceType
    sub_categories?: ServiceSubCategoryModelListRelationFilter
    focus_care_checks?: ZipzoongCareServiceCheckModelListRelationFilter
  }

  export type ServiceSuperCategoryModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    sub_categories?: ServiceSubCategoryModelOrderByRelationAggregateInput
    focus_care_checks?: ZipzoongCareServiceCheckModelOrderByRelationAggregateInput
  }

  export type ServiceSuperCategoryModelWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type ServiceSuperCategoryModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    _count?: ServiceSuperCategoryModelCountOrderByAggregateInput
    _max?: ServiceSuperCategoryModelMaxOrderByAggregateInput
    _min?: ServiceSuperCategoryModelMinOrderByAggregateInput
  }

  export type ServiceSuperCategoryModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServiceSuperCategoryModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServiceSuperCategoryModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServiceSuperCategoryModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    name?: StringWithAggregatesFilter | string
    type?: EnumServiceTypeWithAggregatesFilter | ServiceType
  }

  export type ZipzoongCareRequestModelWhereInput = {
    AND?: Enumerable<ZipzoongCareRequestModelWhereInput>
    OR?: Enumerable<ZipzoongCareRequestModelWhereInput>
    NOT?: Enumerable<ZipzoongCareRequestModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    care_start_date?: DateTimeFilter | Date | string
    care_end_date?: DateTimeFilter | Date | string
    detail?: StringFilter | string
    status?: EnumZipzoongCareStatusFilter | ZipzoongCareStatus
    requester_id?: StringFilter | string
    requester?: XOR<CustomerModelRelationFilter, CustomerModelWhereInput>
    consultation_time_checks?: ZipzoongCareConsultationTimeCheckModelListRelationFilter
    service_checks?: ZipzoongCareServiceCheckModelListRelationFilter
  }

  export type ZipzoongCareRequestModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    care_start_date?: SortOrder
    care_end_date?: SortOrder
    detail?: SortOrder
    status?: SortOrder
    requester_id?: SortOrder
    requester?: CustomerModelOrderByWithRelationInput
    consultation_time_checks?: ZipzoongCareConsultationTimeCheckModelOrderByRelationAggregateInput
    service_checks?: ZipzoongCareServiceCheckModelOrderByRelationAggregateInput
  }

  export type ZipzoongCareRequestModelWhereUniqueInput = {
    id?: string
  }

  export type ZipzoongCareRequestModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    care_start_date?: SortOrder
    care_end_date?: SortOrder
    detail?: SortOrder
    status?: SortOrder
    requester_id?: SortOrder
    _count?: ZipzoongCareRequestModelCountOrderByAggregateInput
    _max?: ZipzoongCareRequestModelMaxOrderByAggregateInput
    _min?: ZipzoongCareRequestModelMinOrderByAggregateInput
  }

  export type ZipzoongCareRequestModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ZipzoongCareRequestModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<ZipzoongCareRequestModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ZipzoongCareRequestModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    care_start_date?: DateTimeWithAggregatesFilter | Date | string
    care_end_date?: DateTimeWithAggregatesFilter | Date | string
    detail?: StringWithAggregatesFilter | string
    status?: EnumZipzoongCareStatusWithAggregatesFilter | ZipzoongCareStatus
    requester_id?: StringWithAggregatesFilter | string
  }

  export type ZipzoongCareServiceCheckModelWhereInput = {
    AND?: Enumerable<ZipzoongCareServiceCheckModelWhereInput>
    OR?: Enumerable<ZipzoongCareServiceCheckModelWhereInput>
    NOT?: Enumerable<ZipzoongCareServiceCheckModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    service_super_category_id?: StringFilter | string
    request_id?: StringFilter | string
    service_super_category?: XOR<ServiceSuperCategoryModelRelationFilter, ServiceSuperCategoryModelWhereInput>
    request?: XOR<ZipzoongCareRequestModelRelationFilter, ZipzoongCareRequestModelWhereInput>
  }

  export type ZipzoongCareServiceCheckModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    service_super_category_id?: SortOrder
    request_id?: SortOrder
    service_super_category?: ServiceSuperCategoryModelOrderByWithRelationInput
    request?: ZipzoongCareRequestModelOrderByWithRelationInput
  }

  export type ZipzoongCareServiceCheckModelWhereUniqueInput = {
    id?: string
  }

  export type ZipzoongCareServiceCheckModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    service_super_category_id?: SortOrder
    request_id?: SortOrder
    _count?: ZipzoongCareServiceCheckModelCountOrderByAggregateInput
    _max?: ZipzoongCareServiceCheckModelMaxOrderByAggregateInput
    _min?: ZipzoongCareServiceCheckModelMinOrderByAggregateInput
  }

  export type ZipzoongCareServiceCheckModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ZipzoongCareServiceCheckModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<ZipzoongCareServiceCheckModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ZipzoongCareServiceCheckModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    service_super_category_id?: StringWithAggregatesFilter | string
    request_id?: StringWithAggregatesFilter | string
  }

  export type ZipzoongCareConsultationTimeCheckModelWhereInput = {
    AND?: Enumerable<ZipzoongCareConsultationTimeCheckModelWhereInput>
    OR?: Enumerable<ZipzoongCareConsultationTimeCheckModelWhereInput>
    NOT?: Enumerable<ZipzoongCareConsultationTimeCheckModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    start_time?: DateTimeFilter | Date | string
    end_time?: DateTimeFilter | Date | string
    request_id?: StringFilter | string
    request?: XOR<ZipzoongCareRequestModelRelationFilter, ZipzoongCareRequestModelWhereInput>
  }

  export type ZipzoongCareConsultationTimeCheckModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    request_id?: SortOrder
    request?: ZipzoongCareRequestModelOrderByWithRelationInput
  }

  export type ZipzoongCareConsultationTimeCheckModelWhereUniqueInput = {
    id?: string
  }

  export type ZipzoongCareConsultationTimeCheckModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    request_id?: SortOrder
    _count?: ZipzoongCareConsultationTimeCheckModelCountOrderByAggregateInput
    _max?: ZipzoongCareConsultationTimeCheckModelMaxOrderByAggregateInput
    _min?: ZipzoongCareConsultationTimeCheckModelMinOrderByAggregateInput
  }

  export type ZipzoongCareConsultationTimeCheckModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ZipzoongCareConsultationTimeCheckModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<ZipzoongCareConsultationTimeCheckModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ZipzoongCareConsultationTimeCheckModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    start_time?: DateTimeWithAggregatesFilter | Date | string
    end_time?: DateTimeWithAggregatesFilter | Date | string
    request_id?: StringWithAggregatesFilter | string
  }

  export type UserModelWhereInput = {
    AND?: Enumerable<UserModelWhereInput>
    OR?: Enumerable<UserModelWhereInput>
    NOT?: Enumerable<UserModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    name?: StringFilter | string
    email?: StringNullableFilter | string | null
    customer?: XOR<CustomerModelRelationFilter, CustomerModelWhereInput> | null
    business_user?: XOR<BusinessUserModelRelationFilter, BusinessUserModelWhereInput> | null
    agreement_acceptances?: AgreementAcceptanceModelListRelationFilter
  }

  export type UserModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    customer?: CustomerModelOrderByWithRelationInput
    business_user?: BusinessUserModelOrderByWithRelationInput
    agreement_acceptances?: AgreementAcceptanceModelOrderByRelationAggregateInput
  }

  export type UserModelWhereUniqueInput = {
    id?: string
  }

  export type UserModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    _count?: UserModelCountOrderByAggregateInput
    _max?: UserModelMaxOrderByAggregateInput
    _min?: UserModelMinOrderByAggregateInput
  }

  export type UserModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    name?: StringWithAggregatesFilter | string
    email?: StringNullableWithAggregatesFilter | string | null
  }

  export type CustomerModelWhereInput = {
    AND?: Enumerable<CustomerModelWhereInput>
    OR?: Enumerable<CustomerModelWhereInput>
    NOT?: Enumerable<CustomerModelWhereInput>
    id?: StringFilter | string
    birth?: StringNullableFilter | string | null
    gender?: EnumGenderTypeNullableFilter | GenderType | null
    phone?: StringNullableFilter | string | null
    address_first?: StringNullableFilter | string | null
    address_second?: StringNullableFilter | string | null
    profile_image_url?: StringNullableFilter | string | null
    base?: XOR<UserModelRelationFilter, UserModelWhereInput>
    oauth_accounts?: OauthAccountModelListRelationFilter
    zipzoong_care_requests?: ZipzoongCareRequestModelListRelationFilter
  }

  export type CustomerModelOrderByWithRelationInput = {
    id?: SortOrder
    birth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address_first?: SortOrderInput | SortOrder
    address_second?: SortOrderInput | SortOrder
    profile_image_url?: SortOrderInput | SortOrder
    base?: UserModelOrderByWithRelationInput
    oauth_accounts?: OauthAccountModelOrderByRelationAggregateInput
    zipzoong_care_requests?: ZipzoongCareRequestModelOrderByRelationAggregateInput
  }

  export type CustomerModelWhereUniqueInput = {
    id?: string
  }

  export type CustomerModelOrderByWithAggregationInput = {
    id?: SortOrder
    birth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address_first?: SortOrderInput | SortOrder
    address_second?: SortOrderInput | SortOrder
    profile_image_url?: SortOrderInput | SortOrder
    _count?: CustomerModelCountOrderByAggregateInput
    _max?: CustomerModelMaxOrderByAggregateInput
    _min?: CustomerModelMinOrderByAggregateInput
  }

  export type CustomerModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    birth?: StringNullableWithAggregatesFilter | string | null
    gender?: EnumGenderTypeNullableWithAggregatesFilter | GenderType | null
    phone?: StringNullableWithAggregatesFilter | string | null
    address_first?: StringNullableWithAggregatesFilter | string | null
    address_second?: StringNullableWithAggregatesFilter | string | null
    profile_image_url?: StringNullableWithAggregatesFilter | string | null
  }

  export type BusinessUserModelWhereInput = {
    AND?: Enumerable<BusinessUserModelWhereInput>
    OR?: Enumerable<BusinessUserModelWhereInput>
    NOT?: Enumerable<BusinessUserModelWhereInput>
    id?: StringFilter | string
    is_verified?: BoolFilter | boolean
    introduction_title?: StringFilter | string
    introduction_content?: StringFilter | string
    phone?: StringFilter | string
    address_first?: StringFilter | string
    address_second?: StringNullableFilter | string | null
    profile_image_url?: StringFilter | string
    base?: XOR<UserModelRelationFilter, UserModelWhereInput>
    re_agent?: XOR<REAgentModelRelationFilter, REAgentModelWhereInput> | null
    hs_provider?: XOR<HSProviderModelRelationFilter, HSProviderModelWhereInput> | null
    certification_images?: BusinessCertificationImageModelListRelationFilter
    sub_expertises?: SubExpertiseModelListRelationFilter
    oauth_accounts?: OauthAccountModelListRelationFilter
  }

  export type BusinessUserModelOrderByWithRelationInput = {
    id?: SortOrder
    is_verified?: SortOrder
    introduction_title?: SortOrder
    introduction_content?: SortOrder
    phone?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrderInput | SortOrder
    profile_image_url?: SortOrder
    base?: UserModelOrderByWithRelationInput
    re_agent?: REAgentModelOrderByWithRelationInput
    hs_provider?: HSProviderModelOrderByWithRelationInput
    certification_images?: BusinessCertificationImageModelOrderByRelationAggregateInput
    sub_expertises?: SubExpertiseModelOrderByRelationAggregateInput
    oauth_accounts?: OauthAccountModelOrderByRelationAggregateInput
  }

  export type BusinessUserModelWhereUniqueInput = {
    id?: string
  }

  export type BusinessUserModelOrderByWithAggregationInput = {
    id?: SortOrder
    is_verified?: SortOrder
    introduction_title?: SortOrder
    introduction_content?: SortOrder
    phone?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrderInput | SortOrder
    profile_image_url?: SortOrder
    _count?: BusinessUserModelCountOrderByAggregateInput
    _max?: BusinessUserModelMaxOrderByAggregateInput
    _min?: BusinessUserModelMinOrderByAggregateInput
  }

  export type BusinessUserModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BusinessUserModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<BusinessUserModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BusinessUserModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    is_verified?: BoolWithAggregatesFilter | boolean
    introduction_title?: StringWithAggregatesFilter | string
    introduction_content?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    address_first?: StringWithAggregatesFilter | string
    address_second?: StringNullableWithAggregatesFilter | string | null
    profile_image_url?: StringWithAggregatesFilter | string
  }

  export type SubExpertiseModelWhereInput = {
    AND?: Enumerable<SubExpertiseModelWhereInput>
    OR?: Enumerable<SubExpertiseModelWhereInput>
    NOT?: Enumerable<SubExpertiseModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    sub_category_id?: StringFilter | string
    business_user_id?: StringFilter | string
    sub_category?: XOR<ServiceSubCategoryModelRelationFilter, ServiceSubCategoryModelWhereInput>
    business_user?: XOR<BusinessUserModelRelationFilter, BusinessUserModelWhereInput>
  }

  export type SubExpertiseModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    sub_category_id?: SortOrder
    business_user_id?: SortOrder
    sub_category?: ServiceSubCategoryModelOrderByWithRelationInput
    business_user?: BusinessUserModelOrderByWithRelationInput
  }

  export type SubExpertiseModelWhereUniqueInput = {
    id?: string
    sub_category_id_business_user_id?: SubExpertiseModelSub_category_idBusiness_user_idCompoundUniqueInput
  }

  export type SubExpertiseModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    sub_category_id?: SortOrder
    business_user_id?: SortOrder
    _count?: SubExpertiseModelCountOrderByAggregateInput
    _max?: SubExpertiseModelMaxOrderByAggregateInput
    _min?: SubExpertiseModelMinOrderByAggregateInput
  }

  export type SubExpertiseModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubExpertiseModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubExpertiseModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubExpertiseModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    sub_category_id?: StringWithAggregatesFilter | string
    business_user_id?: StringWithAggregatesFilter | string
  }

  export type REAgentModelWhereInput = {
    AND?: Enumerable<REAgentModelWhereInput>
    OR?: Enumerable<REAgentModelWhereInput>
    NOT?: Enumerable<REAgentModelWhereInput>
    id?: StringFilter | string
    is_licensed?: BoolFilter | boolean
    re_num?: StringFilter | string
    re_name?: StringFilter | string
    re_phone?: StringFilter | string
    re_licensed_agent_name?: StringFilter | string
    base?: XOR<BusinessUserModelRelationFilter, BusinessUserModelWhereInput>
    properties?: REPropertyModelListRelationFilter
  }

  export type REAgentModelOrderByWithRelationInput = {
    id?: SortOrder
    is_licensed?: SortOrder
    re_num?: SortOrder
    re_name?: SortOrder
    re_phone?: SortOrder
    re_licensed_agent_name?: SortOrder
    base?: BusinessUserModelOrderByWithRelationInput
    properties?: REPropertyModelOrderByRelationAggregateInput
  }

  export type REAgentModelWhereUniqueInput = {
    id?: string
  }

  export type REAgentModelOrderByWithAggregationInput = {
    id?: SortOrder
    is_licensed?: SortOrder
    re_num?: SortOrder
    re_name?: SortOrder
    re_phone?: SortOrder
    re_licensed_agent_name?: SortOrder
    _count?: REAgentModelCountOrderByAggregateInput
    _max?: REAgentModelMaxOrderByAggregateInput
    _min?: REAgentModelMinOrderByAggregateInput
  }

  export type REAgentModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<REAgentModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<REAgentModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<REAgentModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    is_licensed?: BoolWithAggregatesFilter | boolean
    re_num?: StringWithAggregatesFilter | string
    re_name?: StringWithAggregatesFilter | string
    re_phone?: StringWithAggregatesFilter | string
    re_licensed_agent_name?: StringWithAggregatesFilter | string
  }

  export type HSProviderModelWhereInput = {
    AND?: Enumerable<HSProviderModelWhereInput>
    OR?: Enumerable<HSProviderModelWhereInput>
    NOT?: Enumerable<HSProviderModelWhereInput>
    id?: StringFilter | string
    business_registration_num?: StringFilter | string
    base?: XOR<BusinessUserModelRelationFilter, BusinessUserModelWhereInput>
    example_images?: HSExampleImageModelListRelationFilter
  }

  export type HSProviderModelOrderByWithRelationInput = {
    id?: SortOrder
    business_registration_num?: SortOrder
    base?: BusinessUserModelOrderByWithRelationInput
    example_images?: HSExampleImageModelOrderByRelationAggregateInput
  }

  export type HSProviderModelWhereUniqueInput = {
    id?: string
  }

  export type HSProviderModelOrderByWithAggregationInput = {
    id?: SortOrder
    business_registration_num?: SortOrder
    _count?: HSProviderModelCountOrderByAggregateInput
    _max?: HSProviderModelMaxOrderByAggregateInput
    _min?: HSProviderModelMinOrderByAggregateInput
  }

  export type HSProviderModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HSProviderModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<HSProviderModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HSProviderModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    business_registration_num?: StringWithAggregatesFilter | string
  }

  export type BusinessCertificationImageModelWhereInput = {
    AND?: Enumerable<BusinessCertificationImageModelWhereInput>
    OR?: Enumerable<BusinessCertificationImageModelWhereInput>
    NOT?: Enumerable<BusinessCertificationImageModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    business_user_id?: StringFilter | string
    url?: StringFilter | string
    business_user?: XOR<BusinessUserModelRelationFilter, BusinessUserModelWhereInput>
  }

  export type BusinessCertificationImageModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    business_user_id?: SortOrder
    url?: SortOrder
    business_user?: BusinessUserModelOrderByWithRelationInput
  }

  export type BusinessCertificationImageModelWhereUniqueInput = {
    id?: string
  }

  export type BusinessCertificationImageModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    business_user_id?: SortOrder
    url?: SortOrder
    _count?: BusinessCertificationImageModelCountOrderByAggregateInput
    _max?: BusinessCertificationImageModelMaxOrderByAggregateInput
    _min?: BusinessCertificationImageModelMinOrderByAggregateInput
  }

  export type BusinessCertificationImageModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BusinessCertificationImageModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<BusinessCertificationImageModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BusinessCertificationImageModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    business_user_id?: StringWithAggregatesFilter | string
    url?: StringWithAggregatesFilter | string
  }

  export type HSExampleImageModelWhereInput = {
    AND?: Enumerable<HSExampleImageModelWhereInput>
    OR?: Enumerable<HSExampleImageModelWhereInput>
    NOT?: Enumerable<HSExampleImageModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    hs_provider_id?: StringFilter | string
    url?: StringFilter | string
    is_visible?: BoolFilter | boolean
    hs_provider?: XOR<HSProviderModelRelationFilter, HSProviderModelWhereInput>
  }

  export type HSExampleImageModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    hs_provider_id?: SortOrder
    url?: SortOrder
    is_visible?: SortOrder
    hs_provider?: HSProviderModelOrderByWithRelationInput
  }

  export type HSExampleImageModelWhereUniqueInput = {
    id?: string
  }

  export type HSExampleImageModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    hs_provider_id?: SortOrder
    url?: SortOrder
    is_visible?: SortOrder
    _count?: HSExampleImageModelCountOrderByAggregateInput
    _max?: HSExampleImageModelMaxOrderByAggregateInput
    _min?: HSExampleImageModelMinOrderByAggregateInput
  }

  export type HSExampleImageModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HSExampleImageModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<HSExampleImageModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HSExampleImageModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    hs_provider_id?: StringWithAggregatesFilter | string
    url?: StringWithAggregatesFilter | string
    is_visible?: BoolWithAggregatesFilter | boolean
  }

  export type OauthAccountModelWhereInput = {
    AND?: Enumerable<OauthAccountModelWhereInput>
    OR?: Enumerable<OauthAccountModelWhereInput>
    NOT?: Enumerable<OauthAccountModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    oauth_type?: EnumOauthTypeFilter | OauthType
    oauth_sub?: StringFilter | string
    business_user_id?: StringNullableFilter | string | null
    customer_id?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    profile_image_url?: StringNullableFilter | string | null
    birth?: StringNullableFilter | string | null
    gender?: EnumGenderTypeNullableFilter | GenderType | null
    address_first?: StringNullableFilter | string | null
    address_second?: StringNullableFilter | string | null
    business_user?: XOR<BusinessUserModelRelationFilter, BusinessUserModelWhereInput> | null
    customer?: XOR<CustomerModelRelationFilter, CustomerModelWhereInput> | null
  }

  export type OauthAccountModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    oauth_type?: SortOrder
    oauth_sub?: SortOrder
    business_user_id?: SortOrderInput | SortOrder
    customer_id?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    profile_image_url?: SortOrderInput | SortOrder
    birth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    address_first?: SortOrderInput | SortOrder
    address_second?: SortOrderInput | SortOrder
    business_user?: BusinessUserModelOrderByWithRelationInput
    customer?: CustomerModelOrderByWithRelationInput
  }

  export type OauthAccountModelWhereUniqueInput = {
    id?: string
  }

  export type OauthAccountModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    oauth_type?: SortOrder
    oauth_sub?: SortOrder
    business_user_id?: SortOrderInput | SortOrder
    customer_id?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    profile_image_url?: SortOrderInput | SortOrder
    birth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    address_first?: SortOrderInput | SortOrder
    address_second?: SortOrderInput | SortOrder
    _count?: OauthAccountModelCountOrderByAggregateInput
    _max?: OauthAccountModelMaxOrderByAggregateInput
    _min?: OauthAccountModelMinOrderByAggregateInput
  }

  export type OauthAccountModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OauthAccountModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<OauthAccountModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OauthAccountModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    oauth_type?: EnumOauthTypeWithAggregatesFilter | OauthType
    oauth_sub?: StringWithAggregatesFilter | string
    business_user_id?: StringNullableWithAggregatesFilter | string | null
    customer_id?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    profile_image_url?: StringNullableWithAggregatesFilter | string | null
    birth?: StringNullableWithAggregatesFilter | string | null
    gender?: EnumGenderTypeNullableWithAggregatesFilter | GenderType | null
    address_first?: StringNullableWithAggregatesFilter | string | null
    address_second?: StringNullableWithAggregatesFilter | string | null
  }

  export type PhoneVerificationModelWhereInput = {
    AND?: Enumerable<PhoneVerificationModelWhereInput>
    OR?: Enumerable<PhoneVerificationModelWhereInput>
    NOT?: Enumerable<PhoneVerificationModelWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    phone?: StringFilter | string
    code?: StringFilter | string
    request_id?: StringFilter | string
    is_verified?: BoolFilter | boolean
  }

  export type PhoneVerificationModelOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    phone?: SortOrder
    code?: SortOrder
    request_id?: SortOrder
    is_verified?: SortOrder
  }

  export type PhoneVerificationModelWhereUniqueInput = {
    id?: string
  }

  export type PhoneVerificationModelOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    phone?: SortOrder
    code?: SortOrder
    request_id?: SortOrder
    is_verified?: SortOrder
    _count?: PhoneVerificationModelCountOrderByAggregateInput
    _max?: PhoneVerificationModelMaxOrderByAggregateInput
    _min?: PhoneVerificationModelMinOrderByAggregateInput
  }

  export type PhoneVerificationModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PhoneVerificationModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<PhoneVerificationModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PhoneVerificationModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    is_deleted?: BoolWithAggregatesFilter | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    phone?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    request_id?: StringWithAggregatesFilter | string
    is_verified?: BoolWithAggregatesFilter | boolean
  }

  export type REPropertyModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    main_image_url: string
    is_visible: boolean
    re_agent: REAgentModelCreateNestedOneWithoutPropertiesInput
    categories?: REPropertyCategoryModelCreateNestedManyWithoutRe_propertyInput
  }

  export type REPropertyModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    main_image_url: string
    re_agent_id: string
    is_visible: boolean
    categories?: REPropertyCategoryModelUncheckedCreateNestedManyWithoutRe_propertyInput
  }

  export type REPropertyModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
    is_visible?: BoolFieldUpdateOperationsInput | boolean
    re_agent?: REAgentModelUpdateOneRequiredWithoutPropertiesNestedInput
    categories?: REPropertyCategoryModelUpdateManyWithoutRe_propertyNestedInput
  }

  export type REPropertyModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
    re_agent_id?: StringFieldUpdateOperationsInput | string
    is_visible?: BoolFieldUpdateOperationsInput | boolean
    categories?: REPropertyCategoryModelUncheckedUpdateManyWithoutRe_propertyNestedInput
  }

  export type REPropertyModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    main_image_url: string
    re_agent_id: string
    is_visible: boolean
  }

  export type REPropertyModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
    is_visible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type REPropertyModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
    re_agent_id?: StringFieldUpdateOperationsInput | string
    is_visible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type REPropertyCategoryModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    re_property: REPropertyModelCreateNestedOneWithoutCategoriesInput
    sub_category: REPropertySubCategoryModelCreateNestedOneWithoutProperty_categoriesInput
  }

  export type REPropertyCategoryModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    re_property_id: string
    sub_category_id: string
  }

  export type REPropertyCategoryModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    re_property?: REPropertyModelUpdateOneRequiredWithoutCategoriesNestedInput
    sub_category?: REPropertySubCategoryModelUpdateOneRequiredWithoutProperty_categoriesNestedInput
  }

  export type REPropertyCategoryModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    re_property_id?: StringFieldUpdateOperationsInput | string
    sub_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertyCategoryModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    re_property_id: string
    sub_category_id: string
  }

  export type REPropertyCategoryModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type REPropertyCategoryModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    re_property_id?: StringFieldUpdateOperationsInput | string
    sub_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertySubCategoryModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    middle_category: REPropertyMiddleCategoryModelCreateNestedOneWithoutSub_categoriesInput
    property_categories?: REPropertyCategoryModelCreateNestedManyWithoutSub_categoryInput
  }

  export type REPropertySubCategoryModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    middle_category_id: string
    property_categories?: REPropertyCategoryModelUncheckedCreateNestedManyWithoutSub_categoryInput
  }

  export type REPropertySubCategoryModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    middle_category?: REPropertyMiddleCategoryModelUpdateOneRequiredWithoutSub_categoriesNestedInput
    property_categories?: REPropertyCategoryModelUpdateManyWithoutSub_categoryNestedInput
  }

  export type REPropertySubCategoryModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    middle_category_id?: StringFieldUpdateOperationsInput | string
    property_categories?: REPropertyCategoryModelUncheckedUpdateManyWithoutSub_categoryNestedInput
  }

  export type REPropertySubCategoryModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    middle_category_id: string
  }

  export type REPropertySubCategoryModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertySubCategoryModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    middle_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertyMiddleCategoryModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    super_category: REPropertySuperCategoryModelCreateNestedOneWithoutMiddle_categoriesInput
    sub_categories?: REPropertySubCategoryModelCreateNestedManyWithoutMiddle_categoryInput
  }

  export type REPropertyMiddleCategoryModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    super_category_id: string
    sub_categories?: REPropertySubCategoryModelUncheckedCreateNestedManyWithoutMiddle_categoryInput
  }

  export type REPropertyMiddleCategoryModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    super_category?: REPropertySuperCategoryModelUpdateOneRequiredWithoutMiddle_categoriesNestedInput
    sub_categories?: REPropertySubCategoryModelUpdateManyWithoutMiddle_categoryNestedInput
  }

  export type REPropertyMiddleCategoryModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    super_category_id?: StringFieldUpdateOperationsInput | string
    sub_categories?: REPropertySubCategoryModelUncheckedUpdateManyWithoutMiddle_categoryNestedInput
  }

  export type REPropertyMiddleCategoryModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    super_category_id: string
  }

  export type REPropertyMiddleCategoryModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertyMiddleCategoryModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    super_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertySuperCategoryModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    middle_categories?: REPropertyMiddleCategoryModelCreateNestedManyWithoutSuper_categoryInput
  }

  export type REPropertySuperCategoryModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    middle_categories?: REPropertyMiddleCategoryModelUncheckedCreateNestedManyWithoutSuper_categoryInput
  }

  export type REPropertySuperCategoryModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    middle_categories?: REPropertyMiddleCategoryModelUpdateManyWithoutSuper_categoryNestedInput
  }

  export type REPropertySuperCategoryModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    middle_categories?: REPropertyMiddleCategoryModelUncheckedUpdateManyWithoutSuper_categoryNestedInput
  }

  export type REPropertySuperCategoryModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
  }

  export type REPropertySuperCategoryModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertySuperCategoryModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AgreementModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    title: string
    content: string
    is_required: boolean
    target_type: AgreementTargetType
    acceptances?: AgreementAcceptanceModelCreateNestedManyWithoutAgreementInput
  }

  export type AgreementModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    title: string
    content: string
    is_required: boolean
    target_type: AgreementTargetType
    acceptances?: AgreementAcceptanceModelUncheckedCreateNestedManyWithoutAgreementInput
  }

  export type AgreementModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_required?: BoolFieldUpdateOperationsInput | boolean
    target_type?: EnumAgreementTargetTypeFieldUpdateOperationsInput | AgreementTargetType
    acceptances?: AgreementAcceptanceModelUpdateManyWithoutAgreementNestedInput
  }

  export type AgreementModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_required?: BoolFieldUpdateOperationsInput | boolean
    target_type?: EnumAgreementTargetTypeFieldUpdateOperationsInput | AgreementTargetType
    acceptances?: AgreementAcceptanceModelUncheckedUpdateManyWithoutAgreementNestedInput
  }

  export type AgreementModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    title: string
    content: string
    is_required: boolean
    target_type: AgreementTargetType
  }

  export type AgreementModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_required?: BoolFieldUpdateOperationsInput | boolean
    target_type?: EnumAgreementTargetTypeFieldUpdateOperationsInput | AgreementTargetType
  }

  export type AgreementModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_required?: BoolFieldUpdateOperationsInput | boolean
    target_type?: EnumAgreementTargetTypeFieldUpdateOperationsInput | AgreementTargetType
  }

  export type AgreementAcceptanceModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    user: UserModelCreateNestedOneWithoutAgreement_acceptancesInput
    agreement: AgreementModelCreateNestedOneWithoutAcceptancesInput
  }

  export type AgreementAcceptanceModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    user_id: string
    agreement_id: string
  }

  export type AgreementAcceptanceModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserModelUpdateOneRequiredWithoutAgreement_acceptancesNestedInput
    agreement?: AgreementModelUpdateOneRequiredWithoutAcceptancesNestedInput
  }

  export type AgreementAcceptanceModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    agreement_id?: StringFieldUpdateOperationsInput | string
  }

  export type AgreementAcceptanceModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    user_id: string
    agreement_id: string
  }

  export type AgreementAcceptanceModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgreementAcceptanceModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    agreement_id?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceSubCategoryModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    super_category: ServiceSuperCategoryModelCreateNestedOneWithoutSub_categoriesInput
    expertises?: SubExpertiseModelCreateNestedManyWithoutSub_categoryInput
  }

  export type ServiceSubCategoryModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    super_category_id: string
    expertises?: SubExpertiseModelUncheckedCreateNestedManyWithoutSub_categoryInput
  }

  export type ServiceSubCategoryModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    super_category?: ServiceSuperCategoryModelUpdateOneRequiredWithoutSub_categoriesNestedInput
    expertises?: SubExpertiseModelUpdateManyWithoutSub_categoryNestedInput
  }

  export type ServiceSubCategoryModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    super_category_id?: StringFieldUpdateOperationsInput | string
    expertises?: SubExpertiseModelUncheckedUpdateManyWithoutSub_categoryNestedInput
  }

  export type ServiceSubCategoryModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    super_category_id: string
  }

  export type ServiceSubCategoryModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceSubCategoryModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    super_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceSuperCategoryModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    type: ServiceType
    sub_categories?: ServiceSubCategoryModelCreateNestedManyWithoutSuper_categoryInput
    focus_care_checks?: ZipzoongCareServiceCheckModelCreateNestedManyWithoutService_super_categoryInput
  }

  export type ServiceSuperCategoryModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    type: ServiceType
    sub_categories?: ServiceSubCategoryModelUncheckedCreateNestedManyWithoutSuper_categoryInput
    focus_care_checks?: ZipzoongCareServiceCheckModelUncheckedCreateNestedManyWithoutService_super_categoryInput
  }

  export type ServiceSuperCategoryModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | ServiceType
    sub_categories?: ServiceSubCategoryModelUpdateManyWithoutSuper_categoryNestedInput
    focus_care_checks?: ZipzoongCareServiceCheckModelUpdateManyWithoutService_super_categoryNestedInput
  }

  export type ServiceSuperCategoryModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | ServiceType
    sub_categories?: ServiceSubCategoryModelUncheckedUpdateManyWithoutSuper_categoryNestedInput
    focus_care_checks?: ZipzoongCareServiceCheckModelUncheckedUpdateManyWithoutService_super_categoryNestedInput
  }

  export type ServiceSuperCategoryModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    type: ServiceType
  }

  export type ServiceSuperCategoryModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | ServiceType
  }

  export type ServiceSuperCategoryModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | ServiceType
  }

  export type ZipzoongCareRequestModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    care_start_date: Date | string
    care_end_date: Date | string
    detail: string
    status: ZipzoongCareStatus
    requester: CustomerModelCreateNestedOneWithoutZipzoong_care_requestsInput
    consultation_time_checks?: ZipzoongCareConsultationTimeCheckModelCreateNestedManyWithoutRequestInput
    service_checks?: ZipzoongCareServiceCheckModelCreateNestedManyWithoutRequestInput
  }

  export type ZipzoongCareRequestModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    care_start_date: Date | string
    care_end_date: Date | string
    detail: string
    status: ZipzoongCareStatus
    requester_id: string
    consultation_time_checks?: ZipzoongCareConsultationTimeCheckModelUncheckedCreateNestedManyWithoutRequestInput
    service_checks?: ZipzoongCareServiceCheckModelUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ZipzoongCareRequestModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    care_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    care_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: StringFieldUpdateOperationsInput | string
    status?: EnumZipzoongCareStatusFieldUpdateOperationsInput | ZipzoongCareStatus
    requester?: CustomerModelUpdateOneRequiredWithoutZipzoong_care_requestsNestedInput
    consultation_time_checks?: ZipzoongCareConsultationTimeCheckModelUpdateManyWithoutRequestNestedInput
    service_checks?: ZipzoongCareServiceCheckModelUpdateManyWithoutRequestNestedInput
  }

  export type ZipzoongCareRequestModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    care_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    care_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: StringFieldUpdateOperationsInput | string
    status?: EnumZipzoongCareStatusFieldUpdateOperationsInput | ZipzoongCareStatus
    requester_id?: StringFieldUpdateOperationsInput | string
    consultation_time_checks?: ZipzoongCareConsultationTimeCheckModelUncheckedUpdateManyWithoutRequestNestedInput
    service_checks?: ZipzoongCareServiceCheckModelUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type ZipzoongCareRequestModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    care_start_date: Date | string
    care_end_date: Date | string
    detail: string
    status: ZipzoongCareStatus
    requester_id: string
  }

  export type ZipzoongCareRequestModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    care_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    care_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: StringFieldUpdateOperationsInput | string
    status?: EnumZipzoongCareStatusFieldUpdateOperationsInput | ZipzoongCareStatus
  }

  export type ZipzoongCareRequestModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    care_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    care_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: StringFieldUpdateOperationsInput | string
    status?: EnumZipzoongCareStatusFieldUpdateOperationsInput | ZipzoongCareStatus
    requester_id?: StringFieldUpdateOperationsInput | string
  }

  export type ZipzoongCareServiceCheckModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    service_super_category: ServiceSuperCategoryModelCreateNestedOneWithoutFocus_care_checksInput
    request: ZipzoongCareRequestModelCreateNestedOneWithoutService_checksInput
  }

  export type ZipzoongCareServiceCheckModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    service_super_category_id: string
    request_id: string
  }

  export type ZipzoongCareServiceCheckModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_super_category?: ServiceSuperCategoryModelUpdateOneRequiredWithoutFocus_care_checksNestedInput
    request?: ZipzoongCareRequestModelUpdateOneRequiredWithoutService_checksNestedInput
  }

  export type ZipzoongCareServiceCheckModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_super_category_id?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
  }

  export type ZipzoongCareServiceCheckModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    service_super_category_id: string
    request_id: string
  }

  export type ZipzoongCareServiceCheckModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ZipzoongCareServiceCheckModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_super_category_id?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
  }

  export type ZipzoongCareConsultationTimeCheckModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    start_time: Date | string
    end_time: Date | string
    request: ZipzoongCareRequestModelCreateNestedOneWithoutConsultation_time_checksInput
  }

  export type ZipzoongCareConsultationTimeCheckModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    start_time: Date | string
    end_time: Date | string
    request_id: string
  }

  export type ZipzoongCareConsultationTimeCheckModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: ZipzoongCareRequestModelUpdateOneRequiredWithoutConsultation_time_checksNestedInput
  }

  export type ZipzoongCareConsultationTimeCheckModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    request_id?: StringFieldUpdateOperationsInput | string
  }

  export type ZipzoongCareConsultationTimeCheckModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    start_time: Date | string
    end_time: Date | string
    request_id: string
  }

  export type ZipzoongCareConsultationTimeCheckModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZipzoongCareConsultationTimeCheckModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    request_id?: StringFieldUpdateOperationsInput | string
  }

  export type UserModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    email?: string | null
    customer?: CustomerModelCreateNestedOneWithoutBaseInput
    business_user?: BusinessUserModelCreateNestedOneWithoutBaseInput
    agreement_acceptances?: AgreementAcceptanceModelCreateNestedManyWithoutUserInput
  }

  export type UserModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    email?: string | null
    customer?: CustomerModelUncheckedCreateNestedOneWithoutBaseInput
    business_user?: BusinessUserModelUncheckedCreateNestedOneWithoutBaseInput
    agreement_acceptances?: AgreementAcceptanceModelUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerModelUpdateOneWithoutBaseNestedInput
    business_user?: BusinessUserModelUpdateOneWithoutBaseNestedInput
    agreement_acceptances?: AgreementAcceptanceModelUpdateManyWithoutUserNestedInput
  }

  export type UserModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerModelUncheckedUpdateOneWithoutBaseNestedInput
    business_user?: BusinessUserModelUncheckedUpdateOneWithoutBaseNestedInput
    agreement_acceptances?: AgreementAcceptanceModelUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    email?: string | null
  }

  export type UserModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerModelCreateInput = {
    birth?: string | null
    gender?: GenderType | null
    phone?: string | null
    address_first?: string | null
    address_second?: string | null
    profile_image_url?: string | null
    base: UserModelCreateNestedOneWithoutCustomerInput
    oauth_accounts?: OauthAccountModelCreateNestedManyWithoutCustomerInput
    zipzoong_care_requests?: ZipzoongCareRequestModelCreateNestedManyWithoutRequesterInput
  }

  export type CustomerModelUncheckedCreateInput = {
    id: string
    birth?: string | null
    gender?: GenderType | null
    phone?: string | null
    address_first?: string | null
    address_second?: string | null
    profile_image_url?: string | null
    oauth_accounts?: OauthAccountModelUncheckedCreateNestedManyWithoutCustomerInput
    zipzoong_care_requests?: ZipzoongCareRequestModelUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type CustomerModelUpdateInput = {
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    base?: UserModelUpdateOneRequiredWithoutCustomerNestedInput
    oauth_accounts?: OauthAccountModelUpdateManyWithoutCustomerNestedInput
    zipzoong_care_requests?: ZipzoongCareRequestModelUpdateManyWithoutRequesterNestedInput
  }

  export type CustomerModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_accounts?: OauthAccountModelUncheckedUpdateManyWithoutCustomerNestedInput
    zipzoong_care_requests?: ZipzoongCareRequestModelUncheckedUpdateManyWithoutRequesterNestedInput
  }

  export type CustomerModelCreateManyInput = {
    id: string
    birth?: string | null
    gender?: GenderType | null
    phone?: string | null
    address_first?: string | null
    address_second?: string | null
    profile_image_url?: string | null
  }

  export type CustomerModelUpdateManyMutationInput = {
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusinessUserModelCreateInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    base: UserModelCreateNestedOneWithoutBusiness_userInput
    re_agent?: REAgentModelCreateNestedOneWithoutBaseInput
    hs_provider?: HSProviderModelCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelCreateNestedManyWithoutBusiness_userInput
    sub_expertises?: SubExpertiseModelCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelCreateNestedManyWithoutBusiness_userInput
  }

  export type BusinessUserModelUncheckedCreateInput = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    re_agent?: REAgentModelUncheckedCreateNestedOneWithoutBaseInput
    hs_provider?: HSProviderModelUncheckedCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelUncheckedCreateNestedManyWithoutBusiness_userInput
    sub_expertises?: SubExpertiseModelUncheckedCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelUncheckedCreateNestedManyWithoutBusiness_userInput
  }

  export type BusinessUserModelUpdateInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    base?: UserModelUpdateOneRequiredWithoutBusiness_userNestedInput
    re_agent?: REAgentModelUpdateOneWithoutBaseNestedInput
    hs_provider?: HSProviderModelUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUpdateManyWithoutBusiness_userNestedInput
    sub_expertises?: SubExpertiseModelUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUpdateManyWithoutBusiness_userNestedInput
  }

  export type BusinessUserModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    re_agent?: REAgentModelUncheckedUpdateOneWithoutBaseNestedInput
    hs_provider?: HSProviderModelUncheckedUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    sub_expertises?: SubExpertiseModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUncheckedUpdateManyWithoutBusiness_userNestedInput
  }

  export type BusinessUserModelCreateManyInput = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
  }

  export type BusinessUserModelUpdateManyMutationInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUserModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
  }

  export type SubExpertiseModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    sub_category: ServiceSubCategoryModelCreateNestedOneWithoutExpertisesInput
    business_user: BusinessUserModelCreateNestedOneWithoutSub_expertisesInput
  }

  export type SubExpertiseModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    sub_category_id: string
    business_user_id: string
  }

  export type SubExpertiseModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_category?: ServiceSubCategoryModelUpdateOneRequiredWithoutExpertisesNestedInput
    business_user?: BusinessUserModelUpdateOneRequiredWithoutSub_expertisesNestedInput
  }

  export type SubExpertiseModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_category_id?: StringFieldUpdateOperationsInput | string
    business_user_id?: StringFieldUpdateOperationsInput | string
  }

  export type SubExpertiseModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    sub_category_id: string
    business_user_id: string
  }

  export type SubExpertiseModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubExpertiseModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_category_id?: StringFieldUpdateOperationsInput | string
    business_user_id?: StringFieldUpdateOperationsInput | string
  }

  export type REAgentModelCreateInput = {
    is_licensed: boolean
    re_num: string
    re_name: string
    re_phone: string
    re_licensed_agent_name: string
    base: BusinessUserModelCreateNestedOneWithoutRe_agentInput
    properties?: REPropertyModelCreateNestedManyWithoutRe_agentInput
  }

  export type REAgentModelUncheckedCreateInput = {
    id: string
    is_licensed: boolean
    re_num: string
    re_name: string
    re_phone: string
    re_licensed_agent_name: string
    properties?: REPropertyModelUncheckedCreateNestedManyWithoutRe_agentInput
  }

  export type REAgentModelUpdateInput = {
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    re_num?: StringFieldUpdateOperationsInput | string
    re_name?: StringFieldUpdateOperationsInput | string
    re_phone?: StringFieldUpdateOperationsInput | string
    re_licensed_agent_name?: StringFieldUpdateOperationsInput | string
    base?: BusinessUserModelUpdateOneRequiredWithoutRe_agentNestedInput
    properties?: REPropertyModelUpdateManyWithoutRe_agentNestedInput
  }

  export type REAgentModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    re_num?: StringFieldUpdateOperationsInput | string
    re_name?: StringFieldUpdateOperationsInput | string
    re_phone?: StringFieldUpdateOperationsInput | string
    re_licensed_agent_name?: StringFieldUpdateOperationsInput | string
    properties?: REPropertyModelUncheckedUpdateManyWithoutRe_agentNestedInput
  }

  export type REAgentModelCreateManyInput = {
    id: string
    is_licensed: boolean
    re_num: string
    re_name: string
    re_phone: string
    re_licensed_agent_name: string
  }

  export type REAgentModelUpdateManyMutationInput = {
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    re_num?: StringFieldUpdateOperationsInput | string
    re_name?: StringFieldUpdateOperationsInput | string
    re_phone?: StringFieldUpdateOperationsInput | string
    re_licensed_agent_name?: StringFieldUpdateOperationsInput | string
  }

  export type REAgentModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    re_num?: StringFieldUpdateOperationsInput | string
    re_name?: StringFieldUpdateOperationsInput | string
    re_phone?: StringFieldUpdateOperationsInput | string
    re_licensed_agent_name?: StringFieldUpdateOperationsInput | string
  }

  export type HSProviderModelCreateInput = {
    business_registration_num: string
    base: BusinessUserModelCreateNestedOneWithoutHs_providerInput
    example_images?: HSExampleImageModelCreateNestedManyWithoutHs_providerInput
  }

  export type HSProviderModelUncheckedCreateInput = {
    id: string
    business_registration_num: string
    example_images?: HSExampleImageModelUncheckedCreateNestedManyWithoutHs_providerInput
  }

  export type HSProviderModelUpdateInput = {
    business_registration_num?: StringFieldUpdateOperationsInput | string
    base?: BusinessUserModelUpdateOneRequiredWithoutHs_providerNestedInput
    example_images?: HSExampleImageModelUpdateManyWithoutHs_providerNestedInput
  }

  export type HSProviderModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    business_registration_num?: StringFieldUpdateOperationsInput | string
    example_images?: HSExampleImageModelUncheckedUpdateManyWithoutHs_providerNestedInput
  }

  export type HSProviderModelCreateManyInput = {
    id: string
    business_registration_num: string
  }

  export type HSProviderModelUpdateManyMutationInput = {
    business_registration_num?: StringFieldUpdateOperationsInput | string
  }

  export type HSProviderModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    business_registration_num?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessCertificationImageModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    url: string
    business_user: BusinessUserModelCreateNestedOneWithoutCertification_imagesInput
  }

  export type BusinessCertificationImageModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    business_user_id: string
    url: string
  }

  export type BusinessCertificationImageModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: StringFieldUpdateOperationsInput | string
    business_user?: BusinessUserModelUpdateOneRequiredWithoutCertification_imagesNestedInput
  }

  export type BusinessCertificationImageModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business_user_id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessCertificationImageModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    business_user_id: string
    url: string
  }

  export type BusinessCertificationImageModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessCertificationImageModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business_user_id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type HSExampleImageModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    url: string
    is_visible: boolean
    hs_provider: HSProviderModelCreateNestedOneWithoutExample_imagesInput
  }

  export type HSExampleImageModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    hs_provider_id: string
    url: string
    is_visible: boolean
  }

  export type HSExampleImageModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: StringFieldUpdateOperationsInput | string
    is_visible?: BoolFieldUpdateOperationsInput | boolean
    hs_provider?: HSProviderModelUpdateOneRequiredWithoutExample_imagesNestedInput
  }

  export type HSExampleImageModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hs_provider_id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    is_visible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HSExampleImageModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    hs_provider_id: string
    url: string
    is_visible: boolean
  }

  export type HSExampleImageModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: StringFieldUpdateOperationsInput | string
    is_visible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HSExampleImageModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hs_provider_id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    is_visible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OauthAccountModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    oauth_type: OauthType
    oauth_sub: string
    name?: string | null
    email?: string | null
    phone?: string | null
    profile_image_url?: string | null
    birth?: string | null
    gender?: GenderType | null
    address_first?: string | null
    address_second?: string | null
    business_user?: BusinessUserModelCreateNestedOneWithoutOauth_accountsInput
    customer?: CustomerModelCreateNestedOneWithoutOauth_accountsInput
  }

  export type OauthAccountModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    oauth_type: OauthType
    oauth_sub: string
    business_user_id?: string | null
    customer_id?: string | null
    name?: string | null
    email?: string | null
    phone?: string | null
    profile_image_url?: string | null
    birth?: string | null
    gender?: GenderType | null
    address_first?: string | null
    address_second?: string | null
  }

  export type OauthAccountModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauth_type?: EnumOauthTypeFieldUpdateOperationsInput | OauthType
    oauth_sub?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    business_user?: BusinessUserModelUpdateOneWithoutOauth_accountsNestedInput
    customer?: CustomerModelUpdateOneWithoutOauth_accountsNestedInput
  }

  export type OauthAccountModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauth_type?: EnumOauthTypeFieldUpdateOperationsInput | OauthType
    oauth_sub?: StringFieldUpdateOperationsInput | string
    business_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OauthAccountModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    oauth_type: OauthType
    oauth_sub: string
    business_user_id?: string | null
    customer_id?: string | null
    name?: string | null
    email?: string | null
    phone?: string | null
    profile_image_url?: string | null
    birth?: string | null
    gender?: GenderType | null
    address_first?: string | null
    address_second?: string | null
  }

  export type OauthAccountModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauth_type?: EnumOauthTypeFieldUpdateOperationsInput | OauthType
    oauth_sub?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OauthAccountModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauth_type?: EnumOauthTypeFieldUpdateOperationsInput | OauthType
    oauth_sub?: StringFieldUpdateOperationsInput | string
    business_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhoneVerificationModelCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    phone: string
    code: string
    request_id: string
    is_verified: boolean
  }

  export type PhoneVerificationModelUncheckedCreateInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    phone: string
    code: string
    request_id: string
    is_verified: boolean
  }

  export type PhoneVerificationModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PhoneVerificationModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PhoneVerificationModelCreateManyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    phone: string
    code: string
    request_id: string
    is_verified: boolean
  }

  export type PhoneVerificationModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PhoneVerificationModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    request_id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type REAgentModelRelationFilter = {
    is?: REAgentModelWhereInput | null
    isNot?: REAgentModelWhereInput | null
  }

  export type REPropertyCategoryModelListRelationFilter = {
    every?: REPropertyCategoryModelWhereInput
    some?: REPropertyCategoryModelWhereInput
    none?: REPropertyCategoryModelWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type REPropertyCategoryModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type REPropertyModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    main_image_url?: SortOrder
    re_agent_id?: SortOrder
    is_visible?: SortOrder
  }

  export type REPropertyModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    main_image_url?: SortOrder
    re_agent_id?: SortOrder
    is_visible?: SortOrder
  }

  export type REPropertyModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    main_image_url?: SortOrder
    re_agent_id?: SortOrder
    is_visible?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type REPropertyModelRelationFilter = {
    is?: REPropertyModelWhereInput | null
    isNot?: REPropertyModelWhereInput | null
  }

  export type REPropertySubCategoryModelRelationFilter = {
    is?: REPropertySubCategoryModelWhereInput | null
    isNot?: REPropertySubCategoryModelWhereInput | null
  }

  export type REPropertyCategoryModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    re_property_id?: SortOrder
    sub_category_id?: SortOrder
  }

  export type REPropertyCategoryModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    re_property_id?: SortOrder
    sub_category_id?: SortOrder
  }

  export type REPropertyCategoryModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    re_property_id?: SortOrder
    sub_category_id?: SortOrder
  }

  export type REPropertyMiddleCategoryModelRelationFilter = {
    is?: REPropertyMiddleCategoryModelWhereInput | null
    isNot?: REPropertyMiddleCategoryModelWhereInput | null
  }

  export type REPropertySubCategoryModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    middle_category_id?: SortOrder
  }

  export type REPropertySubCategoryModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    middle_category_id?: SortOrder
  }

  export type REPropertySubCategoryModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    middle_category_id?: SortOrder
  }

  export type REPropertySuperCategoryModelRelationFilter = {
    is?: REPropertySuperCategoryModelWhereInput | null
    isNot?: REPropertySuperCategoryModelWhereInput | null
  }

  export type REPropertySubCategoryModelListRelationFilter = {
    every?: REPropertySubCategoryModelWhereInput
    some?: REPropertySubCategoryModelWhereInput
    none?: REPropertySubCategoryModelWhereInput
  }

  export type REPropertySubCategoryModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type REPropertyMiddleCategoryModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    super_category_id?: SortOrder
  }

  export type REPropertyMiddleCategoryModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    super_category_id?: SortOrder
  }

  export type REPropertyMiddleCategoryModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    super_category_id?: SortOrder
  }

  export type REPropertyMiddleCategoryModelListRelationFilter = {
    every?: REPropertyMiddleCategoryModelWhereInput
    some?: REPropertyMiddleCategoryModelWhereInput
    none?: REPropertyMiddleCategoryModelWhereInput
  }

  export type REPropertyMiddleCategoryModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type REPropertySuperCategoryModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
  }

  export type REPropertySuperCategoryModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
  }

  export type REPropertySuperCategoryModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
  }

  export type EnumAgreementTargetTypeFilter = {
    equals?: AgreementTargetType
    in?: Enumerable<AgreementTargetType>
    notIn?: Enumerable<AgreementTargetType>
    not?: NestedEnumAgreementTargetTypeFilter | AgreementTargetType
  }

  export type AgreementAcceptanceModelListRelationFilter = {
    every?: AgreementAcceptanceModelWhereInput
    some?: AgreementAcceptanceModelWhereInput
    none?: AgreementAcceptanceModelWhereInput
  }

  export type AgreementAcceptanceModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgreementModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    title?: SortOrder
    content?: SortOrder
    is_required?: SortOrder
    target_type?: SortOrder
  }

  export type AgreementModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    title?: SortOrder
    content?: SortOrder
    is_required?: SortOrder
    target_type?: SortOrder
  }

  export type AgreementModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    title?: SortOrder
    content?: SortOrder
    is_required?: SortOrder
    target_type?: SortOrder
  }

  export type EnumAgreementTargetTypeWithAggregatesFilter = {
    equals?: AgreementTargetType
    in?: Enumerable<AgreementTargetType>
    notIn?: Enumerable<AgreementTargetType>
    not?: NestedEnumAgreementTargetTypeWithAggregatesFilter | AgreementTargetType
    _count?: NestedIntFilter
    _min?: NestedEnumAgreementTargetTypeFilter
    _max?: NestedEnumAgreementTargetTypeFilter
  }

  export type UserModelRelationFilter = {
    is?: UserModelWhereInput | null
    isNot?: UserModelWhereInput | null
  }

  export type AgreementModelRelationFilter = {
    is?: AgreementModelWhereInput | null
    isNot?: AgreementModelWhereInput | null
  }

  export type AgreementAcceptanceModelUser_idAgreement_idCompoundUniqueInput = {
    user_id: string
    agreement_id: string
  }

  export type AgreementAcceptanceModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    user_id?: SortOrder
    agreement_id?: SortOrder
  }

  export type AgreementAcceptanceModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    user_id?: SortOrder
    agreement_id?: SortOrder
  }

  export type AgreementAcceptanceModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    user_id?: SortOrder
    agreement_id?: SortOrder
  }

  export type ServiceSuperCategoryModelRelationFilter = {
    is?: ServiceSuperCategoryModelWhereInput | null
    isNot?: ServiceSuperCategoryModelWhereInput | null
  }

  export type SubExpertiseModelListRelationFilter = {
    every?: SubExpertiseModelWhereInput
    some?: SubExpertiseModelWhereInput
    none?: SubExpertiseModelWhereInput
  }

  export type SubExpertiseModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceSubCategoryModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    super_category_id?: SortOrder
  }

  export type ServiceSubCategoryModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    super_category_id?: SortOrder
  }

  export type ServiceSubCategoryModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    super_category_id?: SortOrder
  }

  export type EnumServiceTypeFilter = {
    equals?: ServiceType
    in?: Enumerable<ServiceType>
    notIn?: Enumerable<ServiceType>
    not?: NestedEnumServiceTypeFilter | ServiceType
  }

  export type ServiceSubCategoryModelListRelationFilter = {
    every?: ServiceSubCategoryModelWhereInput
    some?: ServiceSubCategoryModelWhereInput
    none?: ServiceSubCategoryModelWhereInput
  }

  export type ZipzoongCareServiceCheckModelListRelationFilter = {
    every?: ZipzoongCareServiceCheckModelWhereInput
    some?: ZipzoongCareServiceCheckModelWhereInput
    none?: ZipzoongCareServiceCheckModelWhereInput
  }

  export type ServiceSubCategoryModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZipzoongCareServiceCheckModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceSuperCategoryModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type ServiceSuperCategoryModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type ServiceSuperCategoryModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type EnumServiceTypeWithAggregatesFilter = {
    equals?: ServiceType
    in?: Enumerable<ServiceType>
    notIn?: Enumerable<ServiceType>
    not?: NestedEnumServiceTypeWithAggregatesFilter | ServiceType
    _count?: NestedIntFilter
    _min?: NestedEnumServiceTypeFilter
    _max?: NestedEnumServiceTypeFilter
  }

  export type EnumZipzoongCareStatusFilter = {
    equals?: ZipzoongCareStatus
    in?: Enumerable<ZipzoongCareStatus>
    notIn?: Enumerable<ZipzoongCareStatus>
    not?: NestedEnumZipzoongCareStatusFilter | ZipzoongCareStatus
  }

  export type CustomerModelRelationFilter = {
    is?: CustomerModelWhereInput | null
    isNot?: CustomerModelWhereInput | null
  }

  export type ZipzoongCareConsultationTimeCheckModelListRelationFilter = {
    every?: ZipzoongCareConsultationTimeCheckModelWhereInput
    some?: ZipzoongCareConsultationTimeCheckModelWhereInput
    none?: ZipzoongCareConsultationTimeCheckModelWhereInput
  }

  export type ZipzoongCareConsultationTimeCheckModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZipzoongCareRequestModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    care_start_date?: SortOrder
    care_end_date?: SortOrder
    detail?: SortOrder
    status?: SortOrder
    requester_id?: SortOrder
  }

  export type ZipzoongCareRequestModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    care_start_date?: SortOrder
    care_end_date?: SortOrder
    detail?: SortOrder
    status?: SortOrder
    requester_id?: SortOrder
  }

  export type ZipzoongCareRequestModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    care_start_date?: SortOrder
    care_end_date?: SortOrder
    detail?: SortOrder
    status?: SortOrder
    requester_id?: SortOrder
  }

  export type EnumZipzoongCareStatusWithAggregatesFilter = {
    equals?: ZipzoongCareStatus
    in?: Enumerable<ZipzoongCareStatus>
    notIn?: Enumerable<ZipzoongCareStatus>
    not?: NestedEnumZipzoongCareStatusWithAggregatesFilter | ZipzoongCareStatus
    _count?: NestedIntFilter
    _min?: NestedEnumZipzoongCareStatusFilter
    _max?: NestedEnumZipzoongCareStatusFilter
  }

  export type ZipzoongCareRequestModelRelationFilter = {
    is?: ZipzoongCareRequestModelWhereInput | null
    isNot?: ZipzoongCareRequestModelWhereInput | null
  }

  export type ZipzoongCareServiceCheckModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    service_super_category_id?: SortOrder
    request_id?: SortOrder
  }

  export type ZipzoongCareServiceCheckModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    service_super_category_id?: SortOrder
    request_id?: SortOrder
  }

  export type ZipzoongCareServiceCheckModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    service_super_category_id?: SortOrder
    request_id?: SortOrder
  }

  export type ZipzoongCareConsultationTimeCheckModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    request_id?: SortOrder
  }

  export type ZipzoongCareConsultationTimeCheckModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    request_id?: SortOrder
  }

  export type ZipzoongCareConsultationTimeCheckModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    request_id?: SortOrder
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type BusinessUserModelRelationFilter = {
    is?: BusinessUserModelWhereInput | null
    isNot?: BusinessUserModelWhereInput | null
  }

  export type UserModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    email?: SortOrder
  }

  export type UserModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    email?: SortOrder
  }

  export type UserModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    name?: SortOrder
    email?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type EnumGenderTypeNullableFilter = {
    equals?: GenderType | null
    in?: Enumerable<GenderType> | null
    notIn?: Enumerable<GenderType> | null
    not?: NestedEnumGenderTypeNullableFilter | GenderType | null
  }

  export type OauthAccountModelListRelationFilter = {
    every?: OauthAccountModelWhereInput
    some?: OauthAccountModelWhereInput
    none?: OauthAccountModelWhereInput
  }

  export type ZipzoongCareRequestModelListRelationFilter = {
    every?: ZipzoongCareRequestModelWhereInput
    some?: ZipzoongCareRequestModelWhereInput
    none?: ZipzoongCareRequestModelWhereInput
  }

  export type OauthAccountModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZipzoongCareRequestModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerModelCountOrderByAggregateInput = {
    id?: SortOrder
    birth?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
    profile_image_url?: SortOrder
  }

  export type CustomerModelMaxOrderByAggregateInput = {
    id?: SortOrder
    birth?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
    profile_image_url?: SortOrder
  }

  export type CustomerModelMinOrderByAggregateInput = {
    id?: SortOrder
    birth?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
    profile_image_url?: SortOrder
  }

  export type EnumGenderTypeNullableWithAggregatesFilter = {
    equals?: GenderType | null
    in?: Enumerable<GenderType> | null
    notIn?: Enumerable<GenderType> | null
    not?: NestedEnumGenderTypeNullableWithAggregatesFilter | GenderType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumGenderTypeNullableFilter
    _max?: NestedEnumGenderTypeNullableFilter
  }

  export type HSProviderModelRelationFilter = {
    is?: HSProviderModelWhereInput | null
    isNot?: HSProviderModelWhereInput | null
  }

  export type BusinessCertificationImageModelListRelationFilter = {
    every?: BusinessCertificationImageModelWhereInput
    some?: BusinessCertificationImageModelWhereInput
    none?: BusinessCertificationImageModelWhereInput
  }

  export type BusinessCertificationImageModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessUserModelCountOrderByAggregateInput = {
    id?: SortOrder
    is_verified?: SortOrder
    introduction_title?: SortOrder
    introduction_content?: SortOrder
    phone?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
    profile_image_url?: SortOrder
  }

  export type BusinessUserModelMaxOrderByAggregateInput = {
    id?: SortOrder
    is_verified?: SortOrder
    introduction_title?: SortOrder
    introduction_content?: SortOrder
    phone?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
    profile_image_url?: SortOrder
  }

  export type BusinessUserModelMinOrderByAggregateInput = {
    id?: SortOrder
    is_verified?: SortOrder
    introduction_title?: SortOrder
    introduction_content?: SortOrder
    phone?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
    profile_image_url?: SortOrder
  }

  export type ServiceSubCategoryModelRelationFilter = {
    is?: ServiceSubCategoryModelWhereInput | null
    isNot?: ServiceSubCategoryModelWhereInput | null
  }

  export type SubExpertiseModelSub_category_idBusiness_user_idCompoundUniqueInput = {
    sub_category_id: string
    business_user_id: string
  }

  export type SubExpertiseModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    sub_category_id?: SortOrder
    business_user_id?: SortOrder
  }

  export type SubExpertiseModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    sub_category_id?: SortOrder
    business_user_id?: SortOrder
  }

  export type SubExpertiseModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    sub_category_id?: SortOrder
    business_user_id?: SortOrder
  }

  export type REPropertyModelListRelationFilter = {
    every?: REPropertyModelWhereInput
    some?: REPropertyModelWhereInput
    none?: REPropertyModelWhereInput
  }

  export type REPropertyModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type REAgentModelCountOrderByAggregateInput = {
    id?: SortOrder
    is_licensed?: SortOrder
    re_num?: SortOrder
    re_name?: SortOrder
    re_phone?: SortOrder
    re_licensed_agent_name?: SortOrder
  }

  export type REAgentModelMaxOrderByAggregateInput = {
    id?: SortOrder
    is_licensed?: SortOrder
    re_num?: SortOrder
    re_name?: SortOrder
    re_phone?: SortOrder
    re_licensed_agent_name?: SortOrder
  }

  export type REAgentModelMinOrderByAggregateInput = {
    id?: SortOrder
    is_licensed?: SortOrder
    re_num?: SortOrder
    re_name?: SortOrder
    re_phone?: SortOrder
    re_licensed_agent_name?: SortOrder
  }

  export type HSExampleImageModelListRelationFilter = {
    every?: HSExampleImageModelWhereInput
    some?: HSExampleImageModelWhereInput
    none?: HSExampleImageModelWhereInput
  }

  export type HSExampleImageModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HSProviderModelCountOrderByAggregateInput = {
    id?: SortOrder
    business_registration_num?: SortOrder
  }

  export type HSProviderModelMaxOrderByAggregateInput = {
    id?: SortOrder
    business_registration_num?: SortOrder
  }

  export type HSProviderModelMinOrderByAggregateInput = {
    id?: SortOrder
    business_registration_num?: SortOrder
  }

  export type BusinessCertificationImageModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    business_user_id?: SortOrder
    url?: SortOrder
  }

  export type BusinessCertificationImageModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    business_user_id?: SortOrder
    url?: SortOrder
  }

  export type BusinessCertificationImageModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    business_user_id?: SortOrder
    url?: SortOrder
  }

  export type HSExampleImageModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    hs_provider_id?: SortOrder
    url?: SortOrder
    is_visible?: SortOrder
  }

  export type HSExampleImageModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    hs_provider_id?: SortOrder
    url?: SortOrder
    is_visible?: SortOrder
  }

  export type HSExampleImageModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    hs_provider_id?: SortOrder
    url?: SortOrder
    is_visible?: SortOrder
  }

  export type EnumOauthTypeFilter = {
    equals?: OauthType
    in?: Enumerable<OauthType>
    notIn?: Enumerable<OauthType>
    not?: NestedEnumOauthTypeFilter | OauthType
  }

  export type OauthAccountModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    oauth_type?: SortOrder
    oauth_sub?: SortOrder
    business_user_id?: SortOrder
    customer_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    profile_image_url?: SortOrder
    birth?: SortOrder
    gender?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
  }

  export type OauthAccountModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    oauth_type?: SortOrder
    oauth_sub?: SortOrder
    business_user_id?: SortOrder
    customer_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    profile_image_url?: SortOrder
    birth?: SortOrder
    gender?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
  }

  export type OauthAccountModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    oauth_type?: SortOrder
    oauth_sub?: SortOrder
    business_user_id?: SortOrder
    customer_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    profile_image_url?: SortOrder
    birth?: SortOrder
    gender?: SortOrder
    address_first?: SortOrder
    address_second?: SortOrder
  }

  export type EnumOauthTypeWithAggregatesFilter = {
    equals?: OauthType
    in?: Enumerable<OauthType>
    notIn?: Enumerable<OauthType>
    not?: NestedEnumOauthTypeWithAggregatesFilter | OauthType
    _count?: NestedIntFilter
    _min?: NestedEnumOauthTypeFilter
    _max?: NestedEnumOauthTypeFilter
  }

  export type PhoneVerificationModelCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    phone?: SortOrder
    code?: SortOrder
    request_id?: SortOrder
    is_verified?: SortOrder
  }

  export type PhoneVerificationModelMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    phone?: SortOrder
    code?: SortOrder
    request_id?: SortOrder
    is_verified?: SortOrder
  }

  export type PhoneVerificationModelMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    phone?: SortOrder
    code?: SortOrder
    request_id?: SortOrder
    is_verified?: SortOrder
  }

  export type REAgentModelCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<REAgentModelCreateWithoutPropertiesInput, REAgentModelUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: REAgentModelCreateOrConnectWithoutPropertiesInput
    connect?: REAgentModelWhereUniqueInput
  }

  export type REPropertyCategoryModelCreateNestedManyWithoutRe_propertyInput = {
    create?: XOR<Enumerable<REPropertyCategoryModelCreateWithoutRe_propertyInput>, Enumerable<REPropertyCategoryModelUncheckedCreateWithoutRe_propertyInput>>
    connectOrCreate?: Enumerable<REPropertyCategoryModelCreateOrConnectWithoutRe_propertyInput>
    createMany?: REPropertyCategoryModelCreateManyRe_propertyInputEnvelope
    connect?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
  }

  export type REPropertyCategoryModelUncheckedCreateNestedManyWithoutRe_propertyInput = {
    create?: XOR<Enumerable<REPropertyCategoryModelCreateWithoutRe_propertyInput>, Enumerable<REPropertyCategoryModelUncheckedCreateWithoutRe_propertyInput>>
    connectOrCreate?: Enumerable<REPropertyCategoryModelCreateOrConnectWithoutRe_propertyInput>
    createMany?: REPropertyCategoryModelCreateManyRe_propertyInputEnvelope
    connect?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type REAgentModelUpdateOneRequiredWithoutPropertiesNestedInput = {
    create?: XOR<REAgentModelCreateWithoutPropertiesInput, REAgentModelUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: REAgentModelCreateOrConnectWithoutPropertiesInput
    upsert?: REAgentModelUpsertWithoutPropertiesInput
    connect?: REAgentModelWhereUniqueInput
    update?: XOR<REAgentModelUpdateWithoutPropertiesInput, REAgentModelUncheckedUpdateWithoutPropertiesInput>
  }

  export type REPropertyCategoryModelUpdateManyWithoutRe_propertyNestedInput = {
    create?: XOR<Enumerable<REPropertyCategoryModelCreateWithoutRe_propertyInput>, Enumerable<REPropertyCategoryModelUncheckedCreateWithoutRe_propertyInput>>
    connectOrCreate?: Enumerable<REPropertyCategoryModelCreateOrConnectWithoutRe_propertyInput>
    upsert?: Enumerable<REPropertyCategoryModelUpsertWithWhereUniqueWithoutRe_propertyInput>
    createMany?: REPropertyCategoryModelCreateManyRe_propertyInputEnvelope
    set?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    disconnect?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    delete?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    connect?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    update?: Enumerable<REPropertyCategoryModelUpdateWithWhereUniqueWithoutRe_propertyInput>
    updateMany?: Enumerable<REPropertyCategoryModelUpdateManyWithWhereWithoutRe_propertyInput>
    deleteMany?: Enumerable<REPropertyCategoryModelScalarWhereInput>
  }

  export type REPropertyCategoryModelUncheckedUpdateManyWithoutRe_propertyNestedInput = {
    create?: XOR<Enumerable<REPropertyCategoryModelCreateWithoutRe_propertyInput>, Enumerable<REPropertyCategoryModelUncheckedCreateWithoutRe_propertyInput>>
    connectOrCreate?: Enumerable<REPropertyCategoryModelCreateOrConnectWithoutRe_propertyInput>
    upsert?: Enumerable<REPropertyCategoryModelUpsertWithWhereUniqueWithoutRe_propertyInput>
    createMany?: REPropertyCategoryModelCreateManyRe_propertyInputEnvelope
    set?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    disconnect?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    delete?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    connect?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    update?: Enumerable<REPropertyCategoryModelUpdateWithWhereUniqueWithoutRe_propertyInput>
    updateMany?: Enumerable<REPropertyCategoryModelUpdateManyWithWhereWithoutRe_propertyInput>
    deleteMany?: Enumerable<REPropertyCategoryModelScalarWhereInput>
  }

  export type REPropertyModelCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<REPropertyModelCreateWithoutCategoriesInput, REPropertyModelUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: REPropertyModelCreateOrConnectWithoutCategoriesInput
    connect?: REPropertyModelWhereUniqueInput
  }

  export type REPropertySubCategoryModelCreateNestedOneWithoutProperty_categoriesInput = {
    create?: XOR<REPropertySubCategoryModelCreateWithoutProperty_categoriesInput, REPropertySubCategoryModelUncheckedCreateWithoutProperty_categoriesInput>
    connectOrCreate?: REPropertySubCategoryModelCreateOrConnectWithoutProperty_categoriesInput
    connect?: REPropertySubCategoryModelWhereUniqueInput
  }

  export type REPropertyModelUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<REPropertyModelCreateWithoutCategoriesInput, REPropertyModelUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: REPropertyModelCreateOrConnectWithoutCategoriesInput
    upsert?: REPropertyModelUpsertWithoutCategoriesInput
    connect?: REPropertyModelWhereUniqueInput
    update?: XOR<REPropertyModelUpdateWithoutCategoriesInput, REPropertyModelUncheckedUpdateWithoutCategoriesInput>
  }

  export type REPropertySubCategoryModelUpdateOneRequiredWithoutProperty_categoriesNestedInput = {
    create?: XOR<REPropertySubCategoryModelCreateWithoutProperty_categoriesInput, REPropertySubCategoryModelUncheckedCreateWithoutProperty_categoriesInput>
    connectOrCreate?: REPropertySubCategoryModelCreateOrConnectWithoutProperty_categoriesInput
    upsert?: REPropertySubCategoryModelUpsertWithoutProperty_categoriesInput
    connect?: REPropertySubCategoryModelWhereUniqueInput
    update?: XOR<REPropertySubCategoryModelUpdateWithoutProperty_categoriesInput, REPropertySubCategoryModelUncheckedUpdateWithoutProperty_categoriesInput>
  }

  export type REPropertyMiddleCategoryModelCreateNestedOneWithoutSub_categoriesInput = {
    create?: XOR<REPropertyMiddleCategoryModelCreateWithoutSub_categoriesInput, REPropertyMiddleCategoryModelUncheckedCreateWithoutSub_categoriesInput>
    connectOrCreate?: REPropertyMiddleCategoryModelCreateOrConnectWithoutSub_categoriesInput
    connect?: REPropertyMiddleCategoryModelWhereUniqueInput
  }

  export type REPropertyCategoryModelCreateNestedManyWithoutSub_categoryInput = {
    create?: XOR<Enumerable<REPropertyCategoryModelCreateWithoutSub_categoryInput>, Enumerable<REPropertyCategoryModelUncheckedCreateWithoutSub_categoryInput>>
    connectOrCreate?: Enumerable<REPropertyCategoryModelCreateOrConnectWithoutSub_categoryInput>
    createMany?: REPropertyCategoryModelCreateManySub_categoryInputEnvelope
    connect?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
  }

  export type REPropertyCategoryModelUncheckedCreateNestedManyWithoutSub_categoryInput = {
    create?: XOR<Enumerable<REPropertyCategoryModelCreateWithoutSub_categoryInput>, Enumerable<REPropertyCategoryModelUncheckedCreateWithoutSub_categoryInput>>
    connectOrCreate?: Enumerable<REPropertyCategoryModelCreateOrConnectWithoutSub_categoryInput>
    createMany?: REPropertyCategoryModelCreateManySub_categoryInputEnvelope
    connect?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
  }

  export type REPropertyMiddleCategoryModelUpdateOneRequiredWithoutSub_categoriesNestedInput = {
    create?: XOR<REPropertyMiddleCategoryModelCreateWithoutSub_categoriesInput, REPropertyMiddleCategoryModelUncheckedCreateWithoutSub_categoriesInput>
    connectOrCreate?: REPropertyMiddleCategoryModelCreateOrConnectWithoutSub_categoriesInput
    upsert?: REPropertyMiddleCategoryModelUpsertWithoutSub_categoriesInput
    connect?: REPropertyMiddleCategoryModelWhereUniqueInput
    update?: XOR<REPropertyMiddleCategoryModelUpdateWithoutSub_categoriesInput, REPropertyMiddleCategoryModelUncheckedUpdateWithoutSub_categoriesInput>
  }

  export type REPropertyCategoryModelUpdateManyWithoutSub_categoryNestedInput = {
    create?: XOR<Enumerable<REPropertyCategoryModelCreateWithoutSub_categoryInput>, Enumerable<REPropertyCategoryModelUncheckedCreateWithoutSub_categoryInput>>
    connectOrCreate?: Enumerable<REPropertyCategoryModelCreateOrConnectWithoutSub_categoryInput>
    upsert?: Enumerable<REPropertyCategoryModelUpsertWithWhereUniqueWithoutSub_categoryInput>
    createMany?: REPropertyCategoryModelCreateManySub_categoryInputEnvelope
    set?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    disconnect?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    delete?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    connect?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    update?: Enumerable<REPropertyCategoryModelUpdateWithWhereUniqueWithoutSub_categoryInput>
    updateMany?: Enumerable<REPropertyCategoryModelUpdateManyWithWhereWithoutSub_categoryInput>
    deleteMany?: Enumerable<REPropertyCategoryModelScalarWhereInput>
  }

  export type REPropertyCategoryModelUncheckedUpdateManyWithoutSub_categoryNestedInput = {
    create?: XOR<Enumerable<REPropertyCategoryModelCreateWithoutSub_categoryInput>, Enumerable<REPropertyCategoryModelUncheckedCreateWithoutSub_categoryInput>>
    connectOrCreate?: Enumerable<REPropertyCategoryModelCreateOrConnectWithoutSub_categoryInput>
    upsert?: Enumerable<REPropertyCategoryModelUpsertWithWhereUniqueWithoutSub_categoryInput>
    createMany?: REPropertyCategoryModelCreateManySub_categoryInputEnvelope
    set?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    disconnect?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    delete?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    connect?: Enumerable<REPropertyCategoryModelWhereUniqueInput>
    update?: Enumerable<REPropertyCategoryModelUpdateWithWhereUniqueWithoutSub_categoryInput>
    updateMany?: Enumerable<REPropertyCategoryModelUpdateManyWithWhereWithoutSub_categoryInput>
    deleteMany?: Enumerable<REPropertyCategoryModelScalarWhereInput>
  }

  export type REPropertySuperCategoryModelCreateNestedOneWithoutMiddle_categoriesInput = {
    create?: XOR<REPropertySuperCategoryModelCreateWithoutMiddle_categoriesInput, REPropertySuperCategoryModelUncheckedCreateWithoutMiddle_categoriesInput>
    connectOrCreate?: REPropertySuperCategoryModelCreateOrConnectWithoutMiddle_categoriesInput
    connect?: REPropertySuperCategoryModelWhereUniqueInput
  }

  export type REPropertySubCategoryModelCreateNestedManyWithoutMiddle_categoryInput = {
    create?: XOR<Enumerable<REPropertySubCategoryModelCreateWithoutMiddle_categoryInput>, Enumerable<REPropertySubCategoryModelUncheckedCreateWithoutMiddle_categoryInput>>
    connectOrCreate?: Enumerable<REPropertySubCategoryModelCreateOrConnectWithoutMiddle_categoryInput>
    createMany?: REPropertySubCategoryModelCreateManyMiddle_categoryInputEnvelope
    connect?: Enumerable<REPropertySubCategoryModelWhereUniqueInput>
  }

  export type REPropertySubCategoryModelUncheckedCreateNestedManyWithoutMiddle_categoryInput = {
    create?: XOR<Enumerable<REPropertySubCategoryModelCreateWithoutMiddle_categoryInput>, Enumerable<REPropertySubCategoryModelUncheckedCreateWithoutMiddle_categoryInput>>
    connectOrCreate?: Enumerable<REPropertySubCategoryModelCreateOrConnectWithoutMiddle_categoryInput>
    createMany?: REPropertySubCategoryModelCreateManyMiddle_categoryInputEnvelope
    connect?: Enumerable<REPropertySubCategoryModelWhereUniqueInput>
  }

  export type REPropertySuperCategoryModelUpdateOneRequiredWithoutMiddle_categoriesNestedInput = {
    create?: XOR<REPropertySuperCategoryModelCreateWithoutMiddle_categoriesInput, REPropertySuperCategoryModelUncheckedCreateWithoutMiddle_categoriesInput>
    connectOrCreate?: REPropertySuperCategoryModelCreateOrConnectWithoutMiddle_categoriesInput
    upsert?: REPropertySuperCategoryModelUpsertWithoutMiddle_categoriesInput
    connect?: REPropertySuperCategoryModelWhereUniqueInput
    update?: XOR<REPropertySuperCategoryModelUpdateWithoutMiddle_categoriesInput, REPropertySuperCategoryModelUncheckedUpdateWithoutMiddle_categoriesInput>
  }

  export type REPropertySubCategoryModelUpdateManyWithoutMiddle_categoryNestedInput = {
    create?: XOR<Enumerable<REPropertySubCategoryModelCreateWithoutMiddle_categoryInput>, Enumerable<REPropertySubCategoryModelUncheckedCreateWithoutMiddle_categoryInput>>
    connectOrCreate?: Enumerable<REPropertySubCategoryModelCreateOrConnectWithoutMiddle_categoryInput>
    upsert?: Enumerable<REPropertySubCategoryModelUpsertWithWhereUniqueWithoutMiddle_categoryInput>
    createMany?: REPropertySubCategoryModelCreateManyMiddle_categoryInputEnvelope
    set?: Enumerable<REPropertySubCategoryModelWhereUniqueInput>
    disconnect?: Enumerable<REPropertySubCategoryModelWhereUniqueInput>
    delete?: Enumerable<REPropertySubCategoryModelWhereUniqueInput>
    connect?: Enumerable<REPropertySubCategoryModelWhereUniqueInput>
    update?: Enumerable<REPropertySubCategoryModelUpdateWithWhereUniqueWithoutMiddle_categoryInput>
    updateMany?: Enumerable<REPropertySubCategoryModelUpdateManyWithWhereWithoutMiddle_categoryInput>
    deleteMany?: Enumerable<REPropertySubCategoryModelScalarWhereInput>
  }

  export type REPropertySubCategoryModelUncheckedUpdateManyWithoutMiddle_categoryNestedInput = {
    create?: XOR<Enumerable<REPropertySubCategoryModelCreateWithoutMiddle_categoryInput>, Enumerable<REPropertySubCategoryModelUncheckedCreateWithoutMiddle_categoryInput>>
    connectOrCreate?: Enumerable<REPropertySubCategoryModelCreateOrConnectWithoutMiddle_categoryInput>
    upsert?: Enumerable<REPropertySubCategoryModelUpsertWithWhereUniqueWithoutMiddle_categoryInput>
    createMany?: REPropertySubCategoryModelCreateManyMiddle_categoryInputEnvelope
    set?: Enumerable<REPropertySubCategoryModelWhereUniqueInput>
    disconnect?: Enumerable<REPropertySubCategoryModelWhereUniqueInput>
    delete?: Enumerable<REPropertySubCategoryModelWhereUniqueInput>
    connect?: Enumerable<REPropertySubCategoryModelWhereUniqueInput>
    update?: Enumerable<REPropertySubCategoryModelUpdateWithWhereUniqueWithoutMiddle_categoryInput>
    updateMany?: Enumerable<REPropertySubCategoryModelUpdateManyWithWhereWithoutMiddle_categoryInput>
    deleteMany?: Enumerable<REPropertySubCategoryModelScalarWhereInput>
  }

  export type REPropertyMiddleCategoryModelCreateNestedManyWithoutSuper_categoryInput = {
    create?: XOR<Enumerable<REPropertyMiddleCategoryModelCreateWithoutSuper_categoryInput>, Enumerable<REPropertyMiddleCategoryModelUncheckedCreateWithoutSuper_categoryInput>>
    connectOrCreate?: Enumerable<REPropertyMiddleCategoryModelCreateOrConnectWithoutSuper_categoryInput>
    createMany?: REPropertyMiddleCategoryModelCreateManySuper_categoryInputEnvelope
    connect?: Enumerable<REPropertyMiddleCategoryModelWhereUniqueInput>
  }

  export type REPropertyMiddleCategoryModelUncheckedCreateNestedManyWithoutSuper_categoryInput = {
    create?: XOR<Enumerable<REPropertyMiddleCategoryModelCreateWithoutSuper_categoryInput>, Enumerable<REPropertyMiddleCategoryModelUncheckedCreateWithoutSuper_categoryInput>>
    connectOrCreate?: Enumerable<REPropertyMiddleCategoryModelCreateOrConnectWithoutSuper_categoryInput>
    createMany?: REPropertyMiddleCategoryModelCreateManySuper_categoryInputEnvelope
    connect?: Enumerable<REPropertyMiddleCategoryModelWhereUniqueInput>
  }

  export type REPropertyMiddleCategoryModelUpdateManyWithoutSuper_categoryNestedInput = {
    create?: XOR<Enumerable<REPropertyMiddleCategoryModelCreateWithoutSuper_categoryInput>, Enumerable<REPropertyMiddleCategoryModelUncheckedCreateWithoutSuper_categoryInput>>
    connectOrCreate?: Enumerable<REPropertyMiddleCategoryModelCreateOrConnectWithoutSuper_categoryInput>
    upsert?: Enumerable<REPropertyMiddleCategoryModelUpsertWithWhereUniqueWithoutSuper_categoryInput>
    createMany?: REPropertyMiddleCategoryModelCreateManySuper_categoryInputEnvelope
    set?: Enumerable<REPropertyMiddleCategoryModelWhereUniqueInput>
    disconnect?: Enumerable<REPropertyMiddleCategoryModelWhereUniqueInput>
    delete?: Enumerable<REPropertyMiddleCategoryModelWhereUniqueInput>
    connect?: Enumerable<REPropertyMiddleCategoryModelWhereUniqueInput>
    update?: Enumerable<REPropertyMiddleCategoryModelUpdateWithWhereUniqueWithoutSuper_categoryInput>
    updateMany?: Enumerable<REPropertyMiddleCategoryModelUpdateManyWithWhereWithoutSuper_categoryInput>
    deleteMany?: Enumerable<REPropertyMiddleCategoryModelScalarWhereInput>
  }

  export type REPropertyMiddleCategoryModelUncheckedUpdateManyWithoutSuper_categoryNestedInput = {
    create?: XOR<Enumerable<REPropertyMiddleCategoryModelCreateWithoutSuper_categoryInput>, Enumerable<REPropertyMiddleCategoryModelUncheckedCreateWithoutSuper_categoryInput>>
    connectOrCreate?: Enumerable<REPropertyMiddleCategoryModelCreateOrConnectWithoutSuper_categoryInput>
    upsert?: Enumerable<REPropertyMiddleCategoryModelUpsertWithWhereUniqueWithoutSuper_categoryInput>
    createMany?: REPropertyMiddleCategoryModelCreateManySuper_categoryInputEnvelope
    set?: Enumerable<REPropertyMiddleCategoryModelWhereUniqueInput>
    disconnect?: Enumerable<REPropertyMiddleCategoryModelWhereUniqueInput>
    delete?: Enumerable<REPropertyMiddleCategoryModelWhereUniqueInput>
    connect?: Enumerable<REPropertyMiddleCategoryModelWhereUniqueInput>
    update?: Enumerable<REPropertyMiddleCategoryModelUpdateWithWhereUniqueWithoutSuper_categoryInput>
    updateMany?: Enumerable<REPropertyMiddleCategoryModelUpdateManyWithWhereWithoutSuper_categoryInput>
    deleteMany?: Enumerable<REPropertyMiddleCategoryModelScalarWhereInput>
  }

  export type AgreementAcceptanceModelCreateNestedManyWithoutAgreementInput = {
    create?: XOR<Enumerable<AgreementAcceptanceModelCreateWithoutAgreementInput>, Enumerable<AgreementAcceptanceModelUncheckedCreateWithoutAgreementInput>>
    connectOrCreate?: Enumerable<AgreementAcceptanceModelCreateOrConnectWithoutAgreementInput>
    createMany?: AgreementAcceptanceModelCreateManyAgreementInputEnvelope
    connect?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
  }

  export type AgreementAcceptanceModelUncheckedCreateNestedManyWithoutAgreementInput = {
    create?: XOR<Enumerable<AgreementAcceptanceModelCreateWithoutAgreementInput>, Enumerable<AgreementAcceptanceModelUncheckedCreateWithoutAgreementInput>>
    connectOrCreate?: Enumerable<AgreementAcceptanceModelCreateOrConnectWithoutAgreementInput>
    createMany?: AgreementAcceptanceModelCreateManyAgreementInputEnvelope
    connect?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
  }

  export type EnumAgreementTargetTypeFieldUpdateOperationsInput = {
    set?: AgreementTargetType
  }

  export type AgreementAcceptanceModelUpdateManyWithoutAgreementNestedInput = {
    create?: XOR<Enumerable<AgreementAcceptanceModelCreateWithoutAgreementInput>, Enumerable<AgreementAcceptanceModelUncheckedCreateWithoutAgreementInput>>
    connectOrCreate?: Enumerable<AgreementAcceptanceModelCreateOrConnectWithoutAgreementInput>
    upsert?: Enumerable<AgreementAcceptanceModelUpsertWithWhereUniqueWithoutAgreementInput>
    createMany?: AgreementAcceptanceModelCreateManyAgreementInputEnvelope
    set?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    disconnect?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    delete?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    connect?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    update?: Enumerable<AgreementAcceptanceModelUpdateWithWhereUniqueWithoutAgreementInput>
    updateMany?: Enumerable<AgreementAcceptanceModelUpdateManyWithWhereWithoutAgreementInput>
    deleteMany?: Enumerable<AgreementAcceptanceModelScalarWhereInput>
  }

  export type AgreementAcceptanceModelUncheckedUpdateManyWithoutAgreementNestedInput = {
    create?: XOR<Enumerable<AgreementAcceptanceModelCreateWithoutAgreementInput>, Enumerable<AgreementAcceptanceModelUncheckedCreateWithoutAgreementInput>>
    connectOrCreate?: Enumerable<AgreementAcceptanceModelCreateOrConnectWithoutAgreementInput>
    upsert?: Enumerable<AgreementAcceptanceModelUpsertWithWhereUniqueWithoutAgreementInput>
    createMany?: AgreementAcceptanceModelCreateManyAgreementInputEnvelope
    set?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    disconnect?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    delete?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    connect?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    update?: Enumerable<AgreementAcceptanceModelUpdateWithWhereUniqueWithoutAgreementInput>
    updateMany?: Enumerable<AgreementAcceptanceModelUpdateManyWithWhereWithoutAgreementInput>
    deleteMany?: Enumerable<AgreementAcceptanceModelScalarWhereInput>
  }

  export type UserModelCreateNestedOneWithoutAgreement_acceptancesInput = {
    create?: XOR<UserModelCreateWithoutAgreement_acceptancesInput, UserModelUncheckedCreateWithoutAgreement_acceptancesInput>
    connectOrCreate?: UserModelCreateOrConnectWithoutAgreement_acceptancesInput
    connect?: UserModelWhereUniqueInput
  }

  export type AgreementModelCreateNestedOneWithoutAcceptancesInput = {
    create?: XOR<AgreementModelCreateWithoutAcceptancesInput, AgreementModelUncheckedCreateWithoutAcceptancesInput>
    connectOrCreate?: AgreementModelCreateOrConnectWithoutAcceptancesInput
    connect?: AgreementModelWhereUniqueInput
  }

  export type UserModelUpdateOneRequiredWithoutAgreement_acceptancesNestedInput = {
    create?: XOR<UserModelCreateWithoutAgreement_acceptancesInput, UserModelUncheckedCreateWithoutAgreement_acceptancesInput>
    connectOrCreate?: UserModelCreateOrConnectWithoutAgreement_acceptancesInput
    upsert?: UserModelUpsertWithoutAgreement_acceptancesInput
    connect?: UserModelWhereUniqueInput
    update?: XOR<UserModelUpdateWithoutAgreement_acceptancesInput, UserModelUncheckedUpdateWithoutAgreement_acceptancesInput>
  }

  export type AgreementModelUpdateOneRequiredWithoutAcceptancesNestedInput = {
    create?: XOR<AgreementModelCreateWithoutAcceptancesInput, AgreementModelUncheckedCreateWithoutAcceptancesInput>
    connectOrCreate?: AgreementModelCreateOrConnectWithoutAcceptancesInput
    upsert?: AgreementModelUpsertWithoutAcceptancesInput
    connect?: AgreementModelWhereUniqueInput
    update?: XOR<AgreementModelUpdateWithoutAcceptancesInput, AgreementModelUncheckedUpdateWithoutAcceptancesInput>
  }

  export type ServiceSuperCategoryModelCreateNestedOneWithoutSub_categoriesInput = {
    create?: XOR<ServiceSuperCategoryModelCreateWithoutSub_categoriesInput, ServiceSuperCategoryModelUncheckedCreateWithoutSub_categoriesInput>
    connectOrCreate?: ServiceSuperCategoryModelCreateOrConnectWithoutSub_categoriesInput
    connect?: ServiceSuperCategoryModelWhereUniqueInput
  }

  export type SubExpertiseModelCreateNestedManyWithoutSub_categoryInput = {
    create?: XOR<Enumerable<SubExpertiseModelCreateWithoutSub_categoryInput>, Enumerable<SubExpertiseModelUncheckedCreateWithoutSub_categoryInput>>
    connectOrCreate?: Enumerable<SubExpertiseModelCreateOrConnectWithoutSub_categoryInput>
    createMany?: SubExpertiseModelCreateManySub_categoryInputEnvelope
    connect?: Enumerable<SubExpertiseModelWhereUniqueInput>
  }

  export type SubExpertiseModelUncheckedCreateNestedManyWithoutSub_categoryInput = {
    create?: XOR<Enumerable<SubExpertiseModelCreateWithoutSub_categoryInput>, Enumerable<SubExpertiseModelUncheckedCreateWithoutSub_categoryInput>>
    connectOrCreate?: Enumerable<SubExpertiseModelCreateOrConnectWithoutSub_categoryInput>
    createMany?: SubExpertiseModelCreateManySub_categoryInputEnvelope
    connect?: Enumerable<SubExpertiseModelWhereUniqueInput>
  }

  export type ServiceSuperCategoryModelUpdateOneRequiredWithoutSub_categoriesNestedInput = {
    create?: XOR<ServiceSuperCategoryModelCreateWithoutSub_categoriesInput, ServiceSuperCategoryModelUncheckedCreateWithoutSub_categoriesInput>
    connectOrCreate?: ServiceSuperCategoryModelCreateOrConnectWithoutSub_categoriesInput
    upsert?: ServiceSuperCategoryModelUpsertWithoutSub_categoriesInput
    connect?: ServiceSuperCategoryModelWhereUniqueInput
    update?: XOR<ServiceSuperCategoryModelUpdateWithoutSub_categoriesInput, ServiceSuperCategoryModelUncheckedUpdateWithoutSub_categoriesInput>
  }

  export type SubExpertiseModelUpdateManyWithoutSub_categoryNestedInput = {
    create?: XOR<Enumerable<SubExpertiseModelCreateWithoutSub_categoryInput>, Enumerable<SubExpertiseModelUncheckedCreateWithoutSub_categoryInput>>
    connectOrCreate?: Enumerable<SubExpertiseModelCreateOrConnectWithoutSub_categoryInput>
    upsert?: Enumerable<SubExpertiseModelUpsertWithWhereUniqueWithoutSub_categoryInput>
    createMany?: SubExpertiseModelCreateManySub_categoryInputEnvelope
    set?: Enumerable<SubExpertiseModelWhereUniqueInput>
    disconnect?: Enumerable<SubExpertiseModelWhereUniqueInput>
    delete?: Enumerable<SubExpertiseModelWhereUniqueInput>
    connect?: Enumerable<SubExpertiseModelWhereUniqueInput>
    update?: Enumerable<SubExpertiseModelUpdateWithWhereUniqueWithoutSub_categoryInput>
    updateMany?: Enumerable<SubExpertiseModelUpdateManyWithWhereWithoutSub_categoryInput>
    deleteMany?: Enumerable<SubExpertiseModelScalarWhereInput>
  }

  export type SubExpertiseModelUncheckedUpdateManyWithoutSub_categoryNestedInput = {
    create?: XOR<Enumerable<SubExpertiseModelCreateWithoutSub_categoryInput>, Enumerable<SubExpertiseModelUncheckedCreateWithoutSub_categoryInput>>
    connectOrCreate?: Enumerable<SubExpertiseModelCreateOrConnectWithoutSub_categoryInput>
    upsert?: Enumerable<SubExpertiseModelUpsertWithWhereUniqueWithoutSub_categoryInput>
    createMany?: SubExpertiseModelCreateManySub_categoryInputEnvelope
    set?: Enumerable<SubExpertiseModelWhereUniqueInput>
    disconnect?: Enumerable<SubExpertiseModelWhereUniqueInput>
    delete?: Enumerable<SubExpertiseModelWhereUniqueInput>
    connect?: Enumerable<SubExpertiseModelWhereUniqueInput>
    update?: Enumerable<SubExpertiseModelUpdateWithWhereUniqueWithoutSub_categoryInput>
    updateMany?: Enumerable<SubExpertiseModelUpdateManyWithWhereWithoutSub_categoryInput>
    deleteMany?: Enumerable<SubExpertiseModelScalarWhereInput>
  }

  export type ServiceSubCategoryModelCreateNestedManyWithoutSuper_categoryInput = {
    create?: XOR<Enumerable<ServiceSubCategoryModelCreateWithoutSuper_categoryInput>, Enumerable<ServiceSubCategoryModelUncheckedCreateWithoutSuper_categoryInput>>
    connectOrCreate?: Enumerable<ServiceSubCategoryModelCreateOrConnectWithoutSuper_categoryInput>
    createMany?: ServiceSubCategoryModelCreateManySuper_categoryInputEnvelope
    connect?: Enumerable<ServiceSubCategoryModelWhereUniqueInput>
  }

  export type ZipzoongCareServiceCheckModelCreateNestedManyWithoutService_super_categoryInput = {
    create?: XOR<Enumerable<ZipzoongCareServiceCheckModelCreateWithoutService_super_categoryInput>, Enumerable<ZipzoongCareServiceCheckModelUncheckedCreateWithoutService_super_categoryInput>>
    connectOrCreate?: Enumerable<ZipzoongCareServiceCheckModelCreateOrConnectWithoutService_super_categoryInput>
    createMany?: ZipzoongCareServiceCheckModelCreateManyService_super_categoryInputEnvelope
    connect?: Enumerable<ZipzoongCareServiceCheckModelWhereUniqueInput>
  }

  export type ServiceSubCategoryModelUncheckedCreateNestedManyWithoutSuper_categoryInput = {
    create?: XOR<Enumerable<ServiceSubCategoryModelCreateWithoutSuper_categoryInput>, Enumerable<ServiceSubCategoryModelUncheckedCreateWithoutSuper_categoryInput>>
    connectOrCreate?: Enumerable<ServiceSubCategoryModelCreateOrConnectWithoutSuper_categoryInput>
    createMany?: ServiceSubCategoryModelCreateManySuper_categoryInputEnvelope
    connect?: Enumerable<ServiceSubCategoryModelWhereUniqueInput>
  }

  export type ZipzoongCareServiceCheckModelUncheckedCreateNestedManyWithoutService_super_categoryInput = {
    create?: XOR<Enumerable<ZipzoongCareServiceCheckModelCreateWithoutService_super_categoryInput>, Enumerable<ZipzoongCareServiceCheckModelUncheckedCreateWithoutService_super_categoryInput>>
    connectOrCreate?: Enumerable<ZipzoongCareServiceCheckModelCreateOrConnectWithoutService_super_categoryInput>
    createMany?: ZipzoongCareServiceCheckModelCreateManyService_super_categoryInputEnvelope
    connect?: Enumerable<ZipzoongCareServiceCheckModelWhereUniqueInput>
  }

  export type EnumServiceTypeFieldUpdateOperationsInput = {
    set?: ServiceType
  }

  export type ServiceSubCategoryModelUpdateManyWithoutSuper_categoryNestedInput = {
    create?: XOR<Enumerable<ServiceSubCategoryModelCreateWithoutSuper_categoryInput>, Enumerable<ServiceSubCategoryModelUncheckedCreateWithoutSuper_categoryInput>>
    connectOrCreate?: Enumerable<ServiceSubCategoryModelCreateOrConnectWithoutSuper_categoryInput>
    upsert?: Enumerable<ServiceSubCategoryModelUpsertWithWhereUniqueWithoutSuper_categoryInput>
    createMany?: ServiceSubCategoryModelCreateManySuper_categoryInputEnvelope
    set?: Enumerable<ServiceSubCategoryModelWhereUniqueInput>
    disconnect?: Enumerable<ServiceSubCategoryModelWhereUniqueInput>
    delete?: Enumerable<ServiceSubCategoryModelWhereUniqueInput>
    connect?: Enumerable<ServiceSubCategoryModelWhereUniqueInput>
    update?: Enumerable<ServiceSubCategoryModelUpdateWithWhereUniqueWithoutSuper_categoryInput>
    updateMany?: Enumerable<ServiceSubCategoryModelUpdateManyWithWhereWithoutSuper_categoryInput>
    deleteMany?: Enumerable<ServiceSubCategoryModelScalarWhereInput>
  }

  export type ZipzoongCareServiceCheckModelUpdateManyWithoutService_super_categoryNestedInput = {
    create?: XOR<Enumerable<ZipzoongCareServiceCheckModelCreateWithoutService_super_categoryInput>, Enumerable<ZipzoongCareServiceCheckModelUncheckedCreateWithoutService_super_categoryInput>>
    connectOrCreate?: Enumerable<ZipzoongCareServiceCheckModelCreateOrConnectWithoutService_super_categoryInput>
    upsert?: Enumerable<ZipzoongCareServiceCheckModelUpsertWithWhereUniqueWithoutService_super_categoryInput>
    createMany?: ZipzoongCareServiceCheckModelCreateManyService_super_categoryInputEnvelope
    set?: Enumerable<ZipzoongCareServiceCheckModelWhereUniqueInput>
    disconnect?: Enumerable<ZipzoongCareServiceCheckModelWhereUniqueInput>
    delete?: Enumerable<ZipzoongCareServiceCheckModelWhereUniqueInput>
    connect?: Enumerable<ZipzoongCareServiceCheckModelWhereUniqueInput>
    update?: Enumerable<ZipzoongCareServiceCheckModelUpdateWithWhereUniqueWithoutService_super_categoryInput>
    updateMany?: Enumerable<ZipzoongCareServiceCheckModelUpdateManyWithWhereWithoutService_super_categoryInput>
    deleteMany?: Enumerable<ZipzoongCareServiceCheckModelScalarWhereInput>
  }

  export type ServiceSubCategoryModelUncheckedUpdateManyWithoutSuper_categoryNestedInput = {
    create?: XOR<Enumerable<ServiceSubCategoryModelCreateWithoutSuper_categoryInput>, Enumerable<ServiceSubCategoryModelUncheckedCreateWithoutSuper_categoryInput>>
    connectOrCreate?: Enumerable<ServiceSubCategoryModelCreateOrConnectWithoutSuper_categoryInput>
    upsert?: Enumerable<ServiceSubCategoryModelUpsertWithWhereUniqueWithoutSuper_categoryInput>
    createMany?: ServiceSubCategoryModelCreateManySuper_categoryInputEnvelope
    set?: Enumerable<ServiceSubCategoryModelWhereUniqueInput>
    disconnect?: Enumerable<ServiceSubCategoryModelWhereUniqueInput>
    delete?: Enumerable<ServiceSubCategoryModelWhereUniqueInput>
    connect?: Enumerable<ServiceSubCategoryModelWhereUniqueInput>
    update?: Enumerable<ServiceSubCategoryModelUpdateWithWhereUniqueWithoutSuper_categoryInput>
    updateMany?: Enumerable<ServiceSubCategoryModelUpdateManyWithWhereWithoutSuper_categoryInput>
    deleteMany?: Enumerable<ServiceSubCategoryModelScalarWhereInput>
  }

  export type ZipzoongCareServiceCheckModelUncheckedUpdateManyWithoutService_super_categoryNestedInput = {
    create?: XOR<Enumerable<ZipzoongCareServiceCheckModelCreateWithoutService_super_categoryInput>, Enumerable<ZipzoongCareServiceCheckModelUncheckedCreateWithoutService_super_categoryInput>>
    connectOrCreate?: Enumerable<ZipzoongCareServiceCheckModelCreateOrConnectWithoutService_super_categoryInput>
    upsert?: Enumerable<ZipzoongCareServiceCheckModelUpsertWithWhereUniqueWithoutService_super_categoryInput>
    createMany?: ZipzoongCareServiceCheckModelCreateManyService_super_categoryInputEnvelope
    set?: Enumerable<ZipzoongCareServiceCheckModelWhereUniqueInput>
    disconnect?: Enumerable<ZipzoongCareServiceCheckModelWhereUniqueInput>
    delete?: Enumerable<ZipzoongCareServiceCheckModelWhereUniqueInput>
    connect?: Enumerable<ZipzoongCareServiceCheckModelWhereUniqueInput>
    update?: Enumerable<ZipzoongCareServiceCheckModelUpdateWithWhereUniqueWithoutService_super_categoryInput>
    updateMany?: Enumerable<ZipzoongCareServiceCheckModelUpdateManyWithWhereWithoutService_super_categoryInput>
    deleteMany?: Enumerable<ZipzoongCareServiceCheckModelScalarWhereInput>
  }

  export type CustomerModelCreateNestedOneWithoutZipzoong_care_requestsInput = {
    create?: XOR<CustomerModelCreateWithoutZipzoong_care_requestsInput, CustomerModelUncheckedCreateWithoutZipzoong_care_requestsInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutZipzoong_care_requestsInput
    connect?: CustomerModelWhereUniqueInput
  }

  export type ZipzoongCareConsultationTimeCheckModelCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<ZipzoongCareConsultationTimeCheckModelCreateWithoutRequestInput>, Enumerable<ZipzoongCareConsultationTimeCheckModelUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<ZipzoongCareConsultationTimeCheckModelCreateOrConnectWithoutRequestInput>
    createMany?: ZipzoongCareConsultationTimeCheckModelCreateManyRequestInputEnvelope
    connect?: Enumerable<ZipzoongCareConsultationTimeCheckModelWhereUniqueInput>
  }

  export type ZipzoongCareServiceCheckModelCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<ZipzoongCareServiceCheckModelCreateWithoutRequestInput>, Enumerable<ZipzoongCareServiceCheckModelUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<ZipzoongCareServiceCheckModelCreateOrConnectWithoutRequestInput>
    createMany?: ZipzoongCareServiceCheckModelCreateManyRequestInputEnvelope
    connect?: Enumerable<ZipzoongCareServiceCheckModelWhereUniqueInput>
  }

  export type ZipzoongCareConsultationTimeCheckModelUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<ZipzoongCareConsultationTimeCheckModelCreateWithoutRequestInput>, Enumerable<ZipzoongCareConsultationTimeCheckModelUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<ZipzoongCareConsultationTimeCheckModelCreateOrConnectWithoutRequestInput>
    createMany?: ZipzoongCareConsultationTimeCheckModelCreateManyRequestInputEnvelope
    connect?: Enumerable<ZipzoongCareConsultationTimeCheckModelWhereUniqueInput>
  }

  export type ZipzoongCareServiceCheckModelUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<Enumerable<ZipzoongCareServiceCheckModelCreateWithoutRequestInput>, Enumerable<ZipzoongCareServiceCheckModelUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<ZipzoongCareServiceCheckModelCreateOrConnectWithoutRequestInput>
    createMany?: ZipzoongCareServiceCheckModelCreateManyRequestInputEnvelope
    connect?: Enumerable<ZipzoongCareServiceCheckModelWhereUniqueInput>
  }

  export type EnumZipzoongCareStatusFieldUpdateOperationsInput = {
    set?: ZipzoongCareStatus
  }

  export type CustomerModelUpdateOneRequiredWithoutZipzoong_care_requestsNestedInput = {
    create?: XOR<CustomerModelCreateWithoutZipzoong_care_requestsInput, CustomerModelUncheckedCreateWithoutZipzoong_care_requestsInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutZipzoong_care_requestsInput
    upsert?: CustomerModelUpsertWithoutZipzoong_care_requestsInput
    connect?: CustomerModelWhereUniqueInput
    update?: XOR<CustomerModelUpdateWithoutZipzoong_care_requestsInput, CustomerModelUncheckedUpdateWithoutZipzoong_care_requestsInput>
  }

  export type ZipzoongCareConsultationTimeCheckModelUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<ZipzoongCareConsultationTimeCheckModelCreateWithoutRequestInput>, Enumerable<ZipzoongCareConsultationTimeCheckModelUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<ZipzoongCareConsultationTimeCheckModelCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<ZipzoongCareConsultationTimeCheckModelUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: ZipzoongCareConsultationTimeCheckModelCreateManyRequestInputEnvelope
    set?: Enumerable<ZipzoongCareConsultationTimeCheckModelWhereUniqueInput>
    disconnect?: Enumerable<ZipzoongCareConsultationTimeCheckModelWhereUniqueInput>
    delete?: Enumerable<ZipzoongCareConsultationTimeCheckModelWhereUniqueInput>
    connect?: Enumerable<ZipzoongCareConsultationTimeCheckModelWhereUniqueInput>
    update?: Enumerable<ZipzoongCareConsultationTimeCheckModelUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<ZipzoongCareConsultationTimeCheckModelUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<ZipzoongCareConsultationTimeCheckModelScalarWhereInput>
  }

  export type ZipzoongCareServiceCheckModelUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<ZipzoongCareServiceCheckModelCreateWithoutRequestInput>, Enumerable<ZipzoongCareServiceCheckModelUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<ZipzoongCareServiceCheckModelCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<ZipzoongCareServiceCheckModelUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: ZipzoongCareServiceCheckModelCreateManyRequestInputEnvelope
    set?: Enumerable<ZipzoongCareServiceCheckModelWhereUniqueInput>
    disconnect?: Enumerable<ZipzoongCareServiceCheckModelWhereUniqueInput>
    delete?: Enumerable<ZipzoongCareServiceCheckModelWhereUniqueInput>
    connect?: Enumerable<ZipzoongCareServiceCheckModelWhereUniqueInput>
    update?: Enumerable<ZipzoongCareServiceCheckModelUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<ZipzoongCareServiceCheckModelUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<ZipzoongCareServiceCheckModelScalarWhereInput>
  }

  export type ZipzoongCareConsultationTimeCheckModelUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<ZipzoongCareConsultationTimeCheckModelCreateWithoutRequestInput>, Enumerable<ZipzoongCareConsultationTimeCheckModelUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<ZipzoongCareConsultationTimeCheckModelCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<ZipzoongCareConsultationTimeCheckModelUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: ZipzoongCareConsultationTimeCheckModelCreateManyRequestInputEnvelope
    set?: Enumerable<ZipzoongCareConsultationTimeCheckModelWhereUniqueInput>
    disconnect?: Enumerable<ZipzoongCareConsultationTimeCheckModelWhereUniqueInput>
    delete?: Enumerable<ZipzoongCareConsultationTimeCheckModelWhereUniqueInput>
    connect?: Enumerable<ZipzoongCareConsultationTimeCheckModelWhereUniqueInput>
    update?: Enumerable<ZipzoongCareConsultationTimeCheckModelUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<ZipzoongCareConsultationTimeCheckModelUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<ZipzoongCareConsultationTimeCheckModelScalarWhereInput>
  }

  export type ZipzoongCareServiceCheckModelUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<Enumerable<ZipzoongCareServiceCheckModelCreateWithoutRequestInput>, Enumerable<ZipzoongCareServiceCheckModelUncheckedCreateWithoutRequestInput>>
    connectOrCreate?: Enumerable<ZipzoongCareServiceCheckModelCreateOrConnectWithoutRequestInput>
    upsert?: Enumerable<ZipzoongCareServiceCheckModelUpsertWithWhereUniqueWithoutRequestInput>
    createMany?: ZipzoongCareServiceCheckModelCreateManyRequestInputEnvelope
    set?: Enumerable<ZipzoongCareServiceCheckModelWhereUniqueInput>
    disconnect?: Enumerable<ZipzoongCareServiceCheckModelWhereUniqueInput>
    delete?: Enumerable<ZipzoongCareServiceCheckModelWhereUniqueInput>
    connect?: Enumerable<ZipzoongCareServiceCheckModelWhereUniqueInput>
    update?: Enumerable<ZipzoongCareServiceCheckModelUpdateWithWhereUniqueWithoutRequestInput>
    updateMany?: Enumerable<ZipzoongCareServiceCheckModelUpdateManyWithWhereWithoutRequestInput>
    deleteMany?: Enumerable<ZipzoongCareServiceCheckModelScalarWhereInput>
  }

  export type ServiceSuperCategoryModelCreateNestedOneWithoutFocus_care_checksInput = {
    create?: XOR<ServiceSuperCategoryModelCreateWithoutFocus_care_checksInput, ServiceSuperCategoryModelUncheckedCreateWithoutFocus_care_checksInput>
    connectOrCreate?: ServiceSuperCategoryModelCreateOrConnectWithoutFocus_care_checksInput
    connect?: ServiceSuperCategoryModelWhereUniqueInput
  }

  export type ZipzoongCareRequestModelCreateNestedOneWithoutService_checksInput = {
    create?: XOR<ZipzoongCareRequestModelCreateWithoutService_checksInput, ZipzoongCareRequestModelUncheckedCreateWithoutService_checksInput>
    connectOrCreate?: ZipzoongCareRequestModelCreateOrConnectWithoutService_checksInput
    connect?: ZipzoongCareRequestModelWhereUniqueInput
  }

  export type ServiceSuperCategoryModelUpdateOneRequiredWithoutFocus_care_checksNestedInput = {
    create?: XOR<ServiceSuperCategoryModelCreateWithoutFocus_care_checksInput, ServiceSuperCategoryModelUncheckedCreateWithoutFocus_care_checksInput>
    connectOrCreate?: ServiceSuperCategoryModelCreateOrConnectWithoutFocus_care_checksInput
    upsert?: ServiceSuperCategoryModelUpsertWithoutFocus_care_checksInput
    connect?: ServiceSuperCategoryModelWhereUniqueInput
    update?: XOR<ServiceSuperCategoryModelUpdateWithoutFocus_care_checksInput, ServiceSuperCategoryModelUncheckedUpdateWithoutFocus_care_checksInput>
  }

  export type ZipzoongCareRequestModelUpdateOneRequiredWithoutService_checksNestedInput = {
    create?: XOR<ZipzoongCareRequestModelCreateWithoutService_checksInput, ZipzoongCareRequestModelUncheckedCreateWithoutService_checksInput>
    connectOrCreate?: ZipzoongCareRequestModelCreateOrConnectWithoutService_checksInput
    upsert?: ZipzoongCareRequestModelUpsertWithoutService_checksInput
    connect?: ZipzoongCareRequestModelWhereUniqueInput
    update?: XOR<ZipzoongCareRequestModelUpdateWithoutService_checksInput, ZipzoongCareRequestModelUncheckedUpdateWithoutService_checksInput>
  }

  export type ZipzoongCareRequestModelCreateNestedOneWithoutConsultation_time_checksInput = {
    create?: XOR<ZipzoongCareRequestModelCreateWithoutConsultation_time_checksInput, ZipzoongCareRequestModelUncheckedCreateWithoutConsultation_time_checksInput>
    connectOrCreate?: ZipzoongCareRequestModelCreateOrConnectWithoutConsultation_time_checksInput
    connect?: ZipzoongCareRequestModelWhereUniqueInput
  }

  export type ZipzoongCareRequestModelUpdateOneRequiredWithoutConsultation_time_checksNestedInput = {
    create?: XOR<ZipzoongCareRequestModelCreateWithoutConsultation_time_checksInput, ZipzoongCareRequestModelUncheckedCreateWithoutConsultation_time_checksInput>
    connectOrCreate?: ZipzoongCareRequestModelCreateOrConnectWithoutConsultation_time_checksInput
    upsert?: ZipzoongCareRequestModelUpsertWithoutConsultation_time_checksInput
    connect?: ZipzoongCareRequestModelWhereUniqueInput
    update?: XOR<ZipzoongCareRequestModelUpdateWithoutConsultation_time_checksInput, ZipzoongCareRequestModelUncheckedUpdateWithoutConsultation_time_checksInput>
  }

  export type CustomerModelCreateNestedOneWithoutBaseInput = {
    create?: XOR<CustomerModelCreateWithoutBaseInput, CustomerModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutBaseInput
    connect?: CustomerModelWhereUniqueInput
  }

  export type BusinessUserModelCreateNestedOneWithoutBaseInput = {
    create?: XOR<BusinessUserModelCreateWithoutBaseInput, BusinessUserModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutBaseInput
    connect?: BusinessUserModelWhereUniqueInput
  }

  export type AgreementAcceptanceModelCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AgreementAcceptanceModelCreateWithoutUserInput>, Enumerable<AgreementAcceptanceModelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AgreementAcceptanceModelCreateOrConnectWithoutUserInput>
    createMany?: AgreementAcceptanceModelCreateManyUserInputEnvelope
    connect?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
  }

  export type CustomerModelUncheckedCreateNestedOneWithoutBaseInput = {
    create?: XOR<CustomerModelCreateWithoutBaseInput, CustomerModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutBaseInput
    connect?: CustomerModelWhereUniqueInput
  }

  export type BusinessUserModelUncheckedCreateNestedOneWithoutBaseInput = {
    create?: XOR<BusinessUserModelCreateWithoutBaseInput, BusinessUserModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutBaseInput
    connect?: BusinessUserModelWhereUniqueInput
  }

  export type AgreementAcceptanceModelUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AgreementAcceptanceModelCreateWithoutUserInput>, Enumerable<AgreementAcceptanceModelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AgreementAcceptanceModelCreateOrConnectWithoutUserInput>
    createMany?: AgreementAcceptanceModelCreateManyUserInputEnvelope
    connect?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type CustomerModelUpdateOneWithoutBaseNestedInput = {
    create?: XOR<CustomerModelCreateWithoutBaseInput, CustomerModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutBaseInput
    upsert?: CustomerModelUpsertWithoutBaseInput
    disconnect?: boolean
    delete?: boolean
    connect?: CustomerModelWhereUniqueInput
    update?: XOR<CustomerModelUpdateWithoutBaseInput, CustomerModelUncheckedUpdateWithoutBaseInput>
  }

  export type BusinessUserModelUpdateOneWithoutBaseNestedInput = {
    create?: XOR<BusinessUserModelCreateWithoutBaseInput, BusinessUserModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutBaseInput
    upsert?: BusinessUserModelUpsertWithoutBaseInput
    disconnect?: boolean
    delete?: boolean
    connect?: BusinessUserModelWhereUniqueInput
    update?: XOR<BusinessUserModelUpdateWithoutBaseInput, BusinessUserModelUncheckedUpdateWithoutBaseInput>
  }

  export type AgreementAcceptanceModelUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AgreementAcceptanceModelCreateWithoutUserInput>, Enumerable<AgreementAcceptanceModelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AgreementAcceptanceModelCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AgreementAcceptanceModelUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AgreementAcceptanceModelCreateManyUserInputEnvelope
    set?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    disconnect?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    delete?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    connect?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    update?: Enumerable<AgreementAcceptanceModelUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AgreementAcceptanceModelUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AgreementAcceptanceModelScalarWhereInput>
  }

  export type CustomerModelUncheckedUpdateOneWithoutBaseNestedInput = {
    create?: XOR<CustomerModelCreateWithoutBaseInput, CustomerModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutBaseInput
    upsert?: CustomerModelUpsertWithoutBaseInput
    disconnect?: boolean
    delete?: boolean
    connect?: CustomerModelWhereUniqueInput
    update?: XOR<CustomerModelUpdateWithoutBaseInput, CustomerModelUncheckedUpdateWithoutBaseInput>
  }

  export type BusinessUserModelUncheckedUpdateOneWithoutBaseNestedInput = {
    create?: XOR<BusinessUserModelCreateWithoutBaseInput, BusinessUserModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutBaseInput
    upsert?: BusinessUserModelUpsertWithoutBaseInput
    disconnect?: boolean
    delete?: boolean
    connect?: BusinessUserModelWhereUniqueInput
    update?: XOR<BusinessUserModelUpdateWithoutBaseInput, BusinessUserModelUncheckedUpdateWithoutBaseInput>
  }

  export type AgreementAcceptanceModelUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AgreementAcceptanceModelCreateWithoutUserInput>, Enumerable<AgreementAcceptanceModelUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AgreementAcceptanceModelCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AgreementAcceptanceModelUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AgreementAcceptanceModelCreateManyUserInputEnvelope
    set?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    disconnect?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    delete?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    connect?: Enumerable<AgreementAcceptanceModelWhereUniqueInput>
    update?: Enumerable<AgreementAcceptanceModelUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AgreementAcceptanceModelUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AgreementAcceptanceModelScalarWhereInput>
  }

  export type UserModelCreateNestedOneWithoutCustomerInput = {
    create?: XOR<UserModelCreateWithoutCustomerInput, UserModelUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: UserModelCreateOrConnectWithoutCustomerInput
    connect?: UserModelWhereUniqueInput
  }

  export type OauthAccountModelCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<OauthAccountModelCreateWithoutCustomerInput>, Enumerable<OauthAccountModelUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<OauthAccountModelCreateOrConnectWithoutCustomerInput>
    createMany?: OauthAccountModelCreateManyCustomerInputEnvelope
    connect?: Enumerable<OauthAccountModelWhereUniqueInput>
  }

  export type ZipzoongCareRequestModelCreateNestedManyWithoutRequesterInput = {
    create?: XOR<Enumerable<ZipzoongCareRequestModelCreateWithoutRequesterInput>, Enumerable<ZipzoongCareRequestModelUncheckedCreateWithoutRequesterInput>>
    connectOrCreate?: Enumerable<ZipzoongCareRequestModelCreateOrConnectWithoutRequesterInput>
    createMany?: ZipzoongCareRequestModelCreateManyRequesterInputEnvelope
    connect?: Enumerable<ZipzoongCareRequestModelWhereUniqueInput>
  }

  export type OauthAccountModelUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<OauthAccountModelCreateWithoutCustomerInput>, Enumerable<OauthAccountModelUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<OauthAccountModelCreateOrConnectWithoutCustomerInput>
    createMany?: OauthAccountModelCreateManyCustomerInputEnvelope
    connect?: Enumerable<OauthAccountModelWhereUniqueInput>
  }

  export type ZipzoongCareRequestModelUncheckedCreateNestedManyWithoutRequesterInput = {
    create?: XOR<Enumerable<ZipzoongCareRequestModelCreateWithoutRequesterInput>, Enumerable<ZipzoongCareRequestModelUncheckedCreateWithoutRequesterInput>>
    connectOrCreate?: Enumerable<ZipzoongCareRequestModelCreateOrConnectWithoutRequesterInput>
    createMany?: ZipzoongCareRequestModelCreateManyRequesterInputEnvelope
    connect?: Enumerable<ZipzoongCareRequestModelWhereUniqueInput>
  }

  export type NullableEnumGenderTypeFieldUpdateOperationsInput = {
    set?: GenderType | null
  }

  export type UserModelUpdateOneRequiredWithoutCustomerNestedInput = {
    create?: XOR<UserModelCreateWithoutCustomerInput, UserModelUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: UserModelCreateOrConnectWithoutCustomerInput
    upsert?: UserModelUpsertWithoutCustomerInput
    connect?: UserModelWhereUniqueInput
    update?: XOR<UserModelUpdateWithoutCustomerInput, UserModelUncheckedUpdateWithoutCustomerInput>
  }

  export type OauthAccountModelUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<OauthAccountModelCreateWithoutCustomerInput>, Enumerable<OauthAccountModelUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<OauthAccountModelCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<OauthAccountModelUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: OauthAccountModelCreateManyCustomerInputEnvelope
    set?: Enumerable<OauthAccountModelWhereUniqueInput>
    disconnect?: Enumerable<OauthAccountModelWhereUniqueInput>
    delete?: Enumerable<OauthAccountModelWhereUniqueInput>
    connect?: Enumerable<OauthAccountModelWhereUniqueInput>
    update?: Enumerable<OauthAccountModelUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<OauthAccountModelUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<OauthAccountModelScalarWhereInput>
  }

  export type ZipzoongCareRequestModelUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<Enumerable<ZipzoongCareRequestModelCreateWithoutRequesterInput>, Enumerable<ZipzoongCareRequestModelUncheckedCreateWithoutRequesterInput>>
    connectOrCreate?: Enumerable<ZipzoongCareRequestModelCreateOrConnectWithoutRequesterInput>
    upsert?: Enumerable<ZipzoongCareRequestModelUpsertWithWhereUniqueWithoutRequesterInput>
    createMany?: ZipzoongCareRequestModelCreateManyRequesterInputEnvelope
    set?: Enumerable<ZipzoongCareRequestModelWhereUniqueInput>
    disconnect?: Enumerable<ZipzoongCareRequestModelWhereUniqueInput>
    delete?: Enumerable<ZipzoongCareRequestModelWhereUniqueInput>
    connect?: Enumerable<ZipzoongCareRequestModelWhereUniqueInput>
    update?: Enumerable<ZipzoongCareRequestModelUpdateWithWhereUniqueWithoutRequesterInput>
    updateMany?: Enumerable<ZipzoongCareRequestModelUpdateManyWithWhereWithoutRequesterInput>
    deleteMany?: Enumerable<ZipzoongCareRequestModelScalarWhereInput>
  }

  export type OauthAccountModelUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<OauthAccountModelCreateWithoutCustomerInput>, Enumerable<OauthAccountModelUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<OauthAccountModelCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<OauthAccountModelUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: OauthAccountModelCreateManyCustomerInputEnvelope
    set?: Enumerable<OauthAccountModelWhereUniqueInput>
    disconnect?: Enumerable<OauthAccountModelWhereUniqueInput>
    delete?: Enumerable<OauthAccountModelWhereUniqueInput>
    connect?: Enumerable<OauthAccountModelWhereUniqueInput>
    update?: Enumerable<OauthAccountModelUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<OauthAccountModelUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<OauthAccountModelScalarWhereInput>
  }

  export type ZipzoongCareRequestModelUncheckedUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<Enumerable<ZipzoongCareRequestModelCreateWithoutRequesterInput>, Enumerable<ZipzoongCareRequestModelUncheckedCreateWithoutRequesterInput>>
    connectOrCreate?: Enumerable<ZipzoongCareRequestModelCreateOrConnectWithoutRequesterInput>
    upsert?: Enumerable<ZipzoongCareRequestModelUpsertWithWhereUniqueWithoutRequesterInput>
    createMany?: ZipzoongCareRequestModelCreateManyRequesterInputEnvelope
    set?: Enumerable<ZipzoongCareRequestModelWhereUniqueInput>
    disconnect?: Enumerable<ZipzoongCareRequestModelWhereUniqueInput>
    delete?: Enumerable<ZipzoongCareRequestModelWhereUniqueInput>
    connect?: Enumerable<ZipzoongCareRequestModelWhereUniqueInput>
    update?: Enumerable<ZipzoongCareRequestModelUpdateWithWhereUniqueWithoutRequesterInput>
    updateMany?: Enumerable<ZipzoongCareRequestModelUpdateManyWithWhereWithoutRequesterInput>
    deleteMany?: Enumerable<ZipzoongCareRequestModelScalarWhereInput>
  }

  export type UserModelCreateNestedOneWithoutBusiness_userInput = {
    create?: XOR<UserModelCreateWithoutBusiness_userInput, UserModelUncheckedCreateWithoutBusiness_userInput>
    connectOrCreate?: UserModelCreateOrConnectWithoutBusiness_userInput
    connect?: UserModelWhereUniqueInput
  }

  export type REAgentModelCreateNestedOneWithoutBaseInput = {
    create?: XOR<REAgentModelCreateWithoutBaseInput, REAgentModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: REAgentModelCreateOrConnectWithoutBaseInput
    connect?: REAgentModelWhereUniqueInput
  }

  export type HSProviderModelCreateNestedOneWithoutBaseInput = {
    create?: XOR<HSProviderModelCreateWithoutBaseInput, HSProviderModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: HSProviderModelCreateOrConnectWithoutBaseInput
    connect?: HSProviderModelWhereUniqueInput
  }

  export type BusinessCertificationImageModelCreateNestedManyWithoutBusiness_userInput = {
    create?: XOR<Enumerable<BusinessCertificationImageModelCreateWithoutBusiness_userInput>, Enumerable<BusinessCertificationImageModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<BusinessCertificationImageModelCreateOrConnectWithoutBusiness_userInput>
    createMany?: BusinessCertificationImageModelCreateManyBusiness_userInputEnvelope
    connect?: Enumerable<BusinessCertificationImageModelWhereUniqueInput>
  }

  export type SubExpertiseModelCreateNestedManyWithoutBusiness_userInput = {
    create?: XOR<Enumerable<SubExpertiseModelCreateWithoutBusiness_userInput>, Enumerable<SubExpertiseModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<SubExpertiseModelCreateOrConnectWithoutBusiness_userInput>
    createMany?: SubExpertiseModelCreateManyBusiness_userInputEnvelope
    connect?: Enumerable<SubExpertiseModelWhereUniqueInput>
  }

  export type OauthAccountModelCreateNestedManyWithoutBusiness_userInput = {
    create?: XOR<Enumerable<OauthAccountModelCreateWithoutBusiness_userInput>, Enumerable<OauthAccountModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<OauthAccountModelCreateOrConnectWithoutBusiness_userInput>
    createMany?: OauthAccountModelCreateManyBusiness_userInputEnvelope
    connect?: Enumerable<OauthAccountModelWhereUniqueInput>
  }

  export type REAgentModelUncheckedCreateNestedOneWithoutBaseInput = {
    create?: XOR<REAgentModelCreateWithoutBaseInput, REAgentModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: REAgentModelCreateOrConnectWithoutBaseInput
    connect?: REAgentModelWhereUniqueInput
  }

  export type HSProviderModelUncheckedCreateNestedOneWithoutBaseInput = {
    create?: XOR<HSProviderModelCreateWithoutBaseInput, HSProviderModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: HSProviderModelCreateOrConnectWithoutBaseInput
    connect?: HSProviderModelWhereUniqueInput
  }

  export type BusinessCertificationImageModelUncheckedCreateNestedManyWithoutBusiness_userInput = {
    create?: XOR<Enumerable<BusinessCertificationImageModelCreateWithoutBusiness_userInput>, Enumerable<BusinessCertificationImageModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<BusinessCertificationImageModelCreateOrConnectWithoutBusiness_userInput>
    createMany?: BusinessCertificationImageModelCreateManyBusiness_userInputEnvelope
    connect?: Enumerable<BusinessCertificationImageModelWhereUniqueInput>
  }

  export type SubExpertiseModelUncheckedCreateNestedManyWithoutBusiness_userInput = {
    create?: XOR<Enumerable<SubExpertiseModelCreateWithoutBusiness_userInput>, Enumerable<SubExpertiseModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<SubExpertiseModelCreateOrConnectWithoutBusiness_userInput>
    createMany?: SubExpertiseModelCreateManyBusiness_userInputEnvelope
    connect?: Enumerable<SubExpertiseModelWhereUniqueInput>
  }

  export type OauthAccountModelUncheckedCreateNestedManyWithoutBusiness_userInput = {
    create?: XOR<Enumerable<OauthAccountModelCreateWithoutBusiness_userInput>, Enumerable<OauthAccountModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<OauthAccountModelCreateOrConnectWithoutBusiness_userInput>
    createMany?: OauthAccountModelCreateManyBusiness_userInputEnvelope
    connect?: Enumerable<OauthAccountModelWhereUniqueInput>
  }

  export type UserModelUpdateOneRequiredWithoutBusiness_userNestedInput = {
    create?: XOR<UserModelCreateWithoutBusiness_userInput, UserModelUncheckedCreateWithoutBusiness_userInput>
    connectOrCreate?: UserModelCreateOrConnectWithoutBusiness_userInput
    upsert?: UserModelUpsertWithoutBusiness_userInput
    connect?: UserModelWhereUniqueInput
    update?: XOR<UserModelUpdateWithoutBusiness_userInput, UserModelUncheckedUpdateWithoutBusiness_userInput>
  }

  export type REAgentModelUpdateOneWithoutBaseNestedInput = {
    create?: XOR<REAgentModelCreateWithoutBaseInput, REAgentModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: REAgentModelCreateOrConnectWithoutBaseInput
    upsert?: REAgentModelUpsertWithoutBaseInput
    disconnect?: boolean
    delete?: boolean
    connect?: REAgentModelWhereUniqueInput
    update?: XOR<REAgentModelUpdateWithoutBaseInput, REAgentModelUncheckedUpdateWithoutBaseInput>
  }

  export type HSProviderModelUpdateOneWithoutBaseNestedInput = {
    create?: XOR<HSProviderModelCreateWithoutBaseInput, HSProviderModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: HSProviderModelCreateOrConnectWithoutBaseInput
    upsert?: HSProviderModelUpsertWithoutBaseInput
    disconnect?: boolean
    delete?: boolean
    connect?: HSProviderModelWhereUniqueInput
    update?: XOR<HSProviderModelUpdateWithoutBaseInput, HSProviderModelUncheckedUpdateWithoutBaseInput>
  }

  export type BusinessCertificationImageModelUpdateManyWithoutBusiness_userNestedInput = {
    create?: XOR<Enumerable<BusinessCertificationImageModelCreateWithoutBusiness_userInput>, Enumerable<BusinessCertificationImageModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<BusinessCertificationImageModelCreateOrConnectWithoutBusiness_userInput>
    upsert?: Enumerable<BusinessCertificationImageModelUpsertWithWhereUniqueWithoutBusiness_userInput>
    createMany?: BusinessCertificationImageModelCreateManyBusiness_userInputEnvelope
    set?: Enumerable<BusinessCertificationImageModelWhereUniqueInput>
    disconnect?: Enumerable<BusinessCertificationImageModelWhereUniqueInput>
    delete?: Enumerable<BusinessCertificationImageModelWhereUniqueInput>
    connect?: Enumerable<BusinessCertificationImageModelWhereUniqueInput>
    update?: Enumerable<BusinessCertificationImageModelUpdateWithWhereUniqueWithoutBusiness_userInput>
    updateMany?: Enumerable<BusinessCertificationImageModelUpdateManyWithWhereWithoutBusiness_userInput>
    deleteMany?: Enumerable<BusinessCertificationImageModelScalarWhereInput>
  }

  export type SubExpertiseModelUpdateManyWithoutBusiness_userNestedInput = {
    create?: XOR<Enumerable<SubExpertiseModelCreateWithoutBusiness_userInput>, Enumerable<SubExpertiseModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<SubExpertiseModelCreateOrConnectWithoutBusiness_userInput>
    upsert?: Enumerable<SubExpertiseModelUpsertWithWhereUniqueWithoutBusiness_userInput>
    createMany?: SubExpertiseModelCreateManyBusiness_userInputEnvelope
    set?: Enumerable<SubExpertiseModelWhereUniqueInput>
    disconnect?: Enumerable<SubExpertiseModelWhereUniqueInput>
    delete?: Enumerable<SubExpertiseModelWhereUniqueInput>
    connect?: Enumerable<SubExpertiseModelWhereUniqueInput>
    update?: Enumerable<SubExpertiseModelUpdateWithWhereUniqueWithoutBusiness_userInput>
    updateMany?: Enumerable<SubExpertiseModelUpdateManyWithWhereWithoutBusiness_userInput>
    deleteMany?: Enumerable<SubExpertiseModelScalarWhereInput>
  }

  export type OauthAccountModelUpdateManyWithoutBusiness_userNestedInput = {
    create?: XOR<Enumerable<OauthAccountModelCreateWithoutBusiness_userInput>, Enumerable<OauthAccountModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<OauthAccountModelCreateOrConnectWithoutBusiness_userInput>
    upsert?: Enumerable<OauthAccountModelUpsertWithWhereUniqueWithoutBusiness_userInput>
    createMany?: OauthAccountModelCreateManyBusiness_userInputEnvelope
    set?: Enumerable<OauthAccountModelWhereUniqueInput>
    disconnect?: Enumerable<OauthAccountModelWhereUniqueInput>
    delete?: Enumerable<OauthAccountModelWhereUniqueInput>
    connect?: Enumerable<OauthAccountModelWhereUniqueInput>
    update?: Enumerable<OauthAccountModelUpdateWithWhereUniqueWithoutBusiness_userInput>
    updateMany?: Enumerable<OauthAccountModelUpdateManyWithWhereWithoutBusiness_userInput>
    deleteMany?: Enumerable<OauthAccountModelScalarWhereInput>
  }

  export type REAgentModelUncheckedUpdateOneWithoutBaseNestedInput = {
    create?: XOR<REAgentModelCreateWithoutBaseInput, REAgentModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: REAgentModelCreateOrConnectWithoutBaseInput
    upsert?: REAgentModelUpsertWithoutBaseInput
    disconnect?: boolean
    delete?: boolean
    connect?: REAgentModelWhereUniqueInput
    update?: XOR<REAgentModelUpdateWithoutBaseInput, REAgentModelUncheckedUpdateWithoutBaseInput>
  }

  export type HSProviderModelUncheckedUpdateOneWithoutBaseNestedInput = {
    create?: XOR<HSProviderModelCreateWithoutBaseInput, HSProviderModelUncheckedCreateWithoutBaseInput>
    connectOrCreate?: HSProviderModelCreateOrConnectWithoutBaseInput
    upsert?: HSProviderModelUpsertWithoutBaseInput
    disconnect?: boolean
    delete?: boolean
    connect?: HSProviderModelWhereUniqueInput
    update?: XOR<HSProviderModelUpdateWithoutBaseInput, HSProviderModelUncheckedUpdateWithoutBaseInput>
  }

  export type BusinessCertificationImageModelUncheckedUpdateManyWithoutBusiness_userNestedInput = {
    create?: XOR<Enumerable<BusinessCertificationImageModelCreateWithoutBusiness_userInput>, Enumerable<BusinessCertificationImageModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<BusinessCertificationImageModelCreateOrConnectWithoutBusiness_userInput>
    upsert?: Enumerable<BusinessCertificationImageModelUpsertWithWhereUniqueWithoutBusiness_userInput>
    createMany?: BusinessCertificationImageModelCreateManyBusiness_userInputEnvelope
    set?: Enumerable<BusinessCertificationImageModelWhereUniqueInput>
    disconnect?: Enumerable<BusinessCertificationImageModelWhereUniqueInput>
    delete?: Enumerable<BusinessCertificationImageModelWhereUniqueInput>
    connect?: Enumerable<BusinessCertificationImageModelWhereUniqueInput>
    update?: Enumerable<BusinessCertificationImageModelUpdateWithWhereUniqueWithoutBusiness_userInput>
    updateMany?: Enumerable<BusinessCertificationImageModelUpdateManyWithWhereWithoutBusiness_userInput>
    deleteMany?: Enumerable<BusinessCertificationImageModelScalarWhereInput>
  }

  export type SubExpertiseModelUncheckedUpdateManyWithoutBusiness_userNestedInput = {
    create?: XOR<Enumerable<SubExpertiseModelCreateWithoutBusiness_userInput>, Enumerable<SubExpertiseModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<SubExpertiseModelCreateOrConnectWithoutBusiness_userInput>
    upsert?: Enumerable<SubExpertiseModelUpsertWithWhereUniqueWithoutBusiness_userInput>
    createMany?: SubExpertiseModelCreateManyBusiness_userInputEnvelope
    set?: Enumerable<SubExpertiseModelWhereUniqueInput>
    disconnect?: Enumerable<SubExpertiseModelWhereUniqueInput>
    delete?: Enumerable<SubExpertiseModelWhereUniqueInput>
    connect?: Enumerable<SubExpertiseModelWhereUniqueInput>
    update?: Enumerable<SubExpertiseModelUpdateWithWhereUniqueWithoutBusiness_userInput>
    updateMany?: Enumerable<SubExpertiseModelUpdateManyWithWhereWithoutBusiness_userInput>
    deleteMany?: Enumerable<SubExpertiseModelScalarWhereInput>
  }

  export type OauthAccountModelUncheckedUpdateManyWithoutBusiness_userNestedInput = {
    create?: XOR<Enumerable<OauthAccountModelCreateWithoutBusiness_userInput>, Enumerable<OauthAccountModelUncheckedCreateWithoutBusiness_userInput>>
    connectOrCreate?: Enumerable<OauthAccountModelCreateOrConnectWithoutBusiness_userInput>
    upsert?: Enumerable<OauthAccountModelUpsertWithWhereUniqueWithoutBusiness_userInput>
    createMany?: OauthAccountModelCreateManyBusiness_userInputEnvelope
    set?: Enumerable<OauthAccountModelWhereUniqueInput>
    disconnect?: Enumerable<OauthAccountModelWhereUniqueInput>
    delete?: Enumerable<OauthAccountModelWhereUniqueInput>
    connect?: Enumerable<OauthAccountModelWhereUniqueInput>
    update?: Enumerable<OauthAccountModelUpdateWithWhereUniqueWithoutBusiness_userInput>
    updateMany?: Enumerable<OauthAccountModelUpdateManyWithWhereWithoutBusiness_userInput>
    deleteMany?: Enumerable<OauthAccountModelScalarWhereInput>
  }

  export type ServiceSubCategoryModelCreateNestedOneWithoutExpertisesInput = {
    create?: XOR<ServiceSubCategoryModelCreateWithoutExpertisesInput, ServiceSubCategoryModelUncheckedCreateWithoutExpertisesInput>
    connectOrCreate?: ServiceSubCategoryModelCreateOrConnectWithoutExpertisesInput
    connect?: ServiceSubCategoryModelWhereUniqueInput
  }

  export type BusinessUserModelCreateNestedOneWithoutSub_expertisesInput = {
    create?: XOR<BusinessUserModelCreateWithoutSub_expertisesInput, BusinessUserModelUncheckedCreateWithoutSub_expertisesInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutSub_expertisesInput
    connect?: BusinessUserModelWhereUniqueInput
  }

  export type ServiceSubCategoryModelUpdateOneRequiredWithoutExpertisesNestedInput = {
    create?: XOR<ServiceSubCategoryModelCreateWithoutExpertisesInput, ServiceSubCategoryModelUncheckedCreateWithoutExpertisesInput>
    connectOrCreate?: ServiceSubCategoryModelCreateOrConnectWithoutExpertisesInput
    upsert?: ServiceSubCategoryModelUpsertWithoutExpertisesInput
    connect?: ServiceSubCategoryModelWhereUniqueInput
    update?: XOR<ServiceSubCategoryModelUpdateWithoutExpertisesInput, ServiceSubCategoryModelUncheckedUpdateWithoutExpertisesInput>
  }

  export type BusinessUserModelUpdateOneRequiredWithoutSub_expertisesNestedInput = {
    create?: XOR<BusinessUserModelCreateWithoutSub_expertisesInput, BusinessUserModelUncheckedCreateWithoutSub_expertisesInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutSub_expertisesInput
    upsert?: BusinessUserModelUpsertWithoutSub_expertisesInput
    connect?: BusinessUserModelWhereUniqueInput
    update?: XOR<BusinessUserModelUpdateWithoutSub_expertisesInput, BusinessUserModelUncheckedUpdateWithoutSub_expertisesInput>
  }

  export type BusinessUserModelCreateNestedOneWithoutRe_agentInput = {
    create?: XOR<BusinessUserModelCreateWithoutRe_agentInput, BusinessUserModelUncheckedCreateWithoutRe_agentInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutRe_agentInput
    connect?: BusinessUserModelWhereUniqueInput
  }

  export type REPropertyModelCreateNestedManyWithoutRe_agentInput = {
    create?: XOR<Enumerable<REPropertyModelCreateWithoutRe_agentInput>, Enumerable<REPropertyModelUncheckedCreateWithoutRe_agentInput>>
    connectOrCreate?: Enumerable<REPropertyModelCreateOrConnectWithoutRe_agentInput>
    createMany?: REPropertyModelCreateManyRe_agentInputEnvelope
    connect?: Enumerable<REPropertyModelWhereUniqueInput>
  }

  export type REPropertyModelUncheckedCreateNestedManyWithoutRe_agentInput = {
    create?: XOR<Enumerable<REPropertyModelCreateWithoutRe_agentInput>, Enumerable<REPropertyModelUncheckedCreateWithoutRe_agentInput>>
    connectOrCreate?: Enumerable<REPropertyModelCreateOrConnectWithoutRe_agentInput>
    createMany?: REPropertyModelCreateManyRe_agentInputEnvelope
    connect?: Enumerable<REPropertyModelWhereUniqueInput>
  }

  export type BusinessUserModelUpdateOneRequiredWithoutRe_agentNestedInput = {
    create?: XOR<BusinessUserModelCreateWithoutRe_agentInput, BusinessUserModelUncheckedCreateWithoutRe_agentInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutRe_agentInput
    upsert?: BusinessUserModelUpsertWithoutRe_agentInput
    connect?: BusinessUserModelWhereUniqueInput
    update?: XOR<BusinessUserModelUpdateWithoutRe_agentInput, BusinessUserModelUncheckedUpdateWithoutRe_agentInput>
  }

  export type REPropertyModelUpdateManyWithoutRe_agentNestedInput = {
    create?: XOR<Enumerable<REPropertyModelCreateWithoutRe_agentInput>, Enumerable<REPropertyModelUncheckedCreateWithoutRe_agentInput>>
    connectOrCreate?: Enumerable<REPropertyModelCreateOrConnectWithoutRe_agentInput>
    upsert?: Enumerable<REPropertyModelUpsertWithWhereUniqueWithoutRe_agentInput>
    createMany?: REPropertyModelCreateManyRe_agentInputEnvelope
    set?: Enumerable<REPropertyModelWhereUniqueInput>
    disconnect?: Enumerable<REPropertyModelWhereUniqueInput>
    delete?: Enumerable<REPropertyModelWhereUniqueInput>
    connect?: Enumerable<REPropertyModelWhereUniqueInput>
    update?: Enumerable<REPropertyModelUpdateWithWhereUniqueWithoutRe_agentInput>
    updateMany?: Enumerable<REPropertyModelUpdateManyWithWhereWithoutRe_agentInput>
    deleteMany?: Enumerable<REPropertyModelScalarWhereInput>
  }

  export type REPropertyModelUncheckedUpdateManyWithoutRe_agentNestedInput = {
    create?: XOR<Enumerable<REPropertyModelCreateWithoutRe_agentInput>, Enumerable<REPropertyModelUncheckedCreateWithoutRe_agentInput>>
    connectOrCreate?: Enumerable<REPropertyModelCreateOrConnectWithoutRe_agentInput>
    upsert?: Enumerable<REPropertyModelUpsertWithWhereUniqueWithoutRe_agentInput>
    createMany?: REPropertyModelCreateManyRe_agentInputEnvelope
    set?: Enumerable<REPropertyModelWhereUniqueInput>
    disconnect?: Enumerable<REPropertyModelWhereUniqueInput>
    delete?: Enumerable<REPropertyModelWhereUniqueInput>
    connect?: Enumerable<REPropertyModelWhereUniqueInput>
    update?: Enumerable<REPropertyModelUpdateWithWhereUniqueWithoutRe_agentInput>
    updateMany?: Enumerable<REPropertyModelUpdateManyWithWhereWithoutRe_agentInput>
    deleteMany?: Enumerable<REPropertyModelScalarWhereInput>
  }

  export type BusinessUserModelCreateNestedOneWithoutHs_providerInput = {
    create?: XOR<BusinessUserModelCreateWithoutHs_providerInput, BusinessUserModelUncheckedCreateWithoutHs_providerInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutHs_providerInput
    connect?: BusinessUserModelWhereUniqueInput
  }

  export type HSExampleImageModelCreateNestedManyWithoutHs_providerInput = {
    create?: XOR<Enumerable<HSExampleImageModelCreateWithoutHs_providerInput>, Enumerable<HSExampleImageModelUncheckedCreateWithoutHs_providerInput>>
    connectOrCreate?: Enumerable<HSExampleImageModelCreateOrConnectWithoutHs_providerInput>
    createMany?: HSExampleImageModelCreateManyHs_providerInputEnvelope
    connect?: Enumerable<HSExampleImageModelWhereUniqueInput>
  }

  export type HSExampleImageModelUncheckedCreateNestedManyWithoutHs_providerInput = {
    create?: XOR<Enumerable<HSExampleImageModelCreateWithoutHs_providerInput>, Enumerable<HSExampleImageModelUncheckedCreateWithoutHs_providerInput>>
    connectOrCreate?: Enumerable<HSExampleImageModelCreateOrConnectWithoutHs_providerInput>
    createMany?: HSExampleImageModelCreateManyHs_providerInputEnvelope
    connect?: Enumerable<HSExampleImageModelWhereUniqueInput>
  }

  export type BusinessUserModelUpdateOneRequiredWithoutHs_providerNestedInput = {
    create?: XOR<BusinessUserModelCreateWithoutHs_providerInput, BusinessUserModelUncheckedCreateWithoutHs_providerInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutHs_providerInput
    upsert?: BusinessUserModelUpsertWithoutHs_providerInput
    connect?: BusinessUserModelWhereUniqueInput
    update?: XOR<BusinessUserModelUpdateWithoutHs_providerInput, BusinessUserModelUncheckedUpdateWithoutHs_providerInput>
  }

  export type HSExampleImageModelUpdateManyWithoutHs_providerNestedInput = {
    create?: XOR<Enumerable<HSExampleImageModelCreateWithoutHs_providerInput>, Enumerable<HSExampleImageModelUncheckedCreateWithoutHs_providerInput>>
    connectOrCreate?: Enumerable<HSExampleImageModelCreateOrConnectWithoutHs_providerInput>
    upsert?: Enumerable<HSExampleImageModelUpsertWithWhereUniqueWithoutHs_providerInput>
    createMany?: HSExampleImageModelCreateManyHs_providerInputEnvelope
    set?: Enumerable<HSExampleImageModelWhereUniqueInput>
    disconnect?: Enumerable<HSExampleImageModelWhereUniqueInput>
    delete?: Enumerable<HSExampleImageModelWhereUniqueInput>
    connect?: Enumerable<HSExampleImageModelWhereUniqueInput>
    update?: Enumerable<HSExampleImageModelUpdateWithWhereUniqueWithoutHs_providerInput>
    updateMany?: Enumerable<HSExampleImageModelUpdateManyWithWhereWithoutHs_providerInput>
    deleteMany?: Enumerable<HSExampleImageModelScalarWhereInput>
  }

  export type HSExampleImageModelUncheckedUpdateManyWithoutHs_providerNestedInput = {
    create?: XOR<Enumerable<HSExampleImageModelCreateWithoutHs_providerInput>, Enumerable<HSExampleImageModelUncheckedCreateWithoutHs_providerInput>>
    connectOrCreate?: Enumerable<HSExampleImageModelCreateOrConnectWithoutHs_providerInput>
    upsert?: Enumerable<HSExampleImageModelUpsertWithWhereUniqueWithoutHs_providerInput>
    createMany?: HSExampleImageModelCreateManyHs_providerInputEnvelope
    set?: Enumerable<HSExampleImageModelWhereUniqueInput>
    disconnect?: Enumerable<HSExampleImageModelWhereUniqueInput>
    delete?: Enumerable<HSExampleImageModelWhereUniqueInput>
    connect?: Enumerable<HSExampleImageModelWhereUniqueInput>
    update?: Enumerable<HSExampleImageModelUpdateWithWhereUniqueWithoutHs_providerInput>
    updateMany?: Enumerable<HSExampleImageModelUpdateManyWithWhereWithoutHs_providerInput>
    deleteMany?: Enumerable<HSExampleImageModelScalarWhereInput>
  }

  export type BusinessUserModelCreateNestedOneWithoutCertification_imagesInput = {
    create?: XOR<BusinessUserModelCreateWithoutCertification_imagesInput, BusinessUserModelUncheckedCreateWithoutCertification_imagesInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutCertification_imagesInput
    connect?: BusinessUserModelWhereUniqueInput
  }

  export type BusinessUserModelUpdateOneRequiredWithoutCertification_imagesNestedInput = {
    create?: XOR<BusinessUserModelCreateWithoutCertification_imagesInput, BusinessUserModelUncheckedCreateWithoutCertification_imagesInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutCertification_imagesInput
    upsert?: BusinessUserModelUpsertWithoutCertification_imagesInput
    connect?: BusinessUserModelWhereUniqueInput
    update?: XOR<BusinessUserModelUpdateWithoutCertification_imagesInput, BusinessUserModelUncheckedUpdateWithoutCertification_imagesInput>
  }

  export type HSProviderModelCreateNestedOneWithoutExample_imagesInput = {
    create?: XOR<HSProviderModelCreateWithoutExample_imagesInput, HSProviderModelUncheckedCreateWithoutExample_imagesInput>
    connectOrCreate?: HSProviderModelCreateOrConnectWithoutExample_imagesInput
    connect?: HSProviderModelWhereUniqueInput
  }

  export type HSProviderModelUpdateOneRequiredWithoutExample_imagesNestedInput = {
    create?: XOR<HSProviderModelCreateWithoutExample_imagesInput, HSProviderModelUncheckedCreateWithoutExample_imagesInput>
    connectOrCreate?: HSProviderModelCreateOrConnectWithoutExample_imagesInput
    upsert?: HSProviderModelUpsertWithoutExample_imagesInput
    connect?: HSProviderModelWhereUniqueInput
    update?: XOR<HSProviderModelUpdateWithoutExample_imagesInput, HSProviderModelUncheckedUpdateWithoutExample_imagesInput>
  }

  export type BusinessUserModelCreateNestedOneWithoutOauth_accountsInput = {
    create?: XOR<BusinessUserModelCreateWithoutOauth_accountsInput, BusinessUserModelUncheckedCreateWithoutOauth_accountsInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutOauth_accountsInput
    connect?: BusinessUserModelWhereUniqueInput
  }

  export type CustomerModelCreateNestedOneWithoutOauth_accountsInput = {
    create?: XOR<CustomerModelCreateWithoutOauth_accountsInput, CustomerModelUncheckedCreateWithoutOauth_accountsInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutOauth_accountsInput
    connect?: CustomerModelWhereUniqueInput
  }

  export type EnumOauthTypeFieldUpdateOperationsInput = {
    set?: OauthType
  }

  export type BusinessUserModelUpdateOneWithoutOauth_accountsNestedInput = {
    create?: XOR<BusinessUserModelCreateWithoutOauth_accountsInput, BusinessUserModelUncheckedCreateWithoutOauth_accountsInput>
    connectOrCreate?: BusinessUserModelCreateOrConnectWithoutOauth_accountsInput
    upsert?: BusinessUserModelUpsertWithoutOauth_accountsInput
    disconnect?: boolean
    delete?: boolean
    connect?: BusinessUserModelWhereUniqueInput
    update?: XOR<BusinessUserModelUpdateWithoutOauth_accountsInput, BusinessUserModelUncheckedUpdateWithoutOauth_accountsInput>
  }

  export type CustomerModelUpdateOneWithoutOauth_accountsNestedInput = {
    create?: XOR<CustomerModelCreateWithoutOauth_accountsInput, CustomerModelUncheckedCreateWithoutOauth_accountsInput>
    connectOrCreate?: CustomerModelCreateOrConnectWithoutOauth_accountsInput
    upsert?: CustomerModelUpsertWithoutOauth_accountsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CustomerModelWhereUniqueInput
    update?: XOR<CustomerModelUpdateWithoutOauth_accountsInput, CustomerModelUncheckedUpdateWithoutOauth_accountsInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedEnumAgreementTargetTypeFilter = {
    equals?: AgreementTargetType
    in?: Enumerable<AgreementTargetType>
    notIn?: Enumerable<AgreementTargetType>
    not?: NestedEnumAgreementTargetTypeFilter | AgreementTargetType
  }

  export type NestedEnumAgreementTargetTypeWithAggregatesFilter = {
    equals?: AgreementTargetType
    in?: Enumerable<AgreementTargetType>
    notIn?: Enumerable<AgreementTargetType>
    not?: NestedEnumAgreementTargetTypeWithAggregatesFilter | AgreementTargetType
    _count?: NestedIntFilter
    _min?: NestedEnumAgreementTargetTypeFilter
    _max?: NestedEnumAgreementTargetTypeFilter
  }

  export type NestedEnumServiceTypeFilter = {
    equals?: ServiceType
    in?: Enumerable<ServiceType>
    notIn?: Enumerable<ServiceType>
    not?: NestedEnumServiceTypeFilter | ServiceType
  }

  export type NestedEnumServiceTypeWithAggregatesFilter = {
    equals?: ServiceType
    in?: Enumerable<ServiceType>
    notIn?: Enumerable<ServiceType>
    not?: NestedEnumServiceTypeWithAggregatesFilter | ServiceType
    _count?: NestedIntFilter
    _min?: NestedEnumServiceTypeFilter
    _max?: NestedEnumServiceTypeFilter
  }

  export type NestedEnumZipzoongCareStatusFilter = {
    equals?: ZipzoongCareStatus
    in?: Enumerable<ZipzoongCareStatus>
    notIn?: Enumerable<ZipzoongCareStatus>
    not?: NestedEnumZipzoongCareStatusFilter | ZipzoongCareStatus
  }

  export type NestedEnumZipzoongCareStatusWithAggregatesFilter = {
    equals?: ZipzoongCareStatus
    in?: Enumerable<ZipzoongCareStatus>
    notIn?: Enumerable<ZipzoongCareStatus>
    not?: NestedEnumZipzoongCareStatusWithAggregatesFilter | ZipzoongCareStatus
    _count?: NestedIntFilter
    _min?: NestedEnumZipzoongCareStatusFilter
    _max?: NestedEnumZipzoongCareStatusFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedEnumGenderTypeNullableFilter = {
    equals?: GenderType | null
    in?: Enumerable<GenderType> | null
    notIn?: Enumerable<GenderType> | null
    not?: NestedEnumGenderTypeNullableFilter | GenderType | null
  }

  export type NestedEnumGenderTypeNullableWithAggregatesFilter = {
    equals?: GenderType | null
    in?: Enumerable<GenderType> | null
    notIn?: Enumerable<GenderType> | null
    not?: NestedEnumGenderTypeNullableWithAggregatesFilter | GenderType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumGenderTypeNullableFilter
    _max?: NestedEnumGenderTypeNullableFilter
  }

  export type NestedEnumOauthTypeFilter = {
    equals?: OauthType
    in?: Enumerable<OauthType>
    notIn?: Enumerable<OauthType>
    not?: NestedEnumOauthTypeFilter | OauthType
  }

  export type NestedEnumOauthTypeWithAggregatesFilter = {
    equals?: OauthType
    in?: Enumerable<OauthType>
    notIn?: Enumerable<OauthType>
    not?: NestedEnumOauthTypeWithAggregatesFilter | OauthType
    _count?: NestedIntFilter
    _min?: NestedEnumOauthTypeFilter
    _max?: NestedEnumOauthTypeFilter
  }

  export type REAgentModelCreateWithoutPropertiesInput = {
    is_licensed: boolean
    re_num: string
    re_name: string
    re_phone: string
    re_licensed_agent_name: string
    base: BusinessUserModelCreateNestedOneWithoutRe_agentInput
  }

  export type REAgentModelUncheckedCreateWithoutPropertiesInput = {
    id: string
    is_licensed: boolean
    re_num: string
    re_name: string
    re_phone: string
    re_licensed_agent_name: string
  }

  export type REAgentModelCreateOrConnectWithoutPropertiesInput = {
    where: REAgentModelWhereUniqueInput
    create: XOR<REAgentModelCreateWithoutPropertiesInput, REAgentModelUncheckedCreateWithoutPropertiesInput>
  }

  export type REPropertyCategoryModelCreateWithoutRe_propertyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    sub_category: REPropertySubCategoryModelCreateNestedOneWithoutProperty_categoriesInput
  }

  export type REPropertyCategoryModelUncheckedCreateWithoutRe_propertyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    sub_category_id: string
  }

  export type REPropertyCategoryModelCreateOrConnectWithoutRe_propertyInput = {
    where: REPropertyCategoryModelWhereUniqueInput
    create: XOR<REPropertyCategoryModelCreateWithoutRe_propertyInput, REPropertyCategoryModelUncheckedCreateWithoutRe_propertyInput>
  }

  export type REPropertyCategoryModelCreateManyRe_propertyInputEnvelope = {
    data: Enumerable<REPropertyCategoryModelCreateManyRe_propertyInput>
    skipDuplicates?: boolean
  }

  export type REAgentModelUpsertWithoutPropertiesInput = {
    update: XOR<REAgentModelUpdateWithoutPropertiesInput, REAgentModelUncheckedUpdateWithoutPropertiesInput>
    create: XOR<REAgentModelCreateWithoutPropertiesInput, REAgentModelUncheckedCreateWithoutPropertiesInput>
  }

  export type REAgentModelUpdateWithoutPropertiesInput = {
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    re_num?: StringFieldUpdateOperationsInput | string
    re_name?: StringFieldUpdateOperationsInput | string
    re_phone?: StringFieldUpdateOperationsInput | string
    re_licensed_agent_name?: StringFieldUpdateOperationsInput | string
    base?: BusinessUserModelUpdateOneRequiredWithoutRe_agentNestedInput
  }

  export type REAgentModelUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    re_num?: StringFieldUpdateOperationsInput | string
    re_name?: StringFieldUpdateOperationsInput | string
    re_phone?: StringFieldUpdateOperationsInput | string
    re_licensed_agent_name?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertyCategoryModelUpsertWithWhereUniqueWithoutRe_propertyInput = {
    where: REPropertyCategoryModelWhereUniqueInput
    update: XOR<REPropertyCategoryModelUpdateWithoutRe_propertyInput, REPropertyCategoryModelUncheckedUpdateWithoutRe_propertyInput>
    create: XOR<REPropertyCategoryModelCreateWithoutRe_propertyInput, REPropertyCategoryModelUncheckedCreateWithoutRe_propertyInput>
  }

  export type REPropertyCategoryModelUpdateWithWhereUniqueWithoutRe_propertyInput = {
    where: REPropertyCategoryModelWhereUniqueInput
    data: XOR<REPropertyCategoryModelUpdateWithoutRe_propertyInput, REPropertyCategoryModelUncheckedUpdateWithoutRe_propertyInput>
  }

  export type REPropertyCategoryModelUpdateManyWithWhereWithoutRe_propertyInput = {
    where: REPropertyCategoryModelScalarWhereInput
    data: XOR<REPropertyCategoryModelUpdateManyMutationInput, REPropertyCategoryModelUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type REPropertyCategoryModelScalarWhereInput = {
    AND?: Enumerable<REPropertyCategoryModelScalarWhereInput>
    OR?: Enumerable<REPropertyCategoryModelScalarWhereInput>
    NOT?: Enumerable<REPropertyCategoryModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    re_property_id?: StringFilter | string
    sub_category_id?: StringFilter | string
  }

  export type REPropertyModelCreateWithoutCategoriesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    main_image_url: string
    is_visible: boolean
    re_agent: REAgentModelCreateNestedOneWithoutPropertiesInput
  }

  export type REPropertyModelUncheckedCreateWithoutCategoriesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    main_image_url: string
    re_agent_id: string
    is_visible: boolean
  }

  export type REPropertyModelCreateOrConnectWithoutCategoriesInput = {
    where: REPropertyModelWhereUniqueInput
    create: XOR<REPropertyModelCreateWithoutCategoriesInput, REPropertyModelUncheckedCreateWithoutCategoriesInput>
  }

  export type REPropertySubCategoryModelCreateWithoutProperty_categoriesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    middle_category: REPropertyMiddleCategoryModelCreateNestedOneWithoutSub_categoriesInput
  }

  export type REPropertySubCategoryModelUncheckedCreateWithoutProperty_categoriesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    middle_category_id: string
  }

  export type REPropertySubCategoryModelCreateOrConnectWithoutProperty_categoriesInput = {
    where: REPropertySubCategoryModelWhereUniqueInput
    create: XOR<REPropertySubCategoryModelCreateWithoutProperty_categoriesInput, REPropertySubCategoryModelUncheckedCreateWithoutProperty_categoriesInput>
  }

  export type REPropertyModelUpsertWithoutCategoriesInput = {
    update: XOR<REPropertyModelUpdateWithoutCategoriesInput, REPropertyModelUncheckedUpdateWithoutCategoriesInput>
    create: XOR<REPropertyModelCreateWithoutCategoriesInput, REPropertyModelUncheckedCreateWithoutCategoriesInput>
  }

  export type REPropertyModelUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
    is_visible?: BoolFieldUpdateOperationsInput | boolean
    re_agent?: REAgentModelUpdateOneRequiredWithoutPropertiesNestedInput
  }

  export type REPropertyModelUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
    re_agent_id?: StringFieldUpdateOperationsInput | string
    is_visible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type REPropertySubCategoryModelUpsertWithoutProperty_categoriesInput = {
    update: XOR<REPropertySubCategoryModelUpdateWithoutProperty_categoriesInput, REPropertySubCategoryModelUncheckedUpdateWithoutProperty_categoriesInput>
    create: XOR<REPropertySubCategoryModelCreateWithoutProperty_categoriesInput, REPropertySubCategoryModelUncheckedCreateWithoutProperty_categoriesInput>
  }

  export type REPropertySubCategoryModelUpdateWithoutProperty_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    middle_category?: REPropertyMiddleCategoryModelUpdateOneRequiredWithoutSub_categoriesNestedInput
  }

  export type REPropertySubCategoryModelUncheckedUpdateWithoutProperty_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    middle_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertyMiddleCategoryModelCreateWithoutSub_categoriesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    super_category: REPropertySuperCategoryModelCreateNestedOneWithoutMiddle_categoriesInput
  }

  export type REPropertyMiddleCategoryModelUncheckedCreateWithoutSub_categoriesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    super_category_id: string
  }

  export type REPropertyMiddleCategoryModelCreateOrConnectWithoutSub_categoriesInput = {
    where: REPropertyMiddleCategoryModelWhereUniqueInput
    create: XOR<REPropertyMiddleCategoryModelCreateWithoutSub_categoriesInput, REPropertyMiddleCategoryModelUncheckedCreateWithoutSub_categoriesInput>
  }

  export type REPropertyCategoryModelCreateWithoutSub_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    re_property: REPropertyModelCreateNestedOneWithoutCategoriesInput
  }

  export type REPropertyCategoryModelUncheckedCreateWithoutSub_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    re_property_id: string
  }

  export type REPropertyCategoryModelCreateOrConnectWithoutSub_categoryInput = {
    where: REPropertyCategoryModelWhereUniqueInput
    create: XOR<REPropertyCategoryModelCreateWithoutSub_categoryInput, REPropertyCategoryModelUncheckedCreateWithoutSub_categoryInput>
  }

  export type REPropertyCategoryModelCreateManySub_categoryInputEnvelope = {
    data: Enumerable<REPropertyCategoryModelCreateManySub_categoryInput>
    skipDuplicates?: boolean
  }

  export type REPropertyMiddleCategoryModelUpsertWithoutSub_categoriesInput = {
    update: XOR<REPropertyMiddleCategoryModelUpdateWithoutSub_categoriesInput, REPropertyMiddleCategoryModelUncheckedUpdateWithoutSub_categoriesInput>
    create: XOR<REPropertyMiddleCategoryModelCreateWithoutSub_categoriesInput, REPropertyMiddleCategoryModelUncheckedCreateWithoutSub_categoriesInput>
  }

  export type REPropertyMiddleCategoryModelUpdateWithoutSub_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    super_category?: REPropertySuperCategoryModelUpdateOneRequiredWithoutMiddle_categoriesNestedInput
  }

  export type REPropertyMiddleCategoryModelUncheckedUpdateWithoutSub_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    super_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertyCategoryModelUpsertWithWhereUniqueWithoutSub_categoryInput = {
    where: REPropertyCategoryModelWhereUniqueInput
    update: XOR<REPropertyCategoryModelUpdateWithoutSub_categoryInput, REPropertyCategoryModelUncheckedUpdateWithoutSub_categoryInput>
    create: XOR<REPropertyCategoryModelCreateWithoutSub_categoryInput, REPropertyCategoryModelUncheckedCreateWithoutSub_categoryInput>
  }

  export type REPropertyCategoryModelUpdateWithWhereUniqueWithoutSub_categoryInput = {
    where: REPropertyCategoryModelWhereUniqueInput
    data: XOR<REPropertyCategoryModelUpdateWithoutSub_categoryInput, REPropertyCategoryModelUncheckedUpdateWithoutSub_categoryInput>
  }

  export type REPropertyCategoryModelUpdateManyWithWhereWithoutSub_categoryInput = {
    where: REPropertyCategoryModelScalarWhereInput
    data: XOR<REPropertyCategoryModelUpdateManyMutationInput, REPropertyCategoryModelUncheckedUpdateManyWithoutProperty_categoriesInput>
  }

  export type REPropertySuperCategoryModelCreateWithoutMiddle_categoriesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
  }

  export type REPropertySuperCategoryModelUncheckedCreateWithoutMiddle_categoriesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
  }

  export type REPropertySuperCategoryModelCreateOrConnectWithoutMiddle_categoriesInput = {
    where: REPropertySuperCategoryModelWhereUniqueInput
    create: XOR<REPropertySuperCategoryModelCreateWithoutMiddle_categoriesInput, REPropertySuperCategoryModelUncheckedCreateWithoutMiddle_categoriesInput>
  }

  export type REPropertySubCategoryModelCreateWithoutMiddle_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    property_categories?: REPropertyCategoryModelCreateNestedManyWithoutSub_categoryInput
  }

  export type REPropertySubCategoryModelUncheckedCreateWithoutMiddle_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    property_categories?: REPropertyCategoryModelUncheckedCreateNestedManyWithoutSub_categoryInput
  }

  export type REPropertySubCategoryModelCreateOrConnectWithoutMiddle_categoryInput = {
    where: REPropertySubCategoryModelWhereUniqueInput
    create: XOR<REPropertySubCategoryModelCreateWithoutMiddle_categoryInput, REPropertySubCategoryModelUncheckedCreateWithoutMiddle_categoryInput>
  }

  export type REPropertySubCategoryModelCreateManyMiddle_categoryInputEnvelope = {
    data: Enumerable<REPropertySubCategoryModelCreateManyMiddle_categoryInput>
    skipDuplicates?: boolean
  }

  export type REPropertySuperCategoryModelUpsertWithoutMiddle_categoriesInput = {
    update: XOR<REPropertySuperCategoryModelUpdateWithoutMiddle_categoriesInput, REPropertySuperCategoryModelUncheckedUpdateWithoutMiddle_categoriesInput>
    create: XOR<REPropertySuperCategoryModelCreateWithoutMiddle_categoriesInput, REPropertySuperCategoryModelUncheckedCreateWithoutMiddle_categoriesInput>
  }

  export type REPropertySuperCategoryModelUpdateWithoutMiddle_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertySuperCategoryModelUncheckedUpdateWithoutMiddle_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertySubCategoryModelUpsertWithWhereUniqueWithoutMiddle_categoryInput = {
    where: REPropertySubCategoryModelWhereUniqueInput
    update: XOR<REPropertySubCategoryModelUpdateWithoutMiddle_categoryInput, REPropertySubCategoryModelUncheckedUpdateWithoutMiddle_categoryInput>
    create: XOR<REPropertySubCategoryModelCreateWithoutMiddle_categoryInput, REPropertySubCategoryModelUncheckedCreateWithoutMiddle_categoryInput>
  }

  export type REPropertySubCategoryModelUpdateWithWhereUniqueWithoutMiddle_categoryInput = {
    where: REPropertySubCategoryModelWhereUniqueInput
    data: XOR<REPropertySubCategoryModelUpdateWithoutMiddle_categoryInput, REPropertySubCategoryModelUncheckedUpdateWithoutMiddle_categoryInput>
  }

  export type REPropertySubCategoryModelUpdateManyWithWhereWithoutMiddle_categoryInput = {
    where: REPropertySubCategoryModelScalarWhereInput
    data: XOR<REPropertySubCategoryModelUpdateManyMutationInput, REPropertySubCategoryModelUncheckedUpdateManyWithoutSub_categoriesInput>
  }

  export type REPropertySubCategoryModelScalarWhereInput = {
    AND?: Enumerable<REPropertySubCategoryModelScalarWhereInput>
    OR?: Enumerable<REPropertySubCategoryModelScalarWhereInput>
    NOT?: Enumerable<REPropertySubCategoryModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    name?: StringFilter | string
    middle_category_id?: StringFilter | string
  }

  export type REPropertyMiddleCategoryModelCreateWithoutSuper_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    sub_categories?: REPropertySubCategoryModelCreateNestedManyWithoutMiddle_categoryInput
  }

  export type REPropertyMiddleCategoryModelUncheckedCreateWithoutSuper_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    sub_categories?: REPropertySubCategoryModelUncheckedCreateNestedManyWithoutMiddle_categoryInput
  }

  export type REPropertyMiddleCategoryModelCreateOrConnectWithoutSuper_categoryInput = {
    where: REPropertyMiddleCategoryModelWhereUniqueInput
    create: XOR<REPropertyMiddleCategoryModelCreateWithoutSuper_categoryInput, REPropertyMiddleCategoryModelUncheckedCreateWithoutSuper_categoryInput>
  }

  export type REPropertyMiddleCategoryModelCreateManySuper_categoryInputEnvelope = {
    data: Enumerable<REPropertyMiddleCategoryModelCreateManySuper_categoryInput>
    skipDuplicates?: boolean
  }

  export type REPropertyMiddleCategoryModelUpsertWithWhereUniqueWithoutSuper_categoryInput = {
    where: REPropertyMiddleCategoryModelWhereUniqueInput
    update: XOR<REPropertyMiddleCategoryModelUpdateWithoutSuper_categoryInput, REPropertyMiddleCategoryModelUncheckedUpdateWithoutSuper_categoryInput>
    create: XOR<REPropertyMiddleCategoryModelCreateWithoutSuper_categoryInput, REPropertyMiddleCategoryModelUncheckedCreateWithoutSuper_categoryInput>
  }

  export type REPropertyMiddleCategoryModelUpdateWithWhereUniqueWithoutSuper_categoryInput = {
    where: REPropertyMiddleCategoryModelWhereUniqueInput
    data: XOR<REPropertyMiddleCategoryModelUpdateWithoutSuper_categoryInput, REPropertyMiddleCategoryModelUncheckedUpdateWithoutSuper_categoryInput>
  }

  export type REPropertyMiddleCategoryModelUpdateManyWithWhereWithoutSuper_categoryInput = {
    where: REPropertyMiddleCategoryModelScalarWhereInput
    data: XOR<REPropertyMiddleCategoryModelUpdateManyMutationInput, REPropertyMiddleCategoryModelUncheckedUpdateManyWithoutMiddle_categoriesInput>
  }

  export type REPropertyMiddleCategoryModelScalarWhereInput = {
    AND?: Enumerable<REPropertyMiddleCategoryModelScalarWhereInput>
    OR?: Enumerable<REPropertyMiddleCategoryModelScalarWhereInput>
    NOT?: Enumerable<REPropertyMiddleCategoryModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    name?: StringFilter | string
    super_category_id?: StringFilter | string
  }

  export type AgreementAcceptanceModelCreateWithoutAgreementInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    user: UserModelCreateNestedOneWithoutAgreement_acceptancesInput
  }

  export type AgreementAcceptanceModelUncheckedCreateWithoutAgreementInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    user_id: string
  }

  export type AgreementAcceptanceModelCreateOrConnectWithoutAgreementInput = {
    where: AgreementAcceptanceModelWhereUniqueInput
    create: XOR<AgreementAcceptanceModelCreateWithoutAgreementInput, AgreementAcceptanceModelUncheckedCreateWithoutAgreementInput>
  }

  export type AgreementAcceptanceModelCreateManyAgreementInputEnvelope = {
    data: Enumerable<AgreementAcceptanceModelCreateManyAgreementInput>
    skipDuplicates?: boolean
  }

  export type AgreementAcceptanceModelUpsertWithWhereUniqueWithoutAgreementInput = {
    where: AgreementAcceptanceModelWhereUniqueInput
    update: XOR<AgreementAcceptanceModelUpdateWithoutAgreementInput, AgreementAcceptanceModelUncheckedUpdateWithoutAgreementInput>
    create: XOR<AgreementAcceptanceModelCreateWithoutAgreementInput, AgreementAcceptanceModelUncheckedCreateWithoutAgreementInput>
  }

  export type AgreementAcceptanceModelUpdateWithWhereUniqueWithoutAgreementInput = {
    where: AgreementAcceptanceModelWhereUniqueInput
    data: XOR<AgreementAcceptanceModelUpdateWithoutAgreementInput, AgreementAcceptanceModelUncheckedUpdateWithoutAgreementInput>
  }

  export type AgreementAcceptanceModelUpdateManyWithWhereWithoutAgreementInput = {
    where: AgreementAcceptanceModelScalarWhereInput
    data: XOR<AgreementAcceptanceModelUpdateManyMutationInput, AgreementAcceptanceModelUncheckedUpdateManyWithoutAcceptancesInput>
  }

  export type AgreementAcceptanceModelScalarWhereInput = {
    AND?: Enumerable<AgreementAcceptanceModelScalarWhereInput>
    OR?: Enumerable<AgreementAcceptanceModelScalarWhereInput>
    NOT?: Enumerable<AgreementAcceptanceModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    user_id?: StringFilter | string
    agreement_id?: StringFilter | string
  }

  export type UserModelCreateWithoutAgreement_acceptancesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    email?: string | null
    customer?: CustomerModelCreateNestedOneWithoutBaseInput
    business_user?: BusinessUserModelCreateNestedOneWithoutBaseInput
  }

  export type UserModelUncheckedCreateWithoutAgreement_acceptancesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    email?: string | null
    customer?: CustomerModelUncheckedCreateNestedOneWithoutBaseInput
    business_user?: BusinessUserModelUncheckedCreateNestedOneWithoutBaseInput
  }

  export type UserModelCreateOrConnectWithoutAgreement_acceptancesInput = {
    where: UserModelWhereUniqueInput
    create: XOR<UserModelCreateWithoutAgreement_acceptancesInput, UserModelUncheckedCreateWithoutAgreement_acceptancesInput>
  }

  export type AgreementModelCreateWithoutAcceptancesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    title: string
    content: string
    is_required: boolean
    target_type: AgreementTargetType
  }

  export type AgreementModelUncheckedCreateWithoutAcceptancesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    title: string
    content: string
    is_required: boolean
    target_type: AgreementTargetType
  }

  export type AgreementModelCreateOrConnectWithoutAcceptancesInput = {
    where: AgreementModelWhereUniqueInput
    create: XOR<AgreementModelCreateWithoutAcceptancesInput, AgreementModelUncheckedCreateWithoutAcceptancesInput>
  }

  export type UserModelUpsertWithoutAgreement_acceptancesInput = {
    update: XOR<UserModelUpdateWithoutAgreement_acceptancesInput, UserModelUncheckedUpdateWithoutAgreement_acceptancesInput>
    create: XOR<UserModelCreateWithoutAgreement_acceptancesInput, UserModelUncheckedCreateWithoutAgreement_acceptancesInput>
  }

  export type UserModelUpdateWithoutAgreement_acceptancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerModelUpdateOneWithoutBaseNestedInput
    business_user?: BusinessUserModelUpdateOneWithoutBaseNestedInput
  }

  export type UserModelUncheckedUpdateWithoutAgreement_acceptancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerModelUncheckedUpdateOneWithoutBaseNestedInput
    business_user?: BusinessUserModelUncheckedUpdateOneWithoutBaseNestedInput
  }

  export type AgreementModelUpsertWithoutAcceptancesInput = {
    update: XOR<AgreementModelUpdateWithoutAcceptancesInput, AgreementModelUncheckedUpdateWithoutAcceptancesInput>
    create: XOR<AgreementModelCreateWithoutAcceptancesInput, AgreementModelUncheckedCreateWithoutAcceptancesInput>
  }

  export type AgreementModelUpdateWithoutAcceptancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_required?: BoolFieldUpdateOperationsInput | boolean
    target_type?: EnumAgreementTargetTypeFieldUpdateOperationsInput | AgreementTargetType
  }

  export type AgreementModelUncheckedUpdateWithoutAcceptancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_required?: BoolFieldUpdateOperationsInput | boolean
    target_type?: EnumAgreementTargetTypeFieldUpdateOperationsInput | AgreementTargetType
  }

  export type ServiceSuperCategoryModelCreateWithoutSub_categoriesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    type: ServiceType
    focus_care_checks?: ZipzoongCareServiceCheckModelCreateNestedManyWithoutService_super_categoryInput
  }

  export type ServiceSuperCategoryModelUncheckedCreateWithoutSub_categoriesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    type: ServiceType
    focus_care_checks?: ZipzoongCareServiceCheckModelUncheckedCreateNestedManyWithoutService_super_categoryInput
  }

  export type ServiceSuperCategoryModelCreateOrConnectWithoutSub_categoriesInput = {
    where: ServiceSuperCategoryModelWhereUniqueInput
    create: XOR<ServiceSuperCategoryModelCreateWithoutSub_categoriesInput, ServiceSuperCategoryModelUncheckedCreateWithoutSub_categoriesInput>
  }

  export type SubExpertiseModelCreateWithoutSub_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    business_user: BusinessUserModelCreateNestedOneWithoutSub_expertisesInput
  }

  export type SubExpertiseModelUncheckedCreateWithoutSub_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    business_user_id: string
  }

  export type SubExpertiseModelCreateOrConnectWithoutSub_categoryInput = {
    where: SubExpertiseModelWhereUniqueInput
    create: XOR<SubExpertiseModelCreateWithoutSub_categoryInput, SubExpertiseModelUncheckedCreateWithoutSub_categoryInput>
  }

  export type SubExpertiseModelCreateManySub_categoryInputEnvelope = {
    data: Enumerable<SubExpertiseModelCreateManySub_categoryInput>
    skipDuplicates?: boolean
  }

  export type ServiceSuperCategoryModelUpsertWithoutSub_categoriesInput = {
    update: XOR<ServiceSuperCategoryModelUpdateWithoutSub_categoriesInput, ServiceSuperCategoryModelUncheckedUpdateWithoutSub_categoriesInput>
    create: XOR<ServiceSuperCategoryModelCreateWithoutSub_categoriesInput, ServiceSuperCategoryModelUncheckedCreateWithoutSub_categoriesInput>
  }

  export type ServiceSuperCategoryModelUpdateWithoutSub_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | ServiceType
    focus_care_checks?: ZipzoongCareServiceCheckModelUpdateManyWithoutService_super_categoryNestedInput
  }

  export type ServiceSuperCategoryModelUncheckedUpdateWithoutSub_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | ServiceType
    focus_care_checks?: ZipzoongCareServiceCheckModelUncheckedUpdateManyWithoutService_super_categoryNestedInput
  }

  export type SubExpertiseModelUpsertWithWhereUniqueWithoutSub_categoryInput = {
    where: SubExpertiseModelWhereUniqueInput
    update: XOR<SubExpertiseModelUpdateWithoutSub_categoryInput, SubExpertiseModelUncheckedUpdateWithoutSub_categoryInput>
    create: XOR<SubExpertiseModelCreateWithoutSub_categoryInput, SubExpertiseModelUncheckedCreateWithoutSub_categoryInput>
  }

  export type SubExpertiseModelUpdateWithWhereUniqueWithoutSub_categoryInput = {
    where: SubExpertiseModelWhereUniqueInput
    data: XOR<SubExpertiseModelUpdateWithoutSub_categoryInput, SubExpertiseModelUncheckedUpdateWithoutSub_categoryInput>
  }

  export type SubExpertiseModelUpdateManyWithWhereWithoutSub_categoryInput = {
    where: SubExpertiseModelScalarWhereInput
    data: XOR<SubExpertiseModelUpdateManyMutationInput, SubExpertiseModelUncheckedUpdateManyWithoutExpertisesInput>
  }

  export type SubExpertiseModelScalarWhereInput = {
    AND?: Enumerable<SubExpertiseModelScalarWhereInput>
    OR?: Enumerable<SubExpertiseModelScalarWhereInput>
    NOT?: Enumerable<SubExpertiseModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    sub_category_id?: StringFilter | string
    business_user_id?: StringFilter | string
  }

  export type ServiceSubCategoryModelCreateWithoutSuper_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    expertises?: SubExpertiseModelCreateNestedManyWithoutSub_categoryInput
  }

  export type ServiceSubCategoryModelUncheckedCreateWithoutSuper_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    expertises?: SubExpertiseModelUncheckedCreateNestedManyWithoutSub_categoryInput
  }

  export type ServiceSubCategoryModelCreateOrConnectWithoutSuper_categoryInput = {
    where: ServiceSubCategoryModelWhereUniqueInput
    create: XOR<ServiceSubCategoryModelCreateWithoutSuper_categoryInput, ServiceSubCategoryModelUncheckedCreateWithoutSuper_categoryInput>
  }

  export type ServiceSubCategoryModelCreateManySuper_categoryInputEnvelope = {
    data: Enumerable<ServiceSubCategoryModelCreateManySuper_categoryInput>
    skipDuplicates?: boolean
  }

  export type ZipzoongCareServiceCheckModelCreateWithoutService_super_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    request: ZipzoongCareRequestModelCreateNestedOneWithoutService_checksInput
  }

  export type ZipzoongCareServiceCheckModelUncheckedCreateWithoutService_super_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    request_id: string
  }

  export type ZipzoongCareServiceCheckModelCreateOrConnectWithoutService_super_categoryInput = {
    where: ZipzoongCareServiceCheckModelWhereUniqueInput
    create: XOR<ZipzoongCareServiceCheckModelCreateWithoutService_super_categoryInput, ZipzoongCareServiceCheckModelUncheckedCreateWithoutService_super_categoryInput>
  }

  export type ZipzoongCareServiceCheckModelCreateManyService_super_categoryInputEnvelope = {
    data: Enumerable<ZipzoongCareServiceCheckModelCreateManyService_super_categoryInput>
    skipDuplicates?: boolean
  }

  export type ServiceSubCategoryModelUpsertWithWhereUniqueWithoutSuper_categoryInput = {
    where: ServiceSubCategoryModelWhereUniqueInput
    update: XOR<ServiceSubCategoryModelUpdateWithoutSuper_categoryInput, ServiceSubCategoryModelUncheckedUpdateWithoutSuper_categoryInput>
    create: XOR<ServiceSubCategoryModelCreateWithoutSuper_categoryInput, ServiceSubCategoryModelUncheckedCreateWithoutSuper_categoryInput>
  }

  export type ServiceSubCategoryModelUpdateWithWhereUniqueWithoutSuper_categoryInput = {
    where: ServiceSubCategoryModelWhereUniqueInput
    data: XOR<ServiceSubCategoryModelUpdateWithoutSuper_categoryInput, ServiceSubCategoryModelUncheckedUpdateWithoutSuper_categoryInput>
  }

  export type ServiceSubCategoryModelUpdateManyWithWhereWithoutSuper_categoryInput = {
    where: ServiceSubCategoryModelScalarWhereInput
    data: XOR<ServiceSubCategoryModelUpdateManyMutationInput, ServiceSubCategoryModelUncheckedUpdateManyWithoutSub_categoriesInput>
  }

  export type ServiceSubCategoryModelScalarWhereInput = {
    AND?: Enumerable<ServiceSubCategoryModelScalarWhereInput>
    OR?: Enumerable<ServiceSubCategoryModelScalarWhereInput>
    NOT?: Enumerable<ServiceSubCategoryModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    name?: StringFilter | string
    super_category_id?: StringFilter | string
  }

  export type ZipzoongCareServiceCheckModelUpsertWithWhereUniqueWithoutService_super_categoryInput = {
    where: ZipzoongCareServiceCheckModelWhereUniqueInput
    update: XOR<ZipzoongCareServiceCheckModelUpdateWithoutService_super_categoryInput, ZipzoongCareServiceCheckModelUncheckedUpdateWithoutService_super_categoryInput>
    create: XOR<ZipzoongCareServiceCheckModelCreateWithoutService_super_categoryInput, ZipzoongCareServiceCheckModelUncheckedCreateWithoutService_super_categoryInput>
  }

  export type ZipzoongCareServiceCheckModelUpdateWithWhereUniqueWithoutService_super_categoryInput = {
    where: ZipzoongCareServiceCheckModelWhereUniqueInput
    data: XOR<ZipzoongCareServiceCheckModelUpdateWithoutService_super_categoryInput, ZipzoongCareServiceCheckModelUncheckedUpdateWithoutService_super_categoryInput>
  }

  export type ZipzoongCareServiceCheckModelUpdateManyWithWhereWithoutService_super_categoryInput = {
    where: ZipzoongCareServiceCheckModelScalarWhereInput
    data: XOR<ZipzoongCareServiceCheckModelUpdateManyMutationInput, ZipzoongCareServiceCheckModelUncheckedUpdateManyWithoutFocus_care_checksInput>
  }

  export type ZipzoongCareServiceCheckModelScalarWhereInput = {
    AND?: Enumerable<ZipzoongCareServiceCheckModelScalarWhereInput>
    OR?: Enumerable<ZipzoongCareServiceCheckModelScalarWhereInput>
    NOT?: Enumerable<ZipzoongCareServiceCheckModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    service_super_category_id?: StringFilter | string
    request_id?: StringFilter | string
  }

  export type CustomerModelCreateWithoutZipzoong_care_requestsInput = {
    birth?: string | null
    gender?: GenderType | null
    phone?: string | null
    address_first?: string | null
    address_second?: string | null
    profile_image_url?: string | null
    base: UserModelCreateNestedOneWithoutCustomerInput
    oauth_accounts?: OauthAccountModelCreateNestedManyWithoutCustomerInput
  }

  export type CustomerModelUncheckedCreateWithoutZipzoong_care_requestsInput = {
    id: string
    birth?: string | null
    gender?: GenderType | null
    phone?: string | null
    address_first?: string | null
    address_second?: string | null
    profile_image_url?: string | null
    oauth_accounts?: OauthAccountModelUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerModelCreateOrConnectWithoutZipzoong_care_requestsInput = {
    where: CustomerModelWhereUniqueInput
    create: XOR<CustomerModelCreateWithoutZipzoong_care_requestsInput, CustomerModelUncheckedCreateWithoutZipzoong_care_requestsInput>
  }

  export type ZipzoongCareConsultationTimeCheckModelCreateWithoutRequestInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    start_time: Date | string
    end_time: Date | string
  }

  export type ZipzoongCareConsultationTimeCheckModelUncheckedCreateWithoutRequestInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    start_time: Date | string
    end_time: Date | string
  }

  export type ZipzoongCareConsultationTimeCheckModelCreateOrConnectWithoutRequestInput = {
    where: ZipzoongCareConsultationTimeCheckModelWhereUniqueInput
    create: XOR<ZipzoongCareConsultationTimeCheckModelCreateWithoutRequestInput, ZipzoongCareConsultationTimeCheckModelUncheckedCreateWithoutRequestInput>
  }

  export type ZipzoongCareConsultationTimeCheckModelCreateManyRequestInputEnvelope = {
    data: Enumerable<ZipzoongCareConsultationTimeCheckModelCreateManyRequestInput>
    skipDuplicates?: boolean
  }

  export type ZipzoongCareServiceCheckModelCreateWithoutRequestInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    service_super_category: ServiceSuperCategoryModelCreateNestedOneWithoutFocus_care_checksInput
  }

  export type ZipzoongCareServiceCheckModelUncheckedCreateWithoutRequestInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    service_super_category_id: string
  }

  export type ZipzoongCareServiceCheckModelCreateOrConnectWithoutRequestInput = {
    where: ZipzoongCareServiceCheckModelWhereUniqueInput
    create: XOR<ZipzoongCareServiceCheckModelCreateWithoutRequestInput, ZipzoongCareServiceCheckModelUncheckedCreateWithoutRequestInput>
  }

  export type ZipzoongCareServiceCheckModelCreateManyRequestInputEnvelope = {
    data: Enumerable<ZipzoongCareServiceCheckModelCreateManyRequestInput>
    skipDuplicates?: boolean
  }

  export type CustomerModelUpsertWithoutZipzoong_care_requestsInput = {
    update: XOR<CustomerModelUpdateWithoutZipzoong_care_requestsInput, CustomerModelUncheckedUpdateWithoutZipzoong_care_requestsInput>
    create: XOR<CustomerModelCreateWithoutZipzoong_care_requestsInput, CustomerModelUncheckedCreateWithoutZipzoong_care_requestsInput>
  }

  export type CustomerModelUpdateWithoutZipzoong_care_requestsInput = {
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    base?: UserModelUpdateOneRequiredWithoutCustomerNestedInput
    oauth_accounts?: OauthAccountModelUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerModelUncheckedUpdateWithoutZipzoong_care_requestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_accounts?: OauthAccountModelUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ZipzoongCareConsultationTimeCheckModelUpsertWithWhereUniqueWithoutRequestInput = {
    where: ZipzoongCareConsultationTimeCheckModelWhereUniqueInput
    update: XOR<ZipzoongCareConsultationTimeCheckModelUpdateWithoutRequestInput, ZipzoongCareConsultationTimeCheckModelUncheckedUpdateWithoutRequestInput>
    create: XOR<ZipzoongCareConsultationTimeCheckModelCreateWithoutRequestInput, ZipzoongCareConsultationTimeCheckModelUncheckedCreateWithoutRequestInput>
  }

  export type ZipzoongCareConsultationTimeCheckModelUpdateWithWhereUniqueWithoutRequestInput = {
    where: ZipzoongCareConsultationTimeCheckModelWhereUniqueInput
    data: XOR<ZipzoongCareConsultationTimeCheckModelUpdateWithoutRequestInput, ZipzoongCareConsultationTimeCheckModelUncheckedUpdateWithoutRequestInput>
  }

  export type ZipzoongCareConsultationTimeCheckModelUpdateManyWithWhereWithoutRequestInput = {
    where: ZipzoongCareConsultationTimeCheckModelScalarWhereInput
    data: XOR<ZipzoongCareConsultationTimeCheckModelUpdateManyMutationInput, ZipzoongCareConsultationTimeCheckModelUncheckedUpdateManyWithoutConsultation_time_checksInput>
  }

  export type ZipzoongCareConsultationTimeCheckModelScalarWhereInput = {
    AND?: Enumerable<ZipzoongCareConsultationTimeCheckModelScalarWhereInput>
    OR?: Enumerable<ZipzoongCareConsultationTimeCheckModelScalarWhereInput>
    NOT?: Enumerable<ZipzoongCareConsultationTimeCheckModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    start_time?: DateTimeFilter | Date | string
    end_time?: DateTimeFilter | Date | string
    request_id?: StringFilter | string
  }

  export type ZipzoongCareServiceCheckModelUpsertWithWhereUniqueWithoutRequestInput = {
    where: ZipzoongCareServiceCheckModelWhereUniqueInput
    update: XOR<ZipzoongCareServiceCheckModelUpdateWithoutRequestInput, ZipzoongCareServiceCheckModelUncheckedUpdateWithoutRequestInput>
    create: XOR<ZipzoongCareServiceCheckModelCreateWithoutRequestInput, ZipzoongCareServiceCheckModelUncheckedCreateWithoutRequestInput>
  }

  export type ZipzoongCareServiceCheckModelUpdateWithWhereUniqueWithoutRequestInput = {
    where: ZipzoongCareServiceCheckModelWhereUniqueInput
    data: XOR<ZipzoongCareServiceCheckModelUpdateWithoutRequestInput, ZipzoongCareServiceCheckModelUncheckedUpdateWithoutRequestInput>
  }

  export type ZipzoongCareServiceCheckModelUpdateManyWithWhereWithoutRequestInput = {
    where: ZipzoongCareServiceCheckModelScalarWhereInput
    data: XOR<ZipzoongCareServiceCheckModelUpdateManyMutationInput, ZipzoongCareServiceCheckModelUncheckedUpdateManyWithoutService_checksInput>
  }

  export type ServiceSuperCategoryModelCreateWithoutFocus_care_checksInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    type: ServiceType
    sub_categories?: ServiceSubCategoryModelCreateNestedManyWithoutSuper_categoryInput
  }

  export type ServiceSuperCategoryModelUncheckedCreateWithoutFocus_care_checksInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    type: ServiceType
    sub_categories?: ServiceSubCategoryModelUncheckedCreateNestedManyWithoutSuper_categoryInput
  }

  export type ServiceSuperCategoryModelCreateOrConnectWithoutFocus_care_checksInput = {
    where: ServiceSuperCategoryModelWhereUniqueInput
    create: XOR<ServiceSuperCategoryModelCreateWithoutFocus_care_checksInput, ServiceSuperCategoryModelUncheckedCreateWithoutFocus_care_checksInput>
  }

  export type ZipzoongCareRequestModelCreateWithoutService_checksInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    care_start_date: Date | string
    care_end_date: Date | string
    detail: string
    status: ZipzoongCareStatus
    requester: CustomerModelCreateNestedOneWithoutZipzoong_care_requestsInput
    consultation_time_checks?: ZipzoongCareConsultationTimeCheckModelCreateNestedManyWithoutRequestInput
  }

  export type ZipzoongCareRequestModelUncheckedCreateWithoutService_checksInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    care_start_date: Date | string
    care_end_date: Date | string
    detail: string
    status: ZipzoongCareStatus
    requester_id: string
    consultation_time_checks?: ZipzoongCareConsultationTimeCheckModelUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ZipzoongCareRequestModelCreateOrConnectWithoutService_checksInput = {
    where: ZipzoongCareRequestModelWhereUniqueInput
    create: XOR<ZipzoongCareRequestModelCreateWithoutService_checksInput, ZipzoongCareRequestModelUncheckedCreateWithoutService_checksInput>
  }

  export type ServiceSuperCategoryModelUpsertWithoutFocus_care_checksInput = {
    update: XOR<ServiceSuperCategoryModelUpdateWithoutFocus_care_checksInput, ServiceSuperCategoryModelUncheckedUpdateWithoutFocus_care_checksInput>
    create: XOR<ServiceSuperCategoryModelCreateWithoutFocus_care_checksInput, ServiceSuperCategoryModelUncheckedCreateWithoutFocus_care_checksInput>
  }

  export type ServiceSuperCategoryModelUpdateWithoutFocus_care_checksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | ServiceType
    sub_categories?: ServiceSubCategoryModelUpdateManyWithoutSuper_categoryNestedInput
  }

  export type ServiceSuperCategoryModelUncheckedUpdateWithoutFocus_care_checksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | ServiceType
    sub_categories?: ServiceSubCategoryModelUncheckedUpdateManyWithoutSuper_categoryNestedInput
  }

  export type ZipzoongCareRequestModelUpsertWithoutService_checksInput = {
    update: XOR<ZipzoongCareRequestModelUpdateWithoutService_checksInput, ZipzoongCareRequestModelUncheckedUpdateWithoutService_checksInput>
    create: XOR<ZipzoongCareRequestModelCreateWithoutService_checksInput, ZipzoongCareRequestModelUncheckedCreateWithoutService_checksInput>
  }

  export type ZipzoongCareRequestModelUpdateWithoutService_checksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    care_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    care_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: StringFieldUpdateOperationsInput | string
    status?: EnumZipzoongCareStatusFieldUpdateOperationsInput | ZipzoongCareStatus
    requester?: CustomerModelUpdateOneRequiredWithoutZipzoong_care_requestsNestedInput
    consultation_time_checks?: ZipzoongCareConsultationTimeCheckModelUpdateManyWithoutRequestNestedInput
  }

  export type ZipzoongCareRequestModelUncheckedUpdateWithoutService_checksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    care_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    care_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: StringFieldUpdateOperationsInput | string
    status?: EnumZipzoongCareStatusFieldUpdateOperationsInput | ZipzoongCareStatus
    requester_id?: StringFieldUpdateOperationsInput | string
    consultation_time_checks?: ZipzoongCareConsultationTimeCheckModelUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type ZipzoongCareRequestModelCreateWithoutConsultation_time_checksInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    care_start_date: Date | string
    care_end_date: Date | string
    detail: string
    status: ZipzoongCareStatus
    requester: CustomerModelCreateNestedOneWithoutZipzoong_care_requestsInput
    service_checks?: ZipzoongCareServiceCheckModelCreateNestedManyWithoutRequestInput
  }

  export type ZipzoongCareRequestModelUncheckedCreateWithoutConsultation_time_checksInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    care_start_date: Date | string
    care_end_date: Date | string
    detail: string
    status: ZipzoongCareStatus
    requester_id: string
    service_checks?: ZipzoongCareServiceCheckModelUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ZipzoongCareRequestModelCreateOrConnectWithoutConsultation_time_checksInput = {
    where: ZipzoongCareRequestModelWhereUniqueInput
    create: XOR<ZipzoongCareRequestModelCreateWithoutConsultation_time_checksInput, ZipzoongCareRequestModelUncheckedCreateWithoutConsultation_time_checksInput>
  }

  export type ZipzoongCareRequestModelUpsertWithoutConsultation_time_checksInput = {
    update: XOR<ZipzoongCareRequestModelUpdateWithoutConsultation_time_checksInput, ZipzoongCareRequestModelUncheckedUpdateWithoutConsultation_time_checksInput>
    create: XOR<ZipzoongCareRequestModelCreateWithoutConsultation_time_checksInput, ZipzoongCareRequestModelUncheckedCreateWithoutConsultation_time_checksInput>
  }

  export type ZipzoongCareRequestModelUpdateWithoutConsultation_time_checksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    care_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    care_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: StringFieldUpdateOperationsInput | string
    status?: EnumZipzoongCareStatusFieldUpdateOperationsInput | ZipzoongCareStatus
    requester?: CustomerModelUpdateOneRequiredWithoutZipzoong_care_requestsNestedInput
    service_checks?: ZipzoongCareServiceCheckModelUpdateManyWithoutRequestNestedInput
  }

  export type ZipzoongCareRequestModelUncheckedUpdateWithoutConsultation_time_checksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    care_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    care_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: StringFieldUpdateOperationsInput | string
    status?: EnumZipzoongCareStatusFieldUpdateOperationsInput | ZipzoongCareStatus
    requester_id?: StringFieldUpdateOperationsInput | string
    service_checks?: ZipzoongCareServiceCheckModelUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type CustomerModelCreateWithoutBaseInput = {
    birth?: string | null
    gender?: GenderType | null
    phone?: string | null
    address_first?: string | null
    address_second?: string | null
    profile_image_url?: string | null
    oauth_accounts?: OauthAccountModelCreateNestedManyWithoutCustomerInput
    zipzoong_care_requests?: ZipzoongCareRequestModelCreateNestedManyWithoutRequesterInput
  }

  export type CustomerModelUncheckedCreateWithoutBaseInput = {
    birth?: string | null
    gender?: GenderType | null
    phone?: string | null
    address_first?: string | null
    address_second?: string | null
    profile_image_url?: string | null
    oauth_accounts?: OauthAccountModelUncheckedCreateNestedManyWithoutCustomerInput
    zipzoong_care_requests?: ZipzoongCareRequestModelUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type CustomerModelCreateOrConnectWithoutBaseInput = {
    where: CustomerModelWhereUniqueInput
    create: XOR<CustomerModelCreateWithoutBaseInput, CustomerModelUncheckedCreateWithoutBaseInput>
  }

  export type BusinessUserModelCreateWithoutBaseInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    re_agent?: REAgentModelCreateNestedOneWithoutBaseInput
    hs_provider?: HSProviderModelCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelCreateNestedManyWithoutBusiness_userInput
    sub_expertises?: SubExpertiseModelCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelCreateNestedManyWithoutBusiness_userInput
  }

  export type BusinessUserModelUncheckedCreateWithoutBaseInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    re_agent?: REAgentModelUncheckedCreateNestedOneWithoutBaseInput
    hs_provider?: HSProviderModelUncheckedCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelUncheckedCreateNestedManyWithoutBusiness_userInput
    sub_expertises?: SubExpertiseModelUncheckedCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelUncheckedCreateNestedManyWithoutBusiness_userInput
  }

  export type BusinessUserModelCreateOrConnectWithoutBaseInput = {
    where: BusinessUserModelWhereUniqueInput
    create: XOR<BusinessUserModelCreateWithoutBaseInput, BusinessUserModelUncheckedCreateWithoutBaseInput>
  }

  export type AgreementAcceptanceModelCreateWithoutUserInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    agreement: AgreementModelCreateNestedOneWithoutAcceptancesInput
  }

  export type AgreementAcceptanceModelUncheckedCreateWithoutUserInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    agreement_id: string
  }

  export type AgreementAcceptanceModelCreateOrConnectWithoutUserInput = {
    where: AgreementAcceptanceModelWhereUniqueInput
    create: XOR<AgreementAcceptanceModelCreateWithoutUserInput, AgreementAcceptanceModelUncheckedCreateWithoutUserInput>
  }

  export type AgreementAcceptanceModelCreateManyUserInputEnvelope = {
    data: Enumerable<AgreementAcceptanceModelCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CustomerModelUpsertWithoutBaseInput = {
    update: XOR<CustomerModelUpdateWithoutBaseInput, CustomerModelUncheckedUpdateWithoutBaseInput>
    create: XOR<CustomerModelCreateWithoutBaseInput, CustomerModelUncheckedCreateWithoutBaseInput>
  }

  export type CustomerModelUpdateWithoutBaseInput = {
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_accounts?: OauthAccountModelUpdateManyWithoutCustomerNestedInput
    zipzoong_care_requests?: ZipzoongCareRequestModelUpdateManyWithoutRequesterNestedInput
  }

  export type CustomerModelUncheckedUpdateWithoutBaseInput = {
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    oauth_accounts?: OauthAccountModelUncheckedUpdateManyWithoutCustomerNestedInput
    zipzoong_care_requests?: ZipzoongCareRequestModelUncheckedUpdateManyWithoutRequesterNestedInput
  }

  export type BusinessUserModelUpsertWithoutBaseInput = {
    update: XOR<BusinessUserModelUpdateWithoutBaseInput, BusinessUserModelUncheckedUpdateWithoutBaseInput>
    create: XOR<BusinessUserModelCreateWithoutBaseInput, BusinessUserModelUncheckedCreateWithoutBaseInput>
  }

  export type BusinessUserModelUpdateWithoutBaseInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    re_agent?: REAgentModelUpdateOneWithoutBaseNestedInput
    hs_provider?: HSProviderModelUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUpdateManyWithoutBusiness_userNestedInput
    sub_expertises?: SubExpertiseModelUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUpdateManyWithoutBusiness_userNestedInput
  }

  export type BusinessUserModelUncheckedUpdateWithoutBaseInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    re_agent?: REAgentModelUncheckedUpdateOneWithoutBaseNestedInput
    hs_provider?: HSProviderModelUncheckedUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    sub_expertises?: SubExpertiseModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUncheckedUpdateManyWithoutBusiness_userNestedInput
  }

  export type AgreementAcceptanceModelUpsertWithWhereUniqueWithoutUserInput = {
    where: AgreementAcceptanceModelWhereUniqueInput
    update: XOR<AgreementAcceptanceModelUpdateWithoutUserInput, AgreementAcceptanceModelUncheckedUpdateWithoutUserInput>
    create: XOR<AgreementAcceptanceModelCreateWithoutUserInput, AgreementAcceptanceModelUncheckedCreateWithoutUserInput>
  }

  export type AgreementAcceptanceModelUpdateWithWhereUniqueWithoutUserInput = {
    where: AgreementAcceptanceModelWhereUniqueInput
    data: XOR<AgreementAcceptanceModelUpdateWithoutUserInput, AgreementAcceptanceModelUncheckedUpdateWithoutUserInput>
  }

  export type AgreementAcceptanceModelUpdateManyWithWhereWithoutUserInput = {
    where: AgreementAcceptanceModelScalarWhereInput
    data: XOR<AgreementAcceptanceModelUpdateManyMutationInput, AgreementAcceptanceModelUncheckedUpdateManyWithoutAgreement_acceptancesInput>
  }

  export type UserModelCreateWithoutCustomerInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    email?: string | null
    business_user?: BusinessUserModelCreateNestedOneWithoutBaseInput
    agreement_acceptances?: AgreementAcceptanceModelCreateNestedManyWithoutUserInput
  }

  export type UserModelUncheckedCreateWithoutCustomerInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    email?: string | null
    business_user?: BusinessUserModelUncheckedCreateNestedOneWithoutBaseInput
    agreement_acceptances?: AgreementAcceptanceModelUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserModelCreateOrConnectWithoutCustomerInput = {
    where: UserModelWhereUniqueInput
    create: XOR<UserModelCreateWithoutCustomerInput, UserModelUncheckedCreateWithoutCustomerInput>
  }

  export type OauthAccountModelCreateWithoutCustomerInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    oauth_type: OauthType
    oauth_sub: string
    name?: string | null
    email?: string | null
    phone?: string | null
    profile_image_url?: string | null
    birth?: string | null
    gender?: GenderType | null
    address_first?: string | null
    address_second?: string | null
    business_user?: BusinessUserModelCreateNestedOneWithoutOauth_accountsInput
  }

  export type OauthAccountModelUncheckedCreateWithoutCustomerInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    oauth_type: OauthType
    oauth_sub: string
    business_user_id?: string | null
    name?: string | null
    email?: string | null
    phone?: string | null
    profile_image_url?: string | null
    birth?: string | null
    gender?: GenderType | null
    address_first?: string | null
    address_second?: string | null
  }

  export type OauthAccountModelCreateOrConnectWithoutCustomerInput = {
    where: OauthAccountModelWhereUniqueInput
    create: XOR<OauthAccountModelCreateWithoutCustomerInput, OauthAccountModelUncheckedCreateWithoutCustomerInput>
  }

  export type OauthAccountModelCreateManyCustomerInputEnvelope = {
    data: Enumerable<OauthAccountModelCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type ZipzoongCareRequestModelCreateWithoutRequesterInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    care_start_date: Date | string
    care_end_date: Date | string
    detail: string
    status: ZipzoongCareStatus
    consultation_time_checks?: ZipzoongCareConsultationTimeCheckModelCreateNestedManyWithoutRequestInput
    service_checks?: ZipzoongCareServiceCheckModelCreateNestedManyWithoutRequestInput
  }

  export type ZipzoongCareRequestModelUncheckedCreateWithoutRequesterInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    care_start_date: Date | string
    care_end_date: Date | string
    detail: string
    status: ZipzoongCareStatus
    consultation_time_checks?: ZipzoongCareConsultationTimeCheckModelUncheckedCreateNestedManyWithoutRequestInput
    service_checks?: ZipzoongCareServiceCheckModelUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ZipzoongCareRequestModelCreateOrConnectWithoutRequesterInput = {
    where: ZipzoongCareRequestModelWhereUniqueInput
    create: XOR<ZipzoongCareRequestModelCreateWithoutRequesterInput, ZipzoongCareRequestModelUncheckedCreateWithoutRequesterInput>
  }

  export type ZipzoongCareRequestModelCreateManyRequesterInputEnvelope = {
    data: Enumerable<ZipzoongCareRequestModelCreateManyRequesterInput>
    skipDuplicates?: boolean
  }

  export type UserModelUpsertWithoutCustomerInput = {
    update: XOR<UserModelUpdateWithoutCustomerInput, UserModelUncheckedUpdateWithoutCustomerInput>
    create: XOR<UserModelCreateWithoutCustomerInput, UserModelUncheckedCreateWithoutCustomerInput>
  }

  export type UserModelUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    business_user?: BusinessUserModelUpdateOneWithoutBaseNestedInput
    agreement_acceptances?: AgreementAcceptanceModelUpdateManyWithoutUserNestedInput
  }

  export type UserModelUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    business_user?: BusinessUserModelUncheckedUpdateOneWithoutBaseNestedInput
    agreement_acceptances?: AgreementAcceptanceModelUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OauthAccountModelUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OauthAccountModelWhereUniqueInput
    update: XOR<OauthAccountModelUpdateWithoutCustomerInput, OauthAccountModelUncheckedUpdateWithoutCustomerInput>
    create: XOR<OauthAccountModelCreateWithoutCustomerInput, OauthAccountModelUncheckedCreateWithoutCustomerInput>
  }

  export type OauthAccountModelUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OauthAccountModelWhereUniqueInput
    data: XOR<OauthAccountModelUpdateWithoutCustomerInput, OauthAccountModelUncheckedUpdateWithoutCustomerInput>
  }

  export type OauthAccountModelUpdateManyWithWhereWithoutCustomerInput = {
    where: OauthAccountModelScalarWhereInput
    data: XOR<OauthAccountModelUpdateManyMutationInput, OauthAccountModelUncheckedUpdateManyWithoutOauth_accountsInput>
  }

  export type OauthAccountModelScalarWhereInput = {
    AND?: Enumerable<OauthAccountModelScalarWhereInput>
    OR?: Enumerable<OauthAccountModelScalarWhereInput>
    NOT?: Enumerable<OauthAccountModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    oauth_type?: EnumOauthTypeFilter | OauthType
    oauth_sub?: StringFilter | string
    business_user_id?: StringNullableFilter | string | null
    customer_id?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    profile_image_url?: StringNullableFilter | string | null
    birth?: StringNullableFilter | string | null
    gender?: EnumGenderTypeNullableFilter | GenderType | null
    address_first?: StringNullableFilter | string | null
    address_second?: StringNullableFilter | string | null
  }

  export type ZipzoongCareRequestModelUpsertWithWhereUniqueWithoutRequesterInput = {
    where: ZipzoongCareRequestModelWhereUniqueInput
    update: XOR<ZipzoongCareRequestModelUpdateWithoutRequesterInput, ZipzoongCareRequestModelUncheckedUpdateWithoutRequesterInput>
    create: XOR<ZipzoongCareRequestModelCreateWithoutRequesterInput, ZipzoongCareRequestModelUncheckedCreateWithoutRequesterInput>
  }

  export type ZipzoongCareRequestModelUpdateWithWhereUniqueWithoutRequesterInput = {
    where: ZipzoongCareRequestModelWhereUniqueInput
    data: XOR<ZipzoongCareRequestModelUpdateWithoutRequesterInput, ZipzoongCareRequestModelUncheckedUpdateWithoutRequesterInput>
  }

  export type ZipzoongCareRequestModelUpdateManyWithWhereWithoutRequesterInput = {
    where: ZipzoongCareRequestModelScalarWhereInput
    data: XOR<ZipzoongCareRequestModelUpdateManyMutationInput, ZipzoongCareRequestModelUncheckedUpdateManyWithoutZipzoong_care_requestsInput>
  }

  export type ZipzoongCareRequestModelScalarWhereInput = {
    AND?: Enumerable<ZipzoongCareRequestModelScalarWhereInput>
    OR?: Enumerable<ZipzoongCareRequestModelScalarWhereInput>
    NOT?: Enumerable<ZipzoongCareRequestModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    care_start_date?: DateTimeFilter | Date | string
    care_end_date?: DateTimeFilter | Date | string
    detail?: StringFilter | string
    status?: EnumZipzoongCareStatusFilter | ZipzoongCareStatus
    requester_id?: StringFilter | string
  }

  export type UserModelCreateWithoutBusiness_userInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    email?: string | null
    customer?: CustomerModelCreateNestedOneWithoutBaseInput
    agreement_acceptances?: AgreementAcceptanceModelCreateNestedManyWithoutUserInput
  }

  export type UserModelUncheckedCreateWithoutBusiness_userInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    email?: string | null
    customer?: CustomerModelUncheckedCreateNestedOneWithoutBaseInput
    agreement_acceptances?: AgreementAcceptanceModelUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserModelCreateOrConnectWithoutBusiness_userInput = {
    where: UserModelWhereUniqueInput
    create: XOR<UserModelCreateWithoutBusiness_userInput, UserModelUncheckedCreateWithoutBusiness_userInput>
  }

  export type REAgentModelCreateWithoutBaseInput = {
    is_licensed: boolean
    re_num: string
    re_name: string
    re_phone: string
    re_licensed_agent_name: string
    properties?: REPropertyModelCreateNestedManyWithoutRe_agentInput
  }

  export type REAgentModelUncheckedCreateWithoutBaseInput = {
    is_licensed: boolean
    re_num: string
    re_name: string
    re_phone: string
    re_licensed_agent_name: string
    properties?: REPropertyModelUncheckedCreateNestedManyWithoutRe_agentInput
  }

  export type REAgentModelCreateOrConnectWithoutBaseInput = {
    where: REAgentModelWhereUniqueInput
    create: XOR<REAgentModelCreateWithoutBaseInput, REAgentModelUncheckedCreateWithoutBaseInput>
  }

  export type HSProviderModelCreateWithoutBaseInput = {
    business_registration_num: string
    example_images?: HSExampleImageModelCreateNestedManyWithoutHs_providerInput
  }

  export type HSProviderModelUncheckedCreateWithoutBaseInput = {
    business_registration_num: string
    example_images?: HSExampleImageModelUncheckedCreateNestedManyWithoutHs_providerInput
  }

  export type HSProviderModelCreateOrConnectWithoutBaseInput = {
    where: HSProviderModelWhereUniqueInput
    create: XOR<HSProviderModelCreateWithoutBaseInput, HSProviderModelUncheckedCreateWithoutBaseInput>
  }

  export type BusinessCertificationImageModelCreateWithoutBusiness_userInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    url: string
  }

  export type BusinessCertificationImageModelUncheckedCreateWithoutBusiness_userInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    url: string
  }

  export type BusinessCertificationImageModelCreateOrConnectWithoutBusiness_userInput = {
    where: BusinessCertificationImageModelWhereUniqueInput
    create: XOR<BusinessCertificationImageModelCreateWithoutBusiness_userInput, BusinessCertificationImageModelUncheckedCreateWithoutBusiness_userInput>
  }

  export type BusinessCertificationImageModelCreateManyBusiness_userInputEnvelope = {
    data: Enumerable<BusinessCertificationImageModelCreateManyBusiness_userInput>
    skipDuplicates?: boolean
  }

  export type SubExpertiseModelCreateWithoutBusiness_userInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    sub_category: ServiceSubCategoryModelCreateNestedOneWithoutExpertisesInput
  }

  export type SubExpertiseModelUncheckedCreateWithoutBusiness_userInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    sub_category_id: string
  }

  export type SubExpertiseModelCreateOrConnectWithoutBusiness_userInput = {
    where: SubExpertiseModelWhereUniqueInput
    create: XOR<SubExpertiseModelCreateWithoutBusiness_userInput, SubExpertiseModelUncheckedCreateWithoutBusiness_userInput>
  }

  export type SubExpertiseModelCreateManyBusiness_userInputEnvelope = {
    data: Enumerable<SubExpertiseModelCreateManyBusiness_userInput>
    skipDuplicates?: boolean
  }

  export type OauthAccountModelCreateWithoutBusiness_userInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    oauth_type: OauthType
    oauth_sub: string
    name?: string | null
    email?: string | null
    phone?: string | null
    profile_image_url?: string | null
    birth?: string | null
    gender?: GenderType | null
    address_first?: string | null
    address_second?: string | null
    customer?: CustomerModelCreateNestedOneWithoutOauth_accountsInput
  }

  export type OauthAccountModelUncheckedCreateWithoutBusiness_userInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    oauth_type: OauthType
    oauth_sub: string
    customer_id?: string | null
    name?: string | null
    email?: string | null
    phone?: string | null
    profile_image_url?: string | null
    birth?: string | null
    gender?: GenderType | null
    address_first?: string | null
    address_second?: string | null
  }

  export type OauthAccountModelCreateOrConnectWithoutBusiness_userInput = {
    where: OauthAccountModelWhereUniqueInput
    create: XOR<OauthAccountModelCreateWithoutBusiness_userInput, OauthAccountModelUncheckedCreateWithoutBusiness_userInput>
  }

  export type OauthAccountModelCreateManyBusiness_userInputEnvelope = {
    data: Enumerable<OauthAccountModelCreateManyBusiness_userInput>
    skipDuplicates?: boolean
  }

  export type UserModelUpsertWithoutBusiness_userInput = {
    update: XOR<UserModelUpdateWithoutBusiness_userInput, UserModelUncheckedUpdateWithoutBusiness_userInput>
    create: XOR<UserModelCreateWithoutBusiness_userInput, UserModelUncheckedCreateWithoutBusiness_userInput>
  }

  export type UserModelUpdateWithoutBusiness_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerModelUpdateOneWithoutBaseNestedInput
    agreement_acceptances?: AgreementAcceptanceModelUpdateManyWithoutUserNestedInput
  }

  export type UserModelUncheckedUpdateWithoutBusiness_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerModelUncheckedUpdateOneWithoutBaseNestedInput
    agreement_acceptances?: AgreementAcceptanceModelUncheckedUpdateManyWithoutUserNestedInput
  }

  export type REAgentModelUpsertWithoutBaseInput = {
    update: XOR<REAgentModelUpdateWithoutBaseInput, REAgentModelUncheckedUpdateWithoutBaseInput>
    create: XOR<REAgentModelCreateWithoutBaseInput, REAgentModelUncheckedCreateWithoutBaseInput>
  }

  export type REAgentModelUpdateWithoutBaseInput = {
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    re_num?: StringFieldUpdateOperationsInput | string
    re_name?: StringFieldUpdateOperationsInput | string
    re_phone?: StringFieldUpdateOperationsInput | string
    re_licensed_agent_name?: StringFieldUpdateOperationsInput | string
    properties?: REPropertyModelUpdateManyWithoutRe_agentNestedInput
  }

  export type REAgentModelUncheckedUpdateWithoutBaseInput = {
    is_licensed?: BoolFieldUpdateOperationsInput | boolean
    re_num?: StringFieldUpdateOperationsInput | string
    re_name?: StringFieldUpdateOperationsInput | string
    re_phone?: StringFieldUpdateOperationsInput | string
    re_licensed_agent_name?: StringFieldUpdateOperationsInput | string
    properties?: REPropertyModelUncheckedUpdateManyWithoutRe_agentNestedInput
  }

  export type HSProviderModelUpsertWithoutBaseInput = {
    update: XOR<HSProviderModelUpdateWithoutBaseInput, HSProviderModelUncheckedUpdateWithoutBaseInput>
    create: XOR<HSProviderModelCreateWithoutBaseInput, HSProviderModelUncheckedCreateWithoutBaseInput>
  }

  export type HSProviderModelUpdateWithoutBaseInput = {
    business_registration_num?: StringFieldUpdateOperationsInput | string
    example_images?: HSExampleImageModelUpdateManyWithoutHs_providerNestedInput
  }

  export type HSProviderModelUncheckedUpdateWithoutBaseInput = {
    business_registration_num?: StringFieldUpdateOperationsInput | string
    example_images?: HSExampleImageModelUncheckedUpdateManyWithoutHs_providerNestedInput
  }

  export type BusinessCertificationImageModelUpsertWithWhereUniqueWithoutBusiness_userInput = {
    where: BusinessCertificationImageModelWhereUniqueInput
    update: XOR<BusinessCertificationImageModelUpdateWithoutBusiness_userInput, BusinessCertificationImageModelUncheckedUpdateWithoutBusiness_userInput>
    create: XOR<BusinessCertificationImageModelCreateWithoutBusiness_userInput, BusinessCertificationImageModelUncheckedCreateWithoutBusiness_userInput>
  }

  export type BusinessCertificationImageModelUpdateWithWhereUniqueWithoutBusiness_userInput = {
    where: BusinessCertificationImageModelWhereUniqueInput
    data: XOR<BusinessCertificationImageModelUpdateWithoutBusiness_userInput, BusinessCertificationImageModelUncheckedUpdateWithoutBusiness_userInput>
  }

  export type BusinessCertificationImageModelUpdateManyWithWhereWithoutBusiness_userInput = {
    where: BusinessCertificationImageModelScalarWhereInput
    data: XOR<BusinessCertificationImageModelUpdateManyMutationInput, BusinessCertificationImageModelUncheckedUpdateManyWithoutCertification_imagesInput>
  }

  export type BusinessCertificationImageModelScalarWhereInput = {
    AND?: Enumerable<BusinessCertificationImageModelScalarWhereInput>
    OR?: Enumerable<BusinessCertificationImageModelScalarWhereInput>
    NOT?: Enumerable<BusinessCertificationImageModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    business_user_id?: StringFilter | string
    url?: StringFilter | string
  }

  export type SubExpertiseModelUpsertWithWhereUniqueWithoutBusiness_userInput = {
    where: SubExpertiseModelWhereUniqueInput
    update: XOR<SubExpertiseModelUpdateWithoutBusiness_userInput, SubExpertiseModelUncheckedUpdateWithoutBusiness_userInput>
    create: XOR<SubExpertiseModelCreateWithoutBusiness_userInput, SubExpertiseModelUncheckedCreateWithoutBusiness_userInput>
  }

  export type SubExpertiseModelUpdateWithWhereUniqueWithoutBusiness_userInput = {
    where: SubExpertiseModelWhereUniqueInput
    data: XOR<SubExpertiseModelUpdateWithoutBusiness_userInput, SubExpertiseModelUncheckedUpdateWithoutBusiness_userInput>
  }

  export type SubExpertiseModelUpdateManyWithWhereWithoutBusiness_userInput = {
    where: SubExpertiseModelScalarWhereInput
    data: XOR<SubExpertiseModelUpdateManyMutationInput, SubExpertiseModelUncheckedUpdateManyWithoutSub_expertisesInput>
  }

  export type OauthAccountModelUpsertWithWhereUniqueWithoutBusiness_userInput = {
    where: OauthAccountModelWhereUniqueInput
    update: XOR<OauthAccountModelUpdateWithoutBusiness_userInput, OauthAccountModelUncheckedUpdateWithoutBusiness_userInput>
    create: XOR<OauthAccountModelCreateWithoutBusiness_userInput, OauthAccountModelUncheckedCreateWithoutBusiness_userInput>
  }

  export type OauthAccountModelUpdateWithWhereUniqueWithoutBusiness_userInput = {
    where: OauthAccountModelWhereUniqueInput
    data: XOR<OauthAccountModelUpdateWithoutBusiness_userInput, OauthAccountModelUncheckedUpdateWithoutBusiness_userInput>
  }

  export type OauthAccountModelUpdateManyWithWhereWithoutBusiness_userInput = {
    where: OauthAccountModelScalarWhereInput
    data: XOR<OauthAccountModelUpdateManyMutationInput, OauthAccountModelUncheckedUpdateManyWithoutOauth_accountsInput>
  }

  export type ServiceSubCategoryModelCreateWithoutExpertisesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    super_category: ServiceSuperCategoryModelCreateNestedOneWithoutSub_categoriesInput
  }

  export type ServiceSubCategoryModelUncheckedCreateWithoutExpertisesInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    super_category_id: string
  }

  export type ServiceSubCategoryModelCreateOrConnectWithoutExpertisesInput = {
    where: ServiceSubCategoryModelWhereUniqueInput
    create: XOR<ServiceSubCategoryModelCreateWithoutExpertisesInput, ServiceSubCategoryModelUncheckedCreateWithoutExpertisesInput>
  }

  export type BusinessUserModelCreateWithoutSub_expertisesInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    base: UserModelCreateNestedOneWithoutBusiness_userInput
    re_agent?: REAgentModelCreateNestedOneWithoutBaseInput
    hs_provider?: HSProviderModelCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelCreateNestedManyWithoutBusiness_userInput
  }

  export type BusinessUserModelUncheckedCreateWithoutSub_expertisesInput = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    re_agent?: REAgentModelUncheckedCreateNestedOneWithoutBaseInput
    hs_provider?: HSProviderModelUncheckedCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelUncheckedCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelUncheckedCreateNestedManyWithoutBusiness_userInput
  }

  export type BusinessUserModelCreateOrConnectWithoutSub_expertisesInput = {
    where: BusinessUserModelWhereUniqueInput
    create: XOR<BusinessUserModelCreateWithoutSub_expertisesInput, BusinessUserModelUncheckedCreateWithoutSub_expertisesInput>
  }

  export type ServiceSubCategoryModelUpsertWithoutExpertisesInput = {
    update: XOR<ServiceSubCategoryModelUpdateWithoutExpertisesInput, ServiceSubCategoryModelUncheckedUpdateWithoutExpertisesInput>
    create: XOR<ServiceSubCategoryModelCreateWithoutExpertisesInput, ServiceSubCategoryModelUncheckedCreateWithoutExpertisesInput>
  }

  export type ServiceSubCategoryModelUpdateWithoutExpertisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    super_category?: ServiceSuperCategoryModelUpdateOneRequiredWithoutSub_categoriesNestedInput
  }

  export type ServiceSubCategoryModelUncheckedUpdateWithoutExpertisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    super_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUserModelUpsertWithoutSub_expertisesInput = {
    update: XOR<BusinessUserModelUpdateWithoutSub_expertisesInput, BusinessUserModelUncheckedUpdateWithoutSub_expertisesInput>
    create: XOR<BusinessUserModelCreateWithoutSub_expertisesInput, BusinessUserModelUncheckedCreateWithoutSub_expertisesInput>
  }

  export type BusinessUserModelUpdateWithoutSub_expertisesInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    base?: UserModelUpdateOneRequiredWithoutBusiness_userNestedInput
    re_agent?: REAgentModelUpdateOneWithoutBaseNestedInput
    hs_provider?: HSProviderModelUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUpdateManyWithoutBusiness_userNestedInput
  }

  export type BusinessUserModelUncheckedUpdateWithoutSub_expertisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    re_agent?: REAgentModelUncheckedUpdateOneWithoutBaseNestedInput
    hs_provider?: HSProviderModelUncheckedUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUncheckedUpdateManyWithoutBusiness_userNestedInput
  }

  export type BusinessUserModelCreateWithoutRe_agentInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    base: UserModelCreateNestedOneWithoutBusiness_userInput
    hs_provider?: HSProviderModelCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelCreateNestedManyWithoutBusiness_userInput
    sub_expertises?: SubExpertiseModelCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelCreateNestedManyWithoutBusiness_userInput
  }

  export type BusinessUserModelUncheckedCreateWithoutRe_agentInput = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    hs_provider?: HSProviderModelUncheckedCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelUncheckedCreateNestedManyWithoutBusiness_userInput
    sub_expertises?: SubExpertiseModelUncheckedCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelUncheckedCreateNestedManyWithoutBusiness_userInput
  }

  export type BusinessUserModelCreateOrConnectWithoutRe_agentInput = {
    where: BusinessUserModelWhereUniqueInput
    create: XOR<BusinessUserModelCreateWithoutRe_agentInput, BusinessUserModelUncheckedCreateWithoutRe_agentInput>
  }

  export type REPropertyModelCreateWithoutRe_agentInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    main_image_url: string
    is_visible: boolean
    categories?: REPropertyCategoryModelCreateNestedManyWithoutRe_propertyInput
  }

  export type REPropertyModelUncheckedCreateWithoutRe_agentInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    main_image_url: string
    is_visible: boolean
    categories?: REPropertyCategoryModelUncheckedCreateNestedManyWithoutRe_propertyInput
  }

  export type REPropertyModelCreateOrConnectWithoutRe_agentInput = {
    where: REPropertyModelWhereUniqueInput
    create: XOR<REPropertyModelCreateWithoutRe_agentInput, REPropertyModelUncheckedCreateWithoutRe_agentInput>
  }

  export type REPropertyModelCreateManyRe_agentInputEnvelope = {
    data: Enumerable<REPropertyModelCreateManyRe_agentInput>
    skipDuplicates?: boolean
  }

  export type BusinessUserModelUpsertWithoutRe_agentInput = {
    update: XOR<BusinessUserModelUpdateWithoutRe_agentInput, BusinessUserModelUncheckedUpdateWithoutRe_agentInput>
    create: XOR<BusinessUserModelCreateWithoutRe_agentInput, BusinessUserModelUncheckedCreateWithoutRe_agentInput>
  }

  export type BusinessUserModelUpdateWithoutRe_agentInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    base?: UserModelUpdateOneRequiredWithoutBusiness_userNestedInput
    hs_provider?: HSProviderModelUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUpdateManyWithoutBusiness_userNestedInput
    sub_expertises?: SubExpertiseModelUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUpdateManyWithoutBusiness_userNestedInput
  }

  export type BusinessUserModelUncheckedUpdateWithoutRe_agentInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    hs_provider?: HSProviderModelUncheckedUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    sub_expertises?: SubExpertiseModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUncheckedUpdateManyWithoutBusiness_userNestedInput
  }

  export type REPropertyModelUpsertWithWhereUniqueWithoutRe_agentInput = {
    where: REPropertyModelWhereUniqueInput
    update: XOR<REPropertyModelUpdateWithoutRe_agentInput, REPropertyModelUncheckedUpdateWithoutRe_agentInput>
    create: XOR<REPropertyModelCreateWithoutRe_agentInput, REPropertyModelUncheckedCreateWithoutRe_agentInput>
  }

  export type REPropertyModelUpdateWithWhereUniqueWithoutRe_agentInput = {
    where: REPropertyModelWhereUniqueInput
    data: XOR<REPropertyModelUpdateWithoutRe_agentInput, REPropertyModelUncheckedUpdateWithoutRe_agentInput>
  }

  export type REPropertyModelUpdateManyWithWhereWithoutRe_agentInput = {
    where: REPropertyModelScalarWhereInput
    data: XOR<REPropertyModelUpdateManyMutationInput, REPropertyModelUncheckedUpdateManyWithoutPropertiesInput>
  }

  export type REPropertyModelScalarWhereInput = {
    AND?: Enumerable<REPropertyModelScalarWhereInput>
    OR?: Enumerable<REPropertyModelScalarWhereInput>
    NOT?: Enumerable<REPropertyModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    name?: StringFilter | string
    main_image_url?: StringFilter | string
    re_agent_id?: StringFilter | string
    is_visible?: BoolFilter | boolean
  }

  export type BusinessUserModelCreateWithoutHs_providerInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    base: UserModelCreateNestedOneWithoutBusiness_userInput
    re_agent?: REAgentModelCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelCreateNestedManyWithoutBusiness_userInput
    sub_expertises?: SubExpertiseModelCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelCreateNestedManyWithoutBusiness_userInput
  }

  export type BusinessUserModelUncheckedCreateWithoutHs_providerInput = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    re_agent?: REAgentModelUncheckedCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelUncheckedCreateNestedManyWithoutBusiness_userInput
    sub_expertises?: SubExpertiseModelUncheckedCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelUncheckedCreateNestedManyWithoutBusiness_userInput
  }

  export type BusinessUserModelCreateOrConnectWithoutHs_providerInput = {
    where: BusinessUserModelWhereUniqueInput
    create: XOR<BusinessUserModelCreateWithoutHs_providerInput, BusinessUserModelUncheckedCreateWithoutHs_providerInput>
  }

  export type HSExampleImageModelCreateWithoutHs_providerInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    url: string
    is_visible: boolean
  }

  export type HSExampleImageModelUncheckedCreateWithoutHs_providerInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    url: string
    is_visible: boolean
  }

  export type HSExampleImageModelCreateOrConnectWithoutHs_providerInput = {
    where: HSExampleImageModelWhereUniqueInput
    create: XOR<HSExampleImageModelCreateWithoutHs_providerInput, HSExampleImageModelUncheckedCreateWithoutHs_providerInput>
  }

  export type HSExampleImageModelCreateManyHs_providerInputEnvelope = {
    data: Enumerable<HSExampleImageModelCreateManyHs_providerInput>
    skipDuplicates?: boolean
  }

  export type BusinessUserModelUpsertWithoutHs_providerInput = {
    update: XOR<BusinessUserModelUpdateWithoutHs_providerInput, BusinessUserModelUncheckedUpdateWithoutHs_providerInput>
    create: XOR<BusinessUserModelCreateWithoutHs_providerInput, BusinessUserModelUncheckedCreateWithoutHs_providerInput>
  }

  export type BusinessUserModelUpdateWithoutHs_providerInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    base?: UserModelUpdateOneRequiredWithoutBusiness_userNestedInput
    re_agent?: REAgentModelUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUpdateManyWithoutBusiness_userNestedInput
    sub_expertises?: SubExpertiseModelUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUpdateManyWithoutBusiness_userNestedInput
  }

  export type BusinessUserModelUncheckedUpdateWithoutHs_providerInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    re_agent?: REAgentModelUncheckedUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    sub_expertises?: SubExpertiseModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUncheckedUpdateManyWithoutBusiness_userNestedInput
  }

  export type HSExampleImageModelUpsertWithWhereUniqueWithoutHs_providerInput = {
    where: HSExampleImageModelWhereUniqueInput
    update: XOR<HSExampleImageModelUpdateWithoutHs_providerInput, HSExampleImageModelUncheckedUpdateWithoutHs_providerInput>
    create: XOR<HSExampleImageModelCreateWithoutHs_providerInput, HSExampleImageModelUncheckedCreateWithoutHs_providerInput>
  }

  export type HSExampleImageModelUpdateWithWhereUniqueWithoutHs_providerInput = {
    where: HSExampleImageModelWhereUniqueInput
    data: XOR<HSExampleImageModelUpdateWithoutHs_providerInput, HSExampleImageModelUncheckedUpdateWithoutHs_providerInput>
  }

  export type HSExampleImageModelUpdateManyWithWhereWithoutHs_providerInput = {
    where: HSExampleImageModelScalarWhereInput
    data: XOR<HSExampleImageModelUpdateManyMutationInput, HSExampleImageModelUncheckedUpdateManyWithoutExample_imagesInput>
  }

  export type HSExampleImageModelScalarWhereInput = {
    AND?: Enumerable<HSExampleImageModelScalarWhereInput>
    OR?: Enumerable<HSExampleImageModelScalarWhereInput>
    NOT?: Enumerable<HSExampleImageModelScalarWhereInput>
    id?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    is_deleted?: BoolFilter | boolean
    deleted_at?: DateTimeNullableFilter | Date | string | null
    hs_provider_id?: StringFilter | string
    url?: StringFilter | string
    is_visible?: BoolFilter | boolean
  }

  export type BusinessUserModelCreateWithoutCertification_imagesInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    base: UserModelCreateNestedOneWithoutBusiness_userInput
    re_agent?: REAgentModelCreateNestedOneWithoutBaseInput
    hs_provider?: HSProviderModelCreateNestedOneWithoutBaseInput
    sub_expertises?: SubExpertiseModelCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelCreateNestedManyWithoutBusiness_userInput
  }

  export type BusinessUserModelUncheckedCreateWithoutCertification_imagesInput = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    re_agent?: REAgentModelUncheckedCreateNestedOneWithoutBaseInput
    hs_provider?: HSProviderModelUncheckedCreateNestedOneWithoutBaseInput
    sub_expertises?: SubExpertiseModelUncheckedCreateNestedManyWithoutBusiness_userInput
    oauth_accounts?: OauthAccountModelUncheckedCreateNestedManyWithoutBusiness_userInput
  }

  export type BusinessUserModelCreateOrConnectWithoutCertification_imagesInput = {
    where: BusinessUserModelWhereUniqueInput
    create: XOR<BusinessUserModelCreateWithoutCertification_imagesInput, BusinessUserModelUncheckedCreateWithoutCertification_imagesInput>
  }

  export type BusinessUserModelUpsertWithoutCertification_imagesInput = {
    update: XOR<BusinessUserModelUpdateWithoutCertification_imagesInput, BusinessUserModelUncheckedUpdateWithoutCertification_imagesInput>
    create: XOR<BusinessUserModelCreateWithoutCertification_imagesInput, BusinessUserModelUncheckedCreateWithoutCertification_imagesInput>
  }

  export type BusinessUserModelUpdateWithoutCertification_imagesInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    base?: UserModelUpdateOneRequiredWithoutBusiness_userNestedInput
    re_agent?: REAgentModelUpdateOneWithoutBaseNestedInput
    hs_provider?: HSProviderModelUpdateOneWithoutBaseNestedInput
    sub_expertises?: SubExpertiseModelUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUpdateManyWithoutBusiness_userNestedInput
  }

  export type BusinessUserModelUncheckedUpdateWithoutCertification_imagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    re_agent?: REAgentModelUncheckedUpdateOneWithoutBaseNestedInput
    hs_provider?: HSProviderModelUncheckedUpdateOneWithoutBaseNestedInput
    sub_expertises?: SubExpertiseModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    oauth_accounts?: OauthAccountModelUncheckedUpdateManyWithoutBusiness_userNestedInput
  }

  export type HSProviderModelCreateWithoutExample_imagesInput = {
    business_registration_num: string
    base: BusinessUserModelCreateNestedOneWithoutHs_providerInput
  }

  export type HSProviderModelUncheckedCreateWithoutExample_imagesInput = {
    id: string
    business_registration_num: string
  }

  export type HSProviderModelCreateOrConnectWithoutExample_imagesInput = {
    where: HSProviderModelWhereUniqueInput
    create: XOR<HSProviderModelCreateWithoutExample_imagesInput, HSProviderModelUncheckedCreateWithoutExample_imagesInput>
  }

  export type HSProviderModelUpsertWithoutExample_imagesInput = {
    update: XOR<HSProviderModelUpdateWithoutExample_imagesInput, HSProviderModelUncheckedUpdateWithoutExample_imagesInput>
    create: XOR<HSProviderModelCreateWithoutExample_imagesInput, HSProviderModelUncheckedCreateWithoutExample_imagesInput>
  }

  export type HSProviderModelUpdateWithoutExample_imagesInput = {
    business_registration_num?: StringFieldUpdateOperationsInput | string
    base?: BusinessUserModelUpdateOneRequiredWithoutHs_providerNestedInput
  }

  export type HSProviderModelUncheckedUpdateWithoutExample_imagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    business_registration_num?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUserModelCreateWithoutOauth_accountsInput = {
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    base: UserModelCreateNestedOneWithoutBusiness_userInput
    re_agent?: REAgentModelCreateNestedOneWithoutBaseInput
    hs_provider?: HSProviderModelCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelCreateNestedManyWithoutBusiness_userInput
    sub_expertises?: SubExpertiseModelCreateNestedManyWithoutBusiness_userInput
  }

  export type BusinessUserModelUncheckedCreateWithoutOauth_accountsInput = {
    id: string
    is_verified: boolean
    introduction_title: string
    introduction_content: string
    phone: string
    address_first: string
    address_second?: string | null
    profile_image_url: string
    re_agent?: REAgentModelUncheckedCreateNestedOneWithoutBaseInput
    hs_provider?: HSProviderModelUncheckedCreateNestedOneWithoutBaseInput
    certification_images?: BusinessCertificationImageModelUncheckedCreateNestedManyWithoutBusiness_userInput
    sub_expertises?: SubExpertiseModelUncheckedCreateNestedManyWithoutBusiness_userInput
  }

  export type BusinessUserModelCreateOrConnectWithoutOauth_accountsInput = {
    where: BusinessUserModelWhereUniqueInput
    create: XOR<BusinessUserModelCreateWithoutOauth_accountsInput, BusinessUserModelUncheckedCreateWithoutOauth_accountsInput>
  }

  export type CustomerModelCreateWithoutOauth_accountsInput = {
    birth?: string | null
    gender?: GenderType | null
    phone?: string | null
    address_first?: string | null
    address_second?: string | null
    profile_image_url?: string | null
    base: UserModelCreateNestedOneWithoutCustomerInput
    zipzoong_care_requests?: ZipzoongCareRequestModelCreateNestedManyWithoutRequesterInput
  }

  export type CustomerModelUncheckedCreateWithoutOauth_accountsInput = {
    id: string
    birth?: string | null
    gender?: GenderType | null
    phone?: string | null
    address_first?: string | null
    address_second?: string | null
    profile_image_url?: string | null
    zipzoong_care_requests?: ZipzoongCareRequestModelUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type CustomerModelCreateOrConnectWithoutOauth_accountsInput = {
    where: CustomerModelWhereUniqueInput
    create: XOR<CustomerModelCreateWithoutOauth_accountsInput, CustomerModelUncheckedCreateWithoutOauth_accountsInput>
  }

  export type BusinessUserModelUpsertWithoutOauth_accountsInput = {
    update: XOR<BusinessUserModelUpdateWithoutOauth_accountsInput, BusinessUserModelUncheckedUpdateWithoutOauth_accountsInput>
    create: XOR<BusinessUserModelCreateWithoutOauth_accountsInput, BusinessUserModelUncheckedCreateWithoutOauth_accountsInput>
  }

  export type BusinessUserModelUpdateWithoutOauth_accountsInput = {
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    base?: UserModelUpdateOneRequiredWithoutBusiness_userNestedInput
    re_agent?: REAgentModelUpdateOneWithoutBaseNestedInput
    hs_provider?: HSProviderModelUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUpdateManyWithoutBusiness_userNestedInput
    sub_expertises?: SubExpertiseModelUpdateManyWithoutBusiness_userNestedInput
  }

  export type BusinessUserModelUncheckedUpdateWithoutOauth_accountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    introduction_title?: StringFieldUpdateOperationsInput | string
    introduction_content?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address_first?: StringFieldUpdateOperationsInput | string
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: StringFieldUpdateOperationsInput | string
    re_agent?: REAgentModelUncheckedUpdateOneWithoutBaseNestedInput
    hs_provider?: HSProviderModelUncheckedUpdateOneWithoutBaseNestedInput
    certification_images?: BusinessCertificationImageModelUncheckedUpdateManyWithoutBusiness_userNestedInput
    sub_expertises?: SubExpertiseModelUncheckedUpdateManyWithoutBusiness_userNestedInput
  }

  export type CustomerModelUpsertWithoutOauth_accountsInput = {
    update: XOR<CustomerModelUpdateWithoutOauth_accountsInput, CustomerModelUncheckedUpdateWithoutOauth_accountsInput>
    create: XOR<CustomerModelCreateWithoutOauth_accountsInput, CustomerModelUncheckedCreateWithoutOauth_accountsInput>
  }

  export type CustomerModelUpdateWithoutOauth_accountsInput = {
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    base?: UserModelUpdateOneRequiredWithoutCustomerNestedInput
    zipzoong_care_requests?: ZipzoongCareRequestModelUpdateManyWithoutRequesterNestedInput
  }

  export type CustomerModelUncheckedUpdateWithoutOauth_accountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    zipzoong_care_requests?: ZipzoongCareRequestModelUncheckedUpdateManyWithoutRequesterNestedInput
  }

  export type REPropertyCategoryModelCreateManyRe_propertyInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    sub_category_id: string
  }

  export type REPropertyCategoryModelUpdateWithoutRe_propertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_category?: REPropertySubCategoryModelUpdateOneRequiredWithoutProperty_categoriesNestedInput
  }

  export type REPropertyCategoryModelUncheckedUpdateWithoutRe_propertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertyCategoryModelUncheckedUpdateManyWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertyCategoryModelCreateManySub_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    re_property_id: string
  }

  export type REPropertyCategoryModelUpdateWithoutSub_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    re_property?: REPropertyModelUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type REPropertyCategoryModelUncheckedUpdateWithoutSub_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    re_property_id?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertyCategoryModelUncheckedUpdateManyWithoutProperty_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    re_property_id?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertySubCategoryModelCreateManyMiddle_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
  }

  export type REPropertySubCategoryModelUpdateWithoutMiddle_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    property_categories?: REPropertyCategoryModelUpdateManyWithoutSub_categoryNestedInput
  }

  export type REPropertySubCategoryModelUncheckedUpdateWithoutMiddle_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    property_categories?: REPropertyCategoryModelUncheckedUpdateManyWithoutSub_categoryNestedInput
  }

  export type REPropertySubCategoryModelUncheckedUpdateManyWithoutSub_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type REPropertyMiddleCategoryModelCreateManySuper_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
  }

  export type REPropertyMiddleCategoryModelUpdateWithoutSuper_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    sub_categories?: REPropertySubCategoryModelUpdateManyWithoutMiddle_categoryNestedInput
  }

  export type REPropertyMiddleCategoryModelUncheckedUpdateWithoutSuper_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    sub_categories?: REPropertySubCategoryModelUncheckedUpdateManyWithoutMiddle_categoryNestedInput
  }

  export type REPropertyMiddleCategoryModelUncheckedUpdateManyWithoutMiddle_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AgreementAcceptanceModelCreateManyAgreementInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    user_id: string
  }

  export type AgreementAcceptanceModelUpdateWithoutAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserModelUpdateOneRequiredWithoutAgreement_acceptancesNestedInput
  }

  export type AgreementAcceptanceModelUncheckedUpdateWithoutAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type AgreementAcceptanceModelUncheckedUpdateManyWithoutAcceptancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type SubExpertiseModelCreateManySub_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    business_user_id: string
  }

  export type SubExpertiseModelUpdateWithoutSub_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business_user?: BusinessUserModelUpdateOneRequiredWithoutSub_expertisesNestedInput
  }

  export type SubExpertiseModelUncheckedUpdateWithoutSub_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business_user_id?: StringFieldUpdateOperationsInput | string
  }

  export type SubExpertiseModelUncheckedUpdateManyWithoutExpertisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business_user_id?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceSubCategoryModelCreateManySuper_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
  }

  export type ZipzoongCareServiceCheckModelCreateManyService_super_categoryInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    request_id: string
  }

  export type ServiceSubCategoryModelUpdateWithoutSuper_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    expertises?: SubExpertiseModelUpdateManyWithoutSub_categoryNestedInput
  }

  export type ServiceSubCategoryModelUncheckedUpdateWithoutSuper_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    expertises?: SubExpertiseModelUncheckedUpdateManyWithoutSub_categoryNestedInput
  }

  export type ServiceSubCategoryModelUncheckedUpdateManyWithoutSub_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ZipzoongCareServiceCheckModelUpdateWithoutService_super_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    request?: ZipzoongCareRequestModelUpdateOneRequiredWithoutService_checksNestedInput
  }

  export type ZipzoongCareServiceCheckModelUncheckedUpdateWithoutService_super_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    request_id?: StringFieldUpdateOperationsInput | string
  }

  export type ZipzoongCareServiceCheckModelUncheckedUpdateManyWithoutFocus_care_checksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    request_id?: StringFieldUpdateOperationsInput | string
  }

  export type ZipzoongCareConsultationTimeCheckModelCreateManyRequestInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    start_time: Date | string
    end_time: Date | string
  }

  export type ZipzoongCareServiceCheckModelCreateManyRequestInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    service_super_category_id: string
  }

  export type ZipzoongCareConsultationTimeCheckModelUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZipzoongCareConsultationTimeCheckModelUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZipzoongCareConsultationTimeCheckModelUncheckedUpdateManyWithoutConsultation_time_checksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZipzoongCareServiceCheckModelUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_super_category?: ServiceSuperCategoryModelUpdateOneRequiredWithoutFocus_care_checksNestedInput
  }

  export type ZipzoongCareServiceCheckModelUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_super_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type ZipzoongCareServiceCheckModelUncheckedUpdateManyWithoutService_checksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_super_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type AgreementAcceptanceModelCreateManyUserInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    agreement_id: string
  }

  export type AgreementAcceptanceModelUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agreement?: AgreementModelUpdateOneRequiredWithoutAcceptancesNestedInput
  }

  export type AgreementAcceptanceModelUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agreement_id?: StringFieldUpdateOperationsInput | string
  }

  export type AgreementAcceptanceModelUncheckedUpdateManyWithoutAgreement_acceptancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agreement_id?: StringFieldUpdateOperationsInput | string
  }

  export type OauthAccountModelCreateManyCustomerInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    oauth_type: OauthType
    oauth_sub: string
    business_user_id?: string | null
    name?: string | null
    email?: string | null
    phone?: string | null
    profile_image_url?: string | null
    birth?: string | null
    gender?: GenderType | null
    address_first?: string | null
    address_second?: string | null
  }

  export type ZipzoongCareRequestModelCreateManyRequesterInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    care_start_date: Date | string
    care_end_date: Date | string
    detail: string
    status: ZipzoongCareStatus
  }

  export type OauthAccountModelUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauth_type?: EnumOauthTypeFieldUpdateOperationsInput | OauthType
    oauth_sub?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    business_user?: BusinessUserModelUpdateOneWithoutOauth_accountsNestedInput
  }

  export type OauthAccountModelUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauth_type?: EnumOauthTypeFieldUpdateOperationsInput | OauthType
    oauth_sub?: StringFieldUpdateOperationsInput | string
    business_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OauthAccountModelUncheckedUpdateManyWithoutOauth_accountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauth_type?: EnumOauthTypeFieldUpdateOperationsInput | OauthType
    oauth_sub?: StringFieldUpdateOperationsInput | string
    business_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ZipzoongCareRequestModelUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    care_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    care_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: StringFieldUpdateOperationsInput | string
    status?: EnumZipzoongCareStatusFieldUpdateOperationsInput | ZipzoongCareStatus
    consultation_time_checks?: ZipzoongCareConsultationTimeCheckModelUpdateManyWithoutRequestNestedInput
    service_checks?: ZipzoongCareServiceCheckModelUpdateManyWithoutRequestNestedInput
  }

  export type ZipzoongCareRequestModelUncheckedUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    care_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    care_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: StringFieldUpdateOperationsInput | string
    status?: EnumZipzoongCareStatusFieldUpdateOperationsInput | ZipzoongCareStatus
    consultation_time_checks?: ZipzoongCareConsultationTimeCheckModelUncheckedUpdateManyWithoutRequestNestedInput
    service_checks?: ZipzoongCareServiceCheckModelUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type ZipzoongCareRequestModelUncheckedUpdateManyWithoutZipzoong_care_requestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    care_start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    care_end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: StringFieldUpdateOperationsInput | string
    status?: EnumZipzoongCareStatusFieldUpdateOperationsInput | ZipzoongCareStatus
  }

  export type BusinessCertificationImageModelCreateManyBusiness_userInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    url: string
  }

  export type SubExpertiseModelCreateManyBusiness_userInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    sub_category_id: string
  }

  export type OauthAccountModelCreateManyBusiness_userInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    oauth_type: OauthType
    oauth_sub: string
    customer_id?: string | null
    name?: string | null
    email?: string | null
    phone?: string | null
    profile_image_url?: string | null
    birth?: string | null
    gender?: GenderType | null
    address_first?: string | null
    address_second?: string | null
  }

  export type BusinessCertificationImageModelUpdateWithoutBusiness_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessCertificationImageModelUncheckedUpdateWithoutBusiness_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessCertificationImageModelUncheckedUpdateManyWithoutCertification_imagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: StringFieldUpdateOperationsInput | string
  }

  export type SubExpertiseModelUpdateWithoutBusiness_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_category?: ServiceSubCategoryModelUpdateOneRequiredWithoutExpertisesNestedInput
  }

  export type SubExpertiseModelUncheckedUpdateWithoutBusiness_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type SubExpertiseModelUncheckedUpdateManyWithoutSub_expertisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub_category_id?: StringFieldUpdateOperationsInput | string
  }

  export type OauthAccountModelUpdateWithoutBusiness_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauth_type?: EnumOauthTypeFieldUpdateOperationsInput | OauthType
    oauth_sub?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerModelUpdateOneWithoutOauth_accountsNestedInput
  }

  export type OauthAccountModelUncheckedUpdateWithoutBusiness_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    oauth_type?: EnumOauthTypeFieldUpdateOperationsInput | OauthType
    oauth_sub?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    birth?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderTypeFieldUpdateOperationsInput | GenderType | null
    address_first?: NullableStringFieldUpdateOperationsInput | string | null
    address_second?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type REPropertyModelCreateManyRe_agentInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    name: string
    main_image_url: string
    is_visible: boolean
  }

  export type REPropertyModelUpdateWithoutRe_agentInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
    is_visible?: BoolFieldUpdateOperationsInput | boolean
    categories?: REPropertyCategoryModelUpdateManyWithoutRe_propertyNestedInput
  }

  export type REPropertyModelUncheckedUpdateWithoutRe_agentInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
    is_visible?: BoolFieldUpdateOperationsInput | boolean
    categories?: REPropertyCategoryModelUncheckedUpdateManyWithoutRe_propertyNestedInput
  }

  export type REPropertyModelUncheckedUpdateManyWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    main_image_url?: StringFieldUpdateOperationsInput | string
    is_visible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HSExampleImageModelCreateManyHs_providerInput = {
    id: string
    created_at: Date | string
    updated_at: Date | string
    is_deleted: boolean
    deleted_at?: Date | string | null
    url: string
    is_visible: boolean
  }

  export type HSExampleImageModelUpdateWithoutHs_providerInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: StringFieldUpdateOperationsInput | string
    is_visible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HSExampleImageModelUncheckedUpdateWithoutHs_providerInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: StringFieldUpdateOperationsInput | string
    is_visible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HSExampleImageModelUncheckedUpdateManyWithoutExample_imagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    url?: StringFieldUpdateOperationsInput | string
    is_visible?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}